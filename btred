#!/usr/bin/perl
#
# BTred ver. 0.1 - Copyright (C) 2000 by Petr Pajas
# This software is covered by GPL - The General Public Licence
# Full text of the GPL can be found at http://www.gnu.org/copyleft/gpl.html.
#
# This program allows you run macros written for Tred in batch mode.
#

package main;

use Getopt::Std;

if ($^V lt v5.6.0) {
  print STDERR '-' x 50,"\n";
  print STDERR "WARNING: Your version of perl is older than v5.6.0\n";
  print STDERR "THINGS MAY NOT WORK AS EXPECTED!\n";
  print STDERR '-' x 50,"\n\n";
}

## Passing -o args... -- to TredMacro
@TredMacro::ARGV=grep { /^-o$/.../^--$/ } @ARGV;
shift @TredMacro::ARGV; pop @TredMacro::ARGV;
@ARGV=grep { not(/^-o$/.../^--$/) } @ARGV;

getopts('qQDx:p:r:s:a:f:c:i:m:e:t:n:hd:ENHSTFX:RPWVL:b:');
$opt_q=1 if $opt_Q;

if ($opt_u || $opt_h) {
  print <<EOH;
Usage:
  btred [-c config-file] [-m macro-file] [-e code]
        [-s strip-sfx] [-a append-sfx] [-p strip-prefix] [-r add-prefix]
        [-f out-fmt]  [-x extra_attribs] [-n encoding]
        [-i init-code] [-t context] [-W] [-q|-Q] [-D] [-N|-H] [-V]
        [-S] [-T] [-P] [-F] [-L port] [-b hub] [-o script options -- ] files...
or
  btred -u          to show usage
or
  btred -h          to show help
EOH
  if ($opt_h) {
    print <<'EOF';

This is a "batch mode" version of tree editor TrEd.
BTrEd runs the given script or macro on each file in given context.
Parameters:

config-file   - TrEd configuration file
macro-file    - file with macro definitions
code          - any code (may use macros); typically, code is just
                name of the macro to be run
context       - start in the given macro context (package).
                TredMacro is the default context.
init-code     - any code to be run only once, before any input
                file is loaded.

format        - output format; one of: fs, csts, trxml. Default is csts.
suffix_regexp - strip strings matching given regexp from the end of filenames
append        - append given suffix to the filenames
prefix_regexp - remove strings matching given regexp from
                the beginning of filenames
prepend       - prepend filenames with the given prefix
extra_attribs - comma separated list of non-CSTS attributes to preserve when
                converting to CSTS
encoding      - allows to specify the default charset for FS files (useful
                with perl >= 5.7)

-N            - wrap 'while ($this) { ...; $this=$this->following; }
                around the code
-H            - same as -N but use following_visible instead, skipping
                hidden nodes
-T            - wrap 'do { ... } while NextTree();' around the code
-S            - always save file
-P            - preload all given files into memory
-R            - build tectogrammatic trees from CSTS files
-X <gov>,<ord>  use attribute <gov> to build tree from CSTS files
                and <ord> to order nodes
-q            - quiet
-Q            - by *very* quiet
-D            - enable debugging messages on stderr
-W            - do not die on errors (warn only)
-V            - force Fslib to test validity of values of list attributes in FS
-F            - run macros in safe compartment
-L <port>     - start btred server, listening on given port; implies -P
-b <host>     - make btred server allow only connections from <host>
-d <encoding> - convert stdout and stderr into given encoding (only Perl >= 5.8)

Flags -N and -H may not be combined. If both are used, -N has the
precedence. However, both -N and -H may be used together with -T.

If no macro-file is given, standard macro file (see TrEd
documentation) is searched and used if found. If no code is specified
via -e, call to function autostart in the context is performed in
expectation that such a function is defined in the macro-file.

As in TrEd, the following variables may be used in the macros:

$grp->{FSFile}       - current FSFile object (see section on FSFile in 
                       Fslib documentation)
$grp->{treeNo}       - current tree number
$grp->{macroContext} - current macro context
$this                - current node (root of the first tree at the beginning)
$root                - root node of current tree
$FileNotSaved        - change this to 1 if you want the file to be saved at the end

Also all functions defined in default macro file tred.def
as well as any function from Fslib (see Fslib documentation).
EOF
  }
  exit;
}

if (defined $opt_e) {
  $script=$opt_e;
} else {
  $script="autostart()"; # this is the default macro name
}

if (defined($opt_d) and $]>=5.008) {
  eval {
    _msg("forcing encoding $opt_d for STDERR and STDOUT\n") if $opt_D;
    binmode STDERR,":encoding($opt_d)";
    binmode STDOUT,":encoding($opt_d)";
  };
  _msg $@ if $@;
}

# in Windows, if HOME not defined, use user's AppData folder instaed
if ($^O eq "MSWin32" and !exists $ENV{HOME}) {
  require Win32::Registry;
  my %shf;
  my $ShellFolders;

  my $shfolders="Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders";
  $::HKEY_CURRENT_USER->Open($shfolders,$ShellFolders) or die "Cannot read $shfolders $^E\n";
  $ShellFolders->GetValues(\%shf);
  $ENV{HOME} = $shf{AppData}[2];
}

# Default values of $libDir used to search for macro-file (tred.mac)
# and default-macro file (tred.def) are specified here. They may be
# overriden by value of LibDir in tred resource file (tredrc or ~/.tredrc - see above).
# It is also used to find TrEd::Config.pm module.

use FindBin;
if (exists $ENV{TREDHOME}) {
  $libDir=$ENV{TREDHOME};
} elsif (-d "$FindBin::RealBin/tredlib") {
  $libDir="$FindBin::RealBin/tredlib";
} elsif (-d "$FindBin::RealBin/../lib/tredlib") {
  $libDir="$FindBin::RealBin/../lib/tredlib";
} elsif (-d "$FindBin::RealBin/../lib/tred") {
  $libDir="$FindBin::RealBin/../lib/tred";
}
_msg("Trying $libDir\n") if ($libDir and !$opt_q);

$macroFile=undef;


# We *must* at least find TrEd::Config module to learn the correct libDir!!.
unshift @INC,$libDir if (-d $libDir);

do {
  my $ld=$libDir;
  require TrEd::Config;
  import TrEd::Config;
  import TrEd::Config qw(&read_config &set_default_config_file_search_list $defaultMacroFile $macroDebug $hookDebug);
  $libDir=$ld;
};

$TrEd::Config::quiet=$opt_q;

if (defined $opt_c) {
  @config_file_search_list=($opt_c); # override any other possible config files
} else {
  set_default_config_file_search_list();
}

my $configFile=read_config();
my $safe=$opt_F; # so that it cannot be changed from outside

$macroFile="$libDir/tred.mac" unless (defined $macroFile);
if (defined $opt_m) {
  $macroFile=$opt_m;
}
####################################


unless (-d $libDir) {
  print <<'EOL';
 BTrEd couldn't find a tredlib directory. You may need to point
 to its location by the TREDHOME variable or add a correct LibDir
 field to your ~/.tredrc.

EOL
    die "Error: Couldn't find lib-directory.";
}

use Cwd;
unshift @INC,$libDir unless (grep($_ eq $libDir, @INC));

use Benchmark;


require Fslib;
import Fslib;
import Fslib qw(&Ord &Value &Hide &SentOrd &AOrd &AValue &AHide &ASentOrd &Index);

# import min and max functions
require TrEd::MinMax;
import TrEd::MinMax;

# import encode and decode functions
require TrEd::Convert;
import TrEd::Convert;

# import read_macros etc.
require TrEd::Macros;
import TrEd::Macros;

# basic tree operations
require TrEd::Basics;
import TrEd::Basics;

#load back-ends
@backends=('FSBackend',ImportBackends(qw(AG2FS TrXMLBackend CSTS_SGML_SP_Backend TEIXMLBackend)));
$CSTS_SGML_SP_Backend::doctype = "$libDir/csts.doctype";

$stdout=\*STDOUT;
$stderr=\*STDERR;

use Exporter;
@ISA=qw(Exporter);
# This is default export to macros
@EXPORT = qw($libDir &min &max $stdout $stderr);

# it seems, that under Windoze setting LC_NUMERIC back to us does not
# work, so I recommend not to use czech locales there, unless you
# really want the decimal points to be replaced by commas in
# postscript:)
($TrEd::Config::useLocales) && do {
  use locale;
  use POSIX qw(locale_h);
  $ENV{LC_ALL}=undef;
  setlocale(LC_ALL,undef);
  setlocale(LC_NUMERIC,"C");
};

if ($useCzechLocales) {
  use locale;
  use POSIX qw(locale_h);
  setlocale(LC_COLLATE,"cs_CZ");
  setlocale(LC_NUMERIC,"C");
  setlocale(LANG,"cs_CZ");
}

# These are used only in macros and hooks!!!
$root=undef;
$this=undef;
$TrEd::Macros::FileNotSaved=0;
$forceFileSaved=0;

$_NoSuchTree=0; # for compatibility with Graph2Tred
$NodeClipboard=undef;

$fileNo=0;

#$TrEd::Basics::on_tree_change= \&updateTredMacroGlobals;
#$TrEd::Basics::on_node_change= \&updateTredMacroGlobals;
#$TrEd::Basics::on_current_change= \&updateTredMacroGlobals;

$Fslib::Debug=$opt_D;
if ($opt_q) {
  $tredDebug=$keyboardDebug=$hookDebug=$macroDebug=0;
} elsif ($opt_D) {
  $tredDebug=$keyboardDebug=$hookDebug=$macroDebug=1;
}

_msg("Reading macros from $macroFile...\n") unless $opt_q;
read_macros($macroFile,$libDir);	# read macros
_msg("done.\n") unless $opt_q;

@files=@ARGV;
@ARGV=@TredMacro::ARGV;



%bkmap=(
	fs => 'FSBackend',
	csts => 'CSTS_SGML_SP_Backend',
	trxml => 'TrXMLBackend'
       );

$Fslib::FSTestListValidity=$opt_V;

$opt_R && Csts2fs::setupTR();
if ($opt_X ne "") {
  Csts2fs::setupSpec(split ',',$opt_X);
}

@Fs2csts::extra_attributes=split /,/,$opt_x;

if ($opt_f) {
  my $format=$opt_f ? lc($opt_f) : "";
  unless ( $backend=$bkmap{$format} ) {
    die "Unknown format $format. Use -f [fs|csts|trxml]\n";
  }
}

$TrEd::Convert::inputenc=$opt_n if $opt_n;

startMain();

exit;

############################
############################
############################
sub _msg { print STDERR "BTRED: ",@_; }
sub _make_uniq ($) { my %U; @{$_[0]} = grep {!exists($U{$_}) && ($U{$_}=1)} @{$_[0]} }
sub _benchmark () {
  my $number_of_iters=50000;
  my $i;
  my %a;
  my $benchmark_code='$a{$i++}=(join("",map uc,split "(..)","afa${i}sd ${i}fsd1f2 asf${i}1sdfdsf fsasf")=~/\s+\d+/);';
  (timestr timeit ($number_of_iters,$benchmark_code))=~/(\S+) CPU/;
#  return 200;
  return $1*1000; # miliseconds
}
sub _threads () { 1 };

sub _end_response {
  my ($control,$client)=@_;
  $client->print("$control END_OF_SERVER_RESPONSE\n");
}


sub startMain {
  my $grp={
	   treeNo => 0,
	   FSFile => undef,
	   macroContext =>  defined($opt_t) ? $opt_t : 'TredMacro',
	   currentNode => undef,
	   root => undef
	  };
  my $filecount=@files;
  #  eval (join("",@macros)."\n return 1;");
  my $context = $grp->{macroContext};

  # initialize Safe compartment

  if ($opt_L) {
    require TrEd::Cipher;
    # Start btred server
    preloadFiles($grp,\@files);

    my $control="@@@"; # @@@ marks the beginning of control lines

    my $key = readline(*STDIN);
#    close STDIN;
    if ($key =~ /^$control SESSION-KEY=([0-9A-Z]+)$/) {
      $key = TrEd::Cipher::hex_to_block($1);
      /(.)/; # clean-up :-)
    } else {
      die "Was expecting the session key!\n";
    }

    my $port=$opt_L;
    chomp (my $host=`/bin/hostname`); #$ENV{HOSTNAME};
    my $server = new IO::Socket::INET (LocalHost => $host,
				       LocalPort => $port,
				       Proto => 'tcp',
				       Listen => 5,
				       Reuse => 1,
					     );
    die "Cannot open socket at $host:$port!\n" unless $server;
    _msg("Waiting for hub on $host:$port\n");
    $opt_b=~s/\s//g;
    # resolve peer IP
    if ($opt_b) {
      ($opt_b) = (`LC_ALL=C host "$opt_b"` =~ / has address (.*)$/) if ($opt_b =~/[^:.0-9]/);
      print "Awaiting connection from $opt_b\n";
    }
    my ($hub,$peer);
    do {
      $hub = $server->accept();
      $peer=$hub->peerhost();
      if ($hub and $opt_b and $peer ne $opt_b) {
	_msg("Denying connection to peer $peer!\n");
	$hub->close();
	undef $hub;
      } elsif ($hub and TrEd::Cipher::Authentify($key,$hub,$control)!=1) {
	$hub->close();
	undef $hub;
      }
    } while (!$hub);
    _msg("Connection to the hub on $peer established.\n");
    my $request_no=0;
    _msg("Waiting for a request from the hub...\n\n");
    $hub->autoflush(1);
    while (1) {
      my $state='default';
      my %request;
      # --- reading request from hub ---
      while (<$hub>) {
        if (/^$control REQUEST_TYPE=(.*)/) {
	  $request_no++;
	  _msg("Receiving request $request_no: $1\n");
	  $request{REQUEST_TYPE}=$1;
        } elsif (/^$control STATE=(.*)/) {
	  $state=$1;
        } elsif (!/^$control/) {
	  $request{$state}.=$_;
        } elsif (/$control END_OF_REQUEST/) {
          $state='END_OF_REQUEST';
	  last
        }
      }
      ($state eq 'END_OF_REQUEST') || die "Broken request $request{REQUEST_TYPE}!\n";
      _msg "Request received from the hub: $request{REQUEST_TYPE}\n";

      # --- performing the request on the trees ----
      _msg("Performing the hub request...\n");

      if ($request{REQUEST_TYPE} eq 'LOAD_FILES') {
	eval { preloadFiles($grp,[split /\n/,$request{default}]); die $@ if $@ };
	@files = (@files, grep /\S/,split /\n/,$request{default});
        _make_uniq(\@files);
	if ($@) {
	  $hub->print("$@\n");
	} else {
	  $hub->print("OK\n");
	}
	_end_response($control,$hub);
      } elsif ($request{REQUEST_TYPE} eq 'BENCHMARK') {
	$hub->print(_benchmark(),",",_threads(),"\n"); # benchmark,threads
	_end_response($control,$hub);
      } elsif ($request{REQUEST_TYPE} eq 'EVAL_CODE') {
	_msg("Initializing safe compartment...\n") if $safe;
	init_safe_mode($grp) if $safe;
	gotoFile($grp,0); # neither goto_file_hook nor file_open_hook in server-mode

	# create temporary file to store macro output
	my $macro_stdout = IO::File->new_tmpfile();
	*MOUT=*$macro_stdout;
	#open OLDSTDOUT, ">&STDOUT" or die "Can't dup STDOUT: $!";
	open(STDOUT, "+>&MOUT") or die "Can't redirect STDOUT: $!";
	STDOUT->autoflush();
	# load macro
	_msg "COMPILING MACRO\n";
	doEvalMacro($grp,"package $context;\n"."#line 1 \"$request{REQUEST_TYPE}\"\n".$request{MACRO});
	# execute hooks and the code of the query
	my $time;
	if (!$@ and keys(%{$grp->{preloaded}}) and
	    doEvalHook($grp,"start_hook") ne 'stop' and
	    doEvalHook($grp,"preload_hook") ne 'stop') { # for compatibility
	  _msg "RUNNING CODE: $request{CODE}\n";
	  my $t0 = new Benchmark;
	  do {
	    print STDERR $grp->{currentNode}->{form},"\n";
	    doEvalMacro($grp,"package $context;".$request{CODE});
	  } while (!$@ and nextFile($grp));
	  my $t1 = new Benchmark;
	  $time = timediff($t1, $t0);
	  doEvalHook($grp,"exit_hook") unless $@;
	}
	$hub->print("$control SERVER_RESPONSE_STDERR\n");
	$hub->print("$@\n") if $@;
	msg($@) if $@;
	$hub->print("Total Time: ",timestr($time),"\n");
	$hub->print("No files to process at btred server $host:$port\n") if (!keys(%{$grp->{preloaded}}));
	$hub->print("$control SERVER_RESPONSE_STDOUT\n");
	# send macro's output from tmp file to client
	seek($macro_stdout,0,0);
	my $space;
	while (<$macro_stdout>) {
	  print $hub $_;
	  $space=chomp;
	}
	print $hub "\n" unless $space;
	$macro_stdout->close;
	undef $macro_stdout;
	#open STDOUT, ">&OLDSTDOUT" or die "Can't dup OLDSTDOUT: $!";

	_end_response($control,$hub);
	_msg("The processing of request $request_number completely finished.\n");
      } elsif ($request{REQUEST_TYPE} eq 'QUIT') {
	_msg "Quitting on client's request\n";
	$hub->print("OK\n");
	_end_response($control,$hub);
	exit 0;
      } else {
	$hub->print("ERROR: UNKNOWN REQUEST TYPE\n");
	_end_response($control,$hub);
      }
      _msg("Waiting for a new request from the hub...\n\n");
    }
  } else {
    init_safe_mode($grp) if $safe;
    my $pre='';
    $pre .= "do { " if ($opt_T);
    $pre .= "while (\$this) {" if ($opt_N or $opt_H);
    $post.= "\$this=\$this->following; \n}" if ($opt_N);
    $post.= "\$this=\$this->following_visible(\$grp->{FSFile}->FS); \n}"
      if (not $opt_N and $opt_H);
    $post.= " } while NextTree();" if ($opt_T);
    $premacro= <<EOL;
package $context;
sub _btred_eval_ {
$pre
$script;
$post
}

$opt_i;
EOL

    _msg "<script>\n$premacro;\n</script>\n" unless $opt_q;
    doEvalMacro($grp,$premacro);

    exit if doEvalHook($grp,"start_hook") eq 'stop'; # run start_hook
    preloadFiles($grp,\@files) if $opt_P; # -P : load all files into memory

    exit if $opt_P and doEvalHook($grp,"preload_hook") eq 'stop'; # run start_hook
    openFile($grp,$files[$fileNo]) if $fileNo <= $#files; # goto first file
    if (@files) {
      do {
	_msg "Processing: $files[$fileNo] (",$fileNo+1,"/$filecount)\n" unless $opt_Q;
	doEvalMacro($grp,"$context->_btred_eval_();");
	STDOUT->flush();
	STDERR->flush();
	_msg "Done.\n" unless $opt_q;
	saveFile($grp) if ($grp->{FSFile}->notSaved or $opt_S);
      } while (nextFile($grp));
    } else {
      _msg "No files to process!\n" unless $opt_Q;
    }
    doEvalHook($grp,"exit_hook");
  }
}


sub lastFileNo {
  return $#files;
}

sub currentFileNo {
  return $fileNo;
}

sub gotoFile {
  my ($grp,$fn)=@_;
  return 0 unless $opt_L or doEvalHook($grp,"goto_file_hook") ne 'stop';
  return 0 if ($fn>$#files or $fn<0);
  $fileNo=$fn;
  openFile($grp,$files[$fileNo]);
  return 1;
}


sub nextFile {
  my ($grp)=@_;
  return 0 if ($fileNo >= $#files);
  $fileNo++;
  openFile($grp,$files[$fileNo]);
  return 1;
}

sub prevFile {
  my ($grp)=@_;
  return 0 unless ($fileNo > 0);
  $fileNo--;
  openFile($grp,$files[$fileNo]);
  return 1;
}

sub preloadFiles {
  my ($grp, $filelist)=@_;
  my $filecount=@$filelist;
  my $fno=1;
  foreach my $f (@$filelist) {
    if ($f=~/(##?[0-9A-Z]+(?:\.[0-9]+)?)$/) {
      $f=~s/(##?[0-9A-Z]+(?:\.[0-9]+)?)$//;
    }
    next if exists($grp->{preloaded}->{$f});
    _msg "Preloading: $f (",$fno++,"/$filecount)\n" unless $opt_Q;
    my $fsfile = FSFile->newFSFile($f,$TrEd::Convert::inputenc,@backends);
    $fsfile->changeFileFormat(($f=~/\.gz$/ ? "gz-compressed " : "").$fsfile->backend);
    $grp->{preloaded}->{$f} = $fsfile;
  }
}

sub openFile {
  my ($grp,$f) = @_;
  my $goto = undef;
  my %fs=(fs => 'FS format',
	  fgz => 'gzipped FS format',
	  trxml => 'tree XML format',
	  any => 'any non-specific format (csts?), using CstsToFs');

  if ($f=~/(##?[0-9A-Z]+(?:\.[0-9]+)?)$/) {
    $f=~s/(##?[0-9A-Z]+(?:\.[0-9]+)?)$//;
      $goto=$1;
    _msg "Goto suffix is $goto\n" if $tredDebug;
  }

# saveFile($grp) unless (ref($grp->{FSFile}) and $grp->{FSFile}->filename() eq $f);
  closeFile($grp);

  if (exists($grp->{preloaded}) and
      exists($grp->{preloaded}->{$f})) {
    $grp->{'FSFile'} = $grp->{preloaded}->{$f};
  } else {
    $grp->{'FSFile'} = FSFile->newFSFile($f,$TrEd::Convert::inputenc,@backends);
    $grp->{'FSFile'}->changeFileFormat(($f=~/\.gz$/ ? "gz-compressed " : "").$grp->{'FSFile'}->backend);
    $grp->{preloaded}->{$f}=$grp->{'FSFile'} if ($grp->{FSFile} and exists($grp->{preloaded}));
  }
  _msg "empty or corrupt file!\n" if ($grp->{FSFile}->lastTreeNo<0);

  $grp->{treeNo}=0;
  $grp->{currentNode}=undef;
  applyFileSuffix($grp,$goto);

  doEvalHook($grp,"file_opened_hook") unless $opt_L;
  $grp->{root}=$grp->{FSFile}->treeList->[$grp->{treeNo}];
  unless (!$grp->{FSFile} || defined($grp->{currentNode})) {
    $grp->{currentNode}=$grp->{root};
  }
#  updateTredMacroGlobals($grp);
  return 1;
}

sub applyFileSuffix {
  my ($grp,$goto) = @_;
  return unless ref($grp) and defined($goto) and $goto ne "";
  # -- smells like PDT-specific code, at least the second case
  # but we want it, dont we:)

  if ($goto=~/^##([0-9]+)/) {
    $grp->{treeNo}=min(max(0,$1-1),$grp->{FSFile}->lastTreeNo);
  } elsif ($goto=~/^#([0-9]+)/) {
    for (my $i=0;$i<=$grp->{FSFile}->lastTreeNo;$i++) {
      $grp->{treeNo}=$i,last if ($grp->{FSFile}->treeList->[$i]->{'form'} eq "#$1");
    }
  }
  # new: we're the dot in .[0-9]+ (TM)
  my $root;
  if ($goto=~/\.([0-9]+)$/) {
    $root=$grp->{FSFile}->treeList->[$grp->{treeNo}];
    my $i=$1;
    while ($root and $i>0) {
      $i--;
      $root=$root->following();
    }
    $grp->{currentNode}=$root if ($root);
  }
}

sub saveFile {
  my $grp=shift;
  return unless $grp->{'FSFile'};
  my $f=$grp->{'FSFile'}->filename;

  $grp->{FSFile}->changeBackend($backend) if ($backend);
  my $out=$f;
  $out=~s/$opt_s$/$opt_a/ if ($opt_s or $opt_a);
  $out=~s/^$opt_p/$opt_r/ if ($opt_p or $opt_r);
  if ($f eq $out) {
    unlink "$f~" if (-e "$f~" ); # silly MS OSs need this
    rename $f, "$f~" if (-f $f);
  }

  _msg "Saving $f as $out\n" unless $opt_Q;


  unless ($grp->{FSFile}->writeFile($out)) {
    _msg "Error saving file to '$out'\n($!)\n";
    return 0;
  }
}

sub closeFile {
  my ($grp)=@_;

  undef $NodeClipboard;
  $grp->{root}=undef;
  $grp->{FSFile}=undef;
  $grp->{treeNo}=undef;
  delete $grp->{'currentNode'} if (exists $grp->{'currentNode'});
}

sub doEvalHook {
  my ($group,$hook)=(shift,shift);
  return unless $hook;# and $group->{'currentNode'};

  $TredMacro::this=$group->{currentNode};
  $TredMacro::root=$group->{root};
  $TredMacro::libDir=$libDir;
  $TredMacro::FileNotSaved='?';
  $TredMacro::forceFileSaved=0;
  my $result=do_eval_hook($group,$group->{macroContext},$hook);
  _msg "$@" if $@;
  exit 1 if ($@ and !$opt_W and !$opt_L);

  if ($group->{FSFile}) {
    if ($TredMacro::FileNotSaved eq '?') {
      $TredMacro::FileNotSaved=$group->{FSFile}->notSaved;
    }
    $group->{FSFile}->notSaved($group->{FSFile}->notSaved or $TredMacro::FileNotSaved);
  }

#  $TredMacro::this=undef;
#  $TredMacro::root=undef;
#  $TredMacro::grp=undef;

  _msg "Hook $hook resulted with $result\n" if $hookDebug;
  return $result;
}

sub doEvalMacro {
  my ($group,$macro)=(shift,shift);
  return unless $macro;

  $TredMacro::this=$group->{currentNode};
  $TredMacro::root=$group->{root};
  $TredMacro::libDir=$libDir;
  $TredMacro::FileNotSaved='?';
  $TredMacro::forceFileSaved=0;

  my $result=do_eval_macro($group,$macro);

  _msg "$@" if $@;
  exit 1 if ($@ and !$opt_W and !$opt_L);

  if ($group->{FSFile}) {
    $TredMacro::FileNotSaved=0 if $TredMacro::FileNotSaved eq '?';
    if ($TredMacro::forceFileSaved) {
      $group->{FSFile}->notSaved($TredMacro::FileNotSaved);
    } else {
      $group->{FSFile}->notSaved($group->{FSFile}->notSaved or $TredMacro::FileNotSaved);
    }
    setCurrent($group,$TredMacro::this) if ($TredMacro::this);
  }
  $TredMacro::this=undef;
  $TredMacro::root=undef;
  $TredMacro::grp=undef;
  return $result;
}

sub init_safe_mode {
  my ($grp)=@_;
  require Safe;
  $macrosEvaluated=0;
  $TrEd::Macros::safeCompartment=undef;
  my $compartment;

  $compartment = Safe->new('TredMacro');
  $compartment->reval("package TredMacro;\n");
  $compartment->deny_only(qw()); # everything allowed for the first initialization
  $compartment->share(qw(&do_eval_macro &do_eval_hook &min &max @INC 
                         &nextTree &prevTree &gotoTree &lastFileNo &currentFileNo $stderr $stdout));
  $compartment->share_from('TrEd::Config',[qw($libDir)]);

  $TrEd::Macros::safeCompartment=$compartment;
  TrEd::Macros::initialize_macros($grp);

# OPCODES ALLOWED IN SAFE MODE

#			       :base_io :base_orig :filesys_read :filesys_open
#			       :filesys_write
  $compartment->permit_only(qw(:base_core :base_mem :base_loop :base_math :base_orig
			       entereval caller do
			       print entertry leavetry tie untie bless
			       sprintf localtime gmtime sort require));
  $compartment->deny(qw(getppid getpgrp setpgrp getpriority setpriority
			pipe_op sselect select dbmopen dbmclose tie untie
		       ));
			
  $TrEd::Macros::safeCompartment=$compartment;
}

sub switchContext {}

sub updateTredMacroGlobals {
  my ($grp)=@_;
  $TredMacro::root=$grp->{root};
  $TredMacro::this=$grp->{currentNode};
  print "updateTredMacroGlobals: $TredMacro::root->{form}\n";
}


### Local Variables:
### mode: cperl

