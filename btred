#!/usr/bin/perl
#
# BTred ver. 0.1 - Copyright (C) 2000 by Petr Pajas
# This software is covered by GPL - The General Public Licence
# Full text of the GPL can be found at http://www.gnu.org/copyleft/gpl.html.
#
# This program allows you run macros written for Tred in batch mode.
#

package main;

use Getopt::Std;

if ($^V lt v5.6.0) {
  print STDERR '-' x 50,"\n";
  print STDERR "WARNING: Your version of perl is older than v5.6.0\n";
  print STDERR "THINGS MAY NOT WORK AS EXPECTED!\n";
  print STDERR '-' x 50,"\n\n";
}

## Passing -o args... -- to TredMacro
@TredMacro::ARGV=grep { /^-o$/.../^--$/ } @ARGV;
shift @TredMacro::ARGV; pop @TredMacro::ARGV;
@ARGV=grep { not(/^-o$/.../^--$/) } @ARGV;

getopts('qQDx:p:r:s:a:f:c:i:m:e:t:n:huNHSTX:RPWV');
$opt_q=1 if $opt_Q;

if ($opt_u || $opt_h) {
  print <<EOH;
Usage:
  btred [-c config-file] [-m macro-file] [-e code]
        [-s strip-sfx] [-a append-sfx] [-p strip-prefix] [-r add-prefix]
        [-f out-fmt]  [-x extra_attribs] [-n encoding]
        [-i init-code] [-t context] [-W] [-q|-Q] [-D] [-N|-H] [-V]
        [-S] [-T] [-o script options -- ] files...
or
  btred -u          to show usage
or
  btred -h          to show help
EOH
  if ($opt_h) {
    print <<'EOF';

This is a "batch mode" version of tree editor TrEd.
BTrEd runs the given script or macro on each file in given context.
Parameters:

config-file   - TrEd configuration file
macro-file    - file with macro definitions
code          - any code (may use macros); typically, code is just
                name of the macro to be run
context       - start in the given macro context (package).
                TredMacro is the default context.
init-code     - any code to be run only once, before any input
                file is loaded.

format        - output format; one of: fs, csts, trxml. Default is csts.
suffix_regexp - strip strings matching given regexp from the end of filenames
append        - append given suffix to the filenames
prefix_regexp - remove strings matching given regexp from
                the beginning of filenames
prepend       - prepend filenames with the given prefix
extra_attribs - comma separated list of non-CSTS attributes to preserve when
                converting to CSTS
encoding      - allows to specify the default charset for FS files (useful
                with perl >= 5.7)

-N            - wrap 'while ($this) { ...; $this=$this->following; }
                around the code
-H            - same as -N but use following_visible instead, skipping
                hidden nodes
-T            - wrap 'do { ... } while NextTree();' around the code
-S            - always save file
-P            - preload all given files into memory
-R            - build tectogrammatic trees from CSTS files
-X <gov>,<ord>  use attribute <gov> to build tree from CSTS files
                and <ord> to order nodes
-q            - quiet
-Q            - by *very* quiet
-D            - enable debugging messages on stderr
-W            - do not die on errors (warn only)
-V            - force Fslib to test validity of values of list attributes in FS

Flags -N and -H may not be combined. If both are used, -N has the
precedence. However, both -N and -H may be used together with -T.

If no macro-file is given, standard macro file (see TrEd
documentation) is searched and used if found. If no code is specified
via -e, call to function autostart in the context is performed in
expectation that such a function is defined in the macro-file.

As in TrEd, the following variables may be used in the macros:

$grp->{FSFile}       - current FSFile object (see section on FSFile in 
                       Fslib documentation)
$grp->{treeNo}       - current tree number
$grp->{macroContext} - current macro context
$this                - current node (root of the first tree at the beginning)
$root                - root node of current tree
$FileNotSaved        - change this to 1 if you want the file to be saved at the end

Also all functions defined in default macro file tred.def
as well as any function from Fslib (see Fslib documentation).
EOF
  }
  exit;
}

if (defined $opt_e) {
  $script=$opt_e;
} else {
  $script="autostart()"; # this is the default macro name
}



# in Windows, if HOME not defined, use user's AppData folder instaed
if ($^O eq "MSWin32" and !exists $ENV{HOME}) {
  require Win32::Registry;
  my %shf;
  my $ShellFolders;

  my $shfolders="Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders";
  $::HKEY_CURRENT_USER->Open($shfolders,$ShellFolders) or die "Cannot read $shfolders $^E\n";
  $ShellFolders->GetValues(\%shf);
  $ENV{HOME} = $shf{AppData}[2];
}

# Default values of $libDir used to search for macro-file (tred.mac)
# and default-macro file (tred.def) are specified here. They may be
# overriden by value of LibDir in tred resource file (tredrc or ~/.tredrc - see above).
# It is also used to find TrEd::Config.pm module.

use FindBin;
if (exists $ENV{TREDHOME}) {
  $libDir=$ENV{TREDHOME};
} elsif (-d "$FindBin::RealBin/tredlib") {
  $libDir="$FindBin::RealBin/tredlib";
} elsif (-d "$FindBin::RealBin/../lib/tredlib") {
  $libDir="$FindBin::RealBin/../lib/tredlib";
} elsif (-d "$FindBin::RealBin/../lib/tred") {
  $libDir="$FindBin::RealBin/../lib/tred";
}
print STDERR "Trying $libDir\n" if ($libDir and !$opt_q);

$macroFile=undef;


# We *must* at least find TrEd::Config module to learn the correct libDir!!.
unshift @INC,$libDir if (-d $libDir);

do {
  my $ld=$libDir;
  require TrEd::Config;
  import TrEd::Config;
  import TrEd::Config qw(&read_config &set_default_config_file_search_list $defaultMacroFile $macroDebug $hookDebug);
  $libDir=$ld;
};

$TrEd::Config::quiet=$opt_q;

if (defined $opt_c) {
  @config_file_search_list=($opt_c); # override any other possible config files
} else {
  set_default_config_file_search_list();
}

my $configFile=read_config();

$macroFile="$libDir/tred.mac" unless (defined $macroFile);
if (defined $opt_m) {
  $macroFile=$opt_m;
}
####################################


unless (-d $libDir) {
  print <<'EOL';
 BTrEd couldn't find a tredlib directory. You may need to point
 to its location by the TREDHOME variable or add a correct LibDir
 field to your ~/.tredrc.

EOL
    die "Error: Couldn't find lib-directory.";
}

use Cwd;
unshift @INC,$libDir unless (grep($_ eq $libDir, @INC));


require Fslib;
import Fslib;
import Fslib qw(&Ord &Value &Hide &SentOrd &AOrd &AValue &AHide &ASentOrd &Index);

# import min and max functions
require TrEd::MinMax;
import TrEd::MinMax;

# import encode and decode functions
require TrEd::Convert;
import TrEd::Convert;

# import read_macros etc.
require TrEd::Macros;
import TrEd::Macros;

# basic tree operations
require TrEd::Basics;
import TrEd::Basics;

#load back-ends
@backends=('FSBackend',ImportBackends(qw(AG2FS TrXMLBackend CSTS_SGML_SP_Backend TEIXMLBackend)));
$CSTS_SGML_SP_Backend::doctype = "$libDir/csts.doctype";

use Exporter;
@ISA=qw(Exporter);
# This is default export to macros
@EXPORT = qw($libDir &min &max);

# it seems, that under Windoze setting LC_NUMERIC back to us does not
# work, so I recommend not to use czech locales there, unless you
# really want the decimal points to be replaced by commas in
# postscript:)
($TrEd::Config::useLocales) && do {
  use locale;
  use POSIX qw(locale_h);
  $ENV{LC_ALL}=undef;
  setlocale(LC_ALL,undef);
  setlocale(LC_NUMERIC,"C");
};

if ($useCzechLocales) {
  use locale;
  use POSIX qw(locale_h);
  setlocale(LC_COLLATE,"cs_CZ");
  setlocale(LC_NUMERIC,"C");
  setlocale(LANG,"cs_CZ");
}

# These are used only in macros and hooks!!!
$root=undef;
$this=undef;
$TrEd::Macros::FileNotSaved=0;
$forceFileSaved=0;

$_NoSuchTree=0; # for compatibility with Graph2Tred
$NodeClipboard=undef;

$fileNo=0;

$Fslib::Debug=$opt_D;
if ($opt_q) {
  $tredDebug=$keyboardDebug=$hookDebug=$macroDebug=0;
} elsif ($opt_D) {
  $tredDebug=$keyboardDebug=$hookDebug=$macroDebug=1;
}

print STDERR "Reading macros from $macroFile...\n" unless $opt_q;
read_macros($macroFile,$libDir);	# read macros
print STDERR "done.\n" unless $opt_q;

@files=@ARGV;
@ARGV=@TredMacro::ARGV;



%bkmap=(
	fs => 'FSBackend',
	csts => 'CSTS_SGML_SP_Backend',
	trxml => 'TrXMLBackend'
       );

$Fslib::FSTestListValidity=$opt_V;

$opt_R && Csts2fs::setupTR();
if ($opt_X ne "") {
  Csts2fs::setupSpec(split ',',$opt_X);
}

@Fs2csts::extra_attributes=split /,/,$opt_x;

if ($opt_f) {
  my $format=$opt_f ? lc($opt_f) : "";
  unless ( $backend=$bkmap{$format} ) {
    die "Unknown format $format. Use -f [fs|csts|trxml]\n";
  }
}

$TrEd::Convert::inputenc=$opt_n if $opt_n;

startMain();

exit;

############################
############################
############################
sub startMain {
  my $grp={
	   treeNo => 0,
	   FSFile => undef,
	   macroContext =>  defined($opt_t) ? $opt_t : 'TredMacro',
	   currentNode => undef,
	   root => undef
	  };

  my $filecount=@files;
#  eval (join("",@macros)."\n return 1;");
  my $context = $grp->{macroContext};
  my $pre='';
  $pre .= "do { " if ($opt_T);
  $pre .= "while (\$this) {" if ($opt_N or $opt_H);
  $post.= "\$this=\$this->following; \n}" if ($opt_N);
  $post.= "\$this=\$this->following_visible(\$grp->{FSFile}->FS); \n}"
    if (not $opt_N and $opt_H);
  $post.= " } while NextTree();" if ($opt_T);

  $premacro= <<EOL;
package $context;
sub _btred_eval_ {
$pre
$script;
$post
}

$opt_i;
EOL

  print STDERR "<script>\n$premacro;\n</script>\n" unless $opt_q;
  doEvalMacro($grp,$premacro);
  exit if doEvalHook($grp,"start_hook") eq 'stop'; # run start_hook
  preloadFiles($grp,\@files) if $opt_P;
  doEvalHook($grp,"preload_hook") if $opt_P; # run start_hook
  openFile($grp,$files[$fileNo]);
  do {
    print STDERR "Processing: $files[$fileNo] (",$fileNo+1,"/$filecount)\n" unless $opt_Q;
    doEvalMacro($grp,"$context->_btred_eval_();");
    STDOUT->flush();
    STDERR->flush();
    print STDERR "Done.\n" unless $opt_q;
    saveFile($grp) if ($grp->{FSFile}->notSaved or $opt_S);
  } while (nextFile($grp));
  doEvalHook($grp,"exit_hook");
}

sub nextFile {
  my ($grp)=@_;
  return 0 if ($fileNo >= $#files);
  $fileNo++;
  openFile($grp,$files[$fileNo]);
  return 1;
}

sub prevFile {
  my ($grp)=@_;
  return 0 unless ($fileNo > 0);
  $fileNo--;
  openFile($grp,$files[$fileNo]);
  return 1;
}

sub preloadFiles {
  my ($grp, $filelist)=@_;
  my $filecount=@$filelist;
  my $fno;
  foreach my $f (@$filelist) {
    if ($f=~/(##?[0-9A-Z]+(?:\.[0-9]+)?)$/) {
      $f=~s/(##?[0-9A-Z]+(?:\.[0-9]+)?)$//;
    }
    next if exists($grp->{preloaded}->{$f});
    print STDERR "Preloading: $f (",$fno+1,"/$filecount)\n" unless $opt_Q;
    my $fsfile = FSFile->newFSFile($f,$TrEd::Convert::inputenc,@backends);
    $fsfile->changeFileFormat(($f=~/\.gz$/ ? "gz-compressed " : "").$fsfile->backend);
    $grp->{preloaded}->{$f} = $fsfile;
  }
}

sub openFile {
  my ($grp,$f) = @_;
  my $goto = undef;
  my %fs=(fs => 'FS format',
	  fgz => 'gzipped FS format',
	  trxml => 'tree XML format',
	  any => 'any non-specific format (csts?), using CstsToFs');

  if ($f=~/(##?[0-9A-Z]+(?:\.[0-9]+)?)$/) {
    $f=~s/(##?[0-9A-Z]+(?:\.[0-9]+)?)$//;
      $goto=$1;
    print STDERR "Goto suffix is $goto\n" if $tredDebug;
  }

# saveFile($grp) unless (ref($grp->{FSFile}) and $grp->{FSFile}->filename() eq $f);
  closeFile($grp);

  if (exists($grp->{preloaded}) and
      exists($grp->{preloaded}->{$f})) {
    $grp->{'FSFile'} = $grp->{preloaded}->{$f};
  } else {
    $grp->{'FSFile'} = FSFile->newFSFile($f,$TrEd::Convert::inputenc,@backends);
    $grp->{'FSFile'}->changeFileFormat(($f=~/\.gz$/ ? "gz-compressed " : "").$grp->{'FSFile'}->backend);
    $grp->{preloaded}->{$f}=$grp->{'FSFile'} if ($grp->{FSFile} and exists($grp->{preloaded}));
  }
  print STDERR "empty or corrupt file!\n" if ($grp->{FSFile}->lastTreeNo<0);

  $grp->{treeNo}=0;
  $grp->{currentNode}=undef;
  applyFileSuffix($grp,$goto);
  doEvalHook($grp,"file_opened_hook");
  $grp->{root}=$grp->{FSFile}->treeList->[$grp->{treeNo}];
  unless (!$grp->{FSFile} || defined($grp->{currentNode})) {
    $grp->{currentNode}=$grp->{root};
  }

  return 1;
}

sub applyFileSuffix {
  my ($grp,$goto) = @_;
  return unless ref($grp) and defined($goto) and $goto ne "";
  # -- smells like PDT-specific code, at least the second case
  # but we want it, dont we:)

  if ($goto=~/^##([0-9]+)/) {
    $grp->{treeNo}=min(max(0,$1-1),$grp->{FSFile}->lastTreeNo);
  } elsif ($goto=~/^#([0-9]+)/) {
    for (my $i=0;$i<=$grp->{FSFile}->lastTreeNo;$i++) {
      $grp->{treeNo}=$i,last if ($grp->{FSFile}->treeList->[$i]->{'form'} eq "#$1");
    }
  }
  # new: we're the dot in .[0-9]+ (TM)
  my $root;
  if ($goto=~/\.([0-9]+)$/) {
    $root=$grp->{FSFile}->treeList->[$grp->{treeNo}];
    my $i=$1;
    while ($root and $i>0) {
      $i--;
      $root=$root->following();
    }
    $grp->{currentNode}=$root if ($root);
  }
  # hey, caller, you should redraw after this!
}

sub saveFile {
  my $grp=shift;
  return unless $grp->{'FSFile'};
  my $f=$grp->{'FSFile'}->filename;

  $grp->{FSFile}->changeBackend($backend) if ($backend);
  my $out=$f;
  $out=~s/$opt_s$/$opt_a/ if ($opt_s or $opt_a);
  $out=~s/^$opt_p/$opt_r/ if ($opt_p or $opt_r);
  if ($f eq $out) {
    unlink "$f~" if (-e "$f~" ); # silly MS OSs need this
    rename $f, "$f~" if (-f $f);
  }

  print STDERR "Saving $f as $out\n" unless $opt_Q;


  unless ($grp->{FSFile}->writeFile($out)) {
    print STDERR "Error saving file to '$out'\n($!)\n";
    return 0;
  }
}

sub closeFile {
  my ($grp)=@_;

  undef $NodeClipboard;
  $grp->{root}=undef;
  $grp->{FSFile}=undef;
  $grp->{treeNo}=undef;
  delete $grp->{'currentNode'} if (exists $grp->{'currentNode'});
}

sub doEvalHook {
  my ($group,$hook)=(shift,shift);
  return unless $hook;# and $group->{'currentNode'};

  $TredMacro::this=$group->{currentNode};
  $TredMacro::root=$group->{root};
  $TredMacro::libDir=$libDir;
  $TredMacro::FileNotSaved='?';
  $TredMacro::forceFileSaved=0;  
  my $result=do_eval_hook($group,$group->{macroContext},$hook);
  exit 1 if ($@ and !$opt_W);
  if ($group->{FSFile}) {
    if ($TredMacro::FileNotSaved eq '?') {
      $TredMacro::FileNotSaved=$group->{FSFile}->notSaved;
    }
    $group->{FSFile}->notSaved($group->{FSFile}->notSaved or $TredMacro::FileNotSaved);
  }

  $TredMacro::this=undef;
  $TredMacro::root=undef;
  $TredMacro::grp=undef;

  print STDERR "Hook $hook resulted with $result\n" if $hookDebug;
  return $result;
}

sub doEvalMacro {
  my ($group,$macro)=(shift,shift);
  return unless $macro;

  $TredMacro::this=$group->{currentNode};
  $TredMacro::root=$group->{root};
  $TredMacro::libDir=$libDir;
  $TredMacro::FileNotSaved='?';
  $TredMacro::forceFileSaved=0;

  my $result=do_eval_macro($group,$macro);
  exit 1 if ($@ and !$opt_W);

  if ($group->{FSFile}) {
    $TredMacro::FileNotSaved=0 if $TredMacro::FileNotSaved eq '?';
    if ($TredMacro::forceFileSaved) {
      $group->{FSFile}->notSaved($TredMacro::FileNotSaved);
    } else {
      $group->{FSFile}->notSaved($group->{FSFile}->notSaved or $TredMacro::FileNotSaved);
    }
    setCurrent($group,$TredMacro::this) if ($TredMacro::this);
  }
  $TredMacro::this=undef;
  $TredMacro::root=undef;
  $TredMacro::grp=undef;
  return $result;
}

sub switchContext {}

### Local Variables:
### mode: cperl
