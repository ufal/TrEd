#!/usr/bin/perl
# -*- cperl -*-
#
# BTred ver. 0.1 - Copyright (C) 2000 by Petr Pajas
# This software is covered by GPL - The General Public Licence
# Full text of the GPL can be found at http://www.gnu.org/copyleft/gpl.html.
#
# This program allows you run macros written for Tred in batch mode.
#

package main;

use Getopt::Long;
use Pod::Usage;
#use Getopt::Std;

if ($^V lt v5.6.0) {
  print STDERR '-' x 50,"\n";
  print STDERR "WARNING: Your version of perl is older than v5.6.0\n";
  print STDERR "THINGS MAY NOT WORK AS EXPECTED!\n";
  print STDERR '-' x 50,"\n\n";
}

## Passing -o args... -- to TredMacro
@TredMacro::ARGV=grep { /^-o$/.../^--$/ } @ARGV;
shift @TredMacro::ARGV; pop @TredMacro::ARGV;
@ARGV=grep { not(/^-o$/.../^--$/) } @ARGV;

use strict;
use vars qw($quiet $Quiet $debug $csts_xargs $strip_prefix $add_prefix
	    $strip_suffix $append_suffix $output_format $config_file
	    $initial_code $macro $code $start_context $all_trees
	    $all_nodes $all_nonhidden_nodes $file_encoding
	    $term_encoding $save $safe_mode $csts_tree_attrs
	    $csts_tecto $preload $warn_only $validate_fs $allow_host
	    $start_server $help $usage $manpage
	    $libDir $macroFile $stdout $stderr @backends @ISA @EXPORT
	    $fileNo $tredDebug $keyboardDebug $hookDebug $macroDebug
	    @files $backend %bkmap
	   );

#getopts('qQDx:p:r:s:a:f:c:i:m:e:t:n:hd:NHSTFX:RPWVL:b:');
Getopt::Long::Configure ("bundling");
GetOptions ("quiet|q" => \$quiet,
	    "very-quiet|Q" => \$Quiet,
	    "debugging|D" => \$debug,
	    "fs2csts-attributes|x=s" => \$csts_xargs,
	    "strip-prefix|p=s" => \$strip_prefix,
	    "add-prefix|r=s" => \$add_prefix,
	    "strip-suffix|s=s" => \$strip_suffix,
	    "add-suffix|a=s" => \$append_suffix,
	    "output-format|f=s" => \$output_format,
	    "config-file|c=s" => \$config_file,
	    "initial-code|i=s" => \$initial_code,
	    "macro-file|m=s" => \$macro,
	    "execute|e=s"    => \$code,
	    "context|t=s" => \$start_context,
	    "all-trees|T"    => \$all_trees,
	    "all-nodes|N"    => \$all_nodes,
	    "all-nonhidden-nodes|H"  => \$all_nonhidden_nodes,
	    "file-encoding|n=s" => \$file_encoding,
	    "terminal-encoding|d=s" => \$term_encoding,
	    "save|S" => \$save,
	    "safe-mode|F" => \$safe_mode,
	    "csts-tree-attributes|X" => \$csts_tree_attrs,
	    "tectogrammatical-trees|R" => \$csts_tecto,
	    "preload-files|P" => \$preload,
	    "warn-only|W" => \$warn_only,
	    "validate-fs|V" => \$validate_fs,
	    "allow-host|b=s" => \$allow_host,
	    "server-port|L=i"  => \$start_server,
	    "help|h" => \$help,
	    "usage|u"        => \$usage,
	    "man"            => \$manpage);

$quiet=1 if $Quiet;

# Help and usage
if ($usage) {
  pod2usage(-msg => 'ntred - controller/hub/client for remote btred servers');
#  exit 0;
}
if ($help) {
  pod2usage(-exitstatus => 0, -verbose => 1);
}
if ($manpage) {
  pod2usage(-exitstatus => 0, -verbose => 2);
}

$code||="autostart()"; # this is the default macro name

_set_encoding(\*STDERR,$term_encoding,"STDERR");
_set_encoding(\*STDOUT,$term_encoding,"STDOUT");

# in Windows, if HOME not defined, use user's AppData folder instaed
if ($^O eq "MSWin32" and !exists $ENV{HOME}) {
  require Win32::Registry;
  my %shf;
  my $ShellFolders;

  my $shfolders="Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders";
  $::HKEY_CURRENT_USER->Open($shfolders,$ShellFolders) or die "Cannot read $shfolders $^E\n";
  $ShellFolders->GetValues(\%shf);
  $ENV{HOME} = $shf{AppData}[2];
}

# Default values of $libDir used to search for macro-file (tred.mac)
# and default-macro file (tred.def) are specified here. They may be
# overriden by value of LibDir in tred resource file (tredrc or ~/.tredrc - see above).
# It is also used to find TrEd::Config.pm module.

use FindBin;
if (exists $ENV{TREDHOME}) {
  $libDir=$ENV{TREDHOME};
} elsif (-d "$FindBin::RealBin/tredlib") {
  $libDir="$FindBin::RealBin/tredlib";
} elsif (-d "$FindBin::RealBin/../lib/tredlib") {
  $libDir="$FindBin::RealBin/../lib/tredlib";
} elsif (-d "$FindBin::RealBin/../lib/tred") {
  $libDir="$FindBin::RealBin/../lib/tred";
}
_msg("Trying $libDir\n") if ($libDir and !$quiet);

$macroFile=undef;


# We *must* at least find TrEd::Config module to learn the correct libDir!!.
unshift @INC,$libDir if (-d $libDir);

do {
  my $ld=$libDir;
  require TrEd::Config;
  import TrEd::Config;
  import TrEd::Config qw(&read_config &set_default_config_file_search_list $defaultMacroFile $macroDebug $hookDebug);
  $libDir=$ld;
};

$TrEd::Config::quiet=$quiet;

if (defined $config_file) {
  @TrEd::Config::config_file_search_list=($config_file); 
  # override any other possible config files
} else {
  set_default_config_file_search_list();
}

if ($quiet) {
  $tredDebug=$keyboardDebug=$hookDebug=$macroDebug=0;
} elsif ($debug) {
  $tredDebug=$keyboardDebug=$hookDebug=$macroDebug=1;
}

my $configFile=read_config();
my $safe=$safe_mode; # so that it cannot be changed from outside

$macroFile="$libDir/tred.mac" unless (defined $macroFile);
if (defined $macro) {
  $macroFile=$macro;
}
####################################


unless (-d $libDir) {
  print <<'EOL';
 BTrEd couldn't find a tredlib directory. You may need to point
 to its location by the TREDHOME variable or add a correct LibDir
 field to your ~/.tredrc.

EOL
    die "Error: Couldn't find lib-directory.";
}

use Cwd;
unshift @INC,$libDir unless (grep($_ eq $libDir, @INC));

use Benchmark;


require Fslib;
import Fslib;
import Fslib qw(&Ord &Value &Hide &SentOrd &AOrd &AValue &AHide &ASentOrd &Index &ImportBackends);
$Fslib::Debug=1 if $debug;

# import min and max functions
require TrEd::MinMax;
import TrEd::MinMax;

# import encode and decode functions
require TrEd::Convert;
import TrEd::Convert;

# import read_macros etc.
require TrEd::Macros;
import TrEd::Macros;

# basic tree operations
require TrEd::Basics;
import TrEd::Basics;

#load back-ends
@backends=('FSBackend',ImportBackends(qw(AG2FS TrXMLBackend CSTS_SGML_SP_Backend TEIXMLBackend)));
$CSTS_SGML_SP_Backend::doctype = "$libDir/csts.doctype";

$stdout=\*STDOUT;
$stderr=\*STDERR;

use Exporter;
@ISA=qw(Exporter);
# This is default export to macros
@EXPORT = qw($libDir &min &max $stdout $stderr);

# it seems, that under Windoze setting LC_NUMERIC back to us does not
# work, so I recommend not to use czech locales there, unless you
# really want the decimal points to be replaced by commas in
# postscript:)
($TrEd::Config::useLocales) && do {
  use locale;
  use POSIX qw(locale_h);
  $ENV{LC_ALL}=undef;
  setlocale(LC_ALL,undef);
  setlocale(LC_NUMERIC,"C");
};

if ($TrEd::Config::useCzechLocales) {
  no strict;
  use locale;
  use POSIX qw(locale_h);
  setlocale(LC_COLLATE,"cs_CZ");
  setlocale(LC_NUMERIC,"C");
  setlocale(LANG,"cs_CZ");
}

# These are used only in macros and hooks!!!
$TredMacro::root=undef;
$TredMacro::this=undef;
$TrEd::Macros::FileNotSaved=0;
$TredMacro::forceFileSaved=0;

$TredMacro::_NoSuchTree=0; # for compatibility with Graph2Tred
$TredMacro::NodeClipboard=undef;

$fileNo=0;

#$TrEd::Basics::on_tree_change= \&updateTredMacroGlobals;
#$TrEd::Basics::on_node_change= \&updateTredMacroGlobals;
#$TrEd::Basics::on_current_change= \&updateTredMacroGlobals;

_msg("Reading macros from $macroFile...\n") unless $quiet;
read_macros($macroFile,$libDir);	# read macros
_msg("done.\n") unless $quiet;

@files=@ARGV;
@ARGV=@TredMacro::ARGV;



%bkmap=(
	fs => 'FSBackend',
	csts => 'CSTS_SGML_SP_Backend',
	trxml => 'TrXMLBackend',
	tei => 'TEIXMLBackend',
       );

$Fslib::FSTestListValidity=$validate_fs;

$csts_tecto && Csts2fs::setupTR();
if ($csts_tree_attrs ne "") {
  Csts2fs::setupSpec(split ',',$csts_tree_attrs);
}

@Fs2csts::extra_attributes=split /,/,$csts_xargs;

if ($output_format) {
  my $format=$output_format ? lc($output_format) : "";
  unless ( $backend=$bkmap{$format} ) {
    die "Unknown format $format. Use -f [fs|csts|trxml]\n";
  }
}

$TrEd::Convert::inputenc=$file_encoding if $file_encoding;

startMain();

exit;

############################
############################
############################
sub _msg { print STDERR "BTRED: ",@_; }
sub _make_uniq ($) { my %U; @{$_[0]} = grep {!exists($U{$_}) && ($U{$_}=1)} @{$_[0]} }
sub _benchmark () {
  my $number_of_iters=10000;
  my $i;
  my %a;
  my $benchmark_code='$a{$i++}=(join("",map uc,split "(..)","afa${i}sd ${i}fsd1f2 asf${i}1sdfdsf fsasf")=~/\s+\d+/);';
  (timestr timeit ($number_of_iters,$benchmark_code))=~/(\S+) CPU/;
#  return 200;
  return $1*1000; # miliseconds
}
sub _threads () { 1 };

sub _end_response {
  my ($control,$client)=@_;
  $client->print("$control END_OF_SERVER_RESPONSE\n");
}


sub startMain {
  my $grp={
	   treeNo => 0,
	   FSFile => undef,
	   macroContext =>  defined($start_context) ? $start_context : 'TredMacro',
	   currentNode => undef,
	   root => undef
	  };
  my $filecount=@files;
  #  eval (join("",@macros)."\n return 1;");
  my $context = $grp->{macroContext};

  if ($start_server) {
    require TrEd::Cipher;
    # Start btred server
    preloadFiles($grp,\@files);

    my $control="@@@"; # @@@ marks the beginning of control lines

    my $key = readline(*STDIN);
#    close STDIN;
    if ($key =~ /^$control SESSION-KEY=([0-9A-Z]+)$/) {
      $key = TrEd::Cipher::hex_to_block($1);
      /(.)/; # clean-up :-)
    } else {
      die "Was expecting the session key!\n";
    }

    my $port=$start_server;
    chomp (my $host=`/bin/hostname`); #$ENV{HOSTNAME};
    my $server = new IO::Socket::INET (LocalHost => $host,
				       LocalPort => $port,
				       Proto => 'tcp',
				       Listen => 5,
				       Reuse => 1,
					     );
    die "Cannot open socket at $host:$port!\n" unless $server;
    _msg("Waiting for hub on $host:$port\n");
    $allow_host=~s/\s//g;
    # resolve peer IP
    if ($allow_host) {
      ($allow_host) = (`LC_ALL=C host "$allow_host"` =~ / has address (.*)$/) if ($allow_host =~/[^:.0-9]/);
      _msg("Awaiting connection from $allow_host\n");
    }
    my ($hub,$peer);
    do {
      $hub = $server->accept();
      $peer=$hub->peerhost();
      if ($hub and $allow_host and $peer ne $allow_host) {
	_msg("Denying connection to peer $peer!\n");
	$hub->close();
	undef $hub;
      } elsif ($hub and TrEd::Cipher::Authentify($key,$hub,$control)!=1) {
	$hub->close();
	undef $hub;
      }
    } while (!$hub);
    _set_encoding($hub,$term_encoding,"socket to hub");
    _msg("Connection to the hub on $peer established.\n");
    my $request_no=0;
    _msg("Waiting for a request from the hub...\n\n");
    $hub->autoflush(1);
    while (1) {
      my $state='default';
      my %request;
      # --- reading request from hub ---
      while (<$hub>) {
        if (/^$control REQUEST_TYPE=(.*)/) {
	  $request_no++;
	  _msg("Receiving request $request_no: $1\n");
	  $request{REQUEST_TYPE}=$1;
        } elsif (/^$control STATE=(.*)/) {
	  $state=$1;
        } elsif (!/^$control/) {
	  $request{$state}.=$_;
        } elsif (/$control END_OF_REQUEST/) {
          $state='END_OF_REQUEST';
	  last
        }
      }
      ($state eq 'END_OF_REQUEST') || die "Broken request $request{REQUEST_TYPE}!\n";
      _msg "Request received from the hub: $request{REQUEST_TYPE}\n";

      # --- performing the request on the trees ----
      _msg("Performing the hub request...\n");

      if ($request{REQUEST_TYPE} eq 'LOAD_FILES') {
	my @new=split /\n/,$request{default};
	@files=(@files,@new);
	eval {
	  preloadFiles($grp,[@new],$hub);
	  die $@ if $@ ;
	};
	if ($@) {
	  $hub->print("$@\n");
	} else {
	  $hub->print("OK\n");
	}
	_end_response($control,$hub);
      } elsif ($request{REQUEST_TYPE} eq 'BENCHMARK') {
	$hub->print(_benchmark(),",",_threads(),"\n"); # benchmark,threads
	_end_response($control,$hub);
      } elsif ($request{REQUEST_TYPE} eq 'EVAL_CODE') {
	_msg("Initializing safe compartment...\n") if $safe;

	# initialize Safe compartment
	init_safe_mode($grp) if $safe;
	gotoFile($grp,0); # neither goto_file_hook nor file_open_hook in server-mode

	# create temporary file to store macro output
	my $macro_stdout = IO::File->new_tmpfile();

	*MOUT=*$macro_stdout;
	#open OLDSTDOUT, ">&STDOUT" or die "Can't dup STDOUT: $!";
	open(STDOUT, "+>&MOUT") or die "Can't redirect STDOUT: $!";

	# script command-line arguments
	if (exists($request{ARGS})) {
	  @{macro_variable('TredMacro::ARGV')}=split "\n",$request{ARGS};
	} else {
	  @{macro_variable('TredMacro::ARGV')}=();
	}

	STDOUT->autoflush();
	# load macro
	_msg "COMPILING MACRO\n";
	doEvalMacro($grp,"package $context;\n"."#line 1 \"$request{REQUEST_TYPE}\"\n".$request{MACRO});
	# execute hooks and the code of the query
	my $time;
	$hub->print("$control SERVER_RESPONSE_STDERR\n");
	if (!$@ and keys(%{$grp->{preloaded}}) and
	    doEvalHook($grp,"start_hook") ne 'stop' and
	    doEvalHook($grp,"preload_hook") ne 'stop') { # for compatibility
	  _msg "RUNNING CODE: $request{CODE}\n";
	  my $t0 = new Benchmark;
	  do {
	    doEvalMacro($grp,"package $context;".$request{CODE});
	  } while (!$@ and nextFile($grp));
	  $hub->print("$@\n") if $@;
	  _msg($@) if $@;
	  doEvalHook($grp,"exit_hook");
	  $hub->print("$@\n") if $@;
	  _msg($@) if $@;
	  my $t1 = new Benchmark;
	  $time = timediff($t1, $t0) if ($t1 and $t0);
	}
	$hub->print("Total Time: ",timestr($time),"\n") if $time ne "";
	$hub->print("No files to process at btred server $host:$port\n") if (!keys(%{$grp->{preloaded}}));
	$hub->print("$control SERVER_RESPONSE_STDOUT\n");
	# send macro's output from tmp file to client
	$macro_stdout->flush();
	seek($macro_stdout,0,0);
	my $space;
	while (<$macro_stdout>) {
	  $hub->print($_);
	  $space=chomp;
	}
	$hub->print("\n") unless $space;
	$macro_stdout->close;
	undef $macro_stdout;
	#open STDOUT, ">&OLDSTDOUT" or die "Can't dup OLDSTDOUT: $!";

	_end_response($control,$hub);
	_msg("The processing of request $request_no completely finished.\n");
      } elsif ($request{REQUEST_TYPE} eq 'QUIT') {
	_msg "Quitting on client's request\n";
	$hub->print("OK\n");
	_end_response($control,$hub);
	exit 0;
      } elsif ($request{REQUEST_TYPE} eq 'RELOAD') {
	_msg "Reloading all open files at client's request\n";
	%{$grp->{preloaded}}=();
	eval {
	  preloadFiles($grp,\@files,$hub);
	  die $@ if $@ ;
	};
	if ($@) {
	  $hub->print("$@\n");
	} else {
	  $hub->print("OK\n");
	}
	_end_response($control,$hub);
      } elsif ($request{REQUEST_TYPE} eq 'LIST') {
	_msg "Listing all open files at client's request\n";
	$hub->print("$control SERVER_RESPONSE_STDOUT\n");
	$hub->print(join("\n",@files),"\n");
	_end_response($control,$hub);
      } elsif ($request{REQUEST_TYPE} eq 'DUMP') {
	$hub->print("$control SERVER_RESPONSE_STDOUT\n");
	_msg "Request $request{default} at client's request\n";
	foreach my $f (grep /\S/,split /\n/,$request{default}) {
	  next unless ($f);
	  _msg "Dumping some tree $f at client's request\n";
	  next unless openFile($grp,$f,-justpreloaded => 1);
	  for my $fsfile ($grp->{FSFile}) {
	    $fsfile->FS->writeTo($hub);
	    Fslib::PrintFS($hub,undef,
			   $f=_has_suffix($f) ? [$grp->{root}] :
			   $fsfile->treeList,
			   $fsfile->FS->list,
			   $fsfile->FS->defs);
	  }
	  $hub->print("(2,3)\n\n//FSEND\n\n");
	}
	_end_response($control,$hub);
      } elsif ($request{REQUEST_TYPE} eq 'UPLOAD') {
	$hub->print("$control SERVER_RESPONSE_STDOUT\n");
	_msg "Request $request{Filename} at client's request\n";
	my $f=$request{Filename};
	chomp $f;
	my @fs=map {$_."\n"} split /\n/,$request{FSFile};
	if ($f and openFile($grp,$f,-justpreloaded => 1) and ref($grp->{FSFile})) {
	  _msg "Uploading $f at client's request\n";
	  my $fsfile=FSFile->new();
	  local $Fslib::Debug=1;
#	  _msg "received @fs\n";
	  if (FSBackend::read(\@fs,$fsfile) and ref($fsfile->treeList()->[0])) {
	    if (_has_suffix($f)) {
	      _msg "Updated tree $grp->{treeNo} ($f)\n";
	      # change only one tree
	      $grp->{FSFile}->treeList()->[$grp->{treeNo}]=$fsfile->treeList()->[0];
	      $fsfile->changeTreeList([]);
	      closeFile($grp);
	    } else {
	      _msg "Updated whole file ($f)\n";
	      # change the whole file
	      $grp->{FSFile}->changeTreeList($fsfile->treeList());
	      $fsfile->changeTreeList([]);
	      closeFile($grp);
	    }
	  } else {
	    _msg "read failed\n";
	  }
	}
	_end_response($control,$hub);
      } elsif ($request{REQUEST_TYPE} eq 'SAVE') {
	for (qw(Format Strip-suffix Strip-prefix Prefix Suffix)) {
	  chomp($request{$_}) if exists $request{$_};
	}
	do {
	  local $backend=$bkmap{$request{Format}} if exists $request{Format};
	  local $strip_prefix=$request{"Strip-prefix"} if exists $request{"Strip-prefix"};
	  local $strip_suffix=$request{"Strip-suffix"} if exists $request{"Strip-suffix"};
	  local $add_prefix=$request{"Prefix"} if exists $request{"Prefix"};
	  local $append_suffix=$request{"Suffix"} if exists $request{"Suffix"};
	  eval {
	    gotoFile($grp,0);
	    die $@ if $@;
	    do {
	      next unless ref($grp->{FSFile});
	      my $out = saveFile($grp);
	      $hub->print("Saved ",$grp->{'FSFile'}->filename," as $out\n");
	      die $@ if $@;
	    } while (nextFile($grp));
	    die $@ if $@;
	  };
	};
	$hub->print("$@\n") if $@;
	_end_response($control,$hub);
      } elsif ($request{REQUEST_TYPE} eq 'CLOSE') {
	_msg "Reloading all open files at client's request\n";
	closeFile($grp);
	%{$grp->{preloaded}}=();
	@files=();
	$hub->print("OK\n");
	_end_response($control,$hub);
      } else {
	$hub->print("ERROR: UNKNOWN REQUEST TYPE $request{REQUEST_TYPE}\n");
	_end_response($control,$hub);
      }
      _msg("Waiting for a new request from the hub...\n\n");
    }
  } else {
    init_safe_mode($grp) if $safe;
    my $pre='';
    $pre .= "do { " if ($all_trees);
    $pre .= "while (\$this) {" if ($all_nodes or $all_nonhidden_nodes);
    my $post.= "\$this=\$this->following; \n}" if ($all_nodes);
    $post.= "\$this=\$this->following_visible(\$grp->{FSFile}->FS); \n}"
      if (not $all_nodes and $all_nonhidden_nodes);
    $post.= " } while NextTree();" if ($all_trees);
    my $premacro= <<EOL;
package $context;
sub _btred_eval_ {
$pre
$code;
$post
}

$initial_code;
EOL

    _msg "<script>\n$premacro;\n</script>\n" unless $quiet;
    doEvalMacro($grp,$premacro);

    exit if doEvalHook($grp,"start_hook") eq 'stop'; # run start_hook
    preloadFiles($grp,\@files) if $preload; # -P : load all files into memory

    exit if $preload and doEvalHook($grp,"preload_hook") eq 'stop'; # run start_hook
    openFile($grp,$files[$fileNo]) if $fileNo <= $#files; # goto first file
    if (@files) {
      do {
	_msg "Processing: $files[$fileNo] (",$fileNo+1,"/$filecount)\n" unless $Quiet;
	doEvalMacro($grp,"$context->_btred_eval_();");
	STDOUT->flush();
	STDERR->flush();
	_msg "Done.\n" unless $quiet;
	saveFile($grp) if ($grp->{FSFile}->notSaved or $save);
      } while (nextFile($grp));
    } else {
      _msg "No files to process!\n" unless $Quiet;
    }
    doEvalHook($grp,"exit_hook");
  }
}


sub lastFileNo {
  return $#files;
}

sub currentFileNo {
  return $fileNo;
}

sub gotoFile {
  my ($grp,$fn)=@_;
  return 0 unless $start_server or doEvalHook($grp,"goto_file_hook") ne 'stop';
  return 0 if ($fn>$#files or $fn<0);
  $fileNo=$fn;
  openFile($grp,$files[$fileNo]);
  return 1;
}


sub nextFile {
  my ($grp)=@_;
  return 0 if ($fileNo >= $#files);
  $fileNo++;
  openFile($grp,$files[$fileNo]);
  return 1;
}

sub prevFile {
  my ($grp)=@_;
  return 0 unless ($fileNo > 0);
  $fileNo--;
  openFile($grp,$files[$fileNo]);
  return 1;
}

sub preloadFiles {
  my ($grp, $filelist, $errlog)=@_;
  my $filecount=@$filelist;
  my $fno=1;
  foreach my $f (@$filelist) {
    if ($f=~/(##?[0-9A-Z]+(?:\.[0-9]+)?)$/) {
      $f=~s/(##?[0-9A-Z]+(?:\.[0-9]+)?)$//;
    }
    next if exists($grp->{preloaded}->{$f});
    _msg "Preloading: $f (",$fno++,"/$filecount)\n" unless $Quiet;
    my $fsfile = FSFile->newFSFile($f,$TrEd::Convert::inputenc,@backends);
    if ($fsfile->lastTreeNo<0) {
      _msg "empty or corrupt file: $f!\n";
      $errlog->print("ERROR: Empty or corrupt file: $f!\n") if ($errlog);
      next;
    }
    $fsfile->changeFileFormat(($f=~/\.gz$/ ? "gz-compressed " : "").$fsfile->backend);
    $grp->{preloaded}->{$f} = $fsfile;
  }
  @files=grep { exists($grp->{preloaded}->{$_}) } @files;
  _make_uniq(\@files);
}

sub openFile {
  my ($grp,$f,%opts) = @_;
  my $goto = undef;
  my %fs=(fs => 'FS format',
	  fgz => 'gzipped FS format',
	  trxml => 'tree XML format',
	  any => 'any non-specific format (csts?), using CstsToFs');

  if ($f=~/(##?[0-9A-Z]+(?:\.[0-9]+)?)$/) {
    $f=~s/(##?[0-9A-Z]+(?:\.[0-9]+)?)$//;
      $goto=$1;
    _msg "Goto suffix is $goto\n" if $tredDebug;
  }

# saveFile($grp) unless (ref($grp->{FSFile}) and $grp->{FSFile}->filename() eq $f);
  closeFile($grp);

  if (exists($grp->{preloaded}) and
      exists($grp->{preloaded}->{$f})) {
    $grp->{'FSFile'} = $grp->{preloaded}->{$f};
  } elsif ($opts{-justpreloaded}) {
    return 0;
  } else {
    $grp->{'FSFile'} = FSFile->newFSFile($f,$TrEd::Convert::inputenc,@backends);
    $grp->{'FSFile'}->changeFileFormat(($f=~/\.gz$/ ? "gz-compressed " : "").$grp->{'FSFile'}->backend);
    $grp->{preloaded}->{$f}=$grp->{'FSFile'} if ($grp->{FSFile} and exists($grp->{preloaded}));
  }
  _msg "empty or corrupt file: $f!\n" if ($grp->{FSFile}->lastTreeNo<0);

  $grp->{treeNo}=0;
  $grp->{currentNode}=undef;
  applyFileSuffix($grp,$goto);

  doEvalHook($grp,"file_opened_hook") unless ($opts{-justpreloaded} or $start_server);
  $grp->{root}=$grp->{FSFile}->treeList->[$grp->{treeNo}];
  unless (!$grp->{FSFile} || defined($grp->{currentNode})) {
    $grp->{currentNode}=$grp->{root};
  }

#  updateTredMacroGlobals($grp);
  return 1;
}

sub _has_suffix {
  return $_[0]=~/##?[0-9A-Z]+(?:\.[0-9]+)?$/
}

sub applyFileSuffix {
  my ($grp,$goto) = @_;
  return unless ref($grp) and defined($goto) and $goto ne "";
  # -- smells like PDT-specific code, at least the second case
  # but we want it, dont we:)

  if ($goto=~/^##([0-9]+)/) {
    $grp->{treeNo}=min(max(0,$1-1),$grp->{FSFile}->lastTreeNo);
  } elsif ($goto=~/^#([0-9]+)/) {
    for (my $i=0;$i<=$grp->{FSFile}->lastTreeNo;$i++) {
      $grp->{treeNo}=$i,last if ($grp->{FSFile}->treeList->[$i]->{'form'} eq "#$1");
    }
  }
  # new: we're the dot in .[0-9]+ (TM)
  my $root;
  if ($goto=~/\.([0-9]+)$/) {
    $root=$grp->{FSFile}->treeList->[$grp->{treeNo}];
    my $i=$1;
    while ($root and $i>0) {
      $i--;
      $root=$root->following();
    }
    $grp->{currentNode}=$root if ($root);
  }
}

sub saveFile {
  my $grp=shift;
  return unless $grp->{'FSFile'};
  my $f=$grp->{'FSFile'}->filename;

  $grp->{FSFile}->changeBackend($backend) if ($backend);
  my $out=$f;
  $out=~s/$strip_suffix$/$append_suffix/ if ($strip_suffix ne "" or $append_suffix ne "");
  $out=~s/^$strip_prefix/$add_prefix/ if ($strip_prefix ne "" or $add_prefix ne "");
  if ($f eq $out) {
    unlink "$f~" if (-e "$f~" ); # silly MS OSs need this
    rename $f, "$f~" if (-f $f);
  }

  _msg "Saving $f as $out\n" unless $Quiet;


  unless ($grp->{FSFile}->writeFile($out)) {
    _msg "Error saving file to '$out'\n($!)\n";
    return undef;
  }
  return $out;
}

sub closeFile {
  my ($grp)=@_;

  undef ${macro_variable('TredMacro::NodeClipboard')};
  $grp->{root}=undef;
  $grp->{FSFile}=undef;
  $grp->{treeNo}=undef;
  delete $grp->{'currentNode'} if (exists $grp->{'currentNode'});
}

sub doEvalHook {
  my ($group,$hook)=(shift,shift);
  no strict qw(refs);
  return unless $hook;# and $group->{'currentNode'};

  ${macro_variable('TredMacro::this')}=$group->{currentNode};
  ${macro_variable('TredMacro::root')}=$group->{root};
  ${macro_variable('TredMacro::libDir')}=$libDir;
  ${macro_variable('TredMacro::FileNotSaved')}='?';
  ${macro_variable('TredMacro::forceFileSaved')}=0;
  my $result=do_eval_hook($group,$group->{macroContext},$hook);
  _msg "$@" if $@;
  exit 1 if ($@ and !$warn_only and !$start_server);

  if ($group->{FSFile}) {
    if (${macro_variable('TredMacro::FileNotSaved')} eq '?') {
      ${macro_variable('TredMacro::FileNotSaved')}=$group->{FSFile}->notSaved;
    }
    $group->{FSFile}->notSaved($group->{FSFile}->notSaved or ${macro_variable('TredMacro::FileNotSaved')});
  }

#  ${macro_variable('TredMacro::this')}=undef;
#  ${macro_variable('TredMacro::root')}=undef;
#  ${macro_variable('TredMacro::grp')}=undef;

  _msg "Hook $hook resulted with $result\n" if $hookDebug;
  return $result;
}

sub doEvalMacro {
  my ($group,$macro)=(shift,shift);
  return unless $macro;
  no strict qw(refs);
  ${macro_variable('TredMacro::this')}=$group->{currentNode};
  ${macro_variable('TredMacro::root')}=$group->{root};
  ${macro_variable('TredMacro::libDir')}=$libDir;
  ${macro_variable('TredMacro::FileNotSaved')}='?';
  ${macro_variable('TredMacro::forceFileSaved')}=0;

  my $result=do_eval_macro($group,$macro);

  _msg "$@" if $@;
  exit 1 if ($@ and !$warn_only and !$start_server);

  if ($group->{FSFile}) {
    ${macro_variable('TredMacro::FileNotSaved')}=0 if ${macro_variable('TredMacro::FileNotSaved')} eq '?';
    if (${macro_variable('TredMacro::forceFileSaved')}) {
      $group->{FSFile}->notSaved(${macro_variable('TredMacro::FileNotSaved')});
    } else {
      $group->{FSFile}->notSaved($group->{FSFile}->notSaved or ${macro_variable('TredMacro::FileNotSaved')});
    }
    setCurrent($group,${macro_variable('TredMacro::this')}) if (${macro_variable('TredMacro::this')});
  }
  ${macro_variable('TredMacro::this')}=undef;
  ${macro_variable('TredMacro::root')}=undef;
  ${macro_variable('TredMacro::grp')}=undef;
  return $result;
}

sub init_safe_mode {
  my ($grp)=@_;
  require Safe;
  $TrEd::Macros::macrosEvaluated=0;
  $TrEd::Macros::safeCompartment=undef;
  %{TredMacroCompartment::}=(); # cleanup
  my $compartment = Safe->new('TredMacroCompartment');
  $compartment->reval("package TredMacro;\n");
  $compartment->deny_only(qw()); # everything allowed for the first initialization
  $compartment->share(qw(&do_eval_macro &do_eval_hook &min &max @INC 
                         &nextTree &prevTree &gotoTree &lastFileNo &currentFileNo $stderr $stdout));
  $compartment->share_from('TrEd::Config',[qw($libDir)]);

  $TrEd::Macros::safeCompartment=$compartment;
  TrEd::Macros::initialize_macros($grp);
# OPCODES ALLOWED IN SAFE MODE

#			       :base_io :base_orig :filesys_read :filesys_open
#			       :filesys_write
  $compartment->permit_only(qw(:base_core :base_mem :base_loop :base_math :base_orig
			       entereval caller dofile
			       print entertry leavetry tie untie bless
			       sprintf localtime gmtime sort require));
  $compartment->deny(qw(getppid getpgrp setpgrp getpriority setpriority
			pipe_op sselect select dbmopen dbmclose tie untie
		       ));
			
  $TrEd::Macros::safeCompartment=$compartment;
}

sub switchContext {}

sub updateTredMacroGlobals {
  my ($grp)=@_;
  ${macro_variable('TredMacro::root')}=$grp->{root};
  ${macro_variable('TredMacro::this')}=$grp->{currentNode};
}

sub _set_encoding {
  my ($fh, $enc, $what)=@_;
  if ($enc and $]>=5.008) {
    eval {
      _msg("forcing encoding $enc for $what\n") if $debug;
      binmode $fh,":encoding($enc)";
    };
    _msg $@ if $@;
  }
}

__END__

=head1 ntred

btred - non-interactive scriptable version of the tree editor TrEd

=head1 SYNOPSIS

  btred [-c config-file]
        [-t context] [-m macro-file] [-e code] [-i init-code]
        [-N|-H] [-T] [-S] [-P] [-F]
        [-s strip-sfx] [-a append-sfx] [-p strip-prefix] [-r add-prefix]
        [-f out-fmt] [-n file-encoding] [-d terminal-encoding]
        [-W] [-q|-Q] [-D] [-V] [-L port] [-b hub]
        [-x extra_attribs] [-X gov,ord] [-R]
        [-o script options -- ] files...
or
  btred -u          to show usage
  btred -h          to show help
  btred --man       to show manual page

=head1 DESCRIPTION

BTrEd loads given macro-file and executes given code for each file.

=head1 OPTIONS

=over 8

=item B<--macro-file|-m> filename

File with macro definitions to load.  If no macro-file is given,
standard macro file (see TrEd documentation) is used.

=item B<--execute|-e> code

Macro code to apply to given files. If no code is specified, btred
expects a function called `autostart' to be defined in the used
context and defaults to `autostart()' as the macro code.

The macro code may use all functions defined in the given macro file,
the default macro file tred.def, plus all functions and methods from
Fslib (see Fslib documentation).

Note, that a lot of information on the current node, file etc. can be
obtained using some pre-defined macro from `tred.def'. The
documentation for `tred.def' is a highly recommended reading for btred
macro coder and macros defined there in should be prefered in all
applicable situations.

As in TrEd, the following variables may be used in the macros:

$this - the current node (the root of the first tree in a file at the
beginning)

$root - the root node of the current tree

$grp->{FSFile} - current FSFile object (see section on FSFile in Fslib
documentation)

$grp->{treeNo}       - current tree number

$grp->{macroContext} - current macro context

$FileChanged ($TredMacro::FileChanged) - macro may change this to 1 to
indicate that the file should be saved at the end of the
pocessing. This variable is called $FileNotSaved in older
documentation. Both names are equally usable.

=item B<--initial-code|-i> code

Code to be evaluated before any file is open.

=item B<--context|-t>

Start in the given macro context (Perl package).
The default context is `TredMacro'.

=item B<--strip-prefix|-p> regexp

Remove strings matching given regexp from the beginning of filenames
before saving.

=item B<--add-prefix|-r> prefix

Prepend output filenames with the given prefix.

=item B<--strip-suffix|-s> regexp

Strip strings matching given regexp from the end of filenames.

=item B<--add-suffix|-a> suffix

Append given suffix to the filenames.

=item B<--output-format|-f> [fs|csts|trxml|tei]

Format to use for files being saved.

=item B<--config-file|-c> filename

TrEd configuration file.

=item B<--all-trees|-T>

Apply the macro code to all trees (wrapping the code into a
C<do { CODE } while NextTree()> loop).

=item B<--all-nodes|-N>

Apply the macro code tn all nodes (you still must use --all-trees or
-T to aplly to all trees in a file) (wrapping the code into a C<while
($this) { CODE ; $this=$this->following }";> loop).

=item B<--all-nonhidden-nodes|-H>

Apply the macro code to all nodes except the hidden ones (you still
must use --all-trees or -T to process all trees in a file). This
option wraps the code into a C<while ($this) { CODE ;
$this=$this->following_visible(FS()) }";> loop).

=item B<--file-encoding|-n> encoding

Allows to specify character encoding of input files (does not apply to
XML files) and is probably only useful with Perl >= 5.8.

=item B<--terminal-encoding|-d> encoding

Automatically apllies given character encoding to all stdout and
stderr output operations. Works only with Perl >= 5.8.

=item B<--save|-S>

Unconditionally save files after macro code was applied.  By default,
files are saved only if the C<$FileChanged> variable has been set to 1
within the macro code.

=item B<--safe-mode|-F>

Run macro code in a safe compartment restricting some operations that
could be used by a malicious code writer to explore and compromise the
user's environment and potentially the entire system. Most notably,
this blocks most IO operations. NO WARRANTY! If unsure, don't run the
macro code at all.

=item B<--csts-tree-attributes|-X> gov,ord

Allows provide comma separated list consisting of two names for CSTS
elements that contain the necessary information to build a tree out of
a CSTS file. The first one shoud contain the index of the governing
node and the second one the topological order of the node in the tree.

=item B<--tectogrammatical-trees|-R>

Build tectogrammatic trees from CSTS files.

=item B<--fs2csts-attributes|-x> list

Comma separated list of FS attribute names that
should be preserved as <x> elements when saving to CSTS.

=item B<--confing-file|-c> filename

Use given TrEd configuration file.

=item B<--preload-files|-P>

Preload all given files into memory before applying the macros.

=item B<--warn-only|-W>

Do not stop (die) on errors, just warn.

=item B<--validate-fs|-V>

Force Fslib to test validity of values assigned to @L (list)
attributes in FS files.

=item B<--quiet|-q>

Print only general processing information on stderr.

=item B<--very-quiet|-Q>

Don't print anything to stderr at all (except for fatal errors).

=item B<--debugging|-D>

Print a lot of debugging information on the stderr.

=item B<--server-port|-L> port

Start btred server, listening on given port; implies -P. Use a
suitable client such as B<ntred> to apply a macro code on the files
possesed by the server.

=item B<--allow-host|-b> hostname

Accept only connections from given host when operating in the
server-mode.

=item B<--usage|-u>

Print a brief help message on usage and exits.

=item B<--help|-h>

Prints the help page and exits.

=item B<--man>

Displays the help as manual page.

=head1 AUTHOR

Petr Pajas <pajas@matfyz.cz>

Copyright 2000-2003 Petr Pajas, All rights reserved.

