#!/usr/bin/perl
# -*- cperl -*-
#
# $Id$
#
# BTred ver. 0.1 - Copyright (C) 2000 by Petr Pajas
# This software is covered by GPL - The General Public Licence
# Full text of the GPL can be found at http://www.gnu.org/copyleft/gpl.html.
#
# This program allows you run macros written for Tred in batch mode.
#

package main;

use Getopt::Long;
use Pod::Usage;
use IO;
use IO::File;
#use Getopt::Std;

if ($^V lt v5.6.0) {
  print STDERR '-' x 50,"\n";
  print STDERR "WARNING: Your version of perl is older than v5.6.0\n";
  print STDERR "THINGS MAY NOT WORK AS EXPECTED!\n";
  print STDERR '-' x 50,"\n\n";
}

use strict;
use vars qw($quiet $Quiet $debug $csts_xargs $strip_prefix $add_prefix
	    $strip_suffix $append_suffix $output_format $config_file
	    $initial_code $macro $code $start_context $all_trees
	    $all_nodes $no_all_trees $no_all_nodes
	    $all_nonhidden_nodes $file_encoding
	    $term_encoding $save $safe_mode $csts_tree_attrs
	    $csts_tecto $preload $warn_only $validate_fs $allow_host
	    $start_server $help $usage $manpage $obey_locks
	    $NO_HOOKS $userlogin
	    $libDir $macroFile $stdout $stderr @backends @ISA @EXPORT
	    $fileNo $tredDebug $keyboardDebug $hookDebug $macroDebug
	    @files $backend %bkmap $nosave @preload_modules $print_version
	    $version $lib $extra_backends $file_list
	    $_ERR %optmap $no_secondary
	   );

$version='$Revision$ ';

## Passing -o args... -- to TredMacro
@TredMacro::ARGV=grep { /^-o$/.../^--$/ } @ARGV;
shift @TredMacro::ARGV; pop @TredMacro::ARGV;
@ARGV=grep { not(/^-o$/.../^--$/) } @ARGV;

#getopts('qQDx:p:r:s:a:f:c:i:m:e:t:n:hd:NHSTFX:RPWVL:b:');
my $optparser=new Getopt::Long::Parser(config => ["bundling"]);
%optmap =  (
	    "quiet|q" => \$quiet,
	    "very-quiet|Q" => \$Quiet,
	    "debugging|D" => \$debug,
	    "fs2csts-attributes|x=s" => \$csts_xargs,
	    "filelist|l=s" => \$file_list,
	    "strip-prefix|p=s" => \$strip_prefix,
	    "add-prefix|r=s" => \$add_prefix,
	    "strip-suffix|s=s" => \$strip_suffix,
	    "add-suffix|a=s" => \$append_suffix,
	    "output-format|f=s" => \$output_format,
	    "config-file|c=s" => \$config_file,
	    "initial-code|i=s" => \$initial_code,
	    "macro-file|m=s" => \$macro,
	    "execute|e=s"    => \$code,
	    "context|t=s" => \$start_context,
	    "all-trees|T"    => \$all_trees,
	    "no-all-trees"    => \$no_all_trees,
	    "all-nodes|N"    => \$all_nodes,
	    "no-all-nodes"    => \$no_all_nodes,
	    "all-nonhidden-nodes|H"  => \$all_nonhidden_nodes,
	    "file-encoding|n=s" => \$file_encoding,
	    "terminal-encoding|d=s" => \$term_encoding,
	    "save|S" => \$save,
	    "no-save" => \$nosave,
	    "safe-mode|F" => \$safe_mode,
	    "obey-locks|O" => \$obey_locks,
	    "no-secondary|Y" => \$no_secondary,
	    "csts-tree-attributes|X" => \$csts_tree_attrs,
	    "tectogrammatical-trees|R" => \$csts_tecto,
	    "preload-files|P" => \$preload,
	    "warn-only|W" => \$warn_only,
	    "validate-fs|V" => \$validate_fs,
	    "allow-host|b=s" => \$allow_host,
	    "server-port|L=i"  => \$start_server,
	    "help|h" => \$help,
	    "usage|u"        => \$usage,
	    "man"            => \$manpage,
	    "lib"            => \$lib,
	    "preload-module|M=s" => \@preload_modules,
	    "extra-backends|B=s" => \$extra_backends,
	    "version|v"        => \$print_version
	   );

$optparser->getoptions(%optmap) or $usage=1;

if ($print_version) {
  my $ver=$version;
  $ver=~s/\$//g;
  print "BTrEd $ver\nPerl: $]\nPlatform: $^O\n";
  exit;
}


($userlogin) = (getlogin() || ($^O ne 'MSWin32') && getpwuid($<) || 'unknown');
($userlogin =~ /\S/) || warn "Couldn\'t deterbmine user\'s login name\n";

$quiet=1 if $Quiet;
$NO_HOOKS = 0;

unless (open $_ERR, ">&STDERR") {
  warn("Can't dup STDERR: $!");
  $_ERR=\*STDERR;
}

$_ERR->autoflush(1);

# Help and usage
if ($usage) {
  pod2usage(-msg => 'ntred - controller/hub/client for remote btred servers');
#  exit 0;
}
if ($help) {
  pod2usage(-exitstatus => 0, -verbose => 1);
}
if ($manpage) {
  pod2usage(-exitstatus => 0, -verbose => 2);
}

_set_encoding($_ERR,':utf8',"_ERR");
_set_encoding(\*STDERR,$term_encoding,"STDERR");
_set_encoding(\*STDOUT,$term_encoding,"STDOUT");

# in Windows, if HOME not defined, use user's AppData folder instaed
if ($^O eq "MSWin32" and !exists $ENV{HOME}) {
  require Win32::Registry;
  my %shf;
  my $ShellFolders;

  my $shfolders="Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders";
  $::HKEY_CURRENT_USER->Open($shfolders,$ShellFolders) or die "Cannot read $shfolders $^E\n";
  $ShellFolders->GetValues(\%shf);
  $ENV{HOME} = $shf{AppData}[2];
}

# Default values of $libDir used to search for macro-file (tred.mac)
# and default-macro file (tred.def) are specified here. They may be
# overriden by value of LibDir in tred resource file (tredrc or ~/.tredrc - see above).
# It is also used to find TrEd::Config.pm module.

use FindBin;
if (exists $ENV{TREDHOME}) {
  $libDir=$ENV{TREDHOME};
} elsif (-d "$FindBin::RealBin/tredlib") {
  $libDir="$FindBin::RealBin/tredlib";
} elsif (-d "$FindBin::RealBin/../lib/tredlib") {
  $libDir="$FindBin::RealBin/../lib/tredlib";
} elsif (-d "$FindBin::RealBin/../lib/tred") {
  $libDir="$FindBin::RealBin/../lib/tred";
}
_msg("Trying $libDir\n") if ($libDir and !$quiet);

$macroFile=undef;


# We *must* at least find TrEd::Config module to learn the correct libDir!!.
unshift @INC,$libDir if (-d $libDir);

do {
  my $ld=$libDir;
  require TrEd::Config;
  import TrEd::Config;
  import TrEd::Config qw(&read_config &set_default_config_file_search_list $defaultMacroFile $macroDebug $hookDebug);
  $libDir=$ld;
};

$TrEd::Config::quiet=$quiet;

if (defined $config_file) {
  @TrEd::Config::config_file_search_list=($config_file); 
  # override any other possible config files
} else {
  set_default_config_file_search_list();
}

if ($quiet) {
  $tredDebug=$keyboardDebug=$hookDebug=$macroDebug=0;
} elsif ($debug) {
  $IOBackend::Debug=$tredDebug=$keyboardDebug=$hookDebug=$macroDebug=1;
}

my $configFile=read_config();
my $safe=$safe_mode; # so that it cannot be changed from outside

$macroFile="$libDir/tred.mac" unless (defined $macroFile);
if (defined $macro) {
  $macroFile=$macro;
}
####################################


unless (-d $libDir) {
  print <<'EOL';
 BTrEd couldn't find a tredlib directory. You may need to point
 to its location by the TREDHOME variable or add a correct LibDir
 field to your ~/.tredrc.

EOL
    die "Error: Couldn't find lib-directory.";
}

use Cwd;
unshift @INC,$libDir unless (grep($_ eq $libDir, @INC));

if ($lib) {
  print $libDir,"\n";
  exit;
}

use Benchmark;


require Fslib;
import Fslib;
import Fslib qw(&Index &ImportBackends);
$Fslib::Debug=1 if $debug;

# import min and max functions
require TrEd::MinMax;
import TrEd::MinMax;

# import encode and decode functions
require TrEd::Convert;
import TrEd::Convert;

# import read_macros etc.
require TrEd::Macros;
import TrEd::Macros;

# basic tree operations
require TrEd::Basics;
import TrEd::Basics;

#load back-ends
@backends=('FSBackend',ImportBackends(
  split(/,/,$extra_backends),
  qw(NTREDBackend PMLBackend AG2FS TrXMLBackend CSTS_SGML_SP_Backend TEIXMLBackend StorableBackend)));
$CSTS_SGML_SP_Backend::doctype = "$libDir/csts.doctype";

# different namespace only to load local rather than system files
# (rel2abs is not supported in all instalations)
use File::Spec;
if (not File::Spec->can('rel2abs')) {
  print "Using TFile::Spec\n" if $tredDebug;
  require TFile::Spec;
  require TFile::Spec::Functions;
  import TFile::Spec::Functions qw(rel2abs);
} else {
  print "Using File::Spec\n" if $tredDebug;
  require File::Spec;
  require File::Spec::Functions;
  import File::Spec::Functions qw(rel2abs);
}

# these are for macros
$stdout=\*STDOUT;
$stderr=\*STDERR;

use Exporter;
@ISA=qw(Exporter);
# This is default export to macros
@EXPORT = qw($libDir &min &max $stdout $stderr);

# it seems, that under Windoze setting LC_NUMERIC back to us does not
# work, so I recommend not to use czech locales there, unless you
# really want the decimal points to be replaced by commas in
# postscript:)
($TrEd::Config::useLocales) && do {
  use locale;
  use POSIX qw(locale_h);
  $ENV{LC_ALL}=undef;
  setlocale(LC_ALL,undef);
  setlocale(LC_NUMERIC,"C");
};

if ($TrEd::Config::useCzechLocales) {
  no strict;
  use locale;
  use POSIX qw(locale_h);
  setlocale(LC_COLLATE,"cs_CZ");
  setlocale(LC_NUMERIC,"C");
  setlocale(LANG,"cs_CZ");
}

# These are used only in macros and hooks!!!
$TredMacro::root=undef;
$TredMacro::this=undef;
$TrEd::Macros::FileNotSaved=0;
$TrEd::Macros::defines{BTRED}=1;
$TredMacro::forceFileSaved=0;

$TredMacro::_NoSuchTree=0; # for compatibility with Graph2Tred
$TredMacro::NodeClipboard=undef;

$fileNo=0;

#$TrEd::Basics::on_tree_change= \&updateTredMacroGlobals;
#$TrEd::Basics::on_node_change= \&updateTredMacroGlobals;
#$TrEd::Basics::on_current_change= \&updateTredMacroGlobals;

_msg("Reading macros from $macroFile...\n") unless $quiet;
read_macros($macroFile,$libDir);	# read macros
_msg("done.\n") unless $quiet;

if ($file_list) {
  foreach my $l (split /\s*,\s*/,$file_list) {
    print STDERR "Reading -l filelist $l...\n" if $tredDebug;
    if (open(F,"<$l")) {
      @files=<F>;
      shift @files if ($l=~/\.fl$/i and $files[0]!~m{[/.]} and ! -f absolutize($files[0]));
      close(F);
    } else {
      print STDERR "Warning: Can't open filelist $l: $!\n";
    }
  }
}

if ($^O eq 'MSWin32') {
  push @files,map glob, @ARGV;
} else {
  push @files,@ARGV;
}
s/\s+$// for @files;

@ARGV=@TredMacro::ARGV;



%bkmap=(
	fs => 'FSBackend',
	csts => 'CSTS_SGML_SP_Backend',
	trxml => 'TrXMLBackend',
	tei => 'TEIXMLBackend',
	storable => 'StorableBackend'
       );

$FSBackend::CheckListValidity=$validate_fs;

$csts_tecto && Csts2fs::setupTR();
if ($csts_tree_attrs ne "") {
  Csts2fs::setupSpec(split ',',$csts_tree_attrs);
}

@Fs2csts::extra_attributes=split /,/,$csts_xargs;

if ($output_format) {
  my $format=$output_format ? lc($output_format) : "";
  unless ( $backend=$bkmap{$format} ) {
    die "Unknown format $format. Use -f [".join("|",sort keys %bkmap)."]\n";
  }
}

$TrEd::Convert::inputenc=$file_encoding if $file_encoding;

foreach my $module (@preload_modules) {
  eval "require $module";
  die $@ if $@;
}

startMain();

exit;

############################
############################
############################

sub absolutize {
  return map { m(^[[:alnum:]]+:/|^\s*\||^\s*/) ? $_ : rel2abs($_) } grep { !/^\s*$/ } @_;
}


sub _msg { $_ERR->print("BTRED: ",@_); }
sub _make_uniq ($) { my %U; @{$_[0]} = grep {!exists($U{$_}) && ($U{$_}=1)} @{$_[0]} }
sub sign_md5 ($$) {
  my ($key,$message)=@_;
  Encode::_utf8_off($key);
  Encode::_utf8_off($message);
  TrEd::Cipher::block_md5(TrEd::Cipher::block_xor($key,$message));
}
sub _benchmark () {
  my $number_of_iters=10000;
  my $i;
  my %a;
  my $benchmark_code='$a{$i++}=(join("",map uc,split "(..)","afa${i}sd ${i}fsd1f2 asf${i}1sdfdsf fsasf")=~/\s+\d+/);';
  (timestr timeit ($number_of_iters,$benchmark_code))=~/(\S+) CPU/;
#  return 200;
  return $1*1000; # miliseconds
}
sub _threads () { 1 };

sub _end_response {
  my ($control,$client)=@_;
  $client->print("$control END_OF_SERVER_RESPONSE\n");
}

sub _copy_output {
  my ($macro_stdout,$hub)=@_;
  $macro_stdout->flush();
  seek($macro_stdout,0,0);
  my $space=1;
  _set_encoding($hub,$term_encoding,"socket to hub");
  while (<$macro_stdout>) {
    $hub->print($_);
    $space=chomp;
  }
  $hub->print("\n") unless $space;
}

sub _revert_redirect_stdout {
  my ($old)=@_;
  open $old, ">&STDOUT" or die "Can't dup STDOUT: $!";
}

sub _revert_redirect_stderr {
  my ($old)=@_;
  open $old, ">&STDERR" or die "Can't dup STDERR: $!";
}

sub _redirect_stdout {
  my ($new_out)=@_;
  local *MOUT=*$new_out;
  my $old;
  open $old, ">&STDOUT" or die "Can't dup STDOUT: $!";
  open(STDOUT, "+>&MOUT") or die "Can't redirect STDOUT: $!";
  $new_out->autoflush(1);
  return $old;
}

sub _redirect_stderr {
  my ($new_out)=@_;
  local *MOUT=*$new_out;
  my $old;
  open $old, ">&STDERR" or die "Can't dup STDERR: $!";
  open(STDERR, "+>&MOUT") or die "Can't redirect STDERR: $!";
  $new_out->autoflush(1);
  return $old;
}

sub startMain {
  my $grp={
	   treeNo => 0,
	   FSFile => undef,
	   macroContext =>  defined($start_context) ? $start_context : 'TredMacro',
	   currentNode => undef,
	   root => undef
	  };
  my $filecount=@files;
  #  eval (join("",@macros)."\n return 1;");
  my $context = $grp->{macroContext};

  $TrEd::Macros::on_error = sub { _msg($_[1]) };

  if ($start_server) {
    $SIG{USR1} = sub { };
    # ----------------------------------------
    # SERVER MODE
    # ----------------------------------------
    require IO::Socket::INET;
    require TrEd::Cipher;
    # Start btred server
    preloadFiles($grp,\@files);

    my $control='@-NTRED-@-PROTOCOL-@'; # @@@ marks the beginning of control lines

    my $key = readline(*STDIN);
#    close STDIN;
    if ($key =~ /^\Q$control\E SESSION-KEY=([0-9A-Z]+)$/) {
      $key = TrEd::Cipher::hex_to_block($1);
      /(.)/; # clean-up :-)
    } else {
      die "Was expecting the session key!\n";
    }

    my $port=$start_server;
    chomp (my $host=`/bin/hostname`); #$ENV{HOSTNAME};
    my $server = new IO::Socket::INET (LocalHost => $host,
				       LocalPort => $port,
				       Proto => 'tcp',
				       Listen => 5,
				       Reuse => 1,
					     );
    die "Cannot open socket at $host:$port!\n" unless $server;
    _msg("Waiting for hub on $host:$port\n");
    $allow_host=~s/\s//g;
    # resolve peer IP
    if ($allow_host) {
      ($allow_host) = (`LC_ALL=C host "$allow_host"` =~ / has address (.*)$/) if ($allow_host =~/[^:.0-9]/);
      _msg("Awaiting connection from $allow_host\n");
    }
    my ($hub,$peer);
    do {{
      $hub = $server->accept();
      $peer=$hub->peerhost();
      if ($hub and $allow_host and $peer ne $allow_host) {
	_msg("Denying connection to peer $peer!\n");
	$hub->close();
	undef $hub;
      } elsif ($hub and TrEd::Cipher::Authentify($key,$hub,$control)!=1) {
	$hub->close();
	undef $hub;
      }
    }} while (!$hub);
    _msg("Connection to the hub on $peer established.\n");
    my $request_no=0;
    _msg("Waiting for a request from the hub...\n\n");
    $hub->autoflush(1);
    while (1) {
      _set_encoding($hub,':utf8',"socket to hub");
      my $state='default';
      my $request;
      my %request;
      # --- reading request from hub ---
      while (<$hub>) {
        if (/^\Q$control\E REQUEST_TYPE=(.*)/) {
	  $request_no++;
	  _msg("Receiving request $request_no: $1\n");
	  %request = (); # clear
	  $request{REQUEST_TYPE}=$1;
	  $request="";
	} elsif (/^\Q$control\E MD5_SIGNATURE (.*)$/) {
	  $request{SIGNATURE} = $1;
        } elsif (/^\Q$control\E STATE=(.*)/) {
	  $state=$1;
	  $request.=$_;
	  $request{"STATE_".$state}.="";
	  if ($state eq 'FSFile' and $request{REQUEST_TYPE} eq 'UPLOAD') {
	    _set_encoding($hub,undef,"socket to hub");
	  }
        } elsif (!/^\Q$control\E/) {
	  $request.=$_;
	  $request{"STATE_".$state}.=$_;
        } elsif (/\Q$control\E END_OF_REQUEST/) {
          $state='END_OF_REQUEST';
	  last
        }
      }
      ($state eq 'END_OF_REQUEST') || die "Broken request $request{REQUEST_TYPE}!\n";
      _msg "Request received from the hub: $request{REQUEST_TYPE}\n";

      _msg("Verifying request signature...\n");
      if ($request{SIGNATURE} ne sign_md5($key,$request)) {
	$hub->print("$control SERVER_RESPONSE_STDERR\n");
	$hub->print("UNAUTHORIZED REQUEST: MD5 SIGNATURE FAILED\n");
	$hub->print("Signatures:\n$request{SIGNATURE}\n".sign_md5($key,$request)."\n");
	_end_response($control,$hub);
      } else {
	# --- performing the request on the trees ----
	_msg("Performing the hub request...\n");
	$NO_HOOKS=1;
	if ($request{REQUEST_TYPE} eq 'LOAD_FILES') {
	  local $no_secondary = $request{STATE_NO_SECONDARY} ? 1 : $no_secondary;
	  my @new=split /\n/,$request{STATE_FILELIST};
	  @files=(@files,@new);
	  eval {
	    preloadFiles($grp,[@new],$hub);
	    die $@ if $@ ;
	  };
	  if ($@) {
	    $hub->print("$@\n");
	  } else {
	    $hub->print("OK\n");
	  }
	  _end_response($control,$hub);
	} elsif ($request{REQUEST_TYPE} eq 'BENCHMARK') {
	  $hub->print(_benchmark(),",",_threads(),"\n"); # benchmark,threads
	  _end_response($control,$hub);
	} elsif ($request{REQUEST_TYPE} eq 'EVAL_CODE') {
	  $NO_HOOKS=0;
	  _msg("Initializing safe compartment...\n") if $safe;

	  # create temporary file to store macro output
	  my $macro_stdout = IO::File->new_tmpfile();
	  my $macro_stderr = IO::File->new_tmpfile();

	  my $old_stdout = _redirect_stdout($macro_stdout);
	  my $old_stderr = _redirect_stderr($macro_stderr);

	  chomp $request{STATE_ENCODING};
	  local $term_encoding=$request{STATE_ENCODING} if ($request{STATE_ENCODING});
	  _set_encoding(\*STDOUT,$term_encoding);
	  _set_encoding(\*STDERR,$term_encoding);


	  # initialize Safe compartment

	  init_tredmacro($grp);

	  # script command-line arguments
	  if (exists($request{STATE_ARGS})) {
	    no strict qw(refs);
	    @{macro_variable('TredMacro::ARGV')}=split "\n",$request{STATE_ARGS};
	    @{macro_variable('ARGV')}=@{macro_variable('TredMacro::ARGV')};
	  } else {
	    no strict qw(refs);
	    @{macro_variable('TredMacro::ARGV')}=();
	    @{macro_variable('ARGV')}=();
	  }

	  STDOUT->autoflush(1);
	  # load macro
	  _msg "COMPILING MACRO\n";
	  chomp($request{STATE_CONTEXT});
	  $context=$request{STATE_CONTEXT} || 'TredMacro';
	  $context='TredMacro' if $context eq 'main';
	  $SIG{USR1} = sub { die "BTRED: $host: User break!\n" };
	  $grp->{macroContext} = $context;

	  doEvalMacro($grp,"package $context;\n"."#line 1 \"$request{REQUEST_TYPE}\"\n".$request{STATE_MACRO});

	  # execute hooks and the code of the query

	  my $time;
	  $hub->print("$control SERVER_RESPONSE_STDERR\n");
	  $hub->print("$@\n") if $@;
	  if (!$@ and keys(%{$grp->{preloaded}})) {
	    my $stop = doEvalHook($grp,"start_hook");
	    $stop = doEvalHook($grp,"preload_hook") if (!$@ and $stop ne 'stop');
	    $hub->print("$@\n") if $@;
	    if (!$@ and $stop ne 'stop') {
	      _msg "RUNNING CODE: $request{STATE_CODE}\n";
	      gotoFile($grp,0);
	      my $t0 = new Benchmark;
	      if (exists $request{STATE_FILELIST}) {
		my @fl = split /\n/,$request{STATE_FILELIST};
		foreach my $file (@fl) {
		  # normalize urls
		  my $goto;
		  $goto=$1 if $file=~s/(##?[0-9A-Z]+(?:\.[0-9]+)?)$//;
		  if (exists $grp->{preloaded}{$file}) {
		    openFile($grp,$file.$goto);
		    last if $@;
		    doEvalMacro($grp,"package $context;".$request{STATE_CODE});
		    last if $@;
		  }
		}
	      } else {
		do {
		  doEvalMacro($grp,"package $context;".$request{STATE_CODE});
		} while (!$@ and nextFile($grp) and !$@);
	      }
	      $hub->print("$@\n") if $@;
	      _msg($@) if $@; undef $@;
	      closeFile($grp);
	      $hub->print("$@\n") if $@;
	      _msg($@) if $@; undef $@;
	      doEvalHook($grp,"exit_hook");
	      $hub->print("$@\n") if $@;
	      _msg($@) if $@;undef $@;
	      my $t1 = new Benchmark;
	      $time = timediff($t1, $t0) if ($t1 and $t0);
	      $hub->print("BTRED: $host: Total Time: ",timestr($time),"\n") if $time ne "" and not $request{STATE_QUIET};
	      _msg("Total Time: ",timestr($time),"\n");
	    }
	  }
	  $SIG{USR1} = sub { };
	  $hub->print("No files to process at btred server $host:$port\n") if (!keys(%{$grp->{preloaded}}));
	  cleanup_tredmacro($grp,split(/\n/,"package $context;\n".$request{STATE_MACRO}."\n".$request{STATE_CODE}));
	  # send macro's error output from tmp file to client
	  _revert_redirect_stderr($old_stderr);
	  _set_encoding($macro_stderr,$term_encoding);
	  _copy_output($macro_stderr,$hub);
	  $macro_stderr->close;

	  $hub->print("$control SERVER_RESPONSE_STDOUT\n");

	  # send macro's output from tmp file to client
	  _revert_redirect_stdout($old_stdout);
	  _set_encoding($macro_stdout,$term_encoding);
	  _copy_output($macro_stdout,$hub);
	  $macro_stdout->close;

	  _end_response($control,$hub);
	  _msg("The processing of request $request_no completely finished.\n");
	} elsif ($request{REQUEST_TYPE} eq 'QUIT') {
	  _msg "Quitting on client's request\n";
	  $hub->print("OK\n");
	  _end_response($control,$hub);
	  exit 0;
	} elsif ($request{REQUEST_TYPE} eq 'RELOAD') {
	  local $no_secondary = $request{STATE_NO_SECONDARY} ? 1 : $no_secondary;
	  if (exists $request{STATE_FILELIST}) {
	    _msg "Reloading files at client's request\n";
	    my @fl = grep { ref($grp->{preloaded}->{$_}) } split /\n/,$request{STATE_FILELIST};
	    foreach my $file (@fl) {
	      closePreloadedFile($grp,$file);
	    }
	    eval {
	      preloadFiles($grp,\@fl,$hub);
	      die $@ if $@ ;
	    };
	  } else {
	    _msg "Reloading all open files at client's request\n";
	    closeAllPreloaded($grp);
	    eval {
	      preloadFiles($grp,\@files,$hub);
	      die $@ if $@ ;
	    };
	  }
	  if ($@) {
	    $hub->print("$@\n");
	  } else {
	    $hub->print("OK\n");
	  }
	  _end_response($control,$hub);
	} elsif ($request{REQUEST_TYPE} eq 'RELOAD_CHANGED') {
	  local $no_secondary = $request{STATE_NO_SECONDARY} ? 1 : $no_secondary;
	  _msg "Reloading changed files at client's request\n";
	  my @changed = grep { ref($grp->{preloaded}->{$_}) and
				 fileOrSecondariesNotSaved($grp,$grp->{preloaded}->{$_})
			       } @files;
	  foreach my $file (@changed) {
	    closePreloadedFile($grp,$file);
	  }
	  eval {
	    preloadFiles($grp,\@changed,$hub);
	    die $@ if $@;
	  };
	  if ($@) {
	    $hub->print("$@\n");
	  } else {
	    $hub->print("OK\n");
	  }
	  _end_response($control,$hub);
	} elsif ($request{REQUEST_TYPE} eq 'RELOAD_MACROS') {
	  my $f=$request{STATE_Filename};
	  $f =~ s/[\n\r]+$//;
	  # chomp $f;
	  $macroFile = $f if $f;
	  _msg "Reloading macros from $macroFile libdir=$libDir at client's request\n";
	  %TrEd::Macros::defines=(BTRED => 1); # reset defines
	  eval {
	    read_macros($macroFile,$libDir); # read macros
	  };
#	  _msg(@TrEd::Macros::macros);
	  if ($@) {
	    $hub->print("$@\n");
	  } else {
	    $hub->print("OK\n");
	  }
	  _end_response($control,$hub);
	} elsif ($request{REQUEST_TYPE} eq 'COUNT') {
	  _msg "Counting all open files at client's request\n";
	  $hub->print("$control SERVER_RESPONSE_STDOUT\n");
	  $hub->print("$host:$port has ",scalar(@files)," files\n");
	  _end_response($control,$hub);
	} elsif ($request{REQUEST_TYPE} eq 'LIST') {
	  local $no_secondary = $request{STATE_NO_SECONDARY} ? 1 : $no_secondary;
	  _msg "Listing all open files at client's request\n";
	  $hub->print("$control SERVER_RESPONSE_STDOUT\n");
	  if (exists $request{STATE_FILELIST}) {
	    my @f = grep { ref($grp->{preloaded}->{$_}) } split /\n/,$request{STATE_FILELIST};
	    $hub->print(join("\n",@f),"\n") if @f;
	  } else {
	    $hub->print(join("\n",@files),"\n");
	  }
	  _end_response($control,$hub);
	} elsif ($request{REQUEST_TYPE} eq 'LIST_SECONDARY') {
	  _msg "Listing secondary files at client's request\n";
	  $hub->print("$control SERVER_RESPONSE_STDOUT\n");
	  if (ref($grp->{secondary})) { 
	    if (exists $request{STATE_FILELIST}) {
	      my @f = grep { ref($grp->{secondary}->{$_}) } split /\n/,$request{STATE_FILELIST};
	      $hub->print(join("\n",@f),"\n") if @f;
	    } else {
	      $hub->print(join("\n",sort keys %{$grp->{secondary}}),"\n");
	    }
	  }
	  _end_response($control,$hub);
	} elsif ($request{REQUEST_TYPE} eq 'LIST_CHANGED') {
	  local $no_secondary = $request{STATE_NO_SECONDARY} ? 1 : $no_secondary;
	  _msg "Listing all open files at client's request\n";
	  $hub->print("$control SERVER_RESPONSE_STDOUT\n");
	  $hub->print(map { $_."\n"} grep { ref($grp->{preloaded}->{$_}) and
					    fileOrSecondariesNotSaved($grp,$grp->{preloaded}->{$_})
				       } @files);
	  _end_response($control,$hub);
	} elsif ($request{REQUEST_TYPE} eq 'DUMP') {
	  $hub->print("$control SERVER_RESPONSE_STDOUT\n");
	  _msg "Dumping $request{STATE_default} at client's request\n";
	  foreach my $f (grep /\S/,split /\n/,$request{STATE_default}) {
	    next unless ($f);
	    $f=~s{^ntred://}{};
	    $f=~s{@(\d+)##1(\.\d+)?\s*$}{##$1$2};
	    _msg "Dumping some tree $f at client's request\n";
	    next unless openFile($grp,$f,-justpreloaded => 1);
	    for my $fsfile ($grp->{FSFile}) {
	      _set_encoding($hub,$fsfile->encoding(),undef);
	      $fsfile->FS->writeTo($hub);
	      FSBackend::PrintFSFile($hub,
				     $fsfile->FS,
				     $f=_has_suffix($f) ? [$grp->{root}] : $fsfile->treeList);
	      ## Tredish custom attributes:
	      $fsfile->changeTail(
				  (grep { $_!~/\/\/Tred:(?:Custom-Attribute(?:Cont)?|Balloon-Pattern):/ } $fsfile->tail),
				  (map {"//Tred:Custom-Attribute:$_\n"}
				   map {
				     join "\n//Tred:Custom-AttributeCont:",
				       split /\n/,$_
				     } $fsfile->patterns),
				  (map {"//Tred:Balloon-Pattern:$_\n"}
				   split /\n/,$fsfile->hint)
				 );
	      $hub->print($fsfile->tail());
	      $hub->print("\n\n//FSEND\n\n");
	    }
	    ## _set_encoding($hub,$term_encoding,"socket to hub");
	  }
	  _end_response($control,$hub);
	} elsif ($request{REQUEST_TYPE} eq 'UPLOAD') {
	  $hub->print("$control SERVER_RESPONSE_STDOUT\n");
	  my $f=$request{STATE_Filename};
	  # chomp $f;
	  $f =~ s/[\n\r]+$//;
	  _msg "Uploading $f at client's request\n";
	  $f=~s{^ntred://}{};
	  $f=~s{@(\d+)##1(\.\d+)?\s*$}{##$1$2};
	  if ($] >= 5.008) {
	    require Encode;
	    $request{STATE_FSFile} = Encode::decode($TrEd::Convert::inputenc,$request{STATE_FSFile});
	  }
	  my @fs=map {$_."\n"} split /\n/,$request{STATE_FSFile};
	  if ($f and openFile($grp,$f,-justpreloaded => 1) and ref($grp->{FSFile})) {
	    _msg "Uploading $f at client's request\n";
	    my $fsfile=FSFile->new();
	    local $Fslib::Debug=1;
	    #	  _msg "received @fs\n";
	    if (FSBackend::read(\@fs,$fsfile) and ref($fsfile->treeList()->[0])) {
	      {
		my $newdefs=$fsfile->FS->defs();
		my $fs=$grp->{FSFile}->FS;
		my $defs=$grp->{FSFile}->FS->defs();
		my $list=$grp->{FSFile}->FS->list();
		foreach ($fsfile->FS->attributes()) {
		  push @$list, $_ unless ($fs->exists($_));
		  $defs->{$_}=$newdefs->{$_};
		}
		$grp->{FSFile}->FS->renew_specials();
	      }
	      if (_has_suffix($f)) {
		_msg "Updated tree $grp->{treeNo} ($f)\n";
		# change only one tree
		$grp->{FSFile}->treeList()->[$grp->{treeNo}]=$fsfile->treeList()->[0];
		$fsfile->changeTreeList([]);
		$grp->{FSFile}->notSaved(1);
		closeFile($grp);
		# $fsfile is garbage collected
	      } else {
		_msg "Updated whole file ($f)\n";
		# change the whole file
		$grp->{FSFile}->changeTreeList($fsfile->treeList());
		$fsfile->changeTreeList([]);
		$grp->{FSFile}->notSaved(1);
		closeFile($grp);
		# $fsfile is garbage collected
	      }
	    } else {
	      _msg "read failed\n";
	    }
	  }
	  _end_response($control,$hub);
	} elsif ($request{REQUEST_TYPE} eq 'SAVE' or
		 $request{REQUEST_TYPE} eq 'SAVE_CHANGED'
		) {
	  local $no_secondary = $request{STATE_NO_SECONDARY} ? 1 : $no_secondary;
	  for (qw(Format Strip-suffix Strip-prefix Prefix Suffix)) {
	    if (exists $request{"STATE_".$_}) {
	      $request{"STATE_".$_} =~ s/[\n\r]+$//;
	    }
	  }
	  # create temporary file to store std output
	  my $macro_stdout = IO::File->new_tmpfile();
	  my $old_stdout = _redirect_stdout($macro_stdout);
	  do {
	    local $backend=$bkmap{$request{STATE_Format}} if exists $request{STATE_Format};
	    local $strip_prefix=$request{"STATE_Strip-prefix"} if exists $request{"STATE_Strip-prefix"};
	    local $strip_suffix=$request{"STATE_Strip-suffix"} if exists $request{"STATE_Strip-suffix"};
	    local $add_prefix=$request{"STATE_Prefix"} if exists $request{"STATE_Prefix"};
	    local $append_suffix=$request{"STATE_Suffix"} if exists $request{"STATE_Suffix"};

	    my %fl;
	    my $listed = 0;
	    if (exists $request{STATE_FILELIST}) {
	      $listed = 1;
	      %fl = map { $_ => 1 } grep { ref($grp->{preloaded}->{$_}) }
		split /\n/,$request{STATE_FILELIST};
	    }
	    eval {
	      gotoFile($grp,0);
	      die $@ if $@;
	      do {{
		next unless ref($grp->{FSFile});
		if (!$listed or $fl{ $grp->{'FSFile'}->filename }) {
		  if ($request{REQUEST_TYPE} eq 'SAVE' or $grp->{FSFile}->notSaved()) {
		    my ($out,$error) = saveFile($grp);
		    if (!defined($error)) {
		      $macro_stdout->print("Saved ",$grp->{'FSFile'}->filename," as $out\n");
		    } else {
		      $macro_stdout->print("ERROR SAVING",$grp->{'FSFile'}->filename,": $error\n");
		    }
		  }
		  unless ($no_secondary) {
		    foreach my $secondary (secondaryFSFiles($grp,$grp->{FSFile})) {
		      if ($request{REQUEST_TYPE} eq 'SAVE' or $secondary->notSaved()) {
			# TODO: we should probably go recursion here...
			# (secondary files of secondary files...)
			my ($out,$error) = saveFile($grp,$secondary); 
			if (!defined($error)) {
			  $macro_stdout->print("Saved secondary file ",$secondary->filename," as $out\n");
			} else {
			  $macro_stdout->print("ERROR SAVING SECONDARY FILE ",$secondary->filename,": $error\n");
			}
		      }
		    }
		  }
		}
		die $@ if $@;
	      }} while (nextFile($grp));
	      die $@ if $@;
	    };
	  };
	  $hub->print("$control SERVER_RESPONSE_STDERR\n");
	  $hub->print("$@\n") if $@;
	  $hub->print("$control SERVER_RESPONSE_STDOUT\n");
	  _copy_output($macro_stdout,$hub);
	  $macro_stdout->close;
	  _revert_redirect_stdout($old_stdout);
	  _end_response($control,$hub);
	} elsif ($request{REQUEST_TYPE} eq 'CLOSE') {
	  _msg "Closing all open files at client's request\n";
	  my %fl;
	  my $listed = 0;
	  if (exists $request{STATE_FILELIST}) {
	    $listed = 1;
	    %fl = map { $_ => 1 } grep { ref($grp->{preloaded}->{$_}) }
	      split /\n/,$request{STATE_FILELIST};
	  }
	  eval {
	    gotoFile($grp,0);
	    die $@ if $@;
	    do {{
	      next unless ref($grp->{FSFile});
	      if (!$listed or $fl{ $grp->{'FSFile'}->filename }) {
		closeFile($grp);
	      }
	      die $@ if $@;
	    }} while (nextFile($grp));
	    die $@ if $@;
	  };
	  closeAllPreloaded($grp);
	  @files=();
	  $hub->print("OK\n");
	  _end_response($control,$hub);
	} else {
	  $hub->print("ERROR: UNKNOWN REQUEST TYPE $request{REQUEST_TYPE}\n");
	  _end_response($control,$hub);
	}
	_msg("Waiting for a new request from the hub...\n\n");
      }
    }
  } else {
    # ----------------------------------------
    # INTERACTIVE MODE
    # ----------------------------------------

    if ($TrEd::Macros::exec_code=~/^\S*[nb]tred\s(.*)$/) {
      local @ARGV=split /\s+/,$1;
      print STDERR "Applying macro options: @ARGV\n" unless $quiet;
      local $all_trees if $no_all_trees;
      local $all_nodes if $no_all_nodes;
      $optparser->getoptions(
		  map {$_ => $optmap{$_}}
		  (
		   "all-trees|T",
		   "all-nodes|N",
		   "all-nonhidden-nodes|H",
		   "safe-mode|F",
		   $initial_code ? () : ("initial-code|i=s"),
		   $code ? () : ("execute|e=s"),
		   $start_context ? () : ("context|t=s")));
      $context = $grp->{macroContext} = defined($start_context) ? $start_context : 'TredMacro';
    }

    $code||="autostart()"; # this is the default macro name
    init_safe_mode($grp) if $safe;
    my $pre='';
    $pre .= "do { " if ($all_trees);
    $pre .= "while (\$this) {" if ($all_nodes or $all_nonhidden_nodes);
    my $post.= "\$this=\$this->following; \n}" if ($all_nodes);
    $post.= "\$this=\$this->following_visible(\$grp->{FSFile}->FS); \n}"
      if (not $all_nodes and $all_nonhidden_nodes);
    $post.= " } while TredMacro::NextTree();" if ($all_trees);
    my $premacro= <<EOL;
package $context;
sub _btred_eval_ {
$pre
$code;
$post
}

$initial_code;
EOL

   _msg "<script>\n$premacro;\n</script>\n" unless $quiet;
   doEvalMacro($grp,$premacro);

    exit if doEvalHook($grp,"start_hook") eq 'stop'; # run start_hook
    preloadFiles($grp,\@files) if $preload; # -P : load all files into memory

    exit if $preload and doEvalHook($grp,"preload_hook") eq 'stop'; # run start_hook
    openFile($grp,$files[$fileNo]) if $fileNo <= $#files; # goto first file
    if (@files) {
      do {{
	_msg "Processing: $files[$fileNo] (",$fileNo+1,"/$filecount)\n" unless $Quiet;
	doEvalMacro($grp,"$context->_btred_eval_();");
	STDOUT->flush();
	STDERR->flush();
	_msg "Done.\n" unless $quiet;
	my ($out, $error) = saveFile($grp) if ($grp->{FSFile}->notSaved() or $save);
        _msg($error) if defined $error;

        unless ($no_secondary) {
	  foreach my $secondary (secondaryFSFiles($grp,$grp->{FSFile})) {
	    if ($save or $secondary->notSaved()) {
	      # TODO: we should probably go recursion here...
	      # (secondary files of secondary files...)
	      my ($out,$error) = saveFile($grp,$secondary);
	      _msg("Error Saving secondary file:",$error) if defined $error;
	    }
	  }
	}
      }} while (nextFile($grp));
    } else {
      _msg "No files to process!\n" unless $Quiet;
    }
    doEvalHook($grp,"exit_hook");
  }
}


sub lastFileNo {
  return $#files;
}

sub currentFileNo {
  return $fileNo;
}

sub gotoFile {
  my ($grp,$fn)=@_;
  return 0 if (doEvalHook($grp,"goto_file_hook") eq 'stop');
  return 0 if ($fn>$#files or $fn<0);
  $fileNo=$fn;
  openFile($grp,$files[$fileNo]);
  return 1;
}


sub nextFile {
  my ($grp)=@_;
  return 0 if ($fileNo >= $#files);
  $fileNo++;
  openFile($grp,$files[$fileNo]);
  return 1;
}

sub prevFile {
  my ($grp)=@_;
  return 0 unless ($fileNo > 0);
  $fileNo--;
  openFile($grp,$files[$fileNo]);
  return 1;
}

sub preloadFiles {
  my ($grp, $filelist, $errlog)=@_;
  my $filecount=@$filelist;
  my $fno=1;
  foreach my $f (@$filelist) {
    if ($f=~/(##?[0-9A-Z]+(?:\.[0-9]+)?)$/) {
      $f=~s/(##?[0-9A-Z]+(?:\.[0-9]+)?)$//;
    }
    next if exists($grp->{preloaded}->{$f});
    _msg "Preloading: $f (",$fno++,"/$filecount)\n" unless $Quiet;
    my $fsfile = FSFile->newFSFile($f,$TrEd::Convert::inputenc,@backends);
    if ($fsfile->lastTreeNo<0) {
      _msg "empty or corrupt file: $f!\n";
      $errlog->print("ERROR: Empty or corrupt file: $f!\n") if ($errlog);
      next;
    }
    openSecondary($grp,$fsfile);
    $fsfile->changeFileFormat(($f=~/\.gz$/ ? "gz-compressed " : "").$fsfile->backend);
    $grp->{preloaded}->{$f} = $fsfile;
  }
  @files=grep { exists($grp->{preloaded}->{$_}) } @files;
  _make_uniq(\@files);
}

sub openSecondary {
  my ($grp,$fsfile)=@_;
  unless ($no_secondary) {
    my $requires = $fsfile->metaData('fs-require');
    if ($requires) {
      for my $req (@$requires) {
	_msg "Pre-loading dependent $req->[1] as metaData('ref')->{$req->[0]}\n" if $tredDebug;
	unless ($grp->{'secondary'}->{$req->[1]}) {
	  if ($grp->{preloaded}->{$req->[1]}) {
	    $grp->{'secondary'}->{$req->[1]} = $grp->{'preloaded'}->{$req->[1]};
	  } else {
	    my $req_fs = FSFile->newFSFile($req->[1],$TrEd::Convert::inputenc,@backends);
	    $req_fs->changeFileFormat(($req->[1]=~/\.gz$/ ? "gz-compressed " : "").$req_fs->backend);
	    _msg "empty or corrupt secondary file $req->[1] required by $req->[1]!\n" if ($req_fs->lastTreeNo<0);
	    $grp->{'secondary'}->{$req->[1]} = $req_fs;
	    $req_fs->changeUserData({}) unless defined $req_fs->userData();
	    push @{ $req_fs->userData()->{'fs-part-of'} }, $fsfile; # is this a good idea?
	    $fsfile->changeMetaData('ref',{}) unless $fsfile->metaData('ref');
	    $fsfile->metaData('ref')->{$req->[0]}=$req_fs;
	  }
	}
      }
    }
  }
}

sub openFile {
  my ($grp,$f,%opts) = @_;
  my $goto = undef;
  my %fs=(fs => 'FS format',
	  fgz => 'gzipped FS format',
	  trxml => 'tree XML format',
	  any => 'any non-specific format (csts?), using CstsToFs');

  if ($f=~/(##?[0-9A-Z]+(?:\.[0-9]+)?)$/) {
    $f=~s/(##?[0-9A-Z]+(?:\.[0-9]+)?)$//;
      $goto=$1;
    _msg "Goto suffix is $goto\n" if $tredDebug;
  }

  closeFile($grp);

  if (exists($grp->{preloaded}) and
      exists($grp->{preloaded}->{$f})) {
    $grp->{'FSFile'} = $grp->{preloaded}->{$f};
  } elsif ($opts{-justpreloaded}) {
    return 0;
  } else {
    my $fsfile =  FSFile->newFSFile($f,$TrEd::Convert::inputenc,@backends);
    $grp->{FSFile} = $fsfile;
    $fsfile->changeFileFormat(($f=~/\.gz$/ ? "gz-compressed " : "").$fsfile->backend);
    $grp->{preloaded}->{$f}=$fsfile if ($fsfile and exists($grp->{preloaded}));

    # open files required by this one
    openSecondary($grp,$fsfile);
    $fsfile->changeFileFormat(($f=~/\.gz$/ ? "gz-compressed " : "").$fsfile->backend);
    $grp->{preloaded}->{$f}=$fsfile if ($fsfile and exists($grp->{preloaded}));
  }
  _msg "empty or corrupt file: $f!\n" if ($grp->{FSFile}->lastTreeNo<0);

  my $encoding=$grp->{FSFile}->encoding;
  if (!$term_encoding and $encoding ne "") {
    _set_encoding(\*STDERR,$encoding,"STDERR");
    _set_encoding(\*STDOUT,$encoding,"STDOUT");
  }

  $grp->{treeNo}=0;
  $grp->{currentNode}=undef;
  applyFileSuffix($grp,$goto);
  doEvalHook($grp,"file_opened_hook") unless ($opts{-justpreloaded});
  $grp->{root}=$grp->{FSFile}->treeList->[$grp->{treeNo}];
  unless (!$grp->{FSFile} || defined($grp->{currentNode})) {
    $grp->{currentNode}=$grp->{root};
  }

#  updateTredMacroGlobals($grp);
  return 1;
}

sub _has_suffix {
  return $_[0]=~/##?[0-9A-Z]+(?:\.\d+)?$/
}

sub applyFileSuffix {
  my ($grp,$goto) = @_;
  return unless ref($grp) and defined($goto) and $goto ne "";
  # -- smells like PDT-specific code, at least the second case
  # but we want it, dont we:)

  if ($goto=~/^##([0-9]+)/) {
    $grp->{treeNo}=min(max(0,$1-1),$grp->{FSFile}->lastTreeNo);
  } elsif ($goto=~/^#([0-9]+)/) {
    for (my $i=0;$i<=$grp->{FSFile}->lastTreeNo;$i++) {
      $grp->{treeNo}=$i,last if ($grp->{FSFile}->treeList->[$i]->{'form'} eq "#$1");
    }
  }
  # new: we're the dot in .[0-9]+ (TM)
  my $root;
  if ($goto=~/\.([0-9]+)$/) {
    $root=$grp->{FSFile}->treeList->[$grp->{treeNo}];
    my $i=$1;
    while ($root and $i>0) {
      $i--;
      $root=$root->following();
    }
    $grp->{currentNode}=$root if ($root);
  }
}

sub checkLock {
  my ($f) = @_; # filename
  return "none" if (not $f=~s{^file://}{} and $f =~ m{^[[:alnum:]]+://});
  my $lockinfo = "none";
  if (-f $f.".lock") {
    eval { open my $l, $f.".lock"; $lockinfo = <$l>; $lockinfo =~ s/[\n\r]+$//; close $l; };
  }
  return $lockinfo;
}

sub saveFile {
  my ($grp,$fsfile)=@_;
  return if $nosave;
  $fsfile = $grp->{'FSFile'} unless defined $fsfile;
  return unless $fsfile;
  my $f=$fsfile->filename;
  if ($obey_locks) {
    my $lockinfo = checkLock($f);
    if ($lockinfo ne 'none') {
      return (undef,"file locked $lockinfo\n");
    }
  }
  $fsfile->changeBackend($backend) if ($backend);
  my $out=$f;
  $out=~s/$strip_suffix$// if ($strip_suffix ne "");
  $out.=$append_suffix;
  $out=~s/^$strip_prefix// if ($strip_prefix ne "");
  $out=$add_prefix.$out if ($add_prefix ne "");
  if ($f eq $out) {
    unlink "$f~" if (-e "$f~" ); # silly MS OSs need this
    rename $f, "$f~" if (-f $f);
  }

  if ($fsfile == $grp->{FSFile} and doEvalHook($grp,"file_save_hook",$out) eq 'stop') {
    return ($out,"Saving of $f stopped by file_save_hook\n");
  } else {
    _msg "Saving $f as $out\n" unless $Quiet;
  }
  unless ($fsfile->writeFile($out)) {
    return ($out,"Error saving file to '$out'\n");
  }
  $fsfile->notSaved(0);
  return ($out, undef);
}

sub fileOrSecondariesNotSaved ($$) {
  my ($grp,$fsfile)=@_;
  return $fsfile->notSaved() or
    (!$no_secondary and first { $_->notSaved() } secondaryFSFiles($grp,$fsfile));
}

sub secondaryFiles {
  my ($fsfile)=@_;
  my $requires = $fsfile->metaData('fs-require');
  if ($requires) {
    return map { $_->[1] } @$requires;
  } else {
    return ();
  }
}

sub secondaryFSFiles ($$) {
  my ($grp,$fsfile)=@_;
  return grep { ref($_) } map { $grp->{secondary}->{$_} } secondaryFiles($fsfile);
}

sub closeFile {
  my ($grp)=@_;
  doEvalHook($grp,"file_close_hook");
  no strict qw(refs);
  undef ${macro_variable('TredMacro::NodeClipboard')};
  # close required files too, unless file remains pre-loaded

  closeSecondaryFilesOf($grp,$grp->{FSFile});
  $grp->{root}=undef;
  $grp->{FSFile}=undef;
  $grp->{treeNo}=undef;

  delete $grp->{'currentNode'} if (exists $grp->{'currentNode'});
}

# in oreder for a file to close it's dependencies, it
# has to be removed from preloaded first
sub closeSecondaryFilesOf {
  my ($grp,$fsfile)=@_;
  if ($fsfile and
      $grp->{preloaded}->{$fsfile->filename} != $fsfile) {
    my $requires = $fsfile->metaData('fs-require');
    for my $req (@$requires) {
      my $secondary = $grp->{'secondary'}->{$req->[1]};
      if ($secondary) {
	my $part_of = $secondary->userData()->{'fs-part-of'};
	@$part_of = grep { $_ == $fsfile } @$part_of;
	unless (@$part_of) {
	  # close secondary file
	  delete $grp->{'secondary'}->{$req->[1]};
	  delete $fsfile->metaData('ref')->{$req->[0]};
	}
      }
    }
  }
}

sub closePreloadedFile {
  my ($grp,$f)=@_;
  my ($fsfile,$filename);
  if (ref($f)) {
    # it's a FSFile
    $fsfile = $f;
    $filename = $f->filename;
  } else {
    $fsfile = $grp->{preloaded};
    $filename = $f->filename;
  }
  delete $grp->{preloaded}->{$filename};
  closeSecondaryFilesOf($grp,$fsfile)
}

sub closeAllPreloaded {
  my ($grp)=@_;
  my @preloaded = values %{$grp->{preloaded}};
  # first clear preloaded hash
  %{$grp->{preloaded}}=();
  # then close secondary files
  for my $fsfile (@preloaded) {
    closeSecondaryFilesOf($grp,$fsfile)
  }
}

sub doEvalHook {
  my ($group,$hook)=(shift,shift);
  return if $NO_HOOKS;
  no strict qw(refs);
  return unless $hook;# and $group->{'currentNode'};

  ${macro_variable('TredMacro::this')}=$group->{currentNode};
  ${macro_variable('TredMacro::root')}=$group->{root};
  ${macro_variable('TredMacro::libDir')}=$libDir;
  ${macro_variable('TredMacro::FileNotSaved')}='?';
  ${macro_variable('TredMacro::forceFileSaved')}=0;
  my $result=do_eval_hook($group,$group->{macroContext},$hook);
  _msg "$@" if $@;
  exit 1 if ($@ and !$warn_only and !$start_server);

  if ($group->{FSFile}) {
    if (${macro_variable('TredMacro::FileNotSaved')} eq '?') {
      ${macro_variable('TredMacro::FileNotSaved')}=$group->{FSFile}->notSaved;
    }
    $group->{FSFile}->notSaved($group->{FSFile}->notSaved or ${macro_variable('TredMacro::FileNotSaved')});
  }

#  ${macro_variable('TredMacro::this')}=undef;
#  ${macro_variable('TredMacro::root')}=undef;
#  ${macro_variable('TredMacro::grp')}=undef;

  _msg "Hook $hook resulted with $result\n" if $hookDebug;
  return $result;
}

sub doEvalMacro {
  my ($group,$macro)=(shift,shift);
  return unless $macro;
  no strict qw(refs);
  ${macro_variable('TredMacro::this')}=$group->{currentNode};
  ${macro_variable('TredMacro::root')}=$group->{root};
  ${macro_variable('TredMacro::libDir')}=$libDir;
  ${macro_variable('TredMacro::FileNotSaved')}='?';
  ${macro_variable('TredMacro::forceFileSaved')}=0;

  my $result=do_eval_macro($group,$macro);
  exit 1 if ($@ and !$warn_only and !$start_server);

  if ($group->{FSFile}) {
    ${macro_variable('TredMacro::FileNotSaved')}=0 if ${macro_variable('TredMacro::FileNotSaved')} eq '?';
    if (${macro_variable('TredMacro::forceFileSaved')}) {
      $group->{FSFile}->notSaved(${macro_variable('TredMacro::FileNotSaved')});
    } else {
      $group->{FSFile}->notSaved($group->{FSFile}->notSaved or ${macro_variable('TredMacro::FileNotSaved')});
    }
    setCurrent($group,${macro_variable('TredMacro::this')}) if (${macro_variable('TredMacro::this')});
  }
  ${macro_variable('TredMacro::this')}=undef;
  ${macro_variable('TredMacro::root')}=undef;
  ${macro_variable('TredMacro::grp')}=undef;
  return $result;
}

sub init_tredmacro {
  my ($grp)=@_;
  $TrEd::Macros::macrosEvaluated=0;
  $TrEd::Macros::safeCompartment=undef;
  if ($safe) {
    init_safe_mode($grp);
  } else {
    TrEd::Macros::initialize_macros($grp);
  }
}


sub cleanup_tredmacro {
  my ($grp,@macros)=@_;
  $TrEd::Macros::macrosEvaluated=0;
  # cleanup

  my %packages;
  @packages { ('TredMacro',
	       grep {/\S/} grep { !/^main$|^TrEd::/ }
	       map  { (/^package\s+([^;\s]+)\s*;/) } (@TrEd::Macros::macros,@macros))
	    } = ();
  if ($safe) {
    if ($TrEd::Macros::safeCompartment) {
      $TrEd::Macros::safeCompartment->reval(<<'EOF');
      package TredMacro;
undef $this;
undef $root;
undef $nodeClipboard;
EOF
      _msg($@) if $@;
      no strict qw(refs);

      my @pkgs = ('TredMacroCompartment::', 
		  map { 'TredMacroCompartment::'.$_.'::' } keys %packages );
      my %pkgs = map { $_ => 1 } @pkgs;
      for (my $i=0; $i<=$#pkgs;$i++) {
	foreach (keys %{$pkgs[$i]}) {
	  next if $_ eq 'main::';
	  if (/::$/ and !exists($pkgs{$pkgs[$i].$_})) {
	    push @pkgs,$pkgs[$i].$_;
	    $pkgs{ $pkgs[$i].$_ }=1;
	  }
	}
      }
      foreach my $package (sort { length($b)<=>length($a) } @pkgs) {
	$_ERR->flush();
	%{$package}=();
      }
      $_ERR->flush();
      $TrEd::Macros::safeCompartment->erase();
      $_ERR->flush();
    }
    undef %{main::TredMacroCompartment::TredMacro};
    undef %{main::TredMacroCompartment::};
  } else {
    foreach my $package ( sort { length($b)<=>length($a) } keys %packages ) {
      no strict qw(refs);
      _msg("Cleaning package $package\n");
      %{$package."::"}=();
      eval("package $package; use UNIVERSAL qw(isa can);");
      _msg($@) if $@;
    }
  }
  $TrEd::Macros::safeCompartment=undef;
}

sub init_safe_mode {
  my ($grp)=@_;
  require Safe;
  $TrEd::Macros::macrosEvaluated=0;
  if (ref($TrEd::Macros::safeCompartment)) {
    $TrEd::Macros::safeCompartment->erase();
  }
  $TrEd::Macros::safeCompartment=undef;
  %{TredMacroCompartment::}=(); # cleanup
  my $compartment = Safe->new('TredMacroCompartment');
  $compartment->{Erase} = 1;
  $compartment->reval("package TredMacro;");
  $compartment->deny_only(qw()); # everything allowed for the first initialization
  $compartment->share(qw(&do_eval_macro &do_eval_hook &min &max @INC 
                         &nextTree &prevTree &gotoTree 
			 &lastFileNo &currentFileNo $stderr $stdout
			 &switchContext
			));
  $compartment->share_from('TrEd::Config',[qw($libDir)]);

  $TrEd::Macros::safeCompartment=$compartment;
  TrEd::Macros::initialize_macros($grp);
# OPCODES ALLOWED IN SAFE MODE

#			       :base_io :base_orig :filesys_read :filesys_open
#			       :filesys_write
  $compartment->permit_only(qw(:base_core :base_mem :base_loop :base_math :base_orig
			       entereval caller dofile
			       print entertry leavetry tie untie bless
			       sprintf localtime gmtime sort require));
  $compartment->deny(qw(getppid getpgrp setpgrp getpriority setpriority
			pipe_op sselect select dbmopen dbmclose tie untie
		       ));
  $TrEd::Macros::safeCompartment=$compartment;
}

sub switchContext {}

sub updateTredMacroGlobals {
  my ($grp)=@_;
  no strict qw(refs);
  ${macro_variable('TredMacro::root')}=$grp->{root};
  ${macro_variable('TredMacro::this')}=$grp->{currentNode};
}


sub _set_encoding {
  my ($fh, $enc, $what)=@_;
  if ($]>=5.008) {
    eval {
      _msg("forcing encoding $enc for $what\n") if $debug;
      $fh->flush();
      binmode $fh; # first get rid of all I/O layers
      if ($enc =~ /^:/) {
	binmode $fh,$enc;
      } elsif ($enc ne "") {
	binmode $fh,":encoding($enc)";
      }
    };
    _msg($@) if $@;
  }
}

__END__

=head1 btred

btred - non-interactive scriptable version of the tree editor TrEd

=head1 SYNOPSIS

  btred [-c config-file]
        [-t context] [-m macro-file] [-e code] [-i init-code]
        [-N|-H] [-T] [-S | --no-save] [-P] [-F]
        [-s strip-sfx] [-a append-sfx] [-p strip-prefix] [-r add-prefix]
        [-f out-fmt] [-n file-encoding] [-d terminal-encoding]
        [-W] [-q|-Q] [-D] [-V] [-L port] [-b hub]
        [-x extra_attribs] [-X gov,ord] [-R]
        [-o script options -- ] [-l file-list] files...
or
  btred -u          for usage
  btred -h          for help
  btred --man       for the manual page

=head1 DESCRIPTION

BTrEd loads a given macro-file and executes a given code for each
file.

=head1 OPTIONS

=over 8

=item B<--macro-file|-m> filename

File with macro definitions to load.  If no macro-file is given,
standard macro file (see TrEd documentation) is used.

=item B<--execute|-e> code

Macro code to apply to given files. If no code is specified, btred
expects a function called `autostart' to be defined in the used
context and defaults to `autostart()' as the macro code.

The macro code may use all functions defined in a given macro file,
the default macro file tred.def, plus all functions and methods from
Fslib (see Fslib documentation).

Note, that a lot of information on the current node, file etc. can be
obtained using some pre-defined macro from `tred.def'. The
documentation for `tred.def' is a highly recommended reading for btred
macro coder and macros defined there in should be prefered in all
applicable situations.

As in TrEd, the following variables may be used in the macros:

$this - the current node (the root of the first tree in a file at the
beginning)

$root - the root node of the current tree

$grp->{FSFile} - current FSFile object (see section on FSFile in Fslib
documentation)

$grp->{treeNo}       - current tree number

$grp->{macroContext} - current macro context

$FileChanged ($TredMacro::FileChanged) - macro may change this to 1 to
indicate that the file should be saved at the end of the
pocessing. This variable is called $FileNotSaved in older
documentation. Both names are equally usable.

=item B<--initial-code|-i> code

Code to be evaluated before any file is open.

=item B<--context|-t>

Start in a given macro context (Perl package).
The default context is `TredMacro'.

=item B<--preload-module|-M> module-name

Preload a given Perl module at btred startup so as it is available to
all macros (even if running in a safe compartment).  This option may
be specified more than once with different modules.

=item B<--filelist|-l> file-list

Read a list of filenames to process from a given file (one filename
per line). Files specified in a file-list are processed prior to files
specified on the command-line.

=item B<--strip-prefix|-p> regexp

Remove strings matching a given regexp from the beginning of filenames
before saving.

=item B<--add-prefix|-r> prefix

Prepend output filenames with a given prefix.

=item B<--strip-suffix|-s> regexp

Strip strings matching a given regexp from the end of filenames.

=item B<--add-suffix|-a> suffix

Append a given suffix to the filenames.

=item B<--output-format|-f> [fs|csts|trxml|tei|storable]

Format to use for files being saved.

=item B<--config-file|-c> filename

TrEd configuration file.

=item B<--all-trees|-T>

Apply the macro code to all trees (wrapping the code into a
C<do {{ CODE }} while TredMacro::NextTree()> loop).

=item B<--all-nodes|-N>

Apply the macro code tn all nodes (you still must use --all-trees or
-T to aplly to all trees in a file) (wrapping the code into a C<while
($this) { CODE ; $this=$this->following }";> loop).

=item B<--all-nonhidden-nodes|-H>

Apply the macro code to all nodes except the hidden ones (you still
must use --all-trees or -T to process all trees in a file). This
option wraps the code into a C<while ($this) { CODE ;
$this=$this->following_visible(FS()) }";> loop).

=item B<--file-encoding|-n> encoding

Allows to specify character encoding of input files (does not apply to
XML files) and is probably only useful with Perl >= 5.8.

=item B<--terminal-encoding|-d> encoding

Automatically apllies a given character encoding to all stdout and
stderr output operations. Works only with Perl >= 5.8.

=item B<--save|-S>

Unconditionally save files after macro code was applied.  By default,
files are saved only if the C<$FileChanged> variable has been set to 1
within the macro code.

=item B<--no-save>

Never ever save any files (this way you may protect your files from
being saved even if applying a macro that modifies them and sets
C<$TredMacro::FileChanged> to 1).

=item B<--safe-mode|-F>

Run macro code in a safe compartment restricting some operations that
could be used by a malicious code writer to explore and compromise the
user's environment and potentially the entire system. Most notably,
this blocks most IO operations. NO WARRANTY! If unsure, don't run the
macro code at all.

=item B<--csts-tree-attributes|-X> gov,ord

Allows provide comma separated list consisting of two names for CSTS
elements that contain the necessary information to build a tree out of
a CSTS file. The first one shoud contain the index of the governing
node and the second one the topological order of the node in the tree.

=item B<--tectogrammatical-trees|-R>

Build tectogrammatic trees from CSTS files.

=item B<--fs2csts-attributes|-x> list

Comma separated list of FS attribute names that
should be preserved as <x> elements when saving to CSTS.

=item B<--confing-file|-c> filename

Use a given TrEd configuration file.

=item B<--preload-files|-P>

Preload all given files into memory before applying the macros (DOES
NOT WORK WITH RESTRICTED MODE).

=item B<--warn-only|-W>

Do not stop (die) on errors, just warn.

=item B<--validate-fs|-V>

Force Fslib to test validity of values assigned to @L (list)
attributes in FS files.

=item B<--quiet|-q>

Print only general processing information on stderr.

=item B<--very-quiet|-Q>

Don't print anything to stderr at all (except for fatal errors).

=item B<--debugging|-D>

Print a lot of debugging information on the stderr.

=item B<--server-port|-L> port

Start btred server, listening on a given port; implies -P. Use a
suitable client such as B<ntred> to apply a macro code on the files
possesed by the server.

=item B<--allow-host|-b> hostname

Accept only connections from a given host when operating in the
server-mode.

=item B<--extra-backends|-B> backends

Comma separated list of user-defined IO-backend modules to load.

=item B<--lib>

Prints path to module directory containing Fslib and other TrEd specific
libraries and exit.

=item B<--usage|-u>

Print a brief help message on usage and exits.

=item B<--help|-h>

Prints the help page and exits.

=item B<--man>

Displays the help as manual page.

=head1 AUTHOR

Petr Pajas <pajas@matfyz.cz>

Copyright 2000-2003 Petr Pajas, All rights reserved.

