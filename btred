#!/usr/bin/perl
#
# BTred ver. 0.1 - Copyright (C) 2000 by Petr Pajas
# This software is covered by GPL - The General Public Licence
# Full text of the GPL can be found at http://www.gnu.org/copyleft/gpl.html.
#
# This program allows you run macros written for Tred in batch mode.
#

package main;

use Getopt::Std;
getopts('qQc:i:m:e:t:huNHSTR');
$opt_q=1 if $opt_Q;

if ($opt_u) {
  print <<EOH;
Usage:
  btred [-c config-file] [-m macro-file] [-e script] [-t context] [-q|-Q] [-H|-N] [-S] [-T] files...
or
  btred -u          to show usage
or
  btred -h          to show help
EOH
  exit;
}

if ($opt_h) {
  print <<'EOF';
Usage:
  btred [-c config-file] [-m macro-file] [-e script] [-i init-script] [-t context] [-q|-Q] [-N|-H] [-S] [-T] files...
or
  btred -u          to show usage
or
  btred -h          to show help

This is a "batch mode" version of tree editor TrEd.
BTrEd runs the given script or macro on each file in given context.
Parameters:

config-file   - TrEd configuration file
macro-file    - file with macro definitions
script        - any script (may use macros); typically script is just
                name of the macro to be run
context       - start in the given macro context (package).
                TredMacro is the default context.
init-script   - any script to be run only once, before any input
                file is loaded.

-N            - wrap 'while ($this) { ...; $this=$this->following; }
                around the script
-H            - same as -N but use following_visible instead, skipping
                hidden nodes
-T            - wrap 'do { ... } while NextTree();' around the script
-S            - always save file
-R            - build tectogrammatic trees from CSTS files
-q            - quiet
-Q            - by *very* quiet

Flags -N and -H may not be combined. If both are used, -N has the
precedence. However, both -N and -H may be used together with -T.

If no macro-file is given, standard macro file (see TrEd
documentation) is searched and used if found. If no script is
specified, call to function autostart in the context is performed
in expectation that such a function is defined in the macro-file.

As in TrEd, the following variables may be used in the macros and
scripts:

$grp->{FSFile}       - current FSFile object (see section on FSFile in 
                       Fslib documentation)
$grp->{treeNo}       - current tree number
$grp->{macroContext} - current macro context
$this                - current node (root of the first tree at the beginning)
$root                - root node of current tree
$FileNotSaved        - change this to 1 if you want the file to be saved at the end

Also all functions defined in default macro file tred.def
as well as any function from Fslib (see Fslib documentation).
EOF
  exit;
}

if (defined $opt_e) {
  $script=$opt_e;
} else {
  $script="autostart()"; # this is the default macro name
}



# in Windows, if HOME not defined, use user's AppData folder instaed
if ($^O eq "MSWin32" and !exists $ENV{HOME}) {
  require Win32::Registry;
  my %shf;
  my $ShellFolders;

  my $shfolders="Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders";
  $::HKEY_CURRENT_USER->Open($shfolders,$ShellFolders) or die "Cannot read $shfolders $^E\n";
  $ShellFolders->GetValues(\%shf);
  $ENV{HOME} = $shf{AppData}[2];
}

# Default values of $libDir used to search for macro-file (tred.mac)
# and default-macro file (tred.def) are specified here. They may be
# overriden by value of LibDir in tred resource file (tredrc or ~/.tredrc - see above).
# It is also used to find TrEd::Config.pm module.

use FindBin;
if (exists $ENV{TREDHOME}) {
  $libDir=$ENV{TREDHOME};
} elsif (-d "$FindBin::RealBin/tredlib") {
  $libDir="$FindBin::RealBin/tredlib";
} elsif (-d "$FindBin::RealBin/../lib/tredlib") {
  $libDir="$FindBin::RealBin/../lib/tredlib";
} elsif (-d "$FindBin::RealBin/../lib/tred") {
  $libDir="$FindBin::RealBin/../lib/tred";
}
print STDERR "Trying $libDir\n" if ($libDir and !$opt_q);

$macroFile=undef;


# We *must* at least find TrEd::Config module to learn the correct libDir!!.
unshift @INC,$libDir if (-d $libDir);

do {
  my $ld=$libDir;
  require TrEd::Config;
  import TrEd::Config;
  import TrEd::Config qw(&read_config &set_default_config_file_search_list $defaultMacroFile $macroDebug $hookDebug);
  $libDir=$ld;
};

$TrEd::Config::quiet=$opt_q;

if (defined $opt_c) {
  @config_file_search_list=($opt_c); # override any other possible config files
} else {
  set_default_config_file_search_list();
}

my $configFile=read_config();

$macroFile="$libDir/tred.mac" unless (defined $macroFile);
if (defined $opt_m) {
  $macroFile=$opt_m;
}
####################################


unless (-d $libDir) {
  print <<'EOL';
 BTrEd couldn't find a tredlib directory. You may need to point
 to its location by the TREDHOME variable or add a correct LibDir
 field to your ~/.tredrc.

EOL
    die "Error: Couldn't find lib-directory.";
}

use Cwd;
unshift @INC,$libDir unless (grep($_ eq $libDir, @INC));


require Fslib;
import Fslib;
import Fslib qw(&Ord &Value &Hide &SentOrd &AOrd &AValue &AHide &ASentOrd &Index);

# import min and max functions
require TrEd::MinMax;
import TrEd::MinMax;

# import encode and decode functions
require TrEd::Convert;
import TrEd::Convert;

# import read_macros etc.
require TrEd::Macros;
import TrEd::Macros;

# basic tree operations
require TrEd::Basics;
import TrEd::Basics;

#load back-ends
@backends=('FSBackend',ImportBackends(qw(TrXMLBackend CSTS_SGML_SP_Backend CSTSBackend)));
$CSTS_SGML_SP_Backend::doctype = "$libDir/csts.doctype";

use Exporter;
@ISA=qw(Exporter);
# This is default export to macros
@EXPORT = qw($libDir &min &max);

# it seems, that under Windoze setting LC_NUMERIC back to us does not
# work, so I recommend not to use czech locales there, unless you
# really want the decimal points to be replaced by commas in
# postscript:)

if ($useCzechLocales) {
  use locale;
  use POSIX qw(locale_h);
  setlocale(LC_COLLATE,"cs_CZ");
  setlocale(LC_NUMERIC,"us_EN");
  setlocale(LANG,"czech");
}

# These are used only in macros and hooks!!!
$root=undef;
$this=undef;
$TrEd::Macros::FileNotSaved=0;
$forceFileSaved=0;

$_NoSuchTree=0; # for compatibility with Graph2Tred
$NodeClipboard=undef;

$fileNo=0;

print STDERR "Reading macros from $macroFile...\n" unless $opt_q;
read_macros($macroFile,$libDir);	# read macros
print STDERR "done.\n" unless $opt_q;

@files=@ARGV;

$Fslib::Debug=!$opt_q;
if ($opt_q) {
  $tredDebug=$keyboardDebug=$hookDebug=$macroDebug=0;
}


if ($opt_R) {
  $Csts2fs::gov = "govTR";
  $Csts2fs::header = \@Csts2fs::TRheader;
  $Csts2fs::initial_node_values{TR}='hide';
}


startMain();

exit;

############################
############################
############################

sub startMain {
  my $grp={
	   treeNo => 0,
	   FSFile => undef,
	   macroContext =>  defined($opt_t) ? $opt_t : 'TredMacro',
	   currentNode => undef,
	   root => undef
	  };

  my $filecount=@files;
#  eval (join("",@macros)."\n return 1;");
  my $context = $grp->{macroContext};
  my $pre='';
  $pre .= "do { " if ($opt_T);
  $pre .= "while (\$this) {" if ($opt_N or $opt_H);
  $post.= "\$this=\$this->following; \n}" if ($opt_N);
  $post.= "\$this=\$this->following_visible(\$grp->{FSFile}->FS); \n}"
    if (not $opt_N and $opt_H);
  $post.= " } while NextTree();" if ($opt_T);

  $premacro= <<EOL;
package $context;
sub _btred_eval_ {
$pre
$script;
$post
}

$opt_i;
EOL

  doEvalMacro($grp,$premacro);
  print STDERR "<script>\n$premacro;\n</script>\n" unless $opt_q;
  openFile($grp,$files[$fileNo]);
  do {
    print STDERR "Processing: $files[$fileNo] (",$fileNo+1,"/$filecount)\n" unless $opt_Q;
    doEvalMacro($grp,"$context->_btred_eval_();");
    STDOUT->flush();
    STDERR->flush();
    print STDERR "Done.\n" unless $opt_q;
    saveFile($grp) if ($grp->{FSFile}->notSaved or $opt_S);
  } while (nextFile($grp));
}

sub nextFile {
  my ($grp)=@_;
  return 0 if ($fileNo >= $#files);
  $fileNo++;
  openFile($grp,$files[$fileNo]);
  return 1;
}

sub prevFile {
  my ($grp)=@_;
  return 0 unless ($fileNo > 0);
  $fileNo--;
  openFile($grp,$files[$fileNo]);
  return 1;
}

sub openFile {
  my ($grp,$f) = @_;
  my $goto = undef;
  my %fs=(fs => 'FS format',
	  fgz => 'gzipped FS format',
	  trxml => 'tree XML format',
	  any => 'any non-specific format (csts?), using CstsToFs');

  if ($f=~/(##?[0-9A-Z]+(?:\.[0-9]+)?)$/) {
    $f=~s/(##?[0-9A-Z]+(?:\.[0-9]+)?)$//;
      $goto=$1;
    print STDERR "Goto suffix is $goto\n" if $tredDebug;
  }

# saveFile($grp) unless (ref($grp->{FSFile}) and $grp->{FSFile}->filename() eq $f);
  closeFile($grp);

  $grp->{'FSFile'} = FSFile->newFSFile($f,@backends);
  $grp->{'FSFile'}->changeFileFormat(($f=~/\.gz$/ ? "gz-compressed " : "").$grp->{'FSFile'}->backend);
  print STDERR "empty or corrupt file!\n" if ($grp->{FSFile}->lastTreeNo<0);

  $grp->{treeNo}=0;
  $grp->{currentNode}=undef;
  applyFileSuffix($grp,$goto);
  $grp->{root}=$grp->{FSFile}->treeList->[$grp->{treeNo}];
  unless (!$grp->{FSFile} || defined($grp->{currentNode})) {
    $grp->{currentNode}=$grp->{root};
  }

  return 1;
}

sub applyFileSuffix {
  my ($grp,$goto) = @_;
  return unless ref($grp) and defined($goto) and $goto ne "";
  # -- smells like PDT-specific code, at least the second case
  # but we want it, dont we:)

  if ($goto=~/^##([0-9]+)/) {
    $grp->{treeNo}=min(max(0,$1-1),$grp->{FSFile}->lastTreeNo);
  } elsif ($goto=~/^#([0-9]+)/) {
    for (my $i=0;$i<=$grp->{FSFile}->lastTreeNo;$i++) {
      $grp->{treeNo}=$i,last if ($grp->{FSFile}->treeList->[$i]->{'form'} eq "#$1");
    }
  }
  # new: we're the dot in .[0-9]+ (TM)
  my $root;
  if ($goto=~/\.([0-9]+)$/) {
    $root=$grp->{FSFile}->treeList->[$grp->{treeNo}];
    my $i=$1;
    while ($root and $i>0) {
      $i--;
      $root=$root->following();
    }
    $grp->{currentNode}=$root if ($root);
  }
  # hey, caller, you should redraw after this!
}

sub saveFile {
  my $grp=shift;
  return unless $grp->{'FSFile'};
  my $f=$grp->{'FSFile'}->filename;
  print STDERR "Saving $f, $f~ is a backup\n" unless $opt_Q;
  rename $f,$f."~" if (-f $f);

  unless ($grp->{FSFile}->writeFile($f)) {
    print STDERR "Error saving file to '$f'\n($!)\n";
    return 0;
  }
}

sub closeFile {
  my ($grp)=@_;

  undef $NodeClipboard;
  $grp->{root}=undef;
  $grp->{FSFile}=undef;
  $grp->{treeNo}=undef;
  delete $grp->{'currentNode'} if (exists $grp->{'currentNode'});
}

sub doEvalHook {
  my ($group,$hook)=(shift,shift);
  return unless $hook and $group->{'currentNode'};

  $TredMacro::this=$group->{currentNode};
  $TredMacro::root=$group->{root};
  $TredMacro::libDir=$libDir;
  $TredMacro::FileNotSaved=$group->{FSFile}->notSaved;
  $TredMacro::forceFileSaved=0;

  my $result=do_eval_hook($group,$group->{macroContext},$hook);
  $group->{FSFile}->notSaved($group->{FSFile}->notSaved or $TredMacro::FileNotSaved);

  $TredMacro::this=undef;
  $TredMacro::root=undef;
  $TredMacro::grp=undef;

  print STDERR "Hook $hook resulted with $result\n" if $hookDebug;
  return $result;
}

sub doEvalMacro {
  my ($group,$macro)=(shift,shift);
  return unless $macro;

  $TredMacro::this=$group->{currentNode};
  $TredMacro::root=$group->{root};
  $TredMacro::libDir=$libDir;
  $TredMacro::FileNotSaved=0;
  $TredMacro::forceFileSaved=0;

  my $result=do_eval_macro($group,$macro);

  if ($group->{FSFile}) {
#    $TredMacro::FileNotSaved=$group->{FSFile}->notSaved;
    if ($TredMacro::forceFileSaved) {
      $group->{FSFile}->notSaved($TredMacro::FileNotSaved);
    } else {
      $group->{FSFile}->notSaved($group->{FSFile}->notSaved or $TredMacro::FileNotSaved);
    }
    setCurrent($group,$TredMacro::this) if ($TredMacro::this);
  }
  $TredMacro::this=undef;
  $TredMacro::root=undef;
  $TredMacro::grp=undef;
  return $result;
}

### Local Variables:
### mode: cperl
