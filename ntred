#!/usr/bin/perl
#
# $Id$
#
# This is ntred - a hub/client for btred servers
#
# See documentation at the end of program (or run ntred --man)
#

use strict;
use Getopt::Long;
use Pod::Usage;
use IO::Socket;
use IO::Select;

use vars qw($all_trees $all_nodes $no_all_trees $no_all_nodes
	    $all_nonhidden_nodes $macro_file
	    $code $hubname $hubport $init $nocheck $noservers $nohub
	    $client_key_file $verbose $srvlist $kill $filelist
	    $srvlistfile $request_quit $request_dump $request_upload
	    $safe_mode $help $usage $manpage $ssh $run_local $server_debug
	    $maxservers $request_reload $request_reload_changed
	    $request_load $request_close
	    $request_list $request_list_changed $request_save
	    $request_save_changed $strip_prefix $add_prefix
	    $strip_suffix $append_suffix $output_format $term_encoding
	    $config_file $start_context @preload_modules $btred $break
	    $request_reload_macros $quiet $really_quiet %optmap
	    $version $print_version $listedfiles $list_options
            $olddist $count_files $logdir $userlogin
	   );

$version='$Revision$ ';

$usage=1 unless @ARGV;
$ssh='ssh';

use POSIX qw(setlocale);

## Passing -o args... -- to TredMacro
Getopt::Long::Configure ("bundling");
%optmap=("all-trees|T"    => \$all_trees,
	 "all-nodes|N"    => \$all_nodes,
	 "no-all-trees"    => \$no_all_trees,
	 "no-all-nodes"    => \$no_all_nodes,
	 "all-nonhidden-nodes|H"  => \$all_nonhidden_nodes,
	 "help|h"         => \$help,
	 "usage|u"        => \$usage,
	 "man"            => \$manpage,
	 "quiet|q"        => \$quiet,
	 "really-quiet|Q" => \$really_quiet,
	 "macro-file|m=s" => \$macro_file,
	 "execute|e=s"    => \$code,
	 "context|t=s" => \$start_context,
	 "hub=s"          => \$hubname,
	 "port=i"         => \$hubport,
	 "init|i"           => \$init,
	 "ssh=s"           => \$ssh,
	 "local"           => \$run_local,
	 "btred=s"           => \$btred,
	 "kill|k"           => \$kill,
	 "break"           => \$break,
	 "quit"           => \$request_quit,
	 "reload-files"    => \$request_reload,
	 "reload-changed-files"    => \$request_reload_changed,
	 "reload-macros"   => \$request_reload_macros,
	 "close-files"     => \$request_close,
	 "load-files"      => \$request_load,
	 "list-files"      => \$request_list,
	 "count-files"      => \$count_files,
	 "list-changed-files" => \$request_list_changed,
	 "save-files"      => \$request_save,
	 "save-changed-files" => \$request_save_changed,
	 "dump-files"    => \$request_dump,
	 "upload-file"    => \$request_upload,
	 "strip-prefix|p=s" => \$strip_prefix,
	 "add-prefix|r=s" => \$add_prefix,
	 "strip-suffix|s=s" => \$strip_suffix,
	 "add-suffix|a=s" => \$append_suffix,
	 "output-format|f=s" => \$output_format,
	 "config-file|c=s" => \$config_file,
	 "servers=s"    => \$srvlist,
	 "safe-mode|F" => \$safe_mode,
	 "serverlist=s"    => \$srvlistfile,
	 "max-servers=i"    => \$maxservers,
	 "filelist|l=s"    => \$filelist,
	 "listed-files|L"    => \$listedfiles,
	 "no-server-check" => \$nocheck,
	 "no-server-start" => \$noservers,
	 "server-debug|D" => \$server_debug,
	 "no-hub-start"   => \$nohub,
	 "key-file=s"     => \$client_key_file,
	 "verbose|V"      => \$verbose,
	 "output-encoding|d=s" => \$term_encoding,
	 "preload-module|M=s" => \@preload_modules,
	 "version|v" => \$print_version,
         "list-options" => \$list_options,
	 "old-dist-method"        => \$olddist,
	 "logdir"        => \$logdir
	);
GetOptions(%optmap) or $usage=1;

if ($print_version) {
  my $ver=$version;
  $ver=~s/\$//g;
  print "NTrEd $ver\nPerl: $]\nPlatform: $^O\n";
  exit;
}

($userlogin) = (getlogin() || ($^O ne 'MSWin32') && getpwuid($<) || 'unknown');
($userlogin =~ /\S/) || warn "Couldn\'t deterbmine user\'s login name\n";

$client_key_file ||= "$ENV{HOME}/.ntred_session_key";
$hubport ||= 1500;
$hubname ||= 'localhost'; # no remote connections by default

if ($usage) {
  pod2usage(-msg => 'ntred - controller/hub/client for remote btred servers');
#  exit 0;
}
if ($help) {
  pod2usage(-exitstatus => 0, -verbose => 1);
}
if ($manpage) {
  pod2usage(-exitstatus => 0, -verbose => 2);
}
if ($list_options) {
  foreach my $o (keys %optmap) {
    $o=~s/=.$//;
    foreach my $oo (split /\|/,$o) {
      print sort ((length($oo)>1) ? "--$oo\n" : "-$oo\n");
    }
  }
  exit;
}
if ($really_quiet) {
  $quiet = 1;
  open(STDERR, ">/dev/null") or die "Can't redirect STDERR to /dev/null: $!";
}

sub msg { print STDERR ($init ? "NTRED-HUB: " : "NTRED-CLIENT: "), @_ unless $quiet }

# make given list (passes by reference) unique
sub make_uniq ($) { my %U; @{$_[0]} = grep {!exists($U{$_}) && ($U{$_}=1)} @{$_[0]} }

use Encode;

sub sign_md5 ($$) {
  my ($key,$message)=@_;
  Encode::_utf8_off($key);
  Encode::_utf8_off($message);
  TrEd::Cipher::block_md5(TrEd::Cipher::block_xor($key,$message))
}

sub send_request {
  my ($control, $server, $type, $key)=(shift,shift,shift,shift);
  my $request = "";
  return 0 unless $server;
  $server->print("$control REQUEST_TYPE=$type\n");
  $server->flush;
  foreach (@_) {
    chomp; print $server "$_\n";
    $request.="$_\n" if defined $key;
    $server->flush;
  }
  if (defined($key)) {
    $server->print("$control MD5_SIGNATURE ".sign_md5($key,$request)."\n");
  }
  $server->print("$control END_OF_REQUEST\n");
  $server->flush;
}
sub forward_response {
  my ($control, $server, $client)=@_;
  if (ref($client) eq 'SCALAR') {
    # store response to string
    while (<$server>) {
      if (/^\Q$control\E END_OF_SERVER_RESPONSE/) {
	return 1;
      }
      $$client.=$_;
    }
  } elsif (ref($client)) {
    # forward response to client
    while (<$server>) {
      print $client $_;
      if (/^\Q$control\E END_OF_SERVER_RESPONSE/) {
	$client->flush;
	return 1;
      }
    }
    $client->flush;
  } else {
    # spit response to stderr
    while (<$server>) {
      if (/^\Q$control\E END_OF_SERVER_RESPONSE/) {
	return 1;
      }
      msg "Server replies: $_";
    }
  }
  return 0;
}

sub end_response {
  my ($control,$client)=@_;
  print $client "$control END_OF_HUB_RESPONSE\n";
  $client->flush;
}


use FindBin;
my $libDir;
if (exists $ENV{TREDHOME}) {
  $libDir=$ENV{TREDHOME};
} elsif (-d "$FindBin::RealBin/tredlib") {
  $libDir="$FindBin::RealBin/tredlib";
} elsif (-d "$FindBin::RealBin/../lib/tredlib") {
  $libDir="$FindBin::RealBin/../lib/tredlib";
} elsif (-d "$FindBin::RealBin/../lib/tred") {
  $libDir="$FindBin::RealBin/../lib/tred";
}
msg "Trying $libDir\n" if ($libDir);
unshift @INC,$libDir if (-d $libDir);

my $control = '@-NTRED-@-PROTOCOL-@';
require TrEd::Cipher;
import TrEd::Cipher qw(generate_random_block block_to_hex hex_to_block
		       Negotiate Authentify save_block);


do {
  require TrEd::Config;
  $TrEd::Config::quiet=$quiet;
  $TrEd::Config::libDir=$libDir;
};

use File::Spec;
if (not File::Spec->can('rel2abs')) {
  require TFile::Spec;
  require TFile::Spec::Functions;
  import TFile::Spec::Functions qw(rel2abs);
} else {
  require File::Spec;
  require File::Spec::Functions;
  import File::Spec::Functions qw(rel2abs);
}

if (defined $config_file) {
  @TrEd::Config::config_file_search_list=($config_file);
  # override any other possible config files
} else {
  TrEd::Config::set_default_config_file_search_list();
}
my $configFile=TrEd::Config::read_config();

require TrEd::Macros;
import TrEd::Macros;


$TrEd::Macros::defines{NTRED}=1;

if (defined($init) || defined($kill) || defined($break)) {
  # get list of servers
  my @servers;

  if ($srvlist ne "") {
    @servers = split /\s*,\s*/,$srvlist;
  } else {
    $srvlistfile ||= $ENV{HOME}."/.ntred_serverlist";
    if (open(my $f, $srvlistfile)) {
      while (<$f>) {
	s/^\s+//;
	next if (/^#/ || !/\S/);
	chomp; push @servers,$_;
      }
      close $f;
    }
  }

  # --local implies we only want local servers
  if ($run_local) {
    chomp (my $host=`/bin/hostname`);
    @servers = grep { $_ =~ /^\s*\Q$host\E:\d+\s*$/ } @servers;
    @servers=($host) unless (@servers);
  }
  make_uniq(\@servers);

  die "No servers given!\n" unless @servers;


  if (defined($kill) || defined($break)) {
  # ==================================================
  # kill servers and start a hub
  # ==================================================
    msg "Killing all servers\n";
    my %servers;
    my $signal = defined($kill) ? '-TERM' : '-USR1';
    foreach (@servers) {
      my ($machine)=split /:/;
      next if $servers{$machine};
      $servers{$machine}=1;
      $btred ||= 'btred';
      my $sh = $run_local ? "" : "$ssh '$machine'";
      msg "$sh killall $signal $btred\n";
      system("$sh killall $signal $btred");   #'$btred'
    }
    msg "Killing hub\n";
    local $SIG{TERM}=sub {}; # protecting myself :-)
    system("killall ntred") if defined($kill);
    msg "Finished\n";
    exit 0;
  }
  # ==================================================
  # run servers and start a hub
  # ==================================================

  my @files = get_file_list();
  die "No files given!\n" unless @files;

  my $logdir ||= $ENV{NTRED_LOGDIR} || $ENV{TMP} || $ENV{TEMP} || "/tmp";

  my @running;
  my %servers;
  # check that the server machines are actually running
  foreach (@servers) {
    my ($server,$port) = split /:/;
    next if $server !~ /\S/;
    unless ($servers{$server}) {
      $servers{$server}=1;
      $port ||= 1600;
      unless ($nocheck or $run_local) {
	msg "checking $server\n";
	my $cmd = "$ssh $server 'sh -c \"echo -n RUNNING 2>/dev/null\"'";
	msg "$cmd\n";
	my $result=`$cmd`;
	if ($result =~ /RUNNING$/) {
	  msg "Server $server - running\n";
	} else {
	  msg "Server $server - down\n";
	  next;
	}
      }
    }
    push @running, { host => $server, port => $port, fullname => "$server:$port" };
    last if ($maxservers>0 && @running >= $maxservers);
  }

  die "No servers available - exit.\n" unless (@running);
  my $server_key;

  if ($noservers)  {
    msg "Expecting SESSION-KEY on stdin\n";
    # Read the server key from STDIN

    $server_key = readline(*STDIN);
    if ($server_key =~ /^\Q$control\E SESSION-KEY=([0-9A-Z]+)$/) {
      $server_key = $1;
      /(.)/; # clean-up :-)
    } else {
      die "Error: no SESSION-KEY given!\n";
    }
  } else {
    # Start servers

    # generate the session key for servers
    $server_key=generate_random_block();

    foreach (@running) {
      msg "Starting btred server on $_->{host} port $_->{port}\n";
      # as for now, we only make use of the secure pipe to the server
      # in order to pass it the session key

      # btred executable
      $btred ||= "$FindBin::RealBin/btred";
      my $cmd = "$btred -O -P ".
   	  ($safe_mode ? "-F " : "").
	  ($server_debug ? "-D " : "").
	  (join "",map { "-M $_ " } @preload_modules).
	  ($macro_file ? "-m \"".rel2abs($macro_file)."\" " : "").
	  ($term_encoding ? "-d $term_encoding " : "").
	  "-L $_->{port}";
      if ($run_local) {
	$cmd = "$cmd 2> $logdir/ntred-server-$_->{host}-$_->{port}.log";
      } else {
	$cmd = "$ssh '$_->{host}' '$cmd' 2> $logdir/ntred-server-$_->{host}-$_->{port}.log";
      }
      msg "$cmd\n";
      if (open ($_->{ssh},"| ".$cmd)) {
	$_->{ssh}->autoflush(1);
	STDERR->autoflush(1);
	msg "sending session key\n";
	$_->{ssh}->print("$control SESSION-KEY=".block_to_hex($server_key)."\n");
	$_->{ssh}->flush;
	msg "sent session key\n";
	$_->{running}=1;
      } else {
	msg "Failed to start server on $_->{host}.\n";
	$_->{running}=0;
      }
    }
  }
  if ($nohub) {
    print "$control SESSION-KEY=".block_to_hex($server_key)."\n";
    exit;
  }

  # ==================================================
  # Operate as a hub
  # ==================================================
  msg "Opening connections to servers...\n";
  foreach (@running) {
    next unless $_->{running};
    msg "Openning connection to $_->{fullname}\n";
    my $server;
    do {
      $server= new IO::Socket::INET (PeerAddr => $_->{host},
				     PeerPort => $_->{port},
				     Proto => 'tcp',
				    );
      if ($server and $server->connected) {
	die "Authentification to $_->{fullname} has been denied.\n"
	  unless Negotiate($server_key,$server,$control);
      } else {
	msg("$_->{fullname} not ready\n");
	sleep 2;
      }
    } while (!$server);
    $_->{socket} = $server;
    msg  " - connected to $_->{fullname}\n";
  }
  @running = grep $_->{socket},@running;

  msg "Connected to btred servers on the following hosts:\n";
  foreach  (@running) {
    msg " - $_->{fullname}\n"
  }

  if ($olddist) {
    # Benchmark the servers
    foreach my $server (@running) {
      send_request($control,$server->{socket},'BENCHMARK',$server_key);
    }
    foreach my $server (@running) {
      my $response;
      unless (forward_response($control,$server->{socket},\$response)) {
	msg "Communication with $server->{fullname} seems broken; skipping.\n";
	next;
      }
      chomp $response;
      msg "$server->{fullname} benchmark: $response\n";
      $server->{benchmark}=$response;
    }
  }

  # --------------------------------------------------------------
  # --------------- optimal file distribution  -------------------
  use Benchmark;
  my $t0 = Benchmark->new();
  if ($olddist) {
    distribute_files($control,\@running,\@files,1,$server_key);
  } else {
    distribute_files2($control,\@running,\@files,1,$server_key);
  }
  my $t1 = Benchmark->new();
  msg ("Distribution took ",Benchmark::timestr(Benchmark::timediff($t1,$t0))."\n");
  # save client key
  save_block($server_key,$client_key_file);

  # --------------------------------------------------------------
  # -------------- prepare socket for clients  -------------------

  msg "Preparing client connection...\n";

  my $listening_socket =  new IO::Socket::INET (LocalHost => $hubname,
						LocalPort => $hubport,
						Proto => 'tcp',
						Listen => 5,
						Reuse => 1,
					       );
  die $! unless $listening_socket;
  msg "Ready for client requests on $hubname:$hubport\n\n";

  # -------------------------------------------------------------------
  # ------- main cycle: processing requests from clients --------------

  my $request_number;

  sub sigpipe {
    msg "Communication to client interrupted (SIGPIPE).\n";
  }
  $SIG{PIPE} =\&sigpipe;

  while (my $client = $listening_socket->accept()) {
    unless (Authentify($server_key,$client,$control)==1) {
      $client->close();
      next;
    }
    #  $newclient->timeout(5);
    $request_number++;

    # ---------- reading the request ----------------
    msg "Receiving request $request_number from a client...\n";
    my $request;
    my $request_type;
    while (<$client>) {		#
      $request.=$_;
      if (/^\Q$control\E REQUEST_TYPE=(.*)/) {
	$request_type=$1;
      } elsif (/^\Q$control\E END_OF_REQUEST/) {
	last;
      }
    }

    if ($request_type eq 'QUIT') {
      $SIG{PIPE} = sub {};
    }

    if ($request_type eq 'HUB_DISTRIBUTE') {
      @files = ();
      my $md5;
      foreach (split /\n/,$request) {
	if (/^\Q$control\E MD5_SIGNATURE (.*)$/) {
	  $md5 = $1;
	} elsif (!/^\Q$control\E /)  {
	  push @files, $_;
	}
      }
      if (sign_md5($server_key,join "\n",@files) eq $md5) {
	shift @files; pop @files; # get rid of the controls
	if ($olddist) {
	  distribute_files($control,\@running,\@files,0,$server_key);
	} else {
	  distribute_files2($control,\@running,\@files,0,$server_key);
	}
      } else {
	print $client "$control HUB_RESPONSE_STDERR\n";
	print $client "Request MD5 signature failed!\n";
      }
      end_response($control,$client);
    } else {
    #print STDERR "Request: $request\n\n";
    # ---------- distributing the request -------------
      msg "Distributing the request to the servers...\n";
      foreach my $server (@running) {
	next unless $server->{socket};
	msg " - to $server->{fullname}\n";
	$server->{socket}->print($request);
	$server->{socket}->flush;
      }

      # ----------- reading and forwarding the response ---------------
      msg "Waiting for server responses and forwarding them to the client...\n";
      foreach my $server (@running) {
	next unless $server->{socket};
	msg " - from $server->{fullname}\n";
	print $client "$control Response from $server->{fullname}\n";
	unless (forward_response($control,$server->{socket},$client)) {
	  print $client "$control HUB_RESPONSE_STDERR\n";
	  print $client "Warning: server $server->{fullname} seems down!\n";
	  msg "Warning: server $server->{fullname} seems down!\n";
	}
      }
      end_response($control,$client);
      msg "The processing of request $request_number completely finished.\n";
      msg "Waiting for a new client request.\n\n";
      if ($request_type eq 'QUIT') {
	msg "Quitting on client's request.\n";
	exit;
      }
    }
  }
  msg "Closing hub.\n";
} else {
  # ==================================================
  # Operate as a client
  # ==================================================

  $term_encoding = 'utf8' if !defined($term_encoding) and setlocale('LC_CTYPE')=~/UTF-?8/i;

  # Read the session key for authentification to hub
  my $key;
  do {
    open my $tmp, $client_key_file;
    $key = readline($tmp); chomp $key;
    $key = hex_to_block($key);
    close $tmp;
  };

  my $control='@-NTRED-@-PROTOCOL-@';	    # @@@ marks the beginning of control lines

  # ---------- composing and testing the request -----------

  if ($macro_file) {
    #msg("Reading macros from $macro_file ...\n");
    $TrEd::Macros::defaultMacroFile='/dev/null'; # don't read this one
    #$TrEd::Config::macroDebug=1;
    TrEd::Macros::read_macros($macro_file,$libDir) if $macro_file; # read macros
    #msg("done.\n");
    if ($TrEd::Macros::exec_code=~/^\S*[nb]tred\s(.*)$/) {
      local @ARGV=split /\s+/,$1;
      msg "Applying macro options: @ARGV\n";
      local $all_trees if $no_all_trees;
      local $all_nodes if $no_all_nodes;
      GetOptions (map {$_ => $optmap{$_}}
		  "all-trees|T",
		  "all-nodes|N",
		  "all-nonhidden-nodes|H",
		  $code ? () : ("execute|e=s"),
		  $start_context ? () : ("context|t=s"));
    }
  }

  $code ||= 'autostart()';

  if ($all_nonhidden_nodes) {
    $code = "while (\$this) { $code ; \$this=\$this->following_visible(\$grp->{FSFile}->FS)}";
  } elsif ($all_nodes) {
    $code = "while (\$this) { $code ; \$this=\$this->following }";
  }
  if ($all_trees) {
    $code = "do { $code } while TredMacro::NextTree();";
  }

  my $request="";
  my $request_type;
  if ($request_quit) {
    $request_type="QUIT";
  } elsif ($request_reload_changed) {
    $request_type="RELOAD_CHANGED";
  } elsif ($request_reload) {
    $request_type="RELOAD";
    my @files =  get_files();
    foreach (@files) {
      die "Error: File name contains tree suffix: $_\n" if
	/(##?[0-9A-Z]+(?:\.[0-9]+)?)$/;
    }
    $request.="$control STATE=FILELIST\n"._enc2bytes('utf8',join "\n",@files)."\n" if ($listedfiles || @files);
  } elsif ($request_reload_macros) {
    $request_type="RELOAD_MACROS";
    if ($macro_file) {
      $request="$control STATE=Filename\n".$macro_file."\n";
    }
  } elsif ($count_files) {
    $request_type="COUNT";
  } elsif ($request_list) {
    $request_type="LIST";
    if ($listedfiles) {
      my @files =  get_files();
      foreach (@files) {
	die "Error: File name contains tree suffix: $_\n" if
	  /(##?[0-9A-Z]+(?:\.[0-9]+)?)$/;
      }
      $request.="$control STATE=FILELIST\n"._enc2bytes('utf8',join "\n",@files)."\n";
    }
  } elsif ($request_list_changed) {
    $request_type="LIST_CHANGED";
  } elsif ($request_save || $request_save_changed) {
    $request_type= $request_save ? "SAVE" : "SAVE_CHANGED";
    $request="$control STATE=Format\n".($output_format || "fs")."\n" if ($output_format ne "");
    $request.="$control STATE=Strip-prefix\n".$strip_prefix."\n" if ($strip_prefix ne "");
    $request.="$control STATE=Strip-suffix\n".$strip_suffix."\n" if ($strip_suffix ne "");
    $request.="$control STATE=Prefix\n".$add_prefix."\n" if ($add_prefix ne "");
    $request.="$control STATE=Suffix\n".$append_suffix."\n" if ($append_suffix ne "");
    msg($request,"\n");
    if ($listedfiles) {
      my @files =  get_files();
      foreach (@files) {
	die "Error: File name contains tree suffix: $_\n" if
	  /(##?[0-9A-Z]+(?:\.[0-9]+)?)$/;
      }
      $request.="$control STATE=FILELIST\n"._enc2bytes('utf8',join "\n",@files)."\n";
    }
  } elsif ($request_close) {
    $request_type="CLOSE";
    if ($listedfiles) {
      my @files =  get_files();
      foreach (@files) {
	die "Error: File name contains tree suffix: $_\n" if
	  /(##?[0-9A-Z]+(?:\.[0-9]+)?)$/;
      }
      $request.="$control STATE=FILELIST\n"._enc2bytes('utf8',join "\n",@files)."\n";
    }
  } elsif ($request_load) {
    $request_type="HUB_DISTRIBUTE";
    my @files = get_file_list();
    $request=join "\n", @files;
  } elsif ($request_dump) {
    $request_type="DUMP";
    msg "DUMP @ARGV\n";
    my @files = get_file_list();
    $request=join("\n", @files)."\n";
  } elsif ($request_upload) {
    die "Too few parameters for --upload!" unless @ARGV;
    die "Too many parameters for --upload!" if @ARGV>1;
    $request_type="UPLOAD";
    $request.="$control STATE=Filename\n".$ARGV[0]."\n";
    $request.="$control STATE=FSFile\n";
    my @fs=<STDIN>;
    $request.=join("",@fs)."\n";
  } else {
    $request_type="EVAL_CODE";
    my @files =  get_files();
    msg "ARGS: @ARGV\n";
    $request="$control STATE=ENCODING\n"._enc2bytes('utf8',$term_encoding)."\n" if $term_encoding;
    $request.="$control STATE=CODE\n"._enc2bytes('utf8',_enc2utf8($term_encoding || 'utf8',$code))."\n";
    $request.="$control STATE=QUIET\n1\n" if $quiet;
    $request.="$control STATE=CONTEXT\n"._enc2bytes('utf8',$start_context)."\n";
    $request.="$control STATE=FILELIST\n"._enc2bytes('utf8',join "\n",@files)."\n" if ($listedfiles || @files);
    $request.="$control STATE=MACRO\n".
      _enc2bytes("utf8",join("",@TrEd::Macros::macros)."\n");
    $request.="$control STATE=ARGS\n"._enc2bytes('utf8',_enc2utf8($term_encoding || 'utf8',join("\n",@ARGV)))."\n";
    msg "Code: $code\n\n";
  }

  # ---------- open hub connection ----------------
  msg "Opening connection to ntred-hub on $hubname:$hubport\n";
  my $hub= new IO::Socket::INET (PeerAddr => $hubname,
				 PeerPort => $hubport,
				 Proto => 'tcp'
				);
  die "Can't open socket to $hubname:$hubport. $!\n" unless $hub;
  $hub->autoflush(1);
  $hub->timeout(5);

  msg "Negotiating with the hub\n";

  die "Authentification to $hubname:$hubport has been denied.\n"
    unless Negotiate($key,$hub,$control);

  # --------- sending the request to the hub ---------------
  msg "Sending the request to the hub...\n";
  send_request($control,$hub,$request_type,$key,split /\n/,$request);
  # --------- receiving the response from the hub -----------
  msg "Waiting for responses forwarded by the hub...\n";
  my $first=1;
  my $real_response=0;
  my $out=\*STDERR;

  while (<$hub>) {
    if ($first) {
      msg "Receiving the server responses and printing it to STDOUT...\n";
      $first=0;
    }
    if (/^\Q$control\E Response from (\S+)/) { # prasim
      msg "Receiving response from $1\n";
      $real_response=1;
    } elsif (/^\Q$control\E HUB_RESPONSE_STDERR/) {
      $out = \*STDERR;
    } elsif (/^\Q$control\E SERVER_RESPONSE_STDOUT/) {
      $out = \*STDOUT;
    } elsif (/^\Q$control\E SERVER_RESPONSE_STDERR/) {
      $out = \*STDERR;
    } elsif (/^\Q$control\E SERVER_RESPONSE_STDOUT/) {
      $out = \*STDOUT;
    } elsif (/^\Q$control\E/) {
      print STDERR $_ unless $quiet;
    } else {
      if ($real_response) {
	print $out $_;
      } else {
	msg "Hub send: $_";
      }
    }
    if (/^\Q$control\E END_OF_HUB_RESPONSE/) {
      last;
    }
  }

  msg "Done.\n";
}

# --------------------------------------------------------------
sub _enc2utf8 {
  my ($enc,$str)=@_;
  return $str if ($enc eq "" or $]<5.008);
  require Encode;
  return Encode::decode($enc,$str);
}

sub _enc2bytes {
  my ($enc,$str)=@_;
  return $str if ($enc eq "" or $]<5.008);
  require Encode;
  return Encode::encode($enc,$str);
}

# --------------- optimal file distribution  -------------------
sub distribute_files {
  my ($control,$servers,$files,$close_empty,$key) = @_;
  my @totalfilelist=@$files;
  my %benchmark_time;
  my %number_of_procs;
  my %power;

  my $totalpower;
  foreach my $server (@$servers) {
    ($benchmark_time{$server}, $number_of_procs{$server})=split /,/,$server->{benchmark};
    $power{$server}=$number_of_procs{$server}/($benchmark_time{$server}+1);
    $totalpower+=$power{$server};
  }

  my (%files,%filescnt);
  my $totalfilecnt=@totalfilelist;
  my $remaining_power=$totalpower;
  my $remaining_files=$totalfilecnt;
  foreach my $server (sort {$power{$a}<=>$power{$b}} @$servers) {
    $filescnt{$server}=
      sprintf("%0.0f", $remaining_files*$power{$server}/$remaining_power);
    $remaining_power-=$power{$server};
    $remaining_files-=$filescnt{$server};
  }

  # Distribute files
  my @servers_to_respond;
  foreach my $server (@$servers) {
    my @f=splice @totalfilelist,0,$filescnt{$server};
    if (@f) {
      push @servers_to_respond,$server;
      msg "Distributing ".scalar(@f)." files to $server->{fullname}\n";
      send_request($control,$server->{socket},'LOAD_FILES',$key,@f);
    } elsif ($close_empty) {
      msg "No files for server $server->{fullname}, closing it.\n";
      send_request($control,$server->{socket},'QUIT',$key,@f);
    }
  }
  msg "Please wait ...\n";
  # get responses
  foreach my $server (@servers_to_respond) {
    my $response;
    unless (forward_response($control,$server->{socket},\$response)) {
      msg "Communication with $server->{fullname} seems broken\n";
    }
    msg "$server->{fullname} $response\n";
  }
  @$servers = @servers_to_respond;
}


sub distribute_files2 {
  my ($control,$servers,$files,$close_empty,$key) = @_;
  my @totalfilelist=@$files;

  my $files_per_request = 16;
  $files_per_request /= 2 while ($files_per_request>=2 and
				 @$servers * $files_per_request > @totalfilelist);

  require IO::Select;
  my $select = IO::Select->new();
  # Distribute files
  my @servers_to_respond;
  foreach my $server (@$servers) {
    my @f=splice @totalfilelist,0,$files_per_request;
    if (@f) {
      push @servers_to_respond,$server;
      msg "Distributing ".scalar(@f)." files to $server->{fullname}\n";
      send_request($control,$server->{socket},'LOAD_FILES',$key,@f);
      $select->add($server->{socket});
    } elsif ($close_empty) {
      msg "No files for server $server->{fullname}, closing it.\n";
      send_request($control,$server->{socket},'QUIT',$key,@f);
      my $response;
      unless (forward_response($control,$server->{socket},\$response)) {
	msg "Communication with $server->{fullname} seems broken\n";
      }
      msg "$server->{fullname} $response\n";
    } else {
      print "Noop: $server->{fullname}\n";
    }
  }
  @$servers = @servers_to_respond;
  msg "Please wait ...\n";
  # get responses
  my @can_read;
  while (@can_read = $select->can_read()) {
    $files_per_request /= 2 while ($files_per_request>=2 and
				   @can_read * $files_per_request > @totalfilelist);
    foreach my $socket (@can_read) {
      my $response;
      my ($server) = grep { $_->{socket} eq $socket } @$servers;
      unless (forward_response($control,$socket,\$response)) {
	msg "Communication with $server->{fullname} seems broken\n";
	}
	chomp $response;
      msg "$server->{fullname} $response\n";
      my @f=splice @totalfilelist,0,$files_per_request;
      if (@f) {
	msg "Distributing ".scalar(@f)." files to $server->{fullname}\n";
	send_request($control,$socket,'LOAD_FILES',$key,@f);
      } else {
	$select->remove($socket);
      }
    }
  }
  if (@totalfilelist) {
    msg "Error: ".scalar(@totalfilelist)." files left in the filelist ...oooops?\n";
  } else {
    msg "All files distributed\n";
  }
}

sub get_file_list {
  my @files;
  if (defined($filelist) or !scalar(@ARGV)) {
    $filelist ||= $ENV{HOME}."/.ntred_filelist";
    if (open(my $f, $filelist)) {
      while (<$f>) {
	s/^\s+//;
	next if /^#/;
	s/[\n\r]+$//;
	push @files, (m{^/|^[[:alnum:]]+://} ? $_ : rel2abs($_));
      }
      close $f;
    }
  }
  @files = (@files, map { m{^/|^[[:alnum:]]+://} ? $_ : rel2abs($_) } @ARGV);
  make_uniq(\@files);
  return @files;
}


sub get_files {
  my @files;
  if ($filelist) {
    local $_;
    if (open(my $f, $filelist)) {
      while (<$f>) {
	s/^\s+//;
	next if /^#/;
	s{^ntred://}{};
	s{@(\d+)##?1(\.\d+)?$}{##$1$2};
	s/[\n\r]+$//;
	push @files, (m{^/|^[[:alnum:]]+://} ? $_ : rel2abs($_));
      }
      close $f;
    }
  }
  if ($listedfiles) {
    local $_;
    while (@ARGV) {
      $_=shift @ARGV;
      last if ($_ eq '--');
      s{^ntred://}{};
      s{@(\d+)(?:##?1(\.\d+)?)?$}{##$1$2};
      push @files, (m{^/|^[[:alnum:]]+://} ? $_ : rel2abs($_));
    }
  }
  return @files;
}


__END__

=head1 ntred

ntred - controller/hub/client for remote btred servers

=head1 SYNOPSIS

To query the servers:

  ntred [-m macro-file] [-e code] [--hub hub] [--port port]
        [-N|-H] [-T] [--key-file file] [--filelist file-list ] [-L files]
        -- script-arguments

To start remote servers and a hub:

  ntred -i [--servers server[,server,...]] [--serverlist server-list]
           [--filelist file-list] [--max-servers num]
           [--no-server-check] [--no-server-start] [--no-hub-start]
           [--old-dist-method] [--safe-mode] [--server-debug]
           [-m macro-file] [-M module] [--btred path-to-btred]
           [--ssh ssh-command] [--local]
           [--key-file] [--hub hub] [--port port] [file [...]]

To close all remote servers and a hub:

  ntred --quit

To kill all remote servers and a hub:

  ntred --kill

To manage files on the servers:

  ntred --list-files|--list-changed-files

  ntred --reload-files

  ntred --reload-macros [-m macro-file]

  ntred --load-files [--filelist file-list] [file [...]]

  ntred --close-files

  ntred --save-files|--save-changed-files [-s strip-sfx]
       [-a append-sfx] [-p strip-prefix] [-r add-prefix] [-f out-fmt]

  ntred --dump-files [--filelist file-list] [file [...]]

  ntred --upload-file filename < fs-file

Get help:

  ntred -u          for usage (synopsis)
  ntred -h          for help
  ntred --man       for the manual page

=head1 DESCRIPTION

This program is able to start one or more btred servers on remote
machines over SSH (it is highly recommended to use some authentication
method that does not require entering a password each time the SSH
connection is needed), create a proxy hub to provide the communication
between the servers and a client, distribute given files over the
servers (provided the servers are able to load the files from given
filenames (eg. they share the files over NFS), query the servers using
a btred-macro and collect the answers.

In the client mode, the standard output of the macro is printed to
STDOUT of the client. STDERR is reserved for debugging and information
messages as well as error messages caused by the macros on the
servers. The rest of the error output from a server is stored in a
file <logdir>/ntred-server-<host>.log (where <logdir> can be specified
using C<--logdir>, NTRED_LOGDIR or TMP or TEMP environment variable
and defaults to /tmp if none of the previous exists).

=head1 OPTIONS

=head2 QUERY MODE OPTIONS

  ntred [-m macro-file] [-e code] [--hub hub] [--port port]
        [-N|-H] [-T] [--key-file file] -- script-arguments

=over 8

=item B<--execute|-e> code

This is the query to be executed on the remote servers. It usually
either of a name of the macro defined in the file given as
C<--macro-file> or some Perl one-liner. If omitted, it defaults to
'autostart()' and a macro with this name must be defined in
the macro file provided..

=item B<--macro-file|-m> filename

A file containing macros that are to be sent to the servers and
preloaded on the servers before the particular query code is
evaluated. The query code to be evaluated must be specified in
C<--execute>.

=item B<--hub> hostname

The hostname of the hub to connect to (defaults to localhost).

=item B<--port> port

The port on which the hub is listening (defaults to 1500).

=item B<--all-trees|-T>

Run the query code on all trees (wrapping the code into a
C<do { CODE } while TredMacro::NextTree()> loop).

=item B<--all-nodes|-N>

Run the query code on all nodes (you still must use --all-trees or -T
to process all trees) (wrapping the code into a
C<while ($this) { CODE ; $this=$this->following }";> loop).

=item B<--all-nonhidden-nodes|-H>

Run the query code on all nodes that are not hidden (you still must
use --all-trees or -T to process all trees). This wraps
the code into a
C<while ($this) { CODE ; $this=$this->following_visible(FS()) }";> loop).

=item B<--listed-files|-L>

Run the query code only on files specified on the command line
(provided they are already present on some server, i.e. this option
does I<not> make servers load files they don't already
have). Filenames may contain ordinary TrEd suffixes of the form ##tree
or ##tree.node to indicate that the processing should apply only on a
single tree (use in combination with -N) or a single node (use without
-T and -N). NTrEd URIs of the form ntred:// are also allowed. Relative
file-names are expanded according to the current working directory
before they are sent to ntred servers.

=item B<--filelist|-l> filename

Like C<--listed-files|-L> but this time the files to be processed are
listed in the given file rather than on the command line. Both options
may be used togther in which case the file-lists are joined.

=item B<--key-file>

This option may be used to provide a file with a session-key which is
necessary for the authentication to the running hub. This defaults to
`~/.ntred_session_key'.

=back

=head2 HUB/SERVER MODE (-i or --init) OPTIONS

  ntred -i [--servers server[,server,...]] [--serverlist server-list]
           [--filelist file-list] [--max-servers num]
           [--no-server-check] [--no-server-start] [--no-hub-start]
           [--old-dist-method] [--safe-mode] [--server-debug]
           [-m macro-file] [-M module] [--btred path-to-btred]
           [--ssh ssh-command] [--local]
           [--key-file] [--hub hub] [--port port] [file [...]]

=over 8

=item B<--servers> list of hosts

A comma separated list of hosts to run btred servers. The hostname may
be optionally followed by a comma and a port number thus making it
possible to run several btred servers on one host. If the port number
is omitted, it defaults to 1600. See also C<--serverlist>.

=item B<--serverlist> filename

This provides more convenient way to specify servers by providing a
file containing a list of servers, one per line. If neither
C<--servers> nor C<--serverlist> is
provided, then the list of servers is read from ~/.ntred_serverlist.

=item B<--filelist> filename

A list of files to distribute between servers (one filename per line).
Additional files may be given as command-line arguments.

=item B<--max-servers> number

Limit number of servers to start even if the list of servers contains
more of them.

=item B<--no-server-check>

Skip an initial check for server hosts availability (a dummy attempt
for SSH connection).

=item B<--no-server-start>

Don't start new btred servers on the remote hosts. Instead, start a
hub and try to connect to the btred servers already running. This
requires a server-session key to be given on the standard input.

=item B<--no-hub-start>

Start servers on the remote hosts but don't start a hub. The server
session key required for authentication to the servers will be
printed on the standard output.

=item B<--safe-mode|-F>

Run btred servers in safe mode in which all macros are processed in a
Safe compartment whith some security restrictions.  This mode seems to
be likely to cause btred servers to suffer from memory leaks.

In the safe mode, only the following opcodes and opcode-sets are
allowed (see L<Opcode>):

  :base_core :base_mem :base_loop :base_math
  entereval caller dofile
  print entertry leavetry tie untie bless
  sprintf localtime gmtime sort require

plus :base_orig, but the following opcodes (which are forbidden):

  getppid getpgrp setpgrp getpriority setpriority pipe_op sselect
  select dbmopen dbmclose tie untie

=item B<--server-debug>

Run btred server with -D flag for some more debugging information.

=item B<--macro-file|-m> filename

A file containing the default set of macros to be prepared on btred
servers. The file (with exactly the same path) must be visible from
all server hosts.

=item B<--key-file>

Allows to specify a file where the the session-key for a client's
authentication will be stored. It defaults to ~/.ntred_session_key.

=item B<--terminal-encoding|-d> encoding

Automatically applies a given character encoding to all stdout output
operations on the servers and command-line arguments.
Only works with Perl >= 5.8.

=item B<--hub> hostname

The hostname of the local machine the hub will listen on (defaults to
localhost but a machine's hostname may be given to allow remote access
to the hub).

=item B<--port> port

The port number the hub will be listening on (defaults to 1500).

=item B<--preload-module|-M> module-name

This option is passed to the btred command line when starting a btred
server. It makes btred preload a given Perl module at btred startup so
as it is available to all macros (DOES NOT WORK WITH RESTRICTED MODE).
This option may be specified more than once with different modules.

=item B<--old-dist-method>

Use old benchmark-based distribution method.

=back

=head2 HUB CONTROL OPTIONS

  ntred --list-files|--list-changed-files

  ntred --reload-files [-filelist file-list] [--listed-files file [...]]

  ntred --reload-changed-files

  ntred --reload-macros [-m macro_file]

  ntred --load-files [--filelist file-list] [file [...]]

  ntred --close-files

  ntred --save-files|--save-changed-files [-s strip-sfx]
       [-a append-sfx] [-p strip-prefix] [-r add-prefix] [-f out-fmt]

  ntred --quit

  ntred --kill [--servers server[,server,...]] [--serverlist server-list]

  ntred --break

  ntred --dump-files [--filelist file-list] [file [...]]

  ntred --upload-file filename < fs-file


=over 8

=item B<--init|-i>

Start remote btred servers and a hub. See L<"HUB/SERVER MODE"|"HUB/SERVER MODE (-i or --init) OPTIONS">.

=item B<--quit>

Sends the hub and all the servers a command to quit.

=item B<--break>

Tells ntred nub to send USR1 a signal to all running btred servers.
Upon receiving that signal, the servers should stop current processing
and return to the request awaiting state.

=item B<--kill>

Kills all ntred instances on the running machine and all btred
instances on the servers listed with --servers, --serverlist, or 
in ~/.ntred_serverlist.

=item B<--list-files>

List all files currently open on servers.

=item B<--list-changed-files>

List all files that have been changed by some macro. Note, that a macro
has to claim that the file was changed by setting
C<$TredMacro::FileChanged> variable to 1, otherwise the btred server
would never notice.

=item B<--listed-files|-L>

Apply request only on listed files (currently only works for queries
and C<--reload-files> request).

=item B<--count-files>

Query number of files open on each server.

=item B<--reload-files>

Send a command to the btred servers to reload all open files.  If
C<--filelist> or C<--listed-files> options are given, reload only
files occuring in the given lists (all other files remain intact in
servers' memory).

=item B<--reload-changed-files>

Send a command to the btred servers to reload files that have been
modified since (re)loaded.

=item B<--reload-macros>

Send command to the btred servers to reload the initial macro file.
If C<-m> (C<--macro-file>) is specified, the servers use the given
macro-file instead of the original one (specified when initializing
btred servers). Note, that the file (with exactly the same path) must
be visible from all server hosts.

=item B<--load-files>

Send a command to the hub to distribute files given on the
command-line or those specified using C<--filelist> of in
~/.ntred_filelist to the servers. Note, that a file distributed to a
server is not reloaded by the server if the server already has a file
with the same path in memory.

=item B<--close-files>

Send a command to the btred servers to close all open files.

=item B<--save-files>

Send a command to the servers to save all open files.  The filenames
of the saved files may be modified using
C<--add-prefix>, C<--strip-prefix>,
C<--strip-suffix>,
C<--append-suffix>.

=item B<--save-changed-files>

Same as C<--save-files> except that only files that have been changed
by some macro will be saved. Note, that a macro has to claim that the
file was changed by setting C<$TredMacro::FileChanged> variable to 1,
otherwise the btred server would never notice. See also
C<--list-changed-files>.

=item B<--dump-files>

Dumps given files or trees to standard output in FS format as they are
in memory of the btred servers. Individual dumps are separated with
`//FSEND' preceded and followed by two newline characters.  To output
a single tree, follow the filename with C<##n> suffix where C<n> is
the absolute position of the tree in the file (starting from one).
The following example shows how C<csplit> command can be used to
save individual dumps into separate files:

  ntred --dump <files> | csplit -z -f out -b '%d.fs' - '/\/\/FSEND/+2' '{*}'

To merge these separate files into one huge FS file, use

  any2any -m hugeout.fs out*.fs

=item B<--upload-file>

This command is kind of a reverse to dump. It takes a filename from
the first command line argument and a FS file from the standard input
and sends them to the btred servers. The server possessing the file
with the given filename replaces its own in-memory copy of the file
with the one provided on the standard input. To update a single tree,
follow the filename with C<##n> suffix where C<n> is the absolute
position of the tree in the file (starting from one).

=back

=head2 SAVING OPTIONS

=over 8

=item B<--strip-prefix|-p> regexp

Remove strings matching given regexp from the beginning of filenames
before saving.

=item B<--add-prefix|-r> prefix

Prepend output filenames with the given prefix when saving.

=item B<--strip-suffix|-s> regexp

Strip strings matching given regexp from the end of filenames
when saving.

=item B<--add-suffix|-a> suffix

Append given suffix to the filenames when saving.

=item B<--output-format|-f> [fs|csts|trxml|tei|storable]

Format to use for files being saved.

=back

=head2 GENERAL OPTIONS

=over 8

=item B<--usage|-u>

Print a brief help message on usage and exits.

=item B<--help|-h>

Prints the help page and exits.

=item B<--man>

Displays the help as manual page.

=item B<--quiet|-q>

Suppress all NTRED-CLIENT/NTRED-HUB messages on error output.

=item B<--really-quiet|-Q>

Redirect all std error output to /dev/null.


=item B<--ssh> command

This option may be used to specify the ssh/rsh command to use to
connect to remote servers. Default value is `ssh'.

=item B<--local>

Run btred servers locally. It ignores all non-local entries in the
.ntred_serverlist (i.e. entries not matching local machine's
hostname). There still may be more BTrEd instances, provided they use
different ports.  In this case, SSH is not used.

=item B<--btred> command

This option may be used to specify the command to use to start a btred
server on a remote host. The command must accept any btred parameters.

=back

=head1 SECURITY ISSUES

USE AT YOUR OWN RISK. IF SECURITY IS A CRITICAL ISSUE OR IF IN DOUBT,
DON'T USE IT AT ALL.

Why is security an issue here? Because btred servers execute almost
arbitrary Perl code provided by the client. In the C<--unrestricted>
mode such code may contain arbitrary commands such as system() or
open(). It is therefore desirable that the servers are not open for
all parties.

The following precautions have been taken to lower the potential
security risks:

1) Both btred servers and hub require an authorization based on
   verification of a MD5 signature of a random data block (generated
   by the server in case of the hub-to-btred-server communication and
   by the hub in case of the client-to-hub communication) xor-ed with
   an authorization key known to both parties. Although the
   communication is unencrypted, the client must together with each
   request send an MD5 checksum of the request XORed with the secret
   authorization key.  Only requests whose signature is verified
   by the server, are responded.

2) There may be only one connection from a hub to server.  As soon as
   it is closed, the server is terminated.

3) If the servers are started by the hub itself (using C<--init>) the
   authorization key is created by the hub and is passed to the btred
   server via a ssh encrypted pipe.

4) The authorization key is also stored in user's home directory as
   C<~/.ntred_session_key> with permissions set to 600 for cleint's
   disposal. This theoretically (depending on general system security)
   limits the access to the hub and thus to the servers to the user
   running the hub (and root). It may though obviously be abused by
   root who may run some perl code on all machines running btred
   servers. This might especially be undesirable if the hub is running
   on a machine whose administrator would normaly have no user access
   to the machines running btred servers.

5) It is possible to limit perl code evaluated on the servers within a
   safer compartment, where some critical perl commands are disabled.
   In some cases, the restrictions may not be sufficient, in other
   they may be too strict. Some memory leaks can appear when Safe
   compartment is used. See C<--safe-mode> above for more discussion.

6) Unless C<--hub> option is used, the hub runs on localhost and as
   such is not (under normal circumstances) open for connections from
   the outside world.

=head1 FILES

C<~/.ntred_serverlist>  - default list of servers to use

C<~/.ntred_filelist>    - default list of files to load on servers

C<~/.ntred_session_key> - client/hub session key

=head1 AUTHORS

Petr Pajas <pajas@matfyz.cz>

Zdenek Zabokrtsky <zabokrtsky@ckl.mff.cuni.cz>

Copyright 2003 Petr Pajas and Zdenek Zabokrtsky, All rights reserved.

=cut
