#!/usr/bin/perl
#                                                          -*- cperl -*-
use Getopt::Std;
getopts('p:r:s:a:f:CETDNGhu');

if (@ARGV<1 or $opt_h or $opt_u) {
  print "Usage: $0 [-s strip-sfx] [-a append-sfx] [-p strip-prefix] [-r add-prefix] [-f out-fmt] [-T] [-N] [-G] [-D] file [file ...]\n";
  if ($opt_h) {
    print <<EOF;
Open a file and save it in FS format
Parameters:
  -f format          output format; one of: fs, csts, trxml. Default is csts.
  -s suffix_regexp   strip strings matching given regexp from the end of filenames
  -a append          append given suffix to the filenames
  -p prefix_regexp   remove strings matching given regexp from the beginning of filenames
  -r prepend         prepend filenames with the given prefix

  -T                 if converting from csts, build tectogrammatical tree structure
  -N                 if empty, initialize ordering attribute with sentence ordering
  -G                 do not save dependency on the root of the tree in csts format
  -C                 convert to CSTS in mode quite compatible with Dan Zemans cstsfs
  -E                 convert to CSTS save err1 attribute to (non-CSTS) <err> element
  -D                 print some debugging information
EOF
  }
  exit 0;
}

use FindBin;
my $rb=$FindBin::RealBin;
if (exists $ENV{TREDHOME}) {
  $libDir=$ENV{TREDHOME};
} elsif (-d "$rb/tredlib") {
  $libDir="$rb/tredlib";
} elsif (-d "$rb/../lib/tredlib") {
  $libDir="$rb/../lib/tredlib";
} elsif (-d "$rb/../lib/tred") {
  $libDir="$rb/../lib/tred";
}
print STDERR "Trying $libDir\n" if ($libDir);
unshift @INC,"$libDir";

require Fslib;
import Fslib;

#require CSTS_SGML_SP_Backend;
@backends=('FSBackend',ImportBackends(qw(TrXMLBackend CSTS_SGML_SP_Backend)));

$CSTS_SGML_SP_Backend::doctype = "$libDir/csts.doctype";

if ($opt_T) {
  $Csts2fs::gov = "govTR";
  $Csts2fs::header = \@Csts2fs::TRheader;
  $Csts2fs::initial_node_values{TR}='hide';
}

$Fslib::Debug=1 if $opt_D;  
$Csts2fs::fill_empty_ord = 1 if $opt_N;
$Fs2csts::export_dependency = 0 if $opt_G;
$Fs2csts::compatibility_mode = 1 if $opt_C;
$Fs2csts::preserve_err1 = 1 if $opt_E;

%bkmap=(
	fs => 'FSBackend',
	csts => 'CSTS_SGML_SP_Backend',
	trxml => 'TrXMLBackend'
);

$fileno=0;
$filecount=scalar(@ARGV);

$format=defined($opt_f) ? lc($opt_f) : "csts";
unless (  $backend = $bkmap{$format} ) {
  die "Unknown format $format. Use -f [fs|csts|trxml]\n";
}

foreach $f (@ARGV) {
  $fileno++;
  print STDERR "$f\t",int(100*$fileno / $filecount),"%\t$fileno of $filecount\n";
  $fs = FSFile->newFSFile($f,@backends);
  if ($fs->lastTreeNo<0) {
    print STDERR "$f: empty or corrupt file!\n";
    next;
  }
  $fs->changeBackend($backend);

  my $out=$f;
  $out=~s/$opt_s$/$opt_a/ if ($opt_s or $opt_a);
  $out=~s/^$opt_p/$opt_r/ if ($opt_p or $opt_r);
  if ($f eq $out) {
    unlink "$f~" if (-e "$f~" ); # silly MS OSs need this
    rename $f, "$f~" || die "Cannot create backup file named $f~ for $f\n";
  }

  if ($opt_T) {
    $fs->changePatterns('${trlemma}<? ".#{custom1}\${aspect}" if $${aspect} =~/PROC|CPL|RES/ ?>',
                    '<?$${funcaux} if $${funcaux}=~/\#/?>${func}<? "_#{custom2}\${reltype}\${memberof}" if "$${memberof}$${reltype}" =~ /CO|AP|PA/ ?><? ".#{custom3}\${gram}" if $${gram} ne "???" and $${gram} ne ""?>');
    $fs->changeHint('<?"fw:\t\${fw}\n" if $${fw} ne "" ?>form:'."\t".'${form}'."\n".
		      "afun:\t\${afun}\ntag:\t\${tag}".
		      '<?"\ncommentA:\t\${commentA}\n" if $${commentA} ne "" ?>');
  }

  $fs->writeFile($out);
  undef $fs;
}
