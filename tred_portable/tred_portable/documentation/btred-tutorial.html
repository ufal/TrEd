<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>BTrEd/NTrEd Tutorial</title><link rel="stylesheet" href="blue.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.75.2" /></head><body><div class="article" title="BTrEd/NTrEd Tutorial"><div class="titlepage"><div><div><h2 class="title"><a id="id328601"></a>BTrEd/NTrEd Tutorial</h2></div><div><div class="author"><h3 class="author"><span class="firstname">Petr</span> <span class="surname">Pajas</span></h3></div></div></div><hr /></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#id328634">1. Preliminaries</a></span></dt><dt><span class="sect1"><a href="#id362653">2. What BTrEd and NTrEd are and why you may need them?</a></span></dt><dt><span class="sect1"><a href="#id362688">3. Getting started</a></span></dt><dt><span class="sect1"><a href="#id327448">4. Processing too slow? Use NTrEd!</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id327462">4.1. Requirements</a></span></dt><dt><span class="sect2"><a href="#id327508">4.2. Getting started</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id372164">5. Quick API reference</a></span></dt></dl></div><div class="sect1" title="1. Preliminaries"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id328634"></a>1. Preliminaries</h2></div></div></div><p>Both <code class="literal">btred</code> and <code class="literal">ntred</code> are TrEd
    macro processors. TrEd macros are based on Perl, so you should be familiar
    with basics of Perl programming language. Most notably, you should know
    how to deal with Perl's basic data structures (scalars, arrays, hashes)
    and references. You should also know how to write perl subroutines. Basic
    knowledge of perl object oriented programming is also required (as a
    minimum, you should know the
    <code class="literal">$object-&gt;method(arguments)</code> syntax).</p></div><div class="sect1" title="2. What BTrEd and NTrEd are and why you may need them?"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id362653"></a>2. What BTrEd and NTrEd are and why you may need them?</h2></div></div></div><p>You might find these programs useful if you need to
    automatically process a larger amount of files you normally edit
    in TrEd. By processing, we mean programatically editing the data
    searching in the them, and so on, without user interaction.
    </p><p>
    <code class="literal">btred</code> provides a feature-rich environment for
    all these types of tasks. It can be used either directly from the
    command line or as a server which keeps the trees in memory and
    evaluates macros on clients requests.  <code class="literal">ntred</code> is
    the interface between the client and a cluster of one or more
    <code class="literal">btred</code> servers.</p></div><div class="sect1" title="3. Getting started"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id362688"></a>3. Getting started</h2></div></div></div><p>In the most usual case, you run <code class="literal">btred</code> as follows:
    </p><div class="literallayout"><p>btred -m <em class="replaceable"><code>my_macros</code></em><br />
      -e <em class="replaceable"><code>my_function</code></em> <em class="replaceable"><code>files</code></em> ...</p></div><p>
    <code class="literal">btred</code> first reads your macros from the files
    <em class="replaceable"><code>my_macros</code></em>, then starts opening given
    <code class="literal">files</code> one at a time and executes function
    <em class="replaceable"><code>my_function</code></em> on each of them.</p><p>The file <code class="literal">my_macros</code> may for example look as the
    following one: </p><div class="literallayout"><p><br />
sub is_childless_verb {<br />
  my ($node) = @_;<br />
  if (not($node-&gt;firstson()) and $node-&gt;{tag}=~/^V/) {<br />
    return 1;<br />
  } else {<br />
    return 0;<br />
  }<br />
}<br />
<br />
sub find_childless_verbs {<br />
  do {{<br />
    while ($this) {<br />
      if (is_childless_verb($this)) {<br />
         print ThisAddress(),"\n";<br />
      }<br />
      $this=$this-&gt;following;<br />
    } <br />
  }} while (NextTree());<br />
}<br />
      </p></div><p>To apply the above macros on a set of files, you simply type
    </p><div class="literallayout"><p>btred -m my_macros -e find_childless_verbs *.fs</p></div><p>Let's
    see what happens in the code: <code class="literal">find_childless_verbs</code>
    iterates over all trees by calling <code class="literal">NextTree()</code> to move
    to the next tree. Within each tree it iterates over all nodes, using
    <code class="literal">following</code> method on current node
    <code class="literal">$this</code>. This method returns the following node in the
    recursive depth-first ordering. For each node it consults the
    <code class="literal">is_childless_verb</code> function declared above and if this
    function returns <code class="literal">1</code>, prints a string of the form
    <code class="literal"><em class="replaceable"><code>filename.fs</code></em>#<em class="replaceable"><code>tree-no</code></em>.<em class="replaceable"><code>node-position</code></em></code>
    generated by a default macro function called ThisAddress(). Output can be
    passed to <span class="application">TrEd</span> as a file-list and TrEd will
    open each of the files at the exact tree and node.</p><p>The code in <code class="literal">is_childless_verb</code> checks if the given
    node has no children (which in turn means, it has no first son, as node's
    children are all male in the terminology used) and is a verb according to
    the first letter of the attribute <code class="literal">tag</code>, containing
    required morphological information.</p><p>It is quite apparent that most of the code of
    <code class="literal">find_childless_verbs</code> is spent on iterating over all
    nodes of all trees. <code class="literal">btred</code> can do this for you, if you
    use use the options <code class="literal">-T</code> (to iterate over all trees) and
    <code class="literal">-N</code> to iterate over all nodes within each of processed
    trees. Command-line options which don't take arguments can be put
    together, so you can write the above two as <code class="literal">-TN</code>.</p><p>Because it is rather easy to forget to put options like
    <code class="literal">-T</code> or <code class="literal">-N</code> to the command-line, you
    can write them directly into the code as shown below. It is sometimes
    handy to include other options, such as <code class="literal">-e
    find_childless_verbs</code> indicating, which macro should be called on
    each iteration. The script then looks as follows: </p><div class="literallayout"><p><br />
	#!btred -TN -e find_childless_verbs<br />
sub is_childless_verb {<br />
   my ($node) = @_;<br />
   if (not($node-&gt;firstson()) and $node-&gt;{tag}=~/^V/) {<br />
     return 1;<br />
   } else {<br />
     return 0;<br />
   }<br />
}<br />
<br />
sub find_childless_verbs {<br />
   if (is_childless_verb($this)) {<br />
      print ThisAddress(),"\n";<br />
   }<br />
}<br />
      </p></div><p> and can be executed simply as </p><div class="literallayout"><p>$ btred -m my_macros *.fs</p></div><p>If your script is so simple that you don't bother openning an
    editor, you can put your code directly on the command line. Here is an
    example equivalent to the code of <code class="literal">my_macros</code>.
    </p><div class="literallayout"><p>$ btred -TN -e 'print ThisAddress(),"\n" unless ($this-&gt;firstson() or $this-&gt;{tag}!~/^V/)' *.fs</p></div></div><div class="sect1" title="4. Processing too slow? Use NTrEd!"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id327448"></a>4. Processing too slow? Use NTrEd!</h2></div></div></div><div class="toc"><dl><dt><span class="sect2"><a href="#id327462">4.1. Requirements</a></span></dt><dt><span class="sect2"><a href="#id327508">4.2. Getting started</a></span></dt></dl></div><p>Processing a large amount of data with many incremental scripts (or
    just incremental versions of one script) may take a very long time.
    Usually, most of the time is not spent on your script but on opening,
    parsing (and possibly saving) the data files. This is where NTrEd offers
    big improvement, because it 1) allows you to utilize computing power of
    more than one machine, 2) reads the files only once and keeps them in
    memory. As a result, depending on situation, it may shorten the time
    needed for one pass from several minutes to just a few seconds.</p><div class="sect2" title="4.1. Requirements"><div class="titlepage"><div><div><h3 class="title"><a id="id327462"></a>4.1. Requirements</h3></div></div></div><p>NTrEd requires you to have <span class="emphasis"><em>password-free
      access</em></span> to all machines you use. There are many ways to achive
      this, the most common of which are a) using <code class="literal">ssh2</code>
      authorization keys together with a <code class="literal">ssh-agent2</code>, b)
      using <code class="literal">Kerberos</code>, or <code class="literal">c) .rhosts</code>
      files.</p><p>The remote machines <span class="emphasis"><em>must have shared
      filesystems</em></span>. As a minimum, they should share your home
      directory and a directory containing your data.</p></div><div class="sect2" title="4.2. Getting started"><div class="titlepage"><div><div><h3 class="title"><a id="id327508"></a>4.2. Getting started</h3></div></div></div><p>The hostnames of the machines you wish to use with
      <code class="literal">NTrEd</code> can either be specified on the command-line,
      but it is more comfortable to put them in a file called
      <code class="literal">.ntred_serverlist</code> contained in your home directory.
      This file should contain one or more lines of the form
      <code class="literal"><em class="replaceable"><code>hostname</code></em>:<em class="replaceable"><code>port</code></em></code>.
      Empty lines are ignored, and lines starting with a hash sign
      <code class="literal">#</code> are treated as comments. You may specify one
      hostname several times, provided you use different ports. This is
      particularly useful to utilize the whole power of multi-processor
      systems. You may choose any port number above <code class="literal">1024</code>,
      but you should try to avoid collisions with other services running on
      the remote machines, including <span class="application">btred</span>
      instances run by other users.</p><p>You may always override the list by using the
      <code class="literal">--servers</code>.</p><p>Once you have .ntred_serverlist prepared and you have configured
      your system so that you can log in to all listed servers via ssh without
      typing a password, you can try to start the servers and load some
      data:</p><div class="literallayout"><p>$ ntred -i *.fs</p></div><p>If all went well, you see the ntred hub distributing your data
      (*.fs) among btred servers. If you use some other tool than ssh to log
      into the servers, you can specify it using <code class="option">--ssh</code>
      option, for example:</p><div class="literallayout"><p>$ ntred -i --ssh /usr/bin/rsh *.fs</p></div><p>Once all data files are distributed among the servers, you'll see
      the following line:</p><div class="literallayout"><p>NTRED-HUB: Waiting for a new client request.</p></div><p>Now, open a new console (xterm, or whatever) and run the
      following:</p><div class="literallayout"><p>$ ntred --list-files</p></div><p>On standard output, you'll see a list of open files, printed by
      each btred server. Note that the order of the files may be quite
      random. Standard error oputput contains various messages showing e.g.
      which server is being communicated by the hub etc. It's now time to run
      some more interesting code on the servers. We may start with the one
      already crafted for btred above:</p><div class="literallayout"><p>$ ntred -TN -e 'print ThisAddress(),"\n" unless ($this-&gt;firstson() or $this-&gt;{tag}!~/^V/)'</p></div><p>You may see that this is almost identical to the btred example
      above, except that this time we don't have to specify any filenames,
      since we already have files loaded on the server (an of course, this
      time it will be significantly faster, esp. in case of large amount of
      data files). </p><p>Usually, btred scripts can be reused with ntred without changed.
      You only have to remember that:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>each btred server processes it's own files without
          communicating with the others, so if for example, your script does
          some statistics and prints it at the end, you'll get as many results
          as there are servers, so you'll have to collect the output and merge
          the results somehow to obtain the overall statistics for the whole
          data. </p></li><li class="listitem"><p>Your scripts may modify the data on the servers. The servers
          can remember what files were changed by your scrips but you have to
          explicitly tell in your macros if you're making changes (by calling
          <code class="literal">ChangingFile()</code>). You can list the changed files
          with <code class="literal">ntred --list-changed-files</code>. The changes are
          kept in the memory only, unless you explicitly say the servers to
          save them (using <code class="literal">ntred --save-files</code> - saves all -
          or <code class="literal">ntred --save-changed-files</code>).</p></li><li class="listitem"><p>You can open the data from the server's memory (with all
          changes) for inspection or manual processing in TrEd. It only
          suffices to give the full path name to a file and precede it with
          <code class="literal">ntred://</code> protocol prefix. You may optionally
          specify tree number after <code class="literal">@ sign. You can also specify node
          to be made active in TrEd. For example, t</code>o see node with
          recursive ordering 22 in the 10th tree in the file /my/data/foo.fs
          as it is stored in the servers' memory, you would issue</p><div class="literallayout"><p>$ tred ntred:///my/data/foo.fs#1.22@10</p></div><p>For your convenience, there is a predefined macro
          <code class="literal">Position($node)</code> which prints the URI of the above
          form for the given node (or for <code class="literal">$this</code> if no node
          is specified). Here is a nice example of the power of Unix
          redirection and this toolkit: it shows nodes selected by our old
          good macro in TrEd:</p><div class="literallayout"><p>$ ntred -TN -e 'Position unless ($this-&gt;firstson() or $this-&gt;{tag}!~/^V/) | tred -l-</p></div></li><li class="listitem"><p><code class="literal">Most ntred</code> commands can be used with the
          option <code class="literal">-L</code> which allows you to specify files (or a
          list of files) to apply the commands to. The files must be already
          open by the servers. If apropriate, you may also specify individual
          trees or even nodes using the syntax shown above. </p></li></ul></div></div></div><div class="sect1" title="5. Quick API reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id372164"></a>5. Quick API reference</h2></div></div></div><p>Here is a brief list of the macro API. More complete (yet still
    incomplete) information can be found in TrEd's User Manual. This list
    doesn't include contributed extensions for various specific projects, such
    as PDT.</p><div class="variablelist"><dl><dt><span class="term">$this</span></dt><dd><p>This variable contains the currently processed node.</p></dd><dt><span class="term">$root</span></dt><dd><p>This variable contains the root of the currently processed
          tree.</p></dd><dt><span class="term">$node-&gt;attr(<em class="replaceable"><code>attribute</code></em>)</span></dt><dd><p>Get the value of node's attribute named
          <em class="replaceable"><code>attribute</code></em>.</p></dd><dt><span class="term">$node-&gt;set_attr(<em class="replaceable"><code>attribute</code></em>},
          <em class="replaceable"><code>value</code></em>)</span></dt><dd><p>Set the value of node's attribute named
            <em class="replaceable"><code>attribute</code></em> to
            <em class="replaceable"><code>value</code></em>.
	  </p></dd><dt><span class="term">$node-&gt;children()</span></dt><dd><p>Returns a list of node's child nodes.</p></dd><dt><span class="term">$node-&gt;parent()</span></dt><dd><p>Returns node's parent node.</p></dd><dt><span class="term">$node-&gt;lbrother()</span></dt><dd><p>Returns node's left sibling node.</p></dd><dt><span class="term">$node-&gt;rbrother()</span></dt><dd><p>Returns node's right sibling node.</p></dd><dt><span class="term">$node-&gt;descendants()</span></dt><dd><p>Returns all nodes in the node's subtree
          <span class="emphasis"><em>not</em></span> including the node itself.</p></dd><dt><span class="term">$node-&gt;following()</span></dt><dd><p>Returns a node following a given node in the depth-first
          recursive ordering.</p></dd><dt><span class="term">$node-&gt;previous()</span></dt><dd><p>Returns a node preceding a given node in the depth-first
          recursive ordering.</p></dd><dt><span class="term">FS()</span></dt><dd><p>Returns the current Treex::PML::FSFormat object. It is an object containing
          information of currently defined attributes and possibly their
          special semantic (e.g. which attribute is responsible for the
          topological left-to-right ordering of the tree, which attribute is
          used to mark nodes as <code class="literal">hidden</code>, etc).</p></dd><dt><span class="term">$node-&gt;visible_children(FS())</span></dt><dd><p>Return all visible child nodes (i.e. not marked as hidden) of
          the given node.</p></dd><dt><span class="term">$node-&gt;visible_descendants(FS())</span></dt><dd><p>Return all visible child nodes (i.e. not marked as hidden) of
          the given node.</p></dd><dt><span class="term">NextTree()</span></dt><dd><p>Setup $root and $this to the root of the next tree in the
          current file to be processed. Returns <code class="literal">undef</code> if
          all trees in the current file has already been processed.</p></dd><dt><span class="term">ChangingFile()</span></dt><dd><p>Call this macro to let btred know, you're making
          changes.</p></dd><dt><span class="term">CutPaste($node_to_cut,$target_to_paste)</span></dt><dd><p>Cuts given node and pastes it on the target node so it becomes
          it's child. It dies if the target node is in the subtree of the
          source node (since in that case cut/paste operations makes no
          sense).</p></dd><dt><span class="term">Cut($node)</span></dt><dd><p>Disconnects a given node from it's paren and siblings.</p></dd><dt><span class="term">PasteNode($node,$new_parent)</span></dt><dd><p>Make a given node a new child of a given parent node. </p></dd><dt><span class="term">CloneSubtree($node)</span></dt><dd><p>Return a new identical copy of the current sub-tree.</p></dd><dt><span class="term">$node = Treex::PML::Factory-&gt;createNode()</span></dt><dd><p>Create a new node.</p></dd><dt><span class="term">IsHidden($node)</span></dt><dd><p>Return true if a given node is marked as hidden.</p></dd></dl></div></div></div></body></html>
