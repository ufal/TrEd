<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>btred/ntred tutorial</title>
    <link rel="stylesheet" href="blue.css" type="text/css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2" />
  </head>
  <body>
    <div class="article" title="btred/ntred tutorial">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a id="id479551" name="id479551"></a>btred/ntred tutorial</h2>
          </div>
          <div>
            <div class="author">
              <h3 class="author"><span class="firstname">Zdeněk</span> <span class="surname">Žabokrtský</span></h3>
            </div>
          </div>
          <div>
            <div class="author">
              <h3 class="author"><span class="firstname">Petr</span> <span class="surname">Pajas</span></h3>
            </div>
          </div>
        </div>
        <hr />
      </div>
      <div class="toc">
        <p>
          <b>Table of Contents</b>
        </p>
        <dl>
          <dt>
            <span class="section">
              <a href="#id479601">1. Why btred/ntred?</a>
            </span>
          </dt>
          <dt>
            <span class="section">
              <a href="#id478786">2. Running the first btred macro</a>
            </span>
          </dt>
          <dt>
            <span class="section">
              <a href="#id482087">3. Specification of the files to be processed</a>
            </span>
          </dt>
          <dt>
            <span class="section">
              <a href="#id478946">4. Touching the data: node attributes</a>
            </span>
          </dt>
          <dt>
            <span class="section">
              <a href="#id518171">5. Node methods and other functions</a>
            </span>
          </dt>
          <dt>
            <span class="section">
              <a href="#id518512">6. Crossing layer boundaries</a>
            </span>
          </dt>
          <dt>
            <span class="section">
              <a href="#id518830">7. Hooks</a>
            </span>
          </dt>
          <dt>
            <span class="section">
              <a href="#id518889">8.  Make it faster: change the data format</a>
            </span>
          </dt>
          <dt>
            <span class="section">
              <a href="#id518999">9.  Make it much faster: ntred</a>
            </span>
          </dt>
          <dt>
            <span class="section">
              <a href="#id478523">10. Searching</a>
            </span>
          </dt>
        </dl>
      </div>
      <div class="section" title="1. Why btred/ntred?">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="id479601" name="id479601"></a>1. Why btred/ntred?</h2>
            </div>
          </div>
        </div>
        <p>
The tree editor <span class="command"><strong>tred</strong></span>  allows for a quick
and comfortable viewing of linguistic tree structures, but as soon as
you need to handle a bigger piece of the PDT data at a time, tools
allowing automatic processing become necessary. We recommend you to access the PDT data
via <span class="command"><strong>btred/ntred</strong></span> Perl-based interface
tailored for the PDT purposes. <span class="command"><strong>btred</strong></span> is a Perl program that allows
the user to apply another Perl program (called btred macro) on the
data stored in one of the PDT formats. <span class="command"><strong>ntred</strong></span> is a client-server
version of btred and is suited for data processing on multiple
machines in parallel (mnemonics for btred/ntred: "b"
stands for "batch processing", "n"  stands for "networked processing").
</p>
        <p> If you follow the above recommendation, you gain several advantages:
</p>
        <div class="itemizedlist">
          <ul class="itemizedlist" type="disc">
            <li class="listitem">
Object-oriented tree representation, which is used in btred/ntred
environment, offers a rich repertory of basic functions for
tree traversing  and for many other basic operations on trees; besides
that, there are also several highly non-trivial functions available,
suited for linguistically motivated traversing of trees (reflecting
e.g. the interplay of dependency and coordination relations).
</li>
            <li class="listitem">
btred/ntred technology was extensively used by several programmers
during the development of the PDT; this long-time experience has led to
many improvements and also helped to make the tools and accompanying
libraries reasonably error-prone.
</li>
            <li class="listitem">
If you have more computers at your disposal, you can use ntred and
process the data in parallel, which makes the computation considerably
faster. Depending on the situation, it may shorten the time needed for
passing the whole PDT to just a few seconds.
</li>
            <li class="listitem">
Programmers can use btred/ntred (in combination with TrEd) as a
powerful and fast search engine—you write a macro which finds the
treebank positions you are interested in, run it by ntred and then simply view
the retrieved positions in TrEd.
</li>
            <li class="listitem">
All you need to become fluent in writing btred/ntred macros is to know
the basics of Perl syntax and to remember a few names of variables and
subroutines predefined in the btred/ntred environment.
</li>
            <li class="listitem">
Once you learn the btred/ntred style of work, you can re-use all its
benefits when processing the data of other treebanks (be they
dependency- or constituency-based).
</li>
          </ul>
        </div>
        <p>
</p>
        <p>The following text should serve as a short introduction to btred/ntred
style of work with the PDT 2.0 data. More detailed information about
the two commands is available
in <a class="ulink" href="btred.html" target="_top">btred</a> and <a class="ulink" href="ntred.html" target="_top">ntred</a>
manual pages.
</p>
        <p>Note that some of the examples in this tutorial are specific to
PDT 2.0 data only and need not be directly applicable to other data
formats even if supported by TrEd.
</p>
      </div>
      <div class="section" title="2. Running the first btred macro">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="id478786" name="id478786"></a>2. Running the first btred macro</h2>
            </div>
          </div>
        </div>
        <p>
The Perl code which you want to execute can be specified directly on
the command line:
</p>
        <pre class="programlisting">$ <span class="command"><strong>btred</strong></span> -e 'print "Hello world!\n"' data/sample/*.t.gz</pre>
        <p>
</p>
        <p>
In this example, btred loads all the specified files one-by-one and evaluates
the Perl code for each of them. In other words, it prints as many
"Hello world!" lines as there are <code class="filename">data/sample/*.t.gz</code> files.
In this way, you can process three types of PDT 2.0 data files:
<code class="filename">*.m.gz</code>, <code class="filename">*.a.gz</code>, and
<code class="filename">*.t.gz</code>.
It is not recommended to mix files from various layers at a time
(e.g. due to the fact that when processing a file from a certain
layer, btred loads the interlinked files from the lower layers by itself).

</p>
        <p>
It is often the case that you want to perform an action not only for each file, but
repeatedly for each tree in each file, or even for each node of each tree in each
file. To avoid writing the iteration code yourself, you can use
<em class="parameter"><code>-T</code></em> and <em class="parameter"><code>-N</code></em> switches (iterate over
all trees and iterate over all nodes, respectively). Thus the command


</p>
        <pre class="programlisting">$ <span class="command"><strong>btred</strong></span> -TNe 'print "Hello world!\n"' data/sample/*.t.gz | wc -l
</pre>
        <p>


prints the total number of all nodes in all trees in all processed
files.

</p>
        <p>
Naturally, command line evaluation is suited only for very simple
macros. Longer macros can be stored in
a separate macro file. The difference is that the macro file as a
whole is evaluated only once and you have to use the option
<em class="parameter"><code>-e</code></em> to determine which subroutine
should be executed in each iteration.
The iteration options (<em class="parameter"><code>-T</code></em> and
<em class="parameter"><code>-N</code></em> shown above) can be
optionally specified directly in the macro. Example macro file <code class="filename">helloworld.btred</code>:



</p>
        <pre class="programlisting">#!btred -TN -e hello()
sub hello {
    print "Hello world!\n"
}</pre>
        <p>


The tectogrammatical nodes in the processed files can be then counted as follows (not
very elegantly, though):


</p>
        <pre class="programlisting">$ <span class="command"><strong>btred</strong></span> -I helloworld.btred data/sample/*.t.gz | wc -l
</pre>
        <p>


</p>
      </div>
      <div class="section" title="3. Specification of the files to be processed">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="id482087" name="id482087"></a>3. Specification of the files to be processed</h2>
            </div>
          </div>
        </div>
        <p>
So far, we specified the files to be processed simply by using a file name mask
on the command line (<code class="filename">data/sample/*.t.gz</code> in the
above examples).
But when one works with the full data of PDT 2.0, it often happens
that the total length of command line arguments exceeds its limit.
In such a case, expansion of the wildcards can be "postponed" from
shell to btred:

</p>
        <pre class="programlisting">$ <span class="command"><strong>btred</strong></span> -TNe 'print "Hello world!\n"' -g 'data/full/tamw/train*/*.t.gz'
</pre>
        <p>


Instead of specifying the files on the command line, you can first create
a file containing the list of files to be processed (one per line), either by
choosing a subset of the distributed full data file list (which, of course,
contains only relative paths!): 

</p>
        <pre class="programlisting">$ <span class="command"><strong>grep</strong></span> 'tamw/train-[1-4].*a.gz' data/full/filelist &gt; half-train-a.fl
</pre>
        <p>

or by other means, e.g. using <code class="literal">find</code>:

</p>
        <pre class="programlisting">$ <span class="command"><strong>find</strong></span> data/full/*awm/train-[1-4]/ -name '*a.gz' &gt; half-train-a.fl
</pre>
        <p>

and open the file list (instead of a single file) in btred by using <em class="parameter"><code>-l</code></em>:
</p>
        <pre class="programlisting">$ <span class="command"><strong>btred</strong></span> -TNe 'print "Hello world!\n"' -l half-train-a.fl
</pre>
        <p>

(The file lists created by the above commands contain one half of all training a-files: <code class="filename">train-1</code> to
<code class="filename">train-4</code> from <code class="filename">tawm</code> and <code class="filename">awm</code>).


</p>
      </div>
      <div class="section" title="4. Touching the data: node attributes">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="id478946" name="id478946"></a>4. Touching the data: node attributes</h2>
            </div>
          </div>
        </div>
        <p>Until now, we only iteratively executed a blind code, without
really touching the data. The trees and nodes can be
accessed via special variables which are predefined in
the btred environment. The most important ones are:
</p>
        <div class="itemizedlist">
          <ul class="itemizedlist" type="disc">
            <li class="listitem"><code class="literal">$this</code> – current node, and</li>
            <li class="listitem"><code class="literal">$root</code> – root of the current tree.</li>
          </ul>
        </div>
        <p>

See Section <a class="ulink" href="ar01s15.html#defaultmacros" target="_top">15.8. Public API: pre-defined macros</a> in the <a class="ulink" href="ar01-toc.html" target="_top">TrEd User's Manual</a> to see them all. Remember that these variables should not be re-declared in your code;
if you use the <code class="literal">strict</code> module  in your code to restrict
unsafe constructions (including the usage of undeclared variables),
you have to introduce these variables by the following line:
  
  </p>
        <pre class="programlisting">use vars qw($this $root);
  </pre>
        <p>
  

</p>
        <p>Nodes, represented as Perl objects, have attributes of several
types (see the <a class="ulink" href="http://ufal.mff.cuni.cz/pdt2.0/doc/data-formats/pml-markup/index.html" target="_top">exhaustive list of attributes</a>):
</p>
        <div class="itemizedlist">
          <ul class="itemizedlist" type="disc">
            <li class="listitem">
              <p> Values of <span class="emphasis"><em>simple attributes</em></span> are obtained
  directly using <code class="literal">$node-&gt;{attr}</code> syntax. 
  </p>
              <p>
   Example:
  
  </p>
              <pre class="programlisting">my $current_functor = $this-&gt;{functor};</pre>
              <p>
  
  </p>
            </li>
            <li class="listitem">
              <p> Values of <span class="emphasis"><em>structured attributes</em></span> can be obtained
  in two almost equivalent notations:
  <code class="literal">$node-&gt;{level1attr}{level2attr}</code> or
  <code class="literal">$node-&gt;attr('level1attr/level2attr')</code>.    Example:
    </p>
              <pre class="programlisting">my $semnoun_number = $this-&gt;{gram}{number};</pre>
              <p>
     or
    </p>
              <pre class="programlisting">my $semnoun_number = $this-&gt;attr('gram/number');</pre>
              <p>
   The slash with the <code class="literal">-&gt;attr()</code>
  notation is slightly slower but also safer if a part of a non-defined
  structured attribute is accessed (which is the case e.g. of the <code class="literal">number</code>
    grammateme, since it is present only in semantic nouns).

  </p>
            </li>
            <li class="listitem">
              <p> In case of a <span class="emphasis"><em>list attribute</em></span>, the array of its
  values can be obtained by calling
  <code class="literal">ListV($node-&gt;{listattrname})</code>.
  </p>
              <p>
  Example: list of identifiers of tectogrammatical nodes which are
  antecedents (with respect to textual coreference) of the current node:
  
  </p>
              <pre class="programlisting">my @ids = ListV($this-&gt;attr('coref_text.rf'));</pre>
              <p>
  
  </p>
              <p>
  If it is guaranteed that the list is not empty, n-th value in the
  list can be accessed directly by an array index, such as in:
  
  </p>
              <pre class="programlisting">my $first_antec_lemma = PML_T::GetNodeByID($this-&gt;{'coref_text.rf'}
  -&gt;[0])-&gt;{t_lemma};</pre>
              <p>
  
  (Apostrophes or quotes around <code class="literal">coref_text.rf</code> are necessary only because of the dot in the attribute name.)
  </p>
            </li>
          </ul>
        </div>
        <p>

Remember that there are different sets of attributes available on
different layers (as documented in the <a class="ulink" href="http://ufal.mff.cuni.cz/pdt2.0/doc/data-formats/pml-markup/index.html" target="_top">exhaustive list of
attributes</a>). Example - for each node of each analytical tree
in the sample data, print its analytical function
(<em class="parameter"><code>-q</code></em> is used to surpress btred progress messages):


</p>
        <pre class="programlisting">$ <span class="command"><strong>btred</strong></span> -TNqe 'print $this-&gt;{afun}."\n"' /net/projects/pdt/pdt20/data/sample/*.a.gz</pre>
        <p>

Sample from the output:
</p>
        <pre class="programlisting">
AuxS
Pred
Sb
Atr
AuxP
Adv
Adv
Obj
</pre>
        <p>

</p>
        <p>

Note that when you access the m-layer attributes directly in the m-files, the attributes are embeded in a structure
named '#content', as shown in the following example.
The example prints the frequency list of forms of vocalized prepositions
(according to their frequency in m-layer files in the sample
data). The (sorted) frequency list is created by pipelining btred with
standard shell commands:

</p>
        <pre class="programlisting">$ <span class="command"><strong>btred</strong></span> -TNe 'print $this-&gt;attr("#content/form")."\n"\
 if $this-&gt;attr("#content/tag")=~/^RV/' data/sample/*.m.gz | sort | uniq -c | sort -nr </pre>
        <p>



Output:
</p>
        <pre class="programlisting">     25 ve
     11 ze
      8 se
      2 Ve
      1 ke
</pre>
        <p>


</p>
      </div>
      <div class="section" title="5. Node methods and other functions">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="id518171" name="id518171"></a>5. Node methods and other functions</h2>
            </div>
          </div>
        </div>
        <p>
Nodes, as Perl objects, have attributes and methods.
The methods can be accessed using the
<code class="literal">$node-&gt;method(arguments)</code> syntax.

 All the available methods are documented in Table <a class="ulink" href="ar01s15.html#fsnode_methods" target="_top">Treex::PML::Node
 methods</a> in the <a class="ulink" href="ar01-toc.html" target="_top">TrEd User's Manual</a>.


The most important methods for traversing the tree are
<code class="literal">parent()</code> (returning the parent node) and
<code class="literal">children()</code> (returning the array of child nodes).
The following example combines both and prints lemmas of nodes the
parent of which is the technical root of the tree and which have
a directional modifier among its children:


</p>
        <pre class="programlisting">btred -TNe 'print "$this-&gt;{t_lemma}\n" if
  $this-&gt;parent==$root and grep{$_-&gt;{functor}=~/^DIR/} $this-&gt;children()' \
  data/sample/*.t.gz -q</pre>
        <p>

</p>
        <p>
Besides the methods associated with the node objects, there are
many useful functions which take nodes as arguments
and which are implemented in PML macro files (see <a class="ulink" href="PML_mak.html" target="_top">PML.mak documentation</a>).
They are loaded into the btred/ntred environment by default
unless <em class="parameter"><code>-m</code></em> parameter is used (see the
<a class="ulink" href="btred.html" target="_top">btred manual page</a>).
</p>
        <p>

As for tree traversing, there are functions <code class="literal">GetEParents($node)</code> and
<code class="literal">GetEChildren($node)</code> (E standing for effective)
in PML_T (resp. PML_A) package. Although it often makes the code more
difficult, they should be used instead of <code class="literal">$node-&gt;parent()</code> and
<code class="literal">$node-&gt;children()</code>
in most situations because <code class="literal">GetEParents</code> and
<code class="literal">GetEChildren</code> correctly resolve the complex interplay
between dependency and coordination edges in the tectogrammatical
(resp. analytical) trees.
For instance, in the tree of the sentence <em class="wordasword">We sell fresh vegetable and fruits</em>, the
nodes corresponding to <em class="wordasword">fresh</em>,
<em class="wordasword">vegetable</em>
and <em class="wordasword">fruits</em> are all children (in the sense of <code class="literal">children()</code>) of <em class="wordasword">and</em>,
but the correct linguistic interpretation is
different: (1) <em class="wordasword">fresh</em> has two effective parents (the "true governors" in terms
of dependency relations, obtained by calling <code class="literal">GetEParents()</code>), namely <em class="wordasword">vegetable</em>
and <em class="wordasword">fruits</em>, and (2) the effective parent of <em class="wordasword">vegetable</em>
(and also of <em class="wordasword">fruits</em>) is <em class="wordasword">sell</em>. Obviously, the graph of dependency
relations is not a tree any more. 

    </p>
        <div class="figure">
          <a id="i-effective" name="i-effective"></a>
          <p class="title">
            <b>Figure 1. The difference between parents (in the sense of tree topology,
      <code class="literal">$node-&gt;parent()</code>) and effective parents
      (dependency governors, <code class="literal">GetEParents($node)</code>)
      illustrated on a simplified fragment of an analytical tree.</b>
          </p>
          <div class="figure-contents">
            <div class="mediaobject">
              <img src="pics/bn-effective.png" alt="The difference between parents (in the sense of tree topology, $node-&gt;parent()) and effective parents (dependency governors, GetEParents($node)) illustrated on a simplified fragment of an analytical tree." />
            </div>
          </div>
        </div>
        <p><br class="figure-break" />

</p>
        <p>
The following example uses the functions
<code class="literal">GetEParents()</code> and
<code class="literal">GetEChildren()</code> when printing sentences containing
a patient ("deep object") in plural dependent on a negated verb (be there any
coordination node in between or not):


</p>
        <pre class="programlisting">
#!btred -TNe pluralpat()
sub pluralpat() {
  if ($this-&gt;attr('gram/number') eq "pl" and $this-&gt;{functor} eq "PAT"){
    foreach my $eparent (PML_T::GetEParents($this)) {
      if (grep {$_-&gt;{t_lemma} eq "#Neg"} PML_T::GetEChildren($eparent)) {
        print "($this-&gt;{t_lemma}) ".PML_T::GetSentenceString($root)."\n";
      }
    }
  }
}
</pre>
        <p>

Sample from the output:
</p>
        <pre class="programlisting">
(příjem) Jakmile se někde objevilo, že někdo nadměrně bohatne, už se
kontrolovalo, kolik příjmů přiznával a zda nějaké nezatajuje.
(předloha) Tyto předlohy totiž předsednictva SN a SL na program
nezařadila.
(Rom) Cedule s nápisem "Romy neobsluhujeme!" se o tomto víkendu
objevila na jednom z bister v Praze na Smíchově.
(procento) Provoz osobních automobilů ruší ve spánku 22 procent
obyvatel, hluk nákladních vozidel budí 20 procent občanů a také
sousedi nenechají spát 20 procent populace v České republice.
</pre>
        <p>


</p>
      </div>
      <div class="section" title="6. Crossing layer boundaries">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="id518512" name="id518512"></a>6. Crossing layer boundaries</h2>
            </div>
          </div>
        </div>
        <p>
In many tasks it is necessary to work with information from
more than one layer. When data files of a given layer are processed
in btred, the content of associated files of all lower layers is
easily accessible. Due to the different nature of the relation
between the layers (see <a class="xref" href="#i-layers" title="Figure 2. Relations between neighboring layers in PDT 2.0 (Sample sentence: Byl by šel dolesa., lit. [He] would have gone intoforest.)">Figure 2, “Relations between neighboring layers in PDT 2.0 (Sample
      sentence: <em class="wordasword">Byl by šel dolesa.</em>, lit. <em class="wordasword">[He] would have gone intoforest.</em>)”</a>), there are different mechanisms for accessing the data on
a lower layer:

</p>
        <div class="itemizedlist">
          <ul class="itemizedlist" type="disc">
            <li class="listitem"> The relation between a-layer and m-layer is the simplest
one: there is a 1:1 relation between the units of  m-layer
and a-layer. On the a-layer, attributes of the m-layer
are accessible in the same way as if they were joined in a single structured
attribute, named with the letter of the lower layer. Thus
the lemma and tag (in fact situated on the m-layer) can be obtained
from a-layer as <code class="literal">$this-&gt;attr('m/lemma')</code> and
<code class="literal">$this-&gt;attr('m/tag')</code>. 
</li>
            <li class="listitem"> 
Due to the possible occurrence of mistakes in the original
texts (especially superfluous or missing blanks between two
tokens), the correspondence between the units of m-layer and w-layer is
not that simple. The word forms on m-layer are corrected:
if two tokens were joined, then one m-layer unit refers to two
w-layer units; in the other case, when one token was split,
two (or more) m-layer units refer to the same w-layer unit.
On the m-layer, the list of  the original tokens
can be accessed as <code class="literal">ListV($this-&gt;{'w'})</code>.
However, cases other than 1:1 are extremely rare, that is why
it is mostly sufficient to access only the first token from the list:
<code class="literal">$this-&gt;attr('w/token')</code>. The relations between
the layers can be composed and w-layer attributes can be accessed directly
from a-layer, e.g. <code class="literal">$this-&gt;attr('m/w/token')</code>.
</li>
            <li class="listitem">
In general, the relation between the units of a-layer and t-layer is
again M:N
(including 0:N and M:0), but in this case it is not a result of errors
in the input text, but of a systematic, linguistically relevant correspondence.
There are three attributes capturing this relation: <code class="literal">atree.rf</code>,
which is present only in the technical root and refers to the
corresponding root of the analytical tree, and
<code class="literal">a/lex.rf</code> and <code class="literal">a/aux.rf</code>, which are
present only in nodes different from the technical root.
 <code class="literal">a/lex.rf</code> refers to an analytical node
which is the source of the lexical meaning (or of its biggest part) of
the tectogrammatical node (or is possibly empty in case of certain
types of  restored nodes). <code class="literal">a/aux.rf</code>
contains a list (possibly empty) of references  to analytical nodes
corresponding to functional words
(such as prepositions, subordinating conjunctions, or auxiliary verbs),
which are syntactically bound with the autosemantic word referred to in <code class="literal">a/lex.rf</code>.
List of all analytical nodes corresponding to the given
tectogrammatical node can be obtained by calling <code class="literal">PML_T::GetANodes($this)</code>.
</li>
          </ul>
        </div>
        <p>

    </p>
        <div class="figure">
          <a id="i-layers" name="i-layers"></a>
          <p class="title">
            <b>Figure 2. Relations between neighboring layers in PDT 2.0 (Sample
      sentence: <em class="wordasword">Byl by šel dolesa.</em>, lit. <em class="wordasword">[He] would have gone intoforest.</em>)</b>
          </p>
          <div class="figure-contents">
            <div class="mediaobject">
              <img src="pics/bn-layers.png" alt="Relations between neighboring layers in PDT 2.0 (Sample sentence: Byl by šel dolesa., lit. [He] would have gone intoforest.)" />
            </div>
          </div>
        </div>
        <p><br class="figure-break" />


</p>
        <p>

Example: Print complex verbal forms (including reflexives) which express future tense and
contain an auxiliary verb:

</p>
        <pre class="programlisting">#!btred -TN -e complex_future_form()
sub complex_future_form {
  if ($this-&gt;{gram}{tense} eq "post" and
        grep {$_-&gt;{afun} eq "AuxV"} PML_T::GetANodes($this)) {
    print join " ",
      map {$_-&gt;attr('m/form')}
	sort{$a-&gt;{ord}&lt;=&gt;$b-&gt;{ord}}
	  grep {$_-&gt;attr('m/tag')=~/^(V|P7)/}
	    PML_T::GetANodes($this);
    print "\t sentence: ", PML_T::GetSentenceString($root), "\n\n";
  }
}
</pre>
        <p>

Sample from the output:
</p>
        <pre class="programlisting">
bude vést      sentence: Politickou sekci bude nadále vést britský Major
John, historickou trojnásobný Major z Hellerovy hlavy, zdravotnickou
major Hoollighanová, policejní major Zeman.

bude umístěna  sentence: Jiří Ševčík se stal ředitelem sbírky
moderního umění Národní galerie, která bude umístěna ve Veletržním
paláci, jehož rekonstrukce se však už roky vleče.

se budete zabývat      sentence: Čím zejména se budete nyní zabývat?
</pre>
        <p>


Example: Print sentences containing a possessive
pronoun present in the surface shape of the sentence, the
textual antecedent (at least one of them, if there are more) of which
is expressed as a prepositional group and is present in the same sentence:


</p>
        <pre class="programlisting">#!btred -TN -e antec_pg()
use strict;
use vars qw ($root $this);
sub antec_pg() {
  if ($this-&gt;{t_lemma} eq '#PersPron' and $this-&gt;attr('a/lex.rf')){
    my $mainanode=PML_T::GetANodeByID($this-&gt;attr('a/lex.rf'));
    if ($mainanode-&gt;attr('m/tag')=~/^PS/) {
      my @antecedents = map {PML_T::GetNodeByID($_)}
	ListV($this-&gt;{'coref_text.rf'});
      my @candidates =
	grep {$_-&gt;root() == $root}
	  grep {  my $antec=$_;
		  grep{$_-&gt;attr('m/tag')=~/^R/} map {PML_T::GetANodeByID($_)}
		    ListV($antec-&gt;attr('a/aux.rf'))
		  } @antecedents;
      if (@candidates) { print PML_T::GetSentenceString($root),"\n\n" }
    }
  }
}
</pre>
        <p>

Note that information from m-layer (detecting posessive pronoun) and
t-layer (detecting textual coreference) is utilized in this
example, whereas a-layer units serve here only for connecting t-layer and
m-layer units. Sample from the output:
</p>
        <pre class="programlisting">
Izrael žádá od palestinské policie, aby zasáhla proti palestinským
teroristům, a soudí, že autonomní Jericho se proměnilo v jejich útočiště.

V případě rodinného domu lze získat úvěr v rozmezí 100 tisíc až pět
miliónů korun také na jeho opravy a rekonstrukci.
</pre>
        <p>



</p>
      </div>
      <div class="section" title="7. Hooks">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="id518830" name="id518830"></a>7. Hooks</h2>
            </div>
          </div>
        </div>
        <p>There is a special set of subroutines, called hooks, that have
pre-defined names and are executed on certain occasions (see Section
<a class="ulink" href="ar01s15.html#hooks" target="_top">15.9. Hooks: automatically executed macros</a> in the <a class="ulink" href="ar01-toc.html" target="_top">TrEd User's Manual</a> for detailed
information).
For instance, <code class="literal">file_opened_hook()</code> hook is executed
for each file before starting the iterations over its content.
If the user (re)defines some of these hooks, his/her new code
is invoked on the given occasion.

</p>
        <p>
Example: the following macro file prints five most frequent functors
for each of the processed files:
</p>
        <pre class="programlisting">#!btred -TNe count()

my %cnt;

sub file_opened_hook { %cnt=() }

sub file_close_hook {
  my @sorted = sort{$cnt{$b}&lt;=&gt;$cnt{$a}} keys %cnt;
  my $filename=FileName();
  $filename=~s/.*\///;
  print "Five most frequent functors in ",$filename,
    ": ",join(" ",@sorted[0..4]),"\n";
}

sub count{ $cnt{$this-&gt;{functor}}++ unless $this eq $root}

</pre>
        <p>

Sample from the output:
</p>
        <pre class="programlisting">
Five most frequent functors in sample0.t.gz: RSTR PAT ACT PRED APP
Five most frequent functors in sample1.t.gz: RSTR ACT PAT PRED APP
Five most frequent functors in sample2.t.gz: RSTR ACT PAT PRED APP
Five most frequent functors in sample3.t.gz: RSTR ACT PAT PRED CONJ
Five most frequent functors in sample4.t.gz: RSTR ACT PAT PRED LOC
</pre>
        <p>


</p>
        <p>
Note that if you need to perform a certain action only once (for instance, loading
an external file with a list of searched words), you do not have to use
hooks, as it suffices to put this initiation code simply outside the 
subroutines.
</p>
      </div>
      <div class="section" title="8.  Make it faster: change the data format">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="id518889" name="id518889"></a>8.  Make it faster: change the data format</h2>
            </div>
          </div>
        </div>
        <p>
Executing a btred macro on a large amount of data may take a very long
time (even tens of minutes for the whole PDT 2.0). There is a simple
solution how this time can be significantly reduced:  change the
format of the data files from PML to 
Perl Storable Format (<code class="literal">pls.gz</code>).
You can convert the data files in the following way (see the
section about format conversions in the PDT Guide):

</p>
        <pre class="programlisting">$ <span class="command"><strong>btred</strong></span> -Y -m pml2pls.btred -g '*.t' '*.a'
</pre>
        <p>

or (if you already use ntred described in the next section):

</p>
        <pre class="programlisting">
$ <span class="command"><strong>ntred</strong></span> -i -Y -g '*.t' '*.a'
$ <span class="command"><strong>ntred</strong></span> -m pml2pls.btred
$ <span class="command"><strong>ntred</strong></span> --save-files
</pre>
        <p>

</p>
        <p>
And how can the sole change of data format cause a significant acceleration?
When working with PML, which is the XML-based primary format of PDT 2.0,  
btred always has to build its internal data representation from the
original XML. Because Perl hashes are massively used in the internal
representation, the transformation is time-consuming . This transformation
is completely avoided when working with <code class="filename">pls.gz</code> because
 btred stores (and reads) directly its internal data representation
into (from) the data file.
</p>
        <p>
The users of the CD PDT 2.0 are already provided with the full data
from <code class="literal">data/full/amw</code> and
<code class="literal">data/full/tamw</code>
converted into the <code class="literal">pls.gz</code> format. The converted
files are located in the directories
<code class="literal">data/binary/amw</code>
and <code class="literal">data/binary/tamw</code> on the CD. Both of these directories
are further structured in the same way as those
in <code class="literal">data/full</code>, but note that for each file the three annotations
originally distributed in separate files representing the w-layer,
m-layer, and a-layer of annotation are now knit into a single <code class="literal">*.a.pls.gz</code> file. 
</p>
      </div>
      <div class="section" title="9.  Make it much faster: ntred">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="id518999" name="id518999"></a>9.  Make it much faster: ntred</h2>
            </div>
          </div>
        </div>
        <p>
Even if you use <code class="filename">pls.gz</code> data format as suggested above,
 most of the time needed for running your macro is not spent on
performing your code, but by opening and parsing the data files.
 In such a situation, you can use ntred ("networked btred", see
<a class="ulink" href="ntred.html" target="_top">ntred manual page</a> for details) which offers you
a big speed-up, because it (1) processes the data in parallel and
 thus can utilize computing power of
more machines, (2) reads the files only once and keeps them in
memory. As a result,  it may shorten the time
needed for processing the whole PDT 2.0 to just a few seconds.
Even if you have only a single machine, you can reach a speed-up in
 the order of magnitude due to (2). The client-server architecture
of the ntred system is sketched in <a class="xref" href="#i-ntred" title="Figure 3. Parallel processing of the PDT 2.0 data in the ntred system.">Figure 3, “Parallel processing of the PDT 2.0 data in the ntred system.”</a>.
</p>
        <div class="figure">
          <a id="i-ntred" name="i-ntred"></a>
          <p class="title">
            <b>Figure 3. Parallel processing of the PDT 2.0 data in the ntred system.</b>
          </p>
          <div class="figure-contents">
            <div class="mediaobject">
              <img src="pics/bn-ntred.png" alt="Parallel processing of the PDT 2.0 data in the ntred system." />
            </div>
          </div>
        </div>
        <br class="figure-break" />
        <p>
The hostnames of the machines (and port numbers) which you want to employ should be listed in
<code class="filename">.ntred_serverlist</code> file in you home directory.
You may choose any port number above 1024, but you should try to avoid
collisions with other services running on the remote machines
(including ntreds of other users:  all users potentially working on the same machines should have
mutually disjoint sets of hostname-port pairs in their <code class="filename">.ntred_serverlist</code>).
You may specify one hostname several times (using different ports!), which is is particularly useful to
utilize the whole power of multi-processor systems.

Example:

</p>
        <pre class="programlisting">
# two remote single-processor machines:
computer1:2500
computer2:2500

# one remote dual-processor machine:
computer3:2500
computer3:2501
</pre>
        <p>

Empty lines in <code class="filename">.ntred_serverlist</code> are ignored, and lines starting with a hash sign # are treated as comments.
</p>
        <p>
The machines must have shared filesystem (as a minimum, they should
share your home directory and a directory containing your data).
You need to have password-free access to them, e.g. using Kerberos,
<code class="filename">.rhosts</code> files or <code class="literal">ssh2</code>
authorization keys together with a <code class="literal">ssh-agent2</code>.
</p>
        <p>
If the above requirements are fulfilled, you can initiate the ntred
system with files you want to process, e.g.:


</p>
        <pre class="programlisting">$ <span class="command"><strong>ntred</strong></span> -i -l half-train-a.fl
</pre>
        <p>

</p>
        <p>
You can see the ntred hub (usually running on your local computer) distributing your data among
the ntred servers (in fact btred instances running on the remote computers). As soon as all data files are distributed and the
system is ready, the following message is printed:

</p>
        <pre class="programlisting">NTRED-HUB: Waiting for a new client request.
</pre>
        <p>

Now you can start (preferably in a new terminal) running your macro in parallel using
the ntred client. The way it is
executed from the command line is very similar to that of btred (of
course, with the difference that you do not have to specify the files
to be processed, as they have been already loaded on the servers). Example:

</p>
        <pre class="programlisting">$ <span class="command"><strong>ntred</strong></span> -I helloworld.btred
</pre>
        <p>

The hub merges STDOUT (and also STDERR) outputs of the individual
ntred servers and prints the result on the STDOUT (resp. STDERR);
note that the STDOUT outputs are only joined, not mixed.
</p>
        <p>
Usually  you can  use your btred macros also for ntred
 without changing the code. However, remeber that each server processes its
own data without communicating with the others: if your macro for instance
prints some overall statistics, you get as many results as there are
 servers, and have to post-process them in order to obtain the global result.
</p>
        <p>
When your work with ntred servers is finished, you can close the
session by running <code class="literal"><span class="command"><strong>ntred</strong></span> --quit</code>.
If the servers hang (e.g. because of an accidental infinite loop in
your macro), you usually don't have to restart the session: instead, you
can try to "revive" the session by calling
<code class="literal"><span class="command"><strong>ntred</strong></span> --break</code>.  When debugging
your code, it may sometimes be useful to peek into ntred server log
files, located in
<code class="filename">/tmp/ntred-server-<em class="replaceable"><code>host</code></em>-<em class="replaceable"><code>port</code></em>.log</code>.
As a last resort, e.g when the ntred hub crashes, you may remove the
surviving relicts of the last session with <code class="literal"><span class="command"><strong>ntred</strong></span>
--kill</code>.
</p>
      </div>
      <div class="section" title="10. Searching">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="id478523" name="id478523"></a>10. Searching</h2>
            </div>
          </div>
        </div>
        <p>
Supposing ntred is running in your system, you can comfortably search
through the treebank by printing the treebank positions for which your
query conditions hold, e.g.:
</p>
        <pre class="programlisting">$ <span class="command"><strong>ntred</strong></span> -TNe 'NPosition($this) if $this-&gt;{functor}=~/^T(SIN|TIL)/' \
   &gt; positions.lst
</pre>
        <p>

and browse the detected positions in tred (as depicted in <a class="xref" href="#i-search" title="Figure 4. Browsing the query result in tred.">Figure 4, “Browsing the query result in tred.”</a>):
</p>
        <pre class="programlisting">$ <span class="command"><strong>tred</strong></span> -l positions.lst
</pre>
        <p>
</p>
        <div class="figure">
          <a id="i-search" name="i-search"></a>
          <p class="title">
            <b>Figure 4. Browsing the query result in tred.</b>
          </p>
          <div class="figure-contents">
            <div class="mediaobject">
              <img src="pics/bn-search.png" alt="Browsing the query result in tred." />
            </div>
          </div>
        </div>
        <br class="figure-break" />
        <p>
When browsing the list of positions in tred, the nodes corresponding to
the detected positions are focused (i.e., visually
distinguished from the other nodes in the tree). The list of positions can be  passed through
using  the left pair of arrow buttons    
or keyboard shortcuts (<code class="literal">Shift+F11</code>, <code class="literal">Shift+F12</code>, <code class="literal">Alt+Shift+g</code>).
</p>
        <p>The file <code class="filename">positions.lst</code> used in the above example
now contains the list of ntred node addresses (saying which node, in which,
tree in which file matches the query) in a url-like format, e.g.:

</p>
        <pre class="programlisting">
ntred:///net/projects/pdt/work/TR/pml2pls/ln94207_135.t.pls.gz@6##1.8
ntred:///net/projects/pdt/work/TR/pml2pls/ln94206_141.t.pls.gz@7##1.17
ntred:///net/projects/pdt/work/TR/pml2pls/cmpr9413_041.t.pls.gz@2##1.16
</pre>
        <p>
</p>
        <p>
Again, more complicated queries can be stored in a macro file.
The following macro file (<code class="filename">coord_rc.btred</code>) 
searches relative pronouns which are "shared" by at least three
coordinated relative clauses in tectogrammatical trees:

</p>
        <pre class="programlisting">#!btred -TN -e coord_rel_clauses()

use strict;
use vars qw($this $root);

sub coord_rel_clauses {
  if ($this-&gt;attr('gram/sempos') eq 'n.pron.indef' and 
      $this-&gt;attr('gram/indeftype') eq 'relat') {
    my @eparents = PML_T::GetEParents($this);
    my @clauseheads;
    while (@eparents) { # iterative climbing "up" to the clause heads
      @eparents = map {PML_T::GetEParents($_)}
    grep {$_ ne $root and not ($_-&gt;attr('gram/tense')=~/(ant|sim|post)/ and 
		  do{push @clauseheads,$_})} @eparents
    }
    NPosition() if @clauseheads&gt;2
  }
}
</pre>
        <p>


Now you can print the list of positions into a file, 
or you can feed tred directly with the output of your query:

</p>
        <pre class="programlisting">$ <span class="command"><strong>ntred</strong></span> -I coord_rc.btred | tred -l -
</pre>
        <p>

In this way, tred receives from ntred only the trees containing
the detected positions, but not e.g. the trees of the neighbouring
sentences. If you need to have an access to the sentential context
too, use <code class="literal">FPosition()</code> instead of
<code class="literal">NPosition()</code> to print a file list instead
of a list of ntred URLs. When opening the file list in tred,
always the whole file is loaded and not just one tree (but still,
the detected node is focused). Sample of
<code class="literal">FPosition()</code> addresses:

</p>
        <pre class="programlisting">/net/projects/pdt/work/TR/pml2pls/ln94207_135.t.pls.gz##6.8
/net/projects/pdt/work/TR/pml2pls/ln94206_141.t.pls.gz##7.17
/net/projects/pdt/work/TR/pml2pls/cmpr9413_041.t.pls.gz##2.16
</pre>
        <p>

</p>
      </div>
    </div>
  </body>
</html>
