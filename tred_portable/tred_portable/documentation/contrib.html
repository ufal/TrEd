<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head><title>contrib documentation</title>
	<meta name="description" content="Pod documentation for "></meta>
	<meta name="inputfile" content="/home/pierre/ufal_work/install_script/cistinka/dist/tred.new/documentation/pod/contrib.pod"></meta>
	<meta name="outputfile" content="&lt;standard output&gt;"></meta>
	<meta name="created" content="Mon Mar 28 17:45:21 2011"></meta>
	<meta name="generator" content="Pod::Xhtml 1.61"></meta>
<link rel="stylesheet" href="blue.css"></link></head>
<body><h1>contrib documentation</h1>
<div class="pod">
<!-- INDEX START -->
<h3 id="TOP">Table of contents</h3>

<ul><li><a href="#node_groups_mak">node_groups.mak</a>
<ul><li><a href="#USAGE">USAGE</a></li>
</ul>
</li>
<li><a href="#contrib_mac">contrib.mac</a>
<ul><li><a href="#DESCRIPTION">DESCRIPTION</a></li>
</ul>
</li>
<li><a href="#Context_Guessing">Context Guessing</a>
<ul><li><a href="#TredMacro_AUTO_CONTEXT_GUESSING">@TredMacro::AUTO_CONTEXT_GUESSING</a></li>
</ul>
</li>
<li><a href="#arrows_inc">arrows.inc</a>
<ul><li><a href="#USAGE-2">USAGE</a></li>
<li><a href="#DESCRIPTION-2">DESCRIPTION</a>
<ul><li><a href="#Arrow_definitions_and_styles">Arrow definitions and styles</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#non_projectivity_mak">non_projectivity.mak</a>
<ul><li><a href="#USAGE-3">USAGE</a></li>
<li><a href="#MACROS">MACROS</a></li>
<li><a href="#AUTHOR">AUTHOR</a></li>
</ul>
</li>
<li><a href="#move_nodes_freely_inc">move_nodes_freely.inc</a>
<ul><li><a href="#USAGE-4">USAGE</a></li>
<li><a href="#CUSTOMIZING">CUSTOMIZING</a></li>
<li><a href="#WRAPPING">WRAPPING</a></li>
<li><a href="#A_FINAL_NOTE">A FINAL NOTE</a></li>
</ul>
</li>
<li><a href="#fold_subtree_inc">fold_subtree.inc</a>
<ul><li><a href="#USAGE-5">USAGE</a></li>
</ul>
</li>
<li><a href="#unbind_edit_inc">unbind_edit.inc</a>
<ul><li><a href="#USAGE-6">USAGE</a></li>
<li><a href="#DESCRIPTION-3">DESCRIPTION</a></li>
</ul>
</li>
<li><a href="#PML">PML</a>
<ul><li><a href="#USAGE-7">USAGE</a></li>
<li><a href="#MACROS-2">MACROS</a>
</li>
</ul>
</li>
</ul><hr></hr>
<!-- INDEX END -->

<h1 id="node_groups_mak">node_groups.mak</h1><p><a href="#TOP" class="toplink">ToC</a></p>
<div id="node_groups_mak_CONTENT">
<p>TrEd::NodeGroups - macros for visualizing groups of nodes</p>

</div>
<h2 id="USAGE">USAGE</h2>
<div id="USAGE_CONTENT">
<pre>  package MyMacros;
  use strict;
  BEGIN{ import TredMacro };

  sub after_redraw_hook {
    my @nodes = GetDisplayedNodes();
    my $group1 = [ $nodes[0..$#$nodes/2] ];
    my $group2 = [ $nodes[$#$nodes/2..$#$nodes] ];
    my $group3 = [ $nodes[$#$nodes/3..2*$#$nodes/3] ];
    TrEd::NodeGroups::draw_groups(
      $grp,
      [$group1,$group2,$group3],
      { colors =&gt; [qw(red orange pink)],
        # stipples =&gt; [qw(dense1 dense2 ... dense6)],
        # stipples =&gt; [qw(dash1 dash2 ... dash6)], # default
        # group_line_width =&gt; 30, # default
      }
    );
  }

</pre>

</div>
<h1 id="contrib_mac">contrib.mac</h1><p><a href="#TOP" class="toplink">ToC</a></p>
<div id="contrib_mac_CONTENT">
<p>contrib/contrib.mac - the file responsible for loading other macro files</p>

</div>
<h2 id="DESCRIPTION">DESCRIPTION</h2>
<div id="DESCRIPTION_CONTENT">
<p>This file is included by default in tred.mac and serves as a wrapper
for other contributed macro package inclusions.</p>
<p>Besides it provides file_opened_hook and file_resumed_hook in the
package TredMacros. These hooks should not be overriden by other macro
packages. See below how to plug context-specific code in.</p>

</div>
<h1 id="Context_Guessing">Context Guessing</h1><p><a href="#TOP" class="toplink">ToC</a></p>
<div id="Context_Guessing_CONTENT">

</div>
<h2 id="TredMacro_AUTO_CONTEXT_GUESSING">@TredMacro::AUTO_CONTEXT_GUESSING</h2>
<div id="TredMacro_AUTO_CONTEXT_GUESSING_CONT">
<p>This global variable can be used by contributed TrEd macro packages to
plug-in their custom context guessing functions.  The purpose of such
a function is to detect whether the current file is suitable for the
macro package and if so, to indicate the correct binding context.</p>
<p>The function must return name of the context to switch to or undef if
the current file does not suit.</p>
<p>The synopsis for a package named 'Foo' is as follows:</p>
<pre>  #binding-context Foo
  package Foo;
  BEGIN { import TredMacro; }
  context_guessing {
    my ($hook)=@_;
    if (PML::SchemaName() eq 'foo-data') { # some test that the file suites the macro package
      if ($hook eq 'file_opened_hook') {
         # some open-specific code
      } elsif ($hook eq 'file_resumed_hook') {
         # some resume-specific code
      }
      return 'Foo'; # return name of the macro package (context) to use
    }
    return;
  };

</pre>

</div>
<h1 id="arrows_inc">arrows.inc</h1><p><a href="#TOP" class="toplink">ToC</a></p>
<div id="arrows_inc_CONTENT">
<p>This file provides generic support for drawing custom arrows that can be used in any macro context.</p>

</div>
<h2 id="USAGE-2">USAGE</h2>
<div id="USAGE_CONTENT-2">
<p>Add these lines to your macro context:</p>
<pre>  #include &lt;contrib/support/arrows.inc&gt;
  #include &lt;contrib/pml/PML.mak&gt;

  sub root_style_hook {
    DrawArrows_init();
    # ...
  }
  sub after_redraw_hook {
    DrawArrows_cleanup();
    # ...
  }
  sub node_style_hook {
     my ($node,$styles) = @_;
     DrawArrows($node,$styles,
       [ {
           # an arrow with a target
           -target =&gt; PML::GetNodeByID($node-&gt;{ref}),
           # other options: -tag -arrow -arrowshape -width -smooth -fill -dash
         },
         {
           # an arrow without a target
           -deltax =&gt; 10,
           -deltay =&gt; '(yn-yp)/2',
           # ...
         },
         {
           # an arrow with modified origin
           -originx =&gt; 'xn+10',
           -originy =&gt; 'yn+10',
           # ...
         },
      ],
      {
        # options common to all edges
      });
    #...
  }

</pre>

</div>
<h2 id="DESCRIPTION-2">DESCRIPTION</h2>
<div id="DESCRIPTION_CONTENT-2">
<p>This file provides a function DrawArrows which can be called from the node_style_hook to extra
arrows from the current node to some other nodes (or relative coordinates).
The USAGE section above shows a full example.</p>
<p>In the macros for your annotation context, you have to:</p>
<dl>
	<dt>1.</dt>
	<dd>
		<p>include &lt;contrib/support/arrows.inc&gt;</p>
	</dd>
	<dt>2.</dt>
	<dd>
		<p>define the root_style_hook which calls DrawArrow_init() to initialize caches.</p>
	</dd>
	<dt>3.</dt>
	<dd>
		<p>define an after_redraw_hook which calls DrawArrow_cleanup() to clean-up caches.</p>
	</dd>
	<dt>4.</dt>
	<dd>
		<p>define a node_style_hook which calls DrawArrows with the following arguments</p>
<pre>  DrawArrows($node,$styles,\@arrow_definitions,\%common_arrow_options)

</pre>
		<p>The first two arguments ($node and $styles) are the first two arguments passed to the node_style_hook by TrEd.
The third argument,
\@arrow_definitions, is an ARRAY reference containing definitions of
the arrows to draw. Each arrow definition is a HASH reference defining the target node or target coordinates for the other end
of the arrow and style options. Style options common to all arrows can be also passed in the optional HASH reference passed as the last argument 
\%common_arrow_options.</p>
	</dd>
</dl>

</div>
<h3 id="Arrow_definitions_and_styles">Arrow definitions and styles</h3>
<div id="Arrow_definitions_and_styles_CONTENT">
<p>Eeach arrow definition (passed in the \@rrow_definitions list to the
DrawArrows) is a HASH reference consisting of some arrow options.
With the exception of -target, -originx, -originy, -deltax, -deltay,
these options can also be passed as \%common_arrow_options to
DrawArrows.</p>
<dl>
	<dt>-target</dt>
	<dd>
		<p>the target node.</p>
		<p>If no target is specified, the target coordinates default to the
coordinates of the current node and the flags -deltax and -deltay must
be used to specify the target coordinates.</p>
	</dd>
	<dt>-originx</dt>
	<dd>
		<p>the x-coordinate of the origin (defaults to 'xn' - the x-coordinate of the current node)</p>
	</dd>
	<dt>-originy </dt>
	<dd>
		<p>the y-coordinate of the origin (defaults to 'yn' - the y-coordinate of the current node)</p>
	</dd>
	<dt>-deltax</dt>
	<dd>
		<p>value to add to the x-coordinate of the target</p>
	</dd>
	<dt>-deltay</dt>
	<dd>
		<p>value to add to the y-coordinate of the target</p>
	</dd>
	<dt>-smooth</dt>
	<dd>
		<p>1 to make the arrow a smoothed curve (see also -raise and -frac)</p>
	</dd>
	<dt>-frac</dt>
	<dd>
		<p>Defaults to 0.12. When a curved arrow is drawn (i.e. -smooth =&gt; 1 was
given), this value defines the 'lift' of the arrow as a fraction of
the length of the straight line connecting the start and end of the
arrow. 0 means no lift (straight line). The signum of the value
decides the orientation of the lift.</p>
	</dd>
	<dt>-raise</dt>
	<dd>
		<p>Defaults to 25. An absolute value added to the 'lift' of an arrow.</p>
	</dd>
	<dt>-arrow</dt>
	<dd>
		<p>one of 'first', 'last', 'both', 'none' (where to put the the arrow head)</p>
	</dd>
	<dt>-arrowshape</dt>
	<dd>
		<p>a comma-separated list of three integers defining the shape of the arrow head (see Tk::Canvas manual)</p>
	</dd>
	<dt>-dash</dt>
	<dd>
		<p>a comma-separated list of integers (even number) specifying the lengths of dashes and spaces between them</p>
	</dd>
	<dt>-width</dt>
	<dd>
		<p>width of the line</p>
	</dd>
	<dt>-fill</dt>
	<dd>
		<p>color of the line (either the color name or a '#rrggbb' hex code)</p>
	</dd>
	<dt>-hint</dt>
	<dd>
		<p>a tooltip that is displayed when the user hovers mouse over the arrow</p>
	</dd>
	<dt>-tag</dt>
	<dd>
		<p>a comma-separated list of tags associated with the arrow on the
canvas; tags can be used for varius purposes, e.g. to raise or lower
objects on the Tk::Canvas (see the stackOrder instruction in
<a href="http://ufal.mff.cuni.cz/~pajas/tred/ar01s10.html">http://ufal.mff.cuni.cz/~pajas/tred/ar01s10.html</a>).
they are also used as classes when exporting to SVG.</p>
	</dd>
	<dt>-decoration</dt>
	<dd>
		<p>decoration of the arrow (see description of the Line-decoration style
instruction in <a href="http://ufal.mff.cuni.cz/~pajas/tred/ar01s10.html">http://ufal.mff.cuni.cz/~pajas/tred/ar01s10.html</a>).</p>
	</dd>
</dl>

</div>
<h1 id="non_projectivity_mak">non_projectivity.mak</h1><p><a href="#TOP" class="toplink">ToC</a></p>
<div id="non_projectivity_mak_CONTENT">
<p>An efficient algorighm for finding non-projectivity edges in ordered
trees.</p>

</div>
<h2 id="USAGE-3">USAGE</h2>
<div id="USAGE_CONTENT-3">
<pre>  #include &lt;contrib/support/non_projectivity.mak&gt;

  non_proj_edges($root);

</pre>

</div>
<h2 id="MACROS">MACROS</h2>
<div id="MACROS_CONTENT">
<p>The following macros (functions) are provided by this package:</p>
<dl>
	<dt>non_proj_edges($node,$only_visible?,$ord?,$filterNode?,$returnParents?,$subord?,$filterGap?)</dt>
	<dd>
		<p>Returns hash-ref containing all non-projective edges in the subtree
rooted in $node. Values of the hash are references to arrays
containing the non-projective edges (the arrays contain the lower and
upper nodes representing the edge, and then the nodes causing the
non-projectivity of the edge), keys are concatenations of stringified
references to lower and upper nodes of non-projective
edges. Description of the arguments is as follows: $node specifies the
root of a subtree to be checked for non-projective edges;
$only_visible set to true confines the subtree to visible nodes; $ord
specifies the ordering attribute to be used; a subroutine accepting
one argument passed as sub-ref in $filterNode can be used to filter
the edges taken into account (by specifying the lower nodes of the
edges); sub-ref $returnParents accepting one argument returns an array
of upper nodes of the edges to be taken into account; sub-ref $subord
accepting two arguments returns 1 iff the first one is subordinated to
the second one; sub-ref $filterGap accepting one argument can be used
to filter nodes causing non-projectivity.  Defaults are: all nodes,
the default ordering attribute, all nodes, parent (in the technical
representation), subordination in the technical sense, all nodes.</p>
	</dd>
</dl>

</div>
<h2 id="AUTHOR">AUTHOR</h2>
<div id="AUTHOR_CONTENT">
<p>Jiri Havelka</p>

</div>
<h1 id="move_nodes_freely_inc">move_nodes_freely.inc</h1><p><a href="#TOP" class="toplink">ToC</a></p>
<div id="move_nodes_freely_inc_CONTENT">
<p>This file provides generic support for manual repositioning of nodes
on the canvas.</p>

</div>
<h2 id="USAGE-4">USAGE</h2>
<div id="USAGE_CONTENT-4">
<p>Add this line to your macro context:</p>
<pre>  #include &lt;contrib/support/move_nodes_freely.inc&gt;

</pre>
<p>And these to your stylesheet:</p>
<p>style:&lt;?
  my ($x,$y)=($this-&gt;{'.xadj'}||0,$this-&gt;{'.yadj'}||0);
  qq(#{Node-xadj:$x}#{Node-yadj:$y})
 ?&gt;</p>
<p>Then you can drag nodes over the canvas. When releasing the node with
Shift pressed, the node (and its labels and edge-ends) move to the
given position; if Control is pressed, then the complete subtree is
moved in this way.</p>

</div>
<h2 id="CUSTOMIZING">CUSTOMIZING</h2>
<div id="CUSTOMIZING_CONTENT">
<p>You may modify these default bindings by setting
e.g.:</p>
<pre>  $move_nodes_freely{subtree}='Alt'; # default is Control
  $move_nodes_freely{node}='Meta'; # default is Shift

</pre>

</div>
<h2 id="WRAPPING">WRAPPING</h2>
<div id="WRAPPING_CONTENT">
<p>If you want to wrap this code into a more complex hook, you can do it
by using a class:</p>
<pre>  package MyContext::MoveSupport;
  import TredMacro;
  #include &lt;contrib/support/move_nodes_freely.inc&gt;

  package MyContext;
  import TredMacro;
  # ...
  sub node_release_hook {
    my (@args)=@_;
    if (MyContext::MoveSupport::node_release_hook(@args) eq 'subtree') {
       # the hook moved a subtree
    } else (MyContext::MoveSupport::node_release_hook(@args) eq 'node') {
       # the hook moved a node
    } else {
       # the hook moved nothing
    }
  }

</pre>

</div>
<h2 id="A_FINAL_NOTE">A FINAL NOTE</h2>
<div id="A_FINAL_NOTE_CONTENT">
<p>This implementation adds the attributes .xadj and .yadj to the
moved nodes. These may be preserved by some I/O backends,
e.g. Storable.</p>

</div>
<h1 id="fold_subtree_inc">fold_subtree.inc</h1><p><a href="#TOP" class="toplink">ToC</a></p>
<div id="fold_subtree_inc_CONTENT">
<p>This file can add support for folding (collapsing) subtrees to any macro context.</p>

</div>
<h2 id="USAGE-5">USAGE</h2>
<div id="USAGE_CONTENT-5">
<p>1. Add these lines to your macro context:</p>
<pre>  #include &lt;contrib/support/fold_subtree.inc&gt;
  #bind fold_subtree_toggle to SOME_KEY  menu Fold/unfold current subtree (toggle)

</pre>
<p>and possibly</p>
<pre>  #bind fold_subtree_unfold_all to OTHER_KEY menu Unfold all in the current subtree

</pre>
<p>replacing <i>SOME_KEY</i> and <i>OTHER_KEY</i> with suitable key bindings.</p>
<p>2. Add the following lines to your stylesheet:</p>
<pre>  style:&lt;? "#{Node-hide:1}" if FileUserData('hide')-&gt;{$this}; ?&gt;
  style:&lt;? "#{Oval-fill:blue}#{Node-shape:rectangle}"
              if FileUserData('fold')-&gt;{$this} ?&gt;

</pre>
<p>The fist line does the folding, the second defines the visual style
for the root of a folded subtree (blue rectangle in this case). Adjust it
as you need.</p>

</div>
<h1 id="unbind_edit_inc">unbind_edit.inc</h1><p><a href="#TOP" class="toplink">ToC</a></p>
<div id="unbind_edit_inc_CONTENT">
<p>Disable default TredMacro key-bindings that modify trees.</p>

</div>
<h2 id="USAGE-6">USAGE</h2>
<div id="USAGE_CONTENT-6">
<pre>  #include &lt;common/support/unbind_edit.inc&gt;

</pre>

</div>
<h2 id="DESCRIPTION-3">DESCRIPTION</h2>
<div id="DESCRIPTION_CONTENT-3">
<p>Include this macro in your binding context if you want to disable all
default TredMacro key-bindings that modify trees, such as copy/paste,
etc.</p>

</div>
<h1 id="PML">PML</h1><p><a href="#TOP" class="toplink">ToC</a></p>
<div id="PML_CONTENT">
<p>PML.mak - Miscelaneous macros of general use in Prague Dependency
Treebank (PDT) 2.0</p>

</div>
<h2 id="USAGE-7">USAGE</h2>
<div id="USAGE_CONTENT-7">
<pre>  #include &lt;contrib/pml/PML.mak&gt;

</pre>

</div>
<h2 id="MACROS-2">MACROS</h2>
<div id="MACROS_CONTENT-2">
<p>The following macros (functions) are provided by this package:</p>
<dl>
	<dt>PML::SchemaName()</dt>
	<dd>
		<p>Return name of the root element of a PML instance as specified in the
PML schema associated with the current file. PDT uses root element
named <code>adata</code> for analytical layer annotation and <code>tdata</code> for
tectogrammatical layer annotation.</p>
	</dd>
	<dt>PML::SchemaDescription()</dt>
	<dd>
		<p>Return the content of the element <code>description</code> of the PML schema
associated with the current file.</p>
	</dd>
	<dt>PML::Schema($object?)</dt>
	<dd>
		<p>For a Treex::PML::Node object returns PML schema associated with that object.
If the object is a Treex::PML::Document, return PML schema associated with the given
file. If no object is given, the current Treex::PML::Document is used.</p>
		<p>The PML schema is returned in form of a Treex::PML::Schema object.</p>
	</dd>
	<dt id="gen-1">PML::GetNodeByID($id_or_ref,$fsfile?)</dt>
	<dd>
		<p>Looks up a node from the current file (or given fsfile) by its ID (or
PMLREF - i.e. the ID preceded by a file prefix of the form <code>xy#</code>).</p>
	</dd>
	<dt>PML::DeleteFromNodeHash($id,$fsfile?)</dt>
	<dd>
		<p>Deletes a given ID from a node HASH of the current or specified Treex::PML::Document
The node previously hashed under the given ID is returned.</p>
	</dd>
	<dt>PML::AddToNodeHash($id,$node,$fsfile?)</dt>
	<dd>
		<p>Adds a node to the node hash (of the given or current Treex::PML::Document) using
given ID as the hash key.</p>
	</dd>
	<dt>PML::SearchForNodeById($id)</dt>
	<dd>
		<p>Searches for node with given id. Returns the node and the number of
the tree.</p>
	</dd>
	<dt>PML::GetNodeHash($fsfile?)</dt>
	<dd>
		<p>Return a reference to a hash indexing nodes in a given file (or the
current file if no argument is given). If such a hash was not yet
created, it is built upon the first call to this function (or other
functions calling it, such as <a href="#gen-1"><code>GetNodeByID</code></a>. Use <code>clearNodeHash</code> to
clear the hash.</p>
	</dd>
	<dt>PML::ClearNodesHash($fsfile?)</dt>
	<dd>
		<p>Clear the internal hash indexing nodes of a given file (or the current
file if called without an argument).</p>
	</dd>
	<dt>PML::GotoTree()</dt>
	<dd>
		<p>Ask user for sentence or node identificator (tree number or id) and go to the
sentence.</p>
	</dd>
	<dt>PML::NonProjEdges($node,$ord?,$filterNode?,$returnParents?,$subord?,$filterGap?)</dt>
	<dd>
		<p>DEPRECATED, use non_proj_edges from &lt;contrib/support/non_projectivity.mak&gt; instead.</p>
	</dd>
</dl>

</div>
</div></body>
</html>
