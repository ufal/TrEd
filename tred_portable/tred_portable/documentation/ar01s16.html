<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>16. I/O backends</title><link rel="stylesheet" href="blue.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="tred.html" title="TrEd User's Manual"><link rel="up" href="tred.html" title="TrEd User's Manual"><link rel="prev" href="ar01s15.html" title="15. User Macros"><link rel="next" href="ar01s17.html" title="17. Extension Packages"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">16. I/O backends</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ar01s15.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ar01s17.html">Next</a></td></tr></table><hr></div><div class="section" title="16. I/O backends"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="backends"></a>16. I/O backends</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="ar01s16.html#iobackend">16.1. Treex::PML::IO</a></span></dt><dt><span class="section"><a href="ar01s16.html#fsbackend">16.2. FS backend</a></span></dt><dt><span class="section"><a href="ar01s16.html#storablebackend">16.3. Storable backend</a></span></dt><dt><span class="section"><a href="ar01s16.html#csts_sgml_sp_backend">16.4. CSTS_SGML_SP backend</a></span></dt><dt><span class="section"><a href="ar01s16.html#ntredbackend">16.5. NTRED backend</a></span></dt><dt><span class="section"><a href="ar01s16.html#pmlbackend">16.6. PML backend</a></span></dt><dt><span class="section"><a href="ar01s16.html#trxmlbackend">16.7. TrXML backend</a></span></dt><dt><span class="section"><a href="ar01s16.html#teixmlbackend">16.8. TEIXML backend</a></span></dt><dt><span class="section"><a href="ar01s16.html#id585637">16.9. Writing a new I/O backend</a></span></dt></dl></div><p>This section briefly introduces the existing I/O backends
      and then provides a quick introduction to writing a custom backend.
    </p><div class="section" title="16.1. Treex::PML::IO"><div class="titlepage"><div><div><h3 class="title"><a name="iobackend"></a>16.1. Treex::PML::IO</h3></div></div></div><p>
	Actually, this is not a I/O backend per se. It is a base class and a function
	library
	used by Treex::PML and may of the other I/O backends. It provides a simple
	abstraction layer over some common low-level tasks, such as pipe-line redirection,
	gzip-compression, URL resolving, as well as fetching and
	uploading files using remote protocols. Due to this backend,
	<span class="application">TrEd</span> transparently handles
	gzip-compression/de-compression of files with <code class="filename">.gz</code>
	extension as well as remote file transfer over
	<code class="literal">ftp://</code>,
	<code class="literal">http://</code>,
	<code class="literal">ssh://</code> and other protocols. Note however that availability
	of remote file transfer highly depends on a particular setup
	(currently only UNIX systems are fully supported) and may require
	some external tools, such as <a class="link" href="ar01s13.html#curl">curl</a>,
	<a class="link" href="ar01s13.html#kioclient">kioclient</a>,
	<a class="link" href="ar01s13.html#ssh">ssh</a>, 
	<a class="link" href="ar01s13.html#gzip">gzip</a>.
      </p></div><div class="section" title="16.2. FS backend"><div class="titlepage"><div><div><h3 class="title"><a name="fsbackend"></a>16.2. FS backend</h3></div></div></div><p>
	FS backend deals with a format called FS (feature structure). FS-format
	was the first format supported by tred, and for a long time also the only one.
	As a result, some methods of the Perl classes 
	used by <span class="application">TrEd</span> and defined in the the underlying Perl library
	<code class="literal"><a class="ulink" href="http://search.cpan.org/dist/Treex-PML/lib/Treex/PML/Document.pm" target="_top">Treex::PML</a></code>
	still bear the name of the format (even though they
	are now equally used to represent data obtained from any other I/O
	backend).
      </p><p>
	FS format provides a simple and effective way for storing trees.
	In this format, each node of the
	tree uses the same set of attributes declared in the FS-file header. 
	FS format supports string values,
	enumerated values and flat lists of these
	(i.e. strings consisting of a <code class="literal">|</code>-separated list of
	values of the first two types). There is no direct support
	for nested AVS structures, complex lists and alternatives.
      </p><p>
	Recent versions of
	<span class="application">TrEd</span> and <code class="literal">Treex::PML</code>
	provide a simple nested-AVS emulation
	(attiribute-value structure) for FS attribute values, meaning the
	following: an attribute whose name contains one
	or more slashes is represented as a (possibly nested) AVS structure where
	each slash represents one level of nesting. Attributes sharing a
	common name-part followed by a slash are thus represented as members of
	the same structure. For example, attirubtes <code class="literal">a</code>,
	<code class="literal">b/u/x</code>,
	<code class="literal">b/v/x</code> and
	<code class="literal">b/v/y</code> result in the following structure:
</p><div class="literallayout"><p><br>
{<br>
  a =&gt; <em class="replaceable"><code>value-of-a</code></em>,<br>
  b =&gt; { u =&gt; { x =&gt; <em class="replaceable"><code>value-of-a/u/x</code></em> },<br>
         v =&gt; { x =&gt; <em class="replaceable"><code>value-of-a/v/x</code></em>,<br>
                y =&gt; <em class="replaceable"><code>value-of-a/v/y</code></em> <br>
              }<br>
       }<br>
<br>
}<br>
</p></div><p>
	In case that attributes with names <code class="literal">a</code>
	<code class="literal">a/b</code> would both exists, the nested-AVS emulation is
	abandoned and all attributes are represented literally (i.e.
	with slashes in their names).
      </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Even with the recently added nested-AVS emulation, FS format is not 
	  in general fully capable of capturing data originating in other backends
	  such as PML.
	</p></div><p>
	FS format is fully described in
	<a class="ulink" href="http://ufal.mff.cuni.cz/pdt/Corpora/PDT_1.0/Doc/fs.html" target="_top">http://ufal.mff.cuni.cz/pdt/Corpora/PDT_1.0/Doc/fs.html</a>
      </p></div><div class="section" title="16.3. Storable backend"><div class="titlepage"><div><div><h3 class="title"><a name="storablebackend"></a>16.3. Storable backend</h3></div></div></div><p>This backend is based on an excelent Perl module
	<code class="literal">Storable</code>, which can store
	and retrieve almost arbitrary Perl structure in an instant. Because of its
	general	nature, this backend can save and keep intact files
	originating from any other backend. Due to its speed
	with which it saves and retrieves data, it is often
	useful to transfer all data temporarily into this format
	(e.g. using <span class="command"><strong>btred</strong></span>) and
	revert to the original format only after all work on the data is done.
      </p></div><div class="section" title="16.4. CSTS_SGML_SP backend"><div class="titlepage"><div><div><h3 class="title"><a name="csts_sgml_sp_backend"></a>16.4. CSTS_SGML_SP backend</h3></div></div></div><p>This backend provides
	support for the CSTS format. CSTS stands for <span class="quote">&#8220;<span class="quote">Czech
	sentence tree structure</span>&#8221;</span>. Since it is an application of SGML,
	the backend requires an external sgml parser (namely
	<span class="command"><strong><a class="link" href="ar01s13.html#sgmls">nsgmls</a></strong></span>) and a
	document type definition (DTD)
	(<code class="filename">csts.doctype</code>).  This backend represents
	CSTS data as trees with a fixed set of attributes, specific to
	the purpose for which CSTS was created, namely morphological and
	syntactical annotation of Czech texts.
	CSTS has been the primary format of the Prague Dependency
	Treebank 1.0.

      </p></div><div class="section" title="16.5. NTRED backend"><div class="titlepage"><div><div><h3 class="title"><a name="ntredbackend"></a>16.5. NTRED backend</h3></div></div></div><p>This backend used for
      exchanging of data between <span class="application">TrEd</span> and
	btred servers, or in other words to <span class="quote">&#8220;<span class="quote">peek</span>&#8221;</span>
      into the memory of running btred servers.
      This backend only accepts filenames (or we should rather
      say URLs) starting with the <code class="filename">ntred://</code>
      protocol specification and followed by a real file name.  When
      this backend opens a file, it uses <span class="command"><strong>ntred</strong></span>
      client to fetch the file from any currently running btred
      server. If some btred server has a in-memory copy of
      the specified file (possibly edited during previous
      <span class="command"><strong>ntred</strong></span> requests), it sends this copy to the
      client and via the <code class="literal">NTRED</code>  backend to
      <span class="application">TrEd</span>. Saving is performed in a
	reversed way, i.e. <span class="command"><strong>ntred</strong></span> client
	is used to communicate the (possibly edited) file back
      to the btred server replaces its previous in-memory copy of the
      file with the file obtained in this way.
      </p><p>
	Instead of requesting a whole file from the 
	servers, is also possible (and sometimes faster) to request
	only a single tree. This can be achieved by appending
	a suffix of the form
	<code class="literal">@<em class="replaceable"><code>N</code></em></code> to the
	<code class="literal">ntred://</code> URL, where
	<em class="replaceable"><code>N</code></em> is the number of the requested
	tree (counting from 1). In that case,
	<span class="application">TrEd</span> obtains a file containing only
	the requested tree. So, such URL as
	<code class="literal">ntred://<em class="replaceable"><code>filename</code></em>@3##1.4</code>,
	opens a file containing the 3rd tree in <em class="replaceable"><code>filename</code></em> (as
	represented in memory of a btred server) and opens that
	file on the 4th node of its first and only tree. URLs of this
	form are produced by the <code class="literal">TredMacro</code> 
	function <code class="literal">NPosition()</code> (see <a class="xref" href="ar01s15.html#defaultmacros" title="15.8. Public API: pre-defined macros">Section 15.8, &#8220;Public API: pre-defined macros&#8221;</a>).
      </p></div><div class="section" title="16.6. PML backend"><div class="titlepage"><div><div><h3 class="title"><a name="pmlbackend"></a>16.6. PML backend</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="ar01s16.html#id584734">16.6.1. Introduction</a></span></dt><dt><span class="section"><a href="ar01s16.html#pmlbackend_xslt">16.6.2. Support for non-PML XML-based formats</a></span></dt><dt><span class="section"><a href="ar01s16.html#pml_representation">16.6.3. Internal representation of PML data</a></span></dt></dl></div><div class="section" title="16.6.1. Introduction"><div class="titlepage"><div><div><h4 class="title"><a name="id584734"></a>16.6.1. Introduction</h4></div></div></div><p>
	This backend provies  support for a generic XML-based
	format called PML (the <a class="ulink" href="http://ufal.mff.cuni.cz/jazz/PML/index_en.html" target="_top">Prague Markup
	Language</a>), used for capturing rich linguistic annotation.
	PML is the base of the data format of the <a class="ulink" href="http://ufal.mff.cuni.cz/pdt2.0/" target="_top">Prague Dependency
	Treebank 2.0</a>.
      </p><p>
	Since all XML data can be easily transformed into PML and back
	(usually with a few lines of XSLT), this backend also provides
	a bridge between any other XML data format and
	<code class="literal">TrEd</code>, as described below in
	<a class="xref" href="ar01s16.html#pmlbackend_xslt" title="16.6.2. Support for non-PML XML-based formats">Section 16.6.2, &#8220;Support for non-PML XML-based formats&#8221;</a>
      </p><p>
	Each application of PML is described using a
	special XML file called <em class="firstterm">PML schema</em>. 
	This schema file defines which elements and attributes
	construe the nodes and structure of the tree, 
	declares value types of node attributes, etc.
      </p><p>
	Updated version of the full PML specification can be found on the
	<a class="ulink" href="http://ufal.mff.cuni.cz/jazz/PML/index_en.html" target="_top">PML project</a>
	page.
      </p><p>
	While PML can possibly capture all kinds of structured data, the
	<code class="literal">PML</code> backend of <span class="application">TrEd</span>
	is limited only to those applications of PML which satisfy the
	following criteria:
	</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
	      the data contain exactly one PML sequence or PML list
	      with the PML role <code class="literal">#TREES</code> consisting of
	      data with the role <code class="literal">#NODE</code>.
	      In case of a PML sequence, the
	      <code class="literal">#NODE</code>-elements must form a contiguous
	      block in the sequence, but may be preceded and/or
	      followed by some non-<code class="literal">#NODE</code> elements.
	    </p></li><li class="listitem"><p>Of all PML data types only PML structures and PML containers
	      may bear the role <code class="literal">#NODE</code>.
	    </p></li><li class="listitem"><p>
	      A structure with the role <code class="literal">#NODE</code> 
	      may have a member with the role <code class="literal">#CHILDNODES</code>,
	      containing a list or sequence of structures/containers
	      with the role <code class="literal">#NODE</code>.
	    </p></li><li class="listitem"><p>
	      A container with
	      the role <code class="literal">#NODE</code> may contain
	      a list or sequence with the role <code class="literal">#CHILDNODES</code>
	      consisting of structures/containers
	      with the role <code class="literal">#NODE</code>.
	    </p></li></ul></div><p>
      </p></div><div class="section" title="16.6.2. Support for non-PML XML-based formats"><div class="titlepage"><div><div><h4 class="title"><a name="pmlbackend_xslt"></a>16.6.2. Support for non-PML XML-based formats</h4></div></div></div><p>
	  PML backend has its own configuration file
	  <code class="filename">pmlbackend_conf.xml</code> which is looked for
	  in the directories listed in <a class="link" href="ar01s13.html#resourcepath">ResourcePath</a>.
	  The <code class="literal">transform_map</code> section of the configuration file is automatically merged
	  with all files named
	  <code class="filename">pmlbackend_conf.inc</code> found in
	  <a class="link" href="ar01s13.html#resourcepath">ResourcePath</a>
	  (e.g. in a <code class="filename">resource</code> subdirectory
	  of an <a class="link" href="ar01s17.html" title="17. Extension Packages">extension package</a>).
	  The
	  configuration file may specify transformation rules for
	  transparent conversion from legacy XML format to PML and
	  back. The configuration file is a PML file and may look
	  as on the following example:
	</p><pre class="programlisting">
&lt;?xml version="1.0"?&gt;
&lt;pmlbackend xmlns="http://ufal.mff.cuni.cz/pdt/pml/"&gt;
  &lt;head&gt;
    &lt;schema href="pmlbackend_conf_schema.xml"/&gt;
  &lt;/head&gt;
  &lt;transform_map&gt;

    &lt;!--
      Transformation for Alpino XML format.
     --&gt;
    &lt;transform id="alpino" test="alpino_ds[@version='1.1']"&gt;
      &lt;in type="xslt" href="alpino2pml.xsl"/&gt;
      &lt;out type="xslt" href="pml2alpino.xsl"/&gt;
    &lt;/transform&gt;

    &lt;!--
      Transformation for TEI P5 XML format.
     --&gt;
    &lt;transform id="tei" test="TEI.2"&gt;
      &lt;in type="xslt" href="tei2pml.xsl"&gt;
        &lt;param name="only_fLib"&gt;'foo bar'&lt;/param&gt;
      &lt;/in&gt;
      &lt;out type="xslt" href="pml2tei.xsl"/&gt;
    &lt;/transform&gt;

  &lt;/transform_map&gt;
&lt;/pmlbackend&gt;
</pre><p>
	  This example configuration file defines two XSLT-based
	  transformations (<code class="literal">type="xslt"</code>, i.e. XSLT
	  1.0, is currently the only type of transformation
	  implemented by PML backend), each of which consists of a XSLT
	  stylesheet declared in the <code class="sgmltag-element">&lt;in&gt;</code> tag,
	  used by PML backend to convert documents from the original
	  XML format to PML, and a XSLT stylesheet declared in the
	  <code class="sgmltag-element">&lt;out&gt;</code> tag, used by PML backend to
	  convert documents from PML back to the original XML format.
	  Each stylesheet can take zero or more parameters
	  specified as <code class="literal">&lt;param
	  name="<em class="replaceable"><code>parameter-name</code></em>"&gt;<em class="replaceable"><code>parameter-value</code></em>&lt;/param&gt;</code>,
	  where <em class="replaceable"><code>parameter-value</code></em> is an XPath
	  expression evaluated in the context of the transformed
	  document by the XSLT processor.
	  The transformations are further conditioned by
	  an XPath expression in the <code class="literal">test</code> attribute,
	  which selects to which documents is the transformation
	  applicable.
	</p><p>
	  When PML backend opens an XML document and detects that this
	  document does not belong to the PML namespace, it evaluates
	  the XPath expression <code class="literal">test</code> for every
	  transformation rule in the order in which the rules appear in the
	  configuration file, until one of the expressions returns a true value
	  (boolean true, non-zero number, non-empty node-set, or
	  non-empty string) or the last expression fails.  The input
	  stylesheet of the transformation whose test had first
	  succeeded is used to transform the document into PML.
	  The <code class="literal">id</code> of this transformation
	  is remembered and the 
	  output stylesheet of the same transformation
	  is used to convert back from PML when
	  the document is saved.
	</p><p>
	  We now summarize the steps necessary for adding 
	  support for a new XML-based format to TrEd (via XSLT
	  and PML backend):
	  </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Write a PML schema for the resulting PML version
		of the data so that all necessary information stored
		in the original format is captured.
	      </p></li><li class="listitem"><p>Write a XSLT transformation from
		the original format to a PML format described by the 
		previously written PML schema.
	      </p></li><li class="listitem"><p>Write a XSLT transformation from
		the PML format to the original format.
		This is step is not necessary if one
		only wishes to open the documents in TrEd for reading.
	      </p></li><li class="listitem"><p>
		Create a <code class="literal">pmlbackend_conf.xml</code> in one
		of the <a class="link" href="ar01s13.html#resourcepath"><code class="literal">ResourcePath</code></a>
		directories unless it already exists and
		add a transformation rule to it with 
		the input and output XSLT stylesheets and
		an XPath test approximating documents in the format.
		If writing an <a class="link" href="ar01s17.html#extension_format" title="17.1. Extension Package Format and Content">extension</a>,
		one can create a file 
		<code class="literal">pmlbackend_conf.inc</code>
		in the <code class="literal">resources</code>
		directory of the extension, instead.
	      </p><p>
		Instead of specifying the output XSLT stylesheet one may
		also define an identity output transformation
		which simply writes back the data in PML.
		In that case the <code class="literal">out</code> tag
		should look as follows:
	      </p><div class="literallayout"><p>&lt;out type="identity"/&gt;</p></div></li></ul></div><p>
	</p></div><div class="section" title="16.6.3. Internal representation of PML data"><div class="titlepage"><div><div><h4 class="title"><a name="pml_representation"></a>16.6.3. Internal representation of PML data</h4></div></div></div><p>
	This section describes how PML data types are represented in
	<span class="application">TrEd</span>.
      </p><p>
	PML schema is represented by a <a class="ulink" href="http://search.cpan.org/dist/Treex-PML/lib/Treex/PML/Schema.pm" target="_top"><code class="literal">Treex::PML::Schema</code></a>
	object. This object can be retrieved from the current
	<code class="literal">Treex::PML::Document</code> using the macro
	  <code class="literal">MetaData('schema')</code>.
      </p><p>
	PML structures are represented as
	<code class="literal"><a class="ulink" href="http://search.cpan.org/dist/Treex-PML/lib/Treex/PML/Struct.pm" target="_top">Treex::PML::Struct</a></code> objects,
	and so are PML containers, whose attributes
	and content value become members of the
	<code class="literal"><a class="ulink" href="http://search.cpan.org/dist/Treex-PML/lib/Treex/PML/Struct.pm" target="_top">Treex::PML::Struct</a></code> object, the content value
	being represented by a special member named
	<code class="literal">#content</code>.  In both cases, if the role is
	<code class="literal">#NODE</code>, then <code class="literal"><a class="ulink" href="http://search.cpan.org/dist/Treex-PML/lib/Treex/PML/Node.pm" target="_top">Treex::PML::Node</a></code>
	object is used instead of <code class="literal"><a class="ulink" href="http://search.cpan.org/dist/Treex-PML/lib/Treex/PML/Struct.pm" target="_top">Treex::PML::Struct</a></code>.
	PML lists are represented as <code class="literal"><a class="ulink" href="http://search.cpan.org/dist/Treex-PML/lib/Treex/PML/List.pm" target="_top">Treex::PML::List</a></code>
	objects and PML alternatives as <code class="literal"><a class="ulink" href="http://search.cpan.org/dist/Treex-PML/lib/Treex/PML/Alt.pm" target="_top">Treex::PML::Alt</a></code>
	objects. PML sequences as <code class="literal"><a class="ulink" href="http://search.cpan.org/dist/Treex-PML/lib/Treex/PML/Seq.pm" target="_top">Treex::PML::Seq</a></code>
	objects and its elements as
	<code class="literal"><a class="ulink" href="http://search.cpan.org/dist/Treex-PML/lib/Treex/PML/Seq/Element.pm" target="_top">Treex::PML::Seq::Element</a></code> objects.  The only
	exceptions are: a PML sequences with the role
	<code class="literal">#TREES</code>, which is represented by the list of
	the trees of the <code class="literal">Treex::PML::Document</code> object and a PML
	sequence with role <code class="literal">#CHILDNODES</code>, which is
	represented by the child-nodes of the node it belongs to.
	Elements of these sequences therefore represented by by
	<code class="literal"><a class="ulink" href="http://search.cpan.org/dist/Treex-PML/lib/Treex/PML/Node.pm" target="_top">Treex::PML::Node</a></code> (rather than
	<code class="literal"><a class="ulink" href="http://search.cpan.org/dist/Treex-PML/lib/Treex/PML/Seq/Element.pm" target="_top">Treex::PML::Seq::Element</a></code>) objects with a
	dedicated attribute <code class="literal">#name</code> carrying the
	element's name.
      </p><p>
	The non-tree data structures contained in the root element of
	the PML instance can be obtained either from
	<code class="literal">MetaData('pml_root')</code>.  If the root element
	contains a sequence with role <code class="literal">#TREES</code>,
	<code class="literal">MetaData('pml_root')</code> is empty and
	non-tree members of the sequence preceding trees are
        stored in a sequence
	<code class="literal">MetaData('pml_prolog')</code> while
	non-tree members that follow all trees are stored in a sequence
        <code class="literal">MetaData('pml_epilog')</code>.
      </p><p>PML structures/containers that have a member or attribute
	  with the role <code class="literal">#ID</code> are indexed
	  by their IDs in a HASH <code class="literal">AppData('id-hash')</code>.
	</p><p>
	If the PML schema declares a reference to an external resource
	and this declaration has the attribute
	<code class="literal">readas="dom"</code>, then the
	<code class="literal">PML</code> backend
	loads the corresponding PML instance
	as a DOM (Document Object Model) tree (using the Perl module
	<code class="literal">XML::LibXML</code>) and attaches this DOM tree
	to the application data section of the in-memory
	representation of the file.
      </p><p>
	If the PML schema declares a reference to an external resource
	and this declaration has the attribute
	<code class="literal">readas="pml"</code>, then the
	<code class="literal">PML</code> backend
	loads the corresponding PML instance
	as a <a class="ulink" href="http://search.cpan.org/dist/Treex-PML/lib/Treex/PML/Instance.pm" target="_top"><code class="literal">Treex::PML::Instance</code></a>
	object and attaches this object
	to the application data section of the in-memory
	representation of the file.
      </p><p>
	If the PML schema declares a reference to an external resource
	and this declaration bears the attribute
	<code class="literal">readas="trees"</code>, then the
	<code class="literal">PML</code> backend passes the file-name 
	of the corresponding resource to
	<span class="application">TrEd</span>
	and <span class="application">TrEd</span> loads it as an ordinary
	file. This file can be edited and treated as any other file in
	<span class="application">TrEd</span>. In <span class="command"><strong>btred</strong></span>,
	this file is opened as a so called
	<em class="firstterm">secondary</em> file, i.e. a file
	which is not implicitly processed by the macro specified by
	user, but as it is loaded in memory, the macro may explicitly
	choose to process it.
      </p><p>The following HASH references carry information about
	  external resources: <code class="literal">MetaData('refnames')</code>
	  maps reference names to reference IDs,
	  <code class="literal">MetaData('references')</code>
	  maps reference IDs to URLs, 
	  and, for DOM and Treex::PML::Instance resources,
	  <code class="literal">AppData('ref')</code> maps
	  reference IDs to objects representing the
	  resources in <code class="literal">TrEd</code>.
      </p><p>
	The
	<code class="literal">PML</code> backend supports so-called <span class="quote">&#8220;<span class="quote">knitting</span>&#8221;</span>
	of PML instances, i.e. replacing certain type of PML
	references with the content of the referenced entities
	occurring in other PML instance.
	Conversely, when a PML instance on which this
	<span class="quote">&#8220;<span class="quote">knitting</span>&#8221;</span>
	has been applied is saved, the (possible edited) content 
	replaces the content of the referenced entities
	in its original PML instance.
	Knitting only applies to:
	</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
	members of PML structures containing a
	PML reference and having PML role <code class="literal">#KNIT</code>,
	</p></li><li class="listitem"><p>to members of PML structures containing a list with PML
	role <code class="literal">#KNIT</code>, with PML references as list
	members.
	    </p></li></ol></div><p>
	If knitting applies to such a member, then a possible trailing
	<code class="literal">.rf</code> part of its name is stripped and its
	content (either a single PML reference or a list of them) is
	replaced with the corresponding entities in the referenced PML
	instance. It is required that all such PML references refer to
	resources specified in the PML schema either as
	<code class="literal">readas="dom"</code> (in which case <a class="ulink" href="http://search.cpan.org/dist/Treex-PML/lib/Treex/PML.pm" target="_top"><code class="classname">Treex::PML</code></a>
	representation of the referred data structure is created and
	transformed back into DOM only at save) or
	<code class="literal">readas="pml"</code> (in which case, after
	knitting, the referred and referring PML instances share the
	knitted data structure).
      </p></div></div><div class="section" title="16.7. TrXML backend"><div class="titlepage"><div><div><h3 class="title"><a name="trxmlbackend"></a>16.7. TrXML backend</h3></div></div></div><p>The
	<code class="literal">TrXML</code> backend was intended as a XML
	replacement of the FS format. Unfortunatelly, never fully
	developed and thoroughly tested. It is obsoleted by PML and
	therefore not recommended for any future work.
      </p></div><div class="section" title="16.8. TEIXML backend"><div class="titlepage"><div><div><h3 class="title"><a name="teixmlbackend"></a>16.8. TEIXML backend</h3></div></div></div><p>
	This backend reads and stores trees represented in a specific
	subset of the TEI XML format. The format used by this backend
	was (is?) used in the <a class="ulink" href="http://nl.ijs.si/sdt/" target="_top">Slovene Treebank Project</a>.
      </p></div><div class="section" title="16.9. Writing a new I/O backend"><div class="titlepage"><div><div><h3 class="title"><a name="id585637"></a>16.9. Writing a new I/O backend</h3></div></div></div><p>
	While for XML-based formats it is recommended to
	use XSTL transformation to PML as described in
	<a class="xref" href="ar01s16.html#pmlbackend_xslt" title="16.6.2. Support for non-PML XML-based formats">Section 16.6.2, &#8220;Support for non-PML XML-based formats&#8221;</a>, adding support for 
	other formats requires writing a new I/O backend.
	An I/O backend is a Perl module defining at least the
	following five subroutines (listed in the order in which they
	are typically called by <span class="application">TrEd</span>):
      </p><div class="variablelist"><dl><dt><span class="term"><code class="literal"><code class="function">test</code>(<em class="replaceable"><code>$filename</code></em>,<em class="replaceable"><code>$encoding</code></em>)</code></span></dt><dd><p>
	      This function should only quickly peek in the given file
	      in order to determine if it is a file suitable by the
	      backend. If this function accepts the file by returns a
	      defined non-zero value (e.g. 1), then the file is
	      processed by this backend. If the file is not suitable
	      for the backend, this function must reject the file
	      by returning 0 or <code class="literal">undef</code>,
	      so that other backends in the list of backends could
	      try their luck.
	    </p></dd><dt><span class="term"><code class="literal"><code class="function">open_backend</code>(<em class="replaceable"><code>$filename</code></em>,<em class="replaceable"><code>$mode</code></em>,<em class="replaceable"><code>$encoding</code></em>)</code></span></dt><dd><p>This function should open and return a filehandle for a given
	      file. If <em class="replaceable"><code>$mode</code></em> is
	      <code class="literal">r</code>, then this filehandle should be
	      open for reading, if <em class="replaceable"><code>$mode</code></em> is
	      <code class="literal">w</code>, it should be open for writing.
	      The third, <em class="replaceable"><code>$encoding</code></em>, contains
	      the encoding specified by the user in the <a class="link" href="ar01s13.html#defaultfileencoding">defaultFileEncoding</a>
	      configuration option. This information may be ignored if
	      the data format provides another way to determine the
	      encoding. Most backends do not re-implement this
	      function, but simply import (i.e. inherit) it from the
	      base class <a class="ulink" href="http://search.cpan.org/dist/Treex-PML/lib/Treex/PML/IO.pm" target="_top"><code class="classname">Treex::PML::IO</code></a>.
	    </p></dd><dt><span class="term"><code class="literal"><code class="function">read</code>(<em class="replaceable"><code>$filehandle</code></em>,<em class="replaceable"><code>$fsfile</code></em>)</code></span></dt><dd><p>
	      This is the key function that implements converting data
	      from the specific data format to the corresponding
	      memory representation in <span class="application">TrEd</span>.
	      This function obtains two arguments: the
	      <em class="replaceable"><code>$filehandle</code></em> previously
	      obtained by a call to backend's <code class="function">open_backend</code>, 
	      and an empty <a class="ulink" href="http://search.cpan.org/dist/Treex-PML/lib/Treex/PML/Document.pm" target="_top"><code class="classname">Treex::PML::Document</code></a> object (i.e.
	      with no trees). It is supposed to parse the data format,
	      build tree representation of the data (usually using
	      functions such as <code class="literal"><a class="ulink" href="http://search.cpan.org/dist/Treex-PML/lib/Treex/PML/Node.pm" target="_top">Treex::PML::Factory</a>-&gt;createNode()</code>,
	      and <code class="literal"><code class="function">$child-&gt;paste(</code>(<em class="replaceable"><code>$parent</code></em>,<em class="replaceable"><code>$ordering_attribute</code></em>)</code>
	      and populate the <a class="ulink" href="http://search.cpan.org/dist/Treex-PML/lib/Treex/PML/Document.pm" target="_top"><code class="classname">Treex::PML::Document</code></a>
	      with the resulting trees (e.g. using its
	      <code class="methodname">changeTrees</code> method).
	      It should also setup <a class="ulink" href="http://search.cpan.org/dist/Treex-PML/lib/Treex/PML/FSFormat.pm" target="_top"><code class="classname">Treex::PML::FSFormat</code></a>
	      object associated with the
	      <em class="replaceable"><code>$fsfile</code></em>
	      (<code class="literal"><em class="replaceable"><code>$fsfile</code></em>-&gt;FS</code>).
	      Any additional information related to the file (but not representable
	      as trees or <a class="ulink" href="http://search.cpan.org/dist/Treex-PML/lib/Treex/PML/FSFormat.pm" target="_top"><code class="classname">Treex::PML::FSFormat</code></a>) may be attached to the file e.g. using 
	      <code class="literal"><em class="replaceable"><code>$fsfile</code></em>-&gt;<code class="methodname">changeMetaData(<em class="replaceable"><code>$key</code></em>,<em class="replaceable"><code>$value</code></em>)</code></code>.
	    </p></dd><dt><span class="term"><code class="literal"><code class="function">write</code>(<em class="replaceable"><code>$filehandle</code></em>,<em class="replaceable"><code>$fsfile</code></em>)</code></span></dt><dd><p>
	      This function is the opposite of
	      <code class="function">read</code>. By examining the
	      <a class="ulink" href="http://search.cpan.org/dist/Treex-PML/lib/Treex/PML/Document.pm" target="_top"><code class="classname">Treex::PML::Document</code></a> object
	      <em class="replaceable"><code>$fsfile</code></em>
	      (especially its trees and meta data),
	      it should write the corresponding representation
	      in the specific data format to the given
	      <em class="replaceable"><code>$filehandle</code></em>.
	    </p></dd><dt><span class="term"><code class="literal"><code class="function">close_backend</code>(<em class="replaceable"><code>$filehandle</code></em>)</code></span></dt><dd><p>This function should close a given filehandle
	      created by a previous call to
	      <code class="function">open_backend</code>.  It usually only
	      consists of applying a Perl function
	      <code class="function">close</code> on the filehandle, but if
	      additional cleanup is necessary, it should be done here.
	      Most backends do not re-implement this function, but
	      simply import (i.e. inherit) it from the base class
	      <a class="ulink" href="Treex/PML/IO" target="_top"><code class="classname">Treex::PML::IO</code></a>.
	    </p></dd></dl></div><p>
	There are several ways to make <span class="application">TrEd</span>
	know about a user-defined I/O backend, namely:
	</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>listing addtional backends in the <a class="link" href="ar01s13.html#iobackends">Treex::PML::IOs</a> configuration option,</p></li><li class="listitem"><p>listing addtional backends after
	      <em class="parameter"><code>-B</code></em> on the command-line (see <a class="xref" href="ar01s14.html" title="14. Command-line options">Section 14, &#8220;Command-line options&#8221;</a></p></li><li class="listitem"><p>defining a 
	      <a class="link" href="ar01s15.html#get_backends_hook">get_backends_hook</a></p></li></ul></div><p>
      </p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ar01s15.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ar01s17.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">15. User Macros </td><td width="20%" align="center"><a accesskey="h" href="tred.html">Home</a> | <a accesskey="t" href="ar01-toc.html">ToC</a></td><td width="40%" align="right" valign="top"> 17. Extension Packages</td></tr></table></div></body></html>
