#!/usr/bin/env perl
# -*- cperl -*-
#
# $Id: tred 4544 2010-12-28 17:42:53Z stepanek $
#
##############################################################################
#
# This is "TrEd" - a viewer and editor of tree graphs, such as
# dependency trees. TrEd uses PerlTk library as a GUI toolkit.
#
##############################################################################

use strict;
use 5.008;

BEGIN {
############################################################
# start of BEGIN section
############################################################

if ($^V lt 'v5.8.3') {
  print STDERR '-' x 50,"\n";
  print STDERR "WARNING: Your version of perl is older than v5.8.3\n";
  print STDERR "THINGS MAY NOT WORK AS EXPECTED OR NOT AT ALL!\n";
  print STDERR '-' x 50,"\n\n";
}

use constant ABOUT =>
  "Copyright (c) 2000-2010 by Petr Pajas\n".
  "This software is distributed under GPL - The General Public Licence\n".
  "Full text of the GPL can be found at http://www.gnu.org/copyleft/gpl.html";

# from TrEd::Macros 
#%menuBindings %keyBindings

use vars qw($svn_version $version $opt_u $opt_h $opt_c $opt_y
	    $init_macro_context $opt_W $opt_G $opt_R $opt_X $opt_q $opt_B $opt_split_window
	    $opt_n $opt_D $opt_v $opt_H $opt_I $opt_Z $opt_e
            $libDir $docDir $list_options $opt_auto_save
	    $macroFile  
	     $treeViewOpts $opt_m
             @ISA @EXPORT $opt_filelist $opt_s
            $opt_S
            $insideEval %pckey_shift_translates $tredDebug
             $appName  
             $stderr $stdout
	    
	     %backend_map $debug @normal_win_opts @focused_win_opts
	    $locale_charset
	    $no_secondary
	    %HELP  
	    $manpage $listoptions $no_backups $no_locks  %optmap $carp
	    $tred_d $VERSION
            $command
           );

# $userlogin
# $noCheckLocks
# %vertical_key_arrow_map
# @recentFiles
# @filelists
# %filelist_from_extension
# @openfiles
# $ioBackends
# @backends
# $NewFileNo
# %save_types
# @open_types 
# @save_types -- this is probably forgotten since it is never used
# $valueLine -- this is probably forgotten since it is never used
# $enable_extensions $disable_extensions -- moved to TrEd::Extensions
# $configFile -> RuntimeConfig
use Exporter;
@ISA   = qw(Exporter);
@EXPORT= qw($insideEval
            $libDir $stderr $stdout
              &min &max);
# @openfiles
# @filelists

use Getopt::Long;
use Pod::Usage;


my $optparser=new Getopt::Long::Parser(config => ["bundling"]);
%optmap =  (
  'quiet|q' => \$opt_q,
  'macro-file|m=s' => \$opt_m,
  'config-file|c=s' => \$TrEd::RuntimeConfig::cmdline_config_file,
  'filelist|l=s' => \$opt_filelist,
  'context|t=s' => \$init_macro_context,
  'file-encoding|n=s' => \$opt_n,
  'split-window|p=i' => \$opt_split_window,
  'version|v' => \$opt_v,
  'help|h' => \$opt_h,
  'usage|u' => \$opt_u,
  'window-embed|W=s' => \$opt_W,
  'no-geometry|G' => \$opt_G,
  'include-macro-file|I=s' => \$opt_I,
  'show-hidden-nodes|H' => \$opt_H,
  'debugging|D' => \$opt_D,
  'no-secondary-files|Y' => \$no_secondary,
  'extra-backends|B=s' => \$opt_B,
  'tectogrammatical-trees|R' => \$opt_R,
  'csts-tree-attributes|X=s' => \$opt_X,
  'stylesheet|s=s' => \$opt_s ,
  'stylesheet-file|S=s' => \$opt_S,
  'resource-dir|Z=s' => \$opt_Z,
  'define-symbol|y=s@' => \$opt_y,
  'option|O=s@' => \$TrEd::Config::override_options,
  'execute|e=s' => \$opt_e,
  'man' => \$manpage,
  "list-options" => \$list_options,
  "no-backups" => \$no_backups,
  "no-locks" => \$no_locks,
  "autosave=i" => \$opt_auto_save,
  "carp" => \$carp,
  "enable-extensions|j=s" => \$TrEd::Extensions::enable_extensions,
  "disable-extensions|J=s" => \$TrEd::Extensions::disable_extensions,
  "command|C" => \$command,
);
$optparser->getoptions(%optmap) or $opt_u=1;

# Help and usage
if ($opt_u) {
  pod2usage({
    -msg => 'TrEd - a graphical visualizer and editor of tree graphs',
  });
#  exit 0;
}
if ($opt_h) {
  pod2usage(-exitstatus => 0, -verbose => 1);
}
if ($manpage) {
  pod2usage(-exitstatus => 0, -verbose => 2);
}
if ($list_options) {
  foreach my $o (keys %optmap) {
  	# Removes type Getopt::Long's type information from optmap
  	# However, this does not work for 'option|O=s@'
    $o=~s/=.$//;
    foreach my $oo (split /\|/,$o) {
      print sort ((length($oo)>1) ? "--$oo\n" : "-$oo\n");
    }
  }
  exit;
}

# userlogin was here

use Carp;

#TODO: ktore IO moduly sa vlastne pouzivaju? zistit a importovat iba tie, samotne IO je uz deprecated
use IO;
use Cwd;
use File::Spec;
use File::Glob qw(:glob);
use URI::file;
use URI::Escape;
use Fcntl;
use Scalar::Util qw(blessed);
use UNIVERSAL::DOES;

use constant EMPTY => q{};

# Once we got rid of them we call getopt to read all the other options

$SIG{__DIE__} = sub { confess(@_) } if $carp;

# Default values of $libDir used to search for macro-file (tred.mac)
# and default-macro file (tred.def) are specified here. They may be
# overriden by value of LibDir in tred resource file (tredrc or ~/.tredrc - see above).
# It is also used to find TrEd::Config.pm module.

use FindBin;
if (exists $ENV{TREDHOME}) {
  $libDir=$ENV{TREDHOME};
} elsif (-d "$FindBin::RealBin/tredlib") {
  $libDir="$FindBin::RealBin/tredlib";
} elsif (-d "$FindBin::RealBin/../lib/tredlib") {
  $libDir="$FindBin::RealBin/../lib/tredlib";
} elsif (-d "$FindBin::RealBin/../lib/tred") {
  $libDir="$FindBin::RealBin/../lib/tred";
}
print "Libdir: $libDir\n" if ($libDir and $opt_D);

$macroFile=undef;

########## Config file #############
# this must be done before read_config is first used

# We *must* at least find TrEd::Version, TrEd::Utils and TrEd::Config module to learn the correct libDir!!.
unshift @INC,$libDir if -d $libDir;

require TrEd::Utils;
import TrEd::Utils qw(:all);
# set HOME environment variable on Windows to user's AppData
TrEd::Utils::find_win_home();
# set output encoding to utf8 on stdout and stderr
TrEd::Utils::set_fh_encoding(\*STDERR,':utf8',"STDERR");
TrEd::Utils::set_fh_encoding(\*STDOUT,':utf8',"STDOUT");

{
  my $ld=$libDir;
  require TrEd::Version;
  import TrEd::Version;
  $VERSION = TrEd::Version::TRED_VERSION();

  require TrEd::Config;
  import TrEd::Config;
  import TrEd::Config qw(&read_config &apply_config &set_default_config_file_search_list);
  $libDir=$ld;
  $TrEd::Config::quiet = $opt_q;
}

# custom configuration file
if (defined $opt_c) {
  @TrEd::Config::config_file_search_list=($opt_c); # override any other possible config files
} else {
  TrEd::Config::set_default_config_file_search_list();
}

my $initial_config;
#TODO: why is this sub defined here, in the BEGIN section? Because it uses $initial_config

sub apply_initial_config { set_config($initial_config); undef $initial_config }
$TrEd::Config::set_user_config=sub { $initial_config=shift };	# tred specific configuration
my $configFile = TrEd::Config::read_config();

require TrEd::RuntimeConfig;
TrEd::RuntimeConfig::init_config($configFile);

unless (-d $libDir) {
  print <<'EOL';
 TrEd could not find a tredlib directory. You may need to point
 to its location by the TREDHOME variable or add a correct LibDir
 field to your ~/.tredrc.

EOL
    die "Error: Couldn\'t find lib-directory.";
}

unshift @INC,$libDir unless (grep($_ eq $libDir, @INC));
{
  my $libs = File::Spec->catfile($libDir,'libs');
  if (-d $libs) {
    unshift @INC, glob(File::Spec->catfile($libs,'*',''));
  }
}

use XML::LibXML; # this is for Darwin (we want to load our libxml2
                 # before some dependency of Tk loads the system one)
use Tk;
use Tk::Config ();
# process the standard arguments for X resources
Tk::CmdLine::SetArguments();

require Treex::PML;
import Treex::PML;
import Treex::PML qw(&Index $FSError);
import Treex::PML::Schema qw(:constants);
require TrEd::UserAgent;

# require Fslib; # compatibility

# import min and max functions
require TrEd::MinMax;
import TrEd::MinMax;
#sub first (&@); # prototype it for compile-time
import TrEd::MinMax qw(first);



############################################################
# end of BEGIN section
############################################################
}


#TODO: pdt20 and pmltq extensions use this variable :/
*openfiles = \@TrEd::File::openfiles;

if ($opt_v) {
  print <<"EOF";
TrEd $VERSION
Perl: $]
Platform: $^O
Tk: $Tk::VERSION
Treex::PML: $Treex::PML::VERSION
Treex::PML-API: $Treex::PML::API_VERSION
EOF
  exit;
}

apply_initial_config();



{
  # ensure ~/.tred.d exists
  $tred_d = File::Spec->catdir($ENV{HOME},'.tred.d');
  if (! -d $tred_d) {
    mkdir $tred_d || warn "Could not create tred configuration directory: $tred_d: $!\n";
  }
}

my $pid_file = File::Spec->catfile($tred_d,'tred.pid');

# handle -C argument passed to tred -- for now it can only open file in already opened TrEd...
if ($command) {
  if (open(my $fh, '<',$pid_file)) {
    my $pid = <$fh>;
    close $fh;
    if ($pid and kill(0,$pid)) {
      my $cmd_file = File::Spec->catfile($tred_d,'cmd_'.$pid);
      if (sysopen(my $fh, $cmd_file, O_TRUNC|O_CREAT|O_WRONLY, 0600)) {
        my ($command,@args) = @ARGV;
        if ($command eq 'open') {
          #TODO: require in map? what is the purpose of this construct?
          @args = map {
            my ($filename,$suffix) = TrEd::Utils::parse_file_suffix($_);
            require Treex::PML::IO;
            Treex::PML::IO::make_abs_URI($filename)->as_string.$suffix
          } @args;
	    }
        print $fh join("\0",$command,@args);
        close $fh;
        kill "USR2", $pid;
      }
      exit(0);
    }
  }
  if ($ARGV[0] eq 'open') {
    shift;
  } else {
    exit(1);
  }
}

# write PID to $pid_file
if (open(my $fh, '>',$pid_file)) {
  print $fh $$;
  close $fh;
}

# import encode and decode functions
require TrEd::Convert;
import TrEd::Convert;


$TrEd::Convert::inputenc=$opt_n if $opt_n;
$TrEd::Config::treeViewOpts->{showHidden} = 1 if $opt_H;
$TrEd::Config::iconPath = "$libDir/icons/crystal" unless (defined $TrEd::Config::iconPath);
$macroFile="$libDir/tred.mac" unless (defined $macroFile);
if (defined $opt_m) {
  $macroFile=$opt_m;
}

# don't die on error in Treex::PML::Instance::Reader, just warn...
$Treex::PML::Instance::Reader::STRICT=0;

TrEd::Stylesheet::init_stylesheet_paths([split($Treex::PML::resourcePathSplit, $opt_S, -1)]);

# well, setter would be nicer..
$Treex::PML::resourcePath=
  join($Treex::PML::resourcePathSplit,
       map { length($_) ? $_ : $Treex::PML::resourcePath }
       split($Treex::PML::resourcePathSplit, $opt_Z,-1))
  if $opt_Z;

# not very convenient... at least group to a fn
$tredDebug=1 if $opt_D;

$TrEd::TreeView::Debug=1 if $opt_D;
$Treex::PML::Debug=1 if $opt_D;
$Treex::PML::IO::Debug=1 if $opt_D;

# find documentation dir
$docDir = first { -d $_ }
  ("$FindBin::RealBin/documentation",
   "$FindBin::RealBin/../doc/tred",
   "$libDir/../doc/tred",
   "$libDir/../documentation",
  );
if ($docDir ne EMPTY) {
  $docDir = 'file://'.$docDir;
} else {
  #TODO this is quite ugly
  $docDir = 'http://ufal.mff.cuni.cz/~pajas/tred';
}


# make Alt_L and Alt_R work correctly on Darwin
if ($^O eq 'darwin') {
  my $xmodmap = File::Spec->catfile($libDir,'xmodmap.darwin');
  warn "Using xmodmap: $xmodmap\n" unless $opt_q;
  system('xmodmap', $xmodmap) if -f $xmodmap;
}

require Tk::widgets;
import Tk::widgets
  qw(Frame Pane LabFrame Listbox HList Menu
     ItemStyle DialogBox Tiler BrowseEntry Panedwindow Dialog 
     Scale Adjuster Entry Text);
# duplicate import entry DialogBox
require Tk::Font;




# import read_macros etc.
use TrEd::Macros;
#import TrEd::Macros;

TrEd::Macros::define_symbol('TRED');
#opt_y -- define symbol
if ($opt_y) {
  foreach my $def (@$opt_y) {
    foreach my $sym (split(/,/, $def)) {
      if ($sym =~ /=/) {
        TrEd::Macros::define_symbol(split(/=/, $sym, 2));
      } else {
        TrEd::Macros::define_symbol($sym);
      }
    }
  }
}

require TrEd::Extensions;
import TrEd::Extensions qw(:all);

# tree drawing module
require TrEd::TreeView;

# tree view windowing module
require TrEd::Window;

# tree printing module
require TrEd::Print;

# basic tree operations
use TrEd::Window::TreeBasics;

$TrEd::Window::TreeBasics::on_tree_change= \&onTreeChange;
$TrEd::Window::TreeBasics::on_node_change= \&onNodeChange;
$TrEd::Window::TreeBasics::on_current_change= \&onCurrentChange;

eval { require TrEd::Help; };

#### new additions ###
use Readonly;
# maybe use similar approach as Padre here, require/use everything *.pm in tredlib/TrEd?
require TrEd::Stylesheet;
import TrEd::Stylesheet qw(:all);

use TrEd::List::Macros;
use TrEd::HTML::Simple;
use TrEd::Dialog::MacroList;
use TrEd::Filelist::View;
use TrEd::FileLock;
use TrEd::Dialog::EditStylesheet;
use TrEd::Dialog::EditConfig;
use TrEd::Dialog::Text;
use TrEd::Dialog::FocusFix;
use TrEd::Dialog::URL;
use TrEd::Dialog::SelectValues;
use TrEd::Dialog::CopyTrees;
use TrEd::Dialog::EditAttributes;

use TrEd::Binding::Default;
use TrEd::Filelist::Navigation;
use TrEd::ValueLine;
use TrEd::StatusLine;
use TrEd::Undo;
use TrEd::View::Sentence;
use TrEd::RecentFiles;
use TrEd::ManageFilelists;
use TrEd::Bookmarks;
use TrEd::Dialog::Filelist;
use TrEd::Dialog::File::Open;
use TrEd::Menu::Stylesheet;
use TrEd::Menu::Context;
use TrEd::Toolbar::User::Manager;
use TrEd::Error::Message;
use TrEd::Dialog::FileProperties;
use TrEd::Dialog::Print;
use TrEd::Dialog::FindNode;
use TrEd::Dialog::ExamineBindings;
use TrEd::Menu::Macro;
use TrEd::MinorModes;

require TrEd::Query::List;
require TrEd::Query::User;
require TrEd::Query::String;
require TrEd::Query::Simple;

# ex-macro stuff
# this files all live in TredMacro package namespace 
#use TrEd::ExtensionsAPI; # tred.def & tred.mac & contrib.mac 


# still macro stuff, but separate namespace
require TrEd::NodeGroups; # instead of contrib/node_groups/node_groups.mak


# we need to have command line options already prepared 
require TrEd::File;
import TrEd::File;

TrEd::File::init_backends($opt_B);

### eof new additions ###

# @backends


require Filelist;

require Tk::MiscWorkarounds;
require Tk::MyFileSelect;
require Tk::ImgButton;
require Tk::BindButtons;
require Tk::BindMouseWheel;
require Tk::DialogReturn;
require Tk::ErrorReport;
require Tk::Balloon;
require Tk::JComboBox_0_02;
require Tk::TrEdNodeEdit;
require Tk::TextSearchLine;

require TrEd::Menu;

require Data::Snapshot;
import Data::Snapshot;

*which = eval {
  require File::Which;
  \&File::Which::which
} || sub {};
warn $@ if $@;

$stdout=\*STDOUT;
$stderr=\*STDERR;

ApplyGlobalConfig();
$lockFiles=0 if $no_locks;

# it seems, that under Windoze setting LC_NUMERIC back to us does not
# work, so I recommend not to use czech locales there, unless you
# really want the decimal points to be replaced by commas in
# postscript:-)
use locale;
use POSIX qw(locale_h);

eval {
  ($TrEd::Config::useLocales) && do {
    $ENV{LC_ALL}=undef;
    setlocale(LC_ALL,undef);

    if ($TrEd::Convert::support_unicode) {
      my $lc_collate=setlocale(LC_COLLATE);
      if ($lc_collate !~ /\.utf-?8/i) {
        setlocale(LC_COLLATE,$lc_collate.".UTF-8");
      }
      my $lc_ctype=setlocale(LC_CTYPE);
      $lc_ctype=~s/\.utf-?8//i; # Tk doesn't support this
      setlocale(LC_CTYPE,$lc_ctype);
    }
    setlocale(LC_NUMERIC,"C");
  };

  ($TrEd::Config::useCzechLocales or
     setlocale('LANG') =~ /^cs_CZ|^czech/) && do {
       $ENV{LC_ALL}=undef;
       setlocale(LC_ALL,undef);

       if ($TrEd::Convert::support_unicode) {
         setlocale(LC_COLLATE,"cs_CZ.UTF-8");
         setlocale('LANG',"cs_CZ.UTF-8");
         setlocale('LC_CTYPE',"cs_CZ");
       } else {
         setlocale(LC_COLLATE,"cs_CZ");
         setlocale('LANG',"cs_CZ");
       }
       setlocale(LC_NUMERIC,"C");
     };

  setlocale(LC_MESSAGES,"C");
};
warn $@ if $@;

eval {
  require I18N::Langinfo;
  $locale_charset = I18N::Langinfo::langinfo(I18N::Langinfo::CODESET());
};

TrEd::ManageFilelists::create_filelists();


$insideEval=0;

#my %searchTemplate; # was used for find node dialog, moved there
 
#TODO: nepresunut niekam k bindings alebo do configu?
%pckey_shift_translates= (exclam=> 1, at=> 2, numbersign=> 3,
			   dollar=> 4, percent=> 5, asciicircum=> 6,
			   ampersand=> 7, asterisk=> 8, parenleft=> 9,
			   parenright=> 0, plus=> 'equal',
			   underscore=> 'minus',
			   less=> 'comma', greater=> 'period', 
			   question=> 'slash',
			   colon=> 'semicolon', quotedbl=> 'apostroph',
			   braceleft=> 'bracketleft', 
			   braceright=> 'bracketright',
			   bar=> 'backslash', asciitilde=> 'grave'
			  );

$opt_R && Csts2fs::setupTR();
if ($opt_X ne EMPTY) {
  Csts2fs::setupSpec(split ',',$opt_X,-1);
  Fs2csts::setupSpec(split ',',$opt_X,-1);
}

# print STDERR "Reading macros from $macroFile...\n" unless $opt_q;

startMain(); # start the whole thing

print STDERR "TrEd ended.\n" unless $opt_q;

exit_tred();

############################################################
#
# Implementation and auxiliary functions
#
############################################################

# sub create_filelists 
# sub create_cmdline_filelists


#sub createBookmarksFilelist

# tags: treeView
sub gotoFirstDisplayedNode {
  my $win = cast_to_win( $_[0] );
  my $tv = $win->treeView;
  my $node = first { $tv->node_is_displayed($_) } @{$win->{Nodes}};
  if ($node) {
    TrEd::Window::TreeBasics::set_current($win,$node);
    centerTo($win,$node);
  }
}

# tags: treeView
sub gotoLastDisplayedNode {
  my $win = cast_to_win( $_[0] );
  my $tv = $win->treeView;
  my $node = first { $tv->node_is_displayed($_) } reverse @{$win->{Nodes}};
  if ($node) {
    TrEd::Window::TreeBasics::set_current($win,$node);
    centerTo($win,$node);
  }
}


# main
sub exit_tred {
  if (open(my $fh, '<',$pid_file)) {
    my $pid = <$fh>;
    if ($pid==$$) {
      unlink $pid_file;
    }
  }
  if (@_) {
    POSIX::_exit(@_);
  } else {
    exit();
  }
}

# encode, locale
# same in btred, into lib?
sub conv_from_locale {
  my ($str)=@_;
  if ($locale_charset and $TrEd::Convert::support_unicode) {
    require Encode;
    return Encode::decode($locale_charset, $str);
  } else {
    return $str;
  }
}

# UI, icon
sub icon {
  my ($grp, $name)=@_;
  unless (exists $grp->{icon}{$name}) {
    my @extensions=qw(gif xpm);
    eval { require Tk::PNG };
    if (not($@)) {
      unshift @extensions,'png';
    } else {
      warn "PNG icons not supported by running Tk\n" if $tredDebug;
    }
    # prepend $libDir to relative paths
    my $default=0;
    my $split = ($^O eq "MSWin32") ? ',' : ':';
    my @paths = (map {
      my $p =
      m{^\s*\Q${TrEd::File::dir_separator}\E} ? $_ : $libDir."/icons/".$_;
      $default = 1 if $p eq $libDir."/icons/crystal";
      $p;
    } split(/$split/o,$iconPath));
    # add default theme, unless already in the list
    push @paths, $libDir."/icons/crystal" unless $default;
    DIR: for my $dir (@paths) {
      for my $ext (@extensions) {
	my $file = "$dir/$name.$ext";
	if (-f $file) {
	  if ($ext eq 'xpm') {
	    #print "Loading pixmap icon $file\n" if $tredDebug;
	    $grp->{icon}{$name} = 
	      $grp->{top}->Pixmap(-file => $file);
	  } else {
	    require Tk::PNG if $ext eq 'png';
	    #print "Loading photo icon $file\n" if $tredDebug;
	    $grp->{icon}{$name} = 
	      $grp->{top}->Photo(-format => $ext, -file => $file);
	  }
	  last DIR;
	} else {
	  #print "Icon not found $file\n" if $tredDebug;
	}
      }
    }
  }
  print "No icon found for $name\n" if (not $grp->{icon}{$name} and $tredDebug);
  return $grp->{icon}{$name};
}

sub __debug {
  print STDERR @_,"\n" if $tredDebug;
}

# wrapper for extensions
sub get_open_filename {
    return TrEd::Dialog::File::Open::get_open_filename(@_);
}

#TODO: consider moving in the same place as get_open_filename?
# file, current?, top
sub get_save_filename {
  my $w = shift;
  my %opts=@_;
  if ($saveFilenameCommand) {
    my $c = $saveFilenameCommand;
    my $types = ref($opts{-filetypes}) ?
      join " ",map { "*".$_ } map { @{$_->[1]} } @{$opts{-filetypes}} : "*";
    my $title = $opts{-title} || 'Open';
    my $initialdir = $opts{-initialdir}.$TrEd::File::dir_separator || EMPTY;
    my $initialfile = $opts{-initialfile} || EMPTY;
    $c=~s/\%t/"$title"/g;
    $c=~s/\%m/"$types"/g;
    $c=~s/\%d/"$initialdir"/g;
    $c=~s/\%f/"$initialfile"/g;
    my $ret = `$c`;
    s/\s+$// for $ret;
    return $ret;
  } else {
    $w->getSaveFile(%opts);
  }
}

# widget, UI
sub get_widget_descendants {
  my ($w)=@_;
  if (blessed($w) and $w->isa('Tk::Widget')) {
    return ($w,map { get_widget_descendants($_) } $w->children);
  } else {
    return ();
  }
}

# widget, UI, top
sub get_all_widgets {
  my ($grp)=@_;
  get_widget_descendants($grp->{top});
}

# HistEntry
sub get_entry_type {
  my $Entry = "Entry";
  my @Eopts;
  eval {
    require Tk::HistEntry;
    $Entry = "SimpleHistEntry";
    @Eopts = qw(-case 0 -match 1);
  };
  undef $@;
  return ($Entry,@Eopts);
}

#### 
#TODO: TrEd/History?
####
# history
sub set_grp_history {
  my ($grp,$e,$h,$list)=@_;
  if ($e->can('history')){
    push @$list,[$e,$h] if (ref($list)); # just maintains a list of histories
    my $hist = $grp->{"hist_$h"} ||= [];
    $e->history($hist);
  }
}

# history
sub get_grp_history {
  my ($grp,$e,$h)=@_;
  if ($e->can('historyAdd')) {
    $grp->{"hist_$h"}=[] unless ref($grp->{"hist_$h"});
    my $v = $e->get;
    $e->historyAdd($v) if $v ne EMPTY;
    @{$grp->{"hist_$h"}} = $e->history();
  }
}

# history
sub get_grp_histories {
  my ($grp,$list)=@_;
  foreach my $E (@$list) {
    get_grp_history($grp,@$E);
  }
}

#sub bookmarkFilelist

#######################################################################################
# Usage         : set_config($configs)
# Purpose       : Load recently opened files and set autoSave according to value from config  
# Returns       : nothing
# Parameters    : hash_ref \%confs
# Throws        : no exceptions
# Comments      : 
# See Also      : TrEd::ManageFilelists::add_new_filelist(), $autoSave 
# TODO: tests
sub set_config {
  my $confs=shift;
  
  TrEd::RecentFiles::init_recent_files($confs);

  TrEd::ManageFilelists::load_filelists_from_conf($confs);

  #TODO: what does autosave do? What does it saves automatically?
  $autoSave = $opt_auto_save if defined $opt_auto_save;
  print STDERR "Applying configuration.\n" if $tredDebug;
}

#######################################################################################
# Usage         : ApplyGlobalConfig($configs)
# Purpose       : 
# Returns       : 
# Parameters    : 
# Throws        : no exceptions
# Comments      : 
# See Also      :  
# TODO: tests
sub ApplyGlobalConfig {
  my ($grp)=@_;

  my $bg = $treeViewOpts->{backgroundColor} || 'white';
  my $bgoff = $treeViewOpts->{backgroundColorNofocus} || $bg; #'#fbfbfb';
  @normal_win_opts = (qw/-relief flat -borderwidth 0/,
		      -background => $bgoff,
		      -highlightbackground => $bgoff,
		      -highlightthickness  => $highlightWindowWidth, # must be the same as below
		     );
  @focused_win_opts = (qw/-relief flat -borderwidth 0/,
		       -highlightthickness  => $highlightWindowWidth,
		       -highlightbackground => $highlightWindowColor,
		       -bg => $bg
		      );
  return unless $grp;

  delete $grp->{icon};
  foreach my $button (grep { blessed($_) and $_->isa('Tk::Button') } get_all_widgets($grp)) {
    my $icon = $button->cget('-image');
    if (defined $icon) {
      my $f = TrEd::File::filename($icon->cget('-file'));
      $f=~s/\..*//;
      my $new = icon($grp,$f);
      Tk::catch {
	$button->configure(-image => $new) if $new;
      };
    }
  }

  $grp->{valueLine}->update($grp);
  #TrEd::ValueLine::update($grp);
  $grp->{statusLine}->update_status($grp->{focusedWindow});
  print STDERR $@ if $@;
  update_treeviews($grp);
  $grp->{top}->afterCancel($grp->{autoSaveCallback});
  $grp->{autoSaveCallback}=$grp->{top}->repeat($autoSave*60000, [\&autoSaveAll,$grp]) if $autoSave>0;
}

# config
sub reconfigure {
  my ($grp)=@_;
  TrEd::RecentFiles::add_file($grp);
  prepareFonts($grp);
  update_title_and_buttons($grp);
  $grp->{top}->optionAdd("*font",$TrEd::Config::guiFont) if $TrEd::Config::guiFont;
  $grp->{valueLine}->value_line_widget()->configure(-font=> $TrEd::Config::vLineFont);
  if (defined $grp->{statusLine}) {
    $grp->{statusLine}->configure(-font=> $TrEd::Config::vLineFont);
  }
  foreach (@{$grp->{treeWindows}}) {
    $_->treeView->apply_options($TrEd::Config::treeViewOpts);
  }

  ApplyGlobalConfig($grp);
}

# treeView, UI
sub update_treeviews {
  my ($grp) = @_;
  foreach my $w (@{$grp->{treeWindows}}) {
    if ($w->{treeView}) {
      my $c = $w->{treeView}->canvas;
      if ($grp->{focusedWindow} == $w) {
	$c->configure(@focused_win_opts);
	$c->itemconfigure('stipple',-state=> 'hidden');
      } else {
	$c->configure(@normal_win_opts);
	$c->itemconfigure('stipple',-state=> $stippleInactiveWindows ? 'normal' : 'hidden');
      }
    }
  }
}

# sub lastFileNo

# sub currentFileNo

# Window, UI?
sub cast_to_win {
  my ($gw)=@_;
  return (blessed($gw) and $gw->isa('TrEd::Window')) ? $gw
         : (ref $gw                                  ? $gw->{focusedWindow} 
         : undef);
}

# Window
sub cast_to_grp {
  my ($gw)=@_;
  return (blessed($gw) and $gw->isa('TrEd::Window')) ? $gw->{framegroup} : $gw;
}

# grp?
sub grp_win {
  my ($gw)=@_;
  return (cast_to_grp($gw),cast_to_win($gw));
}


# TrEd::Window ? should openFile in focusedWindow
# file, filelist
sub gotoFile {
    return TrEd::Filelist::Navigation::go_to_file(@_);
}

# filelist, UI
sub update_filelist_views {
  my ($grp_or_win,$fl,$reload)=@_;
  my ($grp,$win) = grp_win($grp_or_win);
  my $filelist_widget = TrEd::Dialog::Filelist::filelist_widget();
  if ($filelist_widget && (TrEd::Dialog::Filelist::get_current_filelist() == $fl)) {
    TrEd::Filelist::View::update_a_filelist_view($grp,$filelist_widget,$fl,$win->{currentFileNo},$reload);
  }
  #TODO: nie na sipkovu notaciu?
  TrEd::Filelist::View::update($grp,$fl,$reload);
}



#######################################################################################
# Usage         : fsfileDisplayingWindows($grp, $fsfile)
# Purpose       : Find all the windows which display $fsfile
# Returns       : A list of windows (TrEd::Window objects) that display $fsfile
# Parameters    : hash_ref $grp                -- reference to hash containing TrEd options
#                 Treex::PML::Document $fsfile -- reference to file 
# Throws        : No exception
# Comments      : 
# See Also      : 
sub fsfileDisplayingWindows {
  my ($grp, $fsfile)=@_;
  return 
    grep {
      $_->{FSFile} eq $fsfile 
    } @{$grp->{treeWindows}};
}

# sub is_focused
# sub initAppData


# sub setFSLockInfo

sub _clear_err {
  undef $!; 
  undef $@;
}

sub _last_err {
  my ($ret) = grep { defined $_ && $_ ne EMPTY } ($_[0], "$@", conv_from_locale($!));
  return $ret;
}


# sub setLock
# sub readLock
# sub removeLock
# sub checkLock

# sub closeFileInWindow


# file, UI, fsfile
sub filePartOfADisplayedFile {
  my ($grp,$fsfile)=@_;
  return unless $fsfile;
  my $part_of = $fsfile->appData('fs-part-of');
  return unless ref($part_of) and @$part_of;
  return 1 if first { 
    fsfileDisplayingWindows($grp,$_)>0
			or
		      filePartOfADisplayedFile($grp,$_)
		    } @$part_of;
  return 0;
}

# file, UI, fsfi
sub findToplevelFileFor {
  my ($grp,$fsfile)=@_;
  return unless $fsfile;
  my $part_of = $fsfile->appData('fs-part-of');
  if (ref($part_of) and @$part_of) {
    return TrEd::Utils::uniq(map findToplevelFileFor($grp,$_), @$part_of);
  } else {
    return $fsfile;
  }
}

# sub closeFile


# UI, Error
sub plainErrorMessage {
  my ($grp,$msg)=@_;
  my $top;
  if (ref($grp)=~/^Tk::/) {
    $top = $grp->toplevel;
  } elsif (ref($grp)) {
    my $win = cast_to_win($grp);
    $top = $win->toplevel if ref $win;
  }
  if (ref($top)) {
    $top->messageBox(-icon=> 'error',
		     -message=> $msg,
		     -title=> 'Error', -type=> 'ok');
  } else {
    print STDERR "$msg\n";
  }
}

sub _deleteMenu {
  my ($menu, $item) = @_;
  
  if ($tredDebug) {
    print STDERR "_deleteMenu $item\n";
  }
  my $entry = $menu->entrycget($item,'-menu');
  
  $menu->delete($item);
  if ($entry) {
    $entry->destroy();
  }
}

# sub textDialog
#TODO: wrapper for extensions..
sub textDialog {
  return TrEd::Dialog::Text::create_dialog(@_);
}

# sub userQuery
# wrapper for Elixir and PADT 
sub userQuery {
    require TrEd::Query::User;
    return TrEd::Query::User::new_query(@_);
}

#sub TrEd::RecentFiles::add_file {


# node
# sub getNodeNo -> TrEd::Window::TreeBasics


# bookmarks
#sub bookmarkThis

#sub addBookmark 
#sub lastActionBookmark 

#######################################################################################
# Usage         : update_session_status($win, $fsfile)
# Purpose       : Set tree number, current node and FSFile for Window $win to values 
#                 obtained from $fsfile
# Returns       : Undef/empty list
# Parameters    : TrEd::Window ref $win -- ref to TrEd::Window object which is to be altered
#                 Treex::PML::Document ref $fsfile -- ref to Document which is set as current for the Window
# Throws        : No exception
# Comments      : If $fsfile is not defined, all the beforementioned values are set to undef.
#                 If Windows is focused, session status is updated.
# See Also      : is_focused(), fsfileDisplayingWindows()
sub update_session_status {
    my ($grp) = @_;
    my $win = $grp->{focusedWindow};
    $grp->{ContextsMenu}->update_context_list($grp);
    $grp->{keepcurrentfile}
        = (defined $win->{FSFile} && $win->{FSFile}->appData('noautoclose'))
        ? 1
        : 0;
}



# sub updateBookmarks

#TODO: docs:
#######################################################################################
# Usage         : postpone_update($grp, $menu)
# Purpose       : Fill postponed menu with opened files
# Returns       : Undef/empty list
# Parameters    : hash_ref $grp  -- reference to hash containing TrEd options
#                 Tk::Menu $menu -- reference to posponed menu 
# Throws        : No exception
# Comments      : This function is a part of USR2 signal handler
# See Also      : main::handleUSR2Signal()
sub postponed_update_menu {
    my ( $grp, $menu ) = @_;
    my $i = 0;
    my @openfiles = TrEd::File::get_openfiles();
    foreach my $opened_file (@openfiles) {
        $menu->command(
            -label     => "$i.  " . $opened_file->filename(),
            -underline => 0,
            -command   =>
                [ \&TrEd::File::openStandaloneFile, $grp, $opened_file->filename(), -keep => 1 ]
        );
        $i++;
    }
    if (!@openfiles) {
        $menu->command(
            -label => 'none',
            -state => 'disabled'
        );
    }
    return;
}

sub updatePostponed {
  my ($grp)=@_;
  return if $grp->{noUpdatePostponed};
  if ($grp->{PostponedFileMenu}) {
    print STDERR "Updating session menu\n"  if $tredDebug;
    my $menu = $grp->{PostponedFileMenu};
    $menu->delete(0,'end');
    $_->destroy for $menu->children;
    
    #TODO: extract to TrEd::File & callback...
    main::postponed_update_menu($grp, $menu);
    
    {
      my $menu = $grp->{FileListMenu};
      if ($menu) {
	$menu->delete(0,'end');
	$_->destroy for $menu->children;
	TrEd::ManageFilelists::createFilelistsMenu($grp, $menu, [\&TrEd::ManageFilelists::selectFilelist, $grp]);
      }
    }
    {
      my $menu = $grp->{AddBookmarkMenu};
      if ($menu) {
	$menu->delete(0,'end');
	$_->destroy for $menu->children;
	TrEd::ManageFilelists::createFilelistsMenu($grp, $menu, [\&TrEd::Bookmarks::bookmark_actual_position, $grp], 1);
      }
    }
  }
}


#sub createFilelistsMenu 
#sub _makeNewFilelist 

sub updateScaleFactor {
  my ($grp)=@_;
  my $factor = $grp->{focusedWindow}->treeView()->scale_factor();
  $grp->{canvasScaleLabel}->configure(-text=>'Scale: '.int(100*$factor).'%');
  $grp->{canvasScale}=($grp->{focusedWindow}->treeView->get_scale||0);
}

# enable/disable buttons depending on the position in the filelist
sub _update_buttons {
    my ($grp, $win) = @_;
    if ( ref( $win->{FSFile} ) ) {
        if ( defined( $win->{currentFileNo} ) and $win->{currentFilelist} ) {
            my $current_file_num = $win->{currentFileNo} + 1;
            my $no_of_files      = $win->{currentFilelist}->file_count();

            $grp->{prevFileButton}->configure(
                -state => ( $current_file_num <= 1 ) ? 'disabled' : 'normal' );
            $grp->{nextFileButton}->configure(
                -state => ( $current_file_num >= $no_of_files ) ? 'disabled' 
                                                                : 'normal' );
        }
        else {
            for my $button (qw(nextFileButton prevFileButton)) {
                $grp->{$button}->configure( -state => 'disabled' );
            }
        }
        for my $button (
            qw(printButton reloadButton findButton
            findNextButton findPrevButton sentButton)
            )
        {
            $grp->{$button}->configure( -state => 'normal' );
        }
    }
    else {
        for my $button (
            qw(nextFileButton prevFileButton
            printButton reloadButton findButton
            findNextButton findPrevButton sentButton)
            )
        {
            if (defined $grp->{$button}) {
                $grp->{$button}->configure( -state => 'disabled' );
            }
        }
    }
}


#######################################################################################
# Usage         : update_title_and_buttons($grp)
# Purpose       : Update the title of the program and (de)activate buttons/icons according
#                 to the position in the filelist
# Returns       : Undef/empty list
# Parameters    : hash_ref $grp  -- reference to hash containing TrEd options
# Throws        : No exception
# Comments      : 
# See Also      : _update_buttons()
sub update_title_and_buttons {
    my ($grp) = @_;
    return if ( !ref($grp) );
    return if $grp->{noUpdateTitle};
    my $win = $grp->{focusedWindow};
    _update_buttons($grp, $win);
    if ( ref( $win->{FSFile} ) ) {
        #TODO: vyhutaj pouzitie TrEd::Utils::EMPTY_STR
        my $filelist_info = EMPTY;
        if ( defined $win->{currentFileNo} && $win->{currentFilelist} ) {
            my $current = $win->{currentFileNo} + 1;
            my $all     = $win->{currentFilelist}->file_count();
            $filelist_info = $win->{currentFilelist}->name() 
                            . "($current/$all): ";
        }
        $grp->{top}->title(
            "$appName    " . $filelist_info . $win->{FSFile}->filename() );
    }
    else {
        $grp->{top}->title("$appName");
    }
    return;
}


# UI, menu
sub updateHelpMenu {
  my ($grp,$opts)=@_;
  $opts||={};
  my $hm = $grp->{main_menu}->lookup_menu_item('MENUBAR:HELP:EXTENSION_MANUALS');
  return unless $hm;
  if ($Tk::platform eq 'unix') {
    # this is a very lame work around a probable bug in Tk
    # n'th menu created (where exact n I don't know)
    # will behave strangely: first attempt to post it by clicking on it
    # will post the menu at or near the top left screen cornder
    # rather than on a given x,y; next time, the menu works fine
    #
    # Currently this affects this particular menu,
    # which we now programmatedly post and unpost
    #
    $hm->post(0,0);
    $hm->unpost;
  }
  $hm->delete(0,'end');
  $_->destroy for $hm->children;
  my $preinst_dir = TrEd::Extensions::get_preinstalled_extensions_dir();
  my ($extensions,$pre_installed) = @{
    $opts->{preparedExtensions} ||
    TrEd::Extensions::prepare_extensions($opt_m) ||
    [[],[]]
  };
  my %m;
  foreach my $m (
    (map [ $_, TrEd::Extensions::get_extension_doc_paths([$_]) ], @$extensions),
    (map [ $_, TrEd::Extensions::get_extension_doc_paths([$_],$preinst_dir) ], @$pre_installed)) {
    $m{$m->[0]} = $m->[1] unless exists $m{$m->[0]};
  }
  for my $ext (sort keys %m) {
    my $index = File::Spec->catfile($m{$ext},'index.html');
    if (-f $index) {
      my $url = URI::file->new($index);
      $hm->add('command',
	       -label => $ext,
	       -command => [\&open_url_in_browser,$url]);
    }
  }
}

# sub newFileFromCurrent

#sub openStandaloneFile

# sub reloadFile
# wrapper for PADT extension
sub reloadFile {
    return TrEd::File::reloadFile(@_);
}

# sub _new_status 

# sub loadFile


# sub merge_status


# sub openFile

# wrapper for extensions that use this function
# we can't change them until refactored tred is functional
sub lockOpenFile {
  my ($win, $fsfile) = @_;
  return TrEd::FileLock::lock_open_file($win, $fsfile);
}

# sub openSecondaryFiles


#######################################################################################
# Usage         : unhide_current_node($win)
# Purpose       : Show current node if it is hidden
# Returns       : Undef/empty list
# Parameters    : TrEd::Window ref $win -- reference to TrEd::Window object
# Throws        : No exception
# Comments      : Sets showHidden value to 1 for the Window's TrEd::TreeView object
sub unhide_current_node {
    my ($win) = @_;
    if ( $win->{currentNode} ) {
        if ( !isShown( $win, $win->{currentNode} ) ) {
            $win->treeView()->set_showHidden(1);
        }
    }
    return;
}


# autosave, file
sub autosave_filename {
  my ($f)=@_;
  my $base=TrEd::File::filename($f);
  return undef unless ($f=~s/\Q${base}\E$/#$base#.#tred#/);
  return $f;
}

# autosave, file? to TrEd::File?
sub autoSaveAll {
  my ($grp)=@_;
  my $top=$grp->{top};
  my @files=grep { ($_->notSaved == 1) and !$_->appData('noautosave') } TrEd::File::get_openfiles();
  return unless @files;
  $top->title("Autosaving...");
  $top->update;
  $top->Busy(-recurse=> 1) if (!$insideEval);
  foreach my $fsfile (@files) {
    my $f=autosave_filename($fsfile->filename);
    print STDERR "auto-saving recovery file ".$fsfile->filename." to '$f'\n" if $tredDebug;

    # this is not a kosher implementation but
    # there is no way to call a hook on fsfile
    # not owned by any windows, sigh!
    my ($win) = fsfileDisplayingWindows($grp,$fsfile);
    $win = $grp->{focusedWindow} unless $win;
    return if doEvalHook($win,"file_autosave_hook",$fsfile) eq 'stop';

    my $ok = 0;
    eval {
      $fsfile->changeAppData('refs_save',{});
      my $status = $fsfile->writeFile($f);
      $ok = 1 unless
	doEvalHook($win,"after_autosave_hook",$f,$status) eq 'stop';
      $fsfile->changeAppData('refs_save',undef);
    };
    unless ($ok) {
      $fsfile->changeAppData('refs_save',undef);
      print STDERR "Error auto-saving file to '$f'\n("._last_err()."\n";
      next;
    }
    $fsfile->notSaved(2);
  }
  update_title_and_buttons($grp);
  $top->Unbusy() unless $insideEval;
}

# sub saveFile

# node
sub isShown { # test if node is shown (always 1 if $showHidden)
  my ($win,$node,$show)=@_;
  $show=$win->treeView->get_showHidden() unless defined $show;
  return 0 unless ($node and $win->{FSFile});
  return (!$show and $win->{FSFile}->FS->isHidden($node)) ? 0 : 1;
}

# node
sub HNext { # same as Next but obey $showHidden
  my ($win,$node,$top)= @_;
  $node=$node->following($top);
  while ($node) {
    return $node if (isShown($win,$node));
    $node=$node->following($top);
  }
  return 0;
}

# node
sub HPrev { # same as Prev? but obey $showHidden
  my ($win,$node,$top)= @_;
  $node=$node->previous($top);
  while ($node) {
    return $node if (isShown($win,$node));
    $node=$node->previous($top);
  }
  return 0;
}

# node
sub DisplayedAncestor {
  my ($win,$node)= @_;
  my $tv = $win->treeView;
  $node = $node->parent;
  while ($node and !$tv->node_is_displayed($node)) {
    $node = $node->parent;
  }
  return $node;
}

# node
sub NextDisplayed { # same as Next but obey $showHidden
  my ($win,$node,$top)= @_;
  my $tv = $win->treeView;
  $node=$node->following($top);
  while ($node) {
    return $node if ($tv->node_is_displayed($node));
    $node=$node->following($top);
  }
  return 0;
}

# node
sub PrevDisplayed { # same as Next but obey $showHidden
  my ($win,$node,$top)= @_;
  my $tv = $win->treeView;
  $node=$node->previous($top);
  while ($node) {
    return $node if ($tv->node_is_displayed($node));
    $node=$node->previous($top);
  }
  return 0;
}

# sub get_value_line {

sub reverseWrapLines {
  my ($widget,$font,$text,$width)=@_;
  use integer;
  my @toks;
  if (ref($text)) {
    @toks = @$text;
  } else {
    @toks = map { [$_,EMPTY] } split /\s+/, $text;
  }
  my @result;
  my $wd=0;
  my $w;
  my $t=pop(@toks);
  my @lines=();
  while ($t) {
    $w=$widget->fontMeasure($font," $t->[0]");
    if (($wd+$w>=$width) && (@result>0)) {
      push @lines, (@result,["\n",'space']);
      @result=($t);
      $wd=$widget->fontMeasure($font,$t->[0]);
    } else {
      $wd+=$w;
      unshift @result, $t;
    }
    $t=pop(@toks);
  }
  push @lines,@result;
  return \@lines;
}

#sub set_value_line


# sidepanel
sub toggleSidePanel {
  my ($grp)=@_;
  unless (defined $grp->{sidePanelFrame}) {
    initSidePanel($grp);
  }
  if ($showSidePanel) {
    if (!$grp->{sidePanelPacked}) {
      $grp->{bodyPane}->add($grp->{sidePanelFrame},-before=>$grp->{windowFrame},-width=>$grp->{bodyPane}->width/6);
      $grp->{sidePanelPacked}=1;
    }
  } else {
    if ($grp->{sidePanelPacked}) {
      $grp->{bodyPane}->forget($grp->{sidePanelFrame});
      $grp->{sidePanelPacked}=0;
    }
  }
}


# sidepanel
sub initSidePanel {
  my ($grp)=@_;
  require TrEd::SidePanel;
  if (not $grp->{sidePanel}) {
    $grp->{sidePanel}=TrEd::SidePanel->new($grp->{bodyPane});
    $grp->{sidePanelFrame} = $grp->{sidePanel}->frame();
  }
  
  if (not $grp->{sidePanel}->widget('attrsView')) {
    print STDERR "Creating 'Attribute' sidebar view\n" if $tredDebug;
    $grp->{sidePanel}->init_node_attributes($grp);
  }
  unless ($grp->{sidePanel}->widget('filelistView')) {
    print STDERR "Creating 'File List' sidebar view\n" if $tredDebug;
    $grp->{sidePanel}->init_filelist_view($grp);
  }
  unless ($grp->{sidePanel}->widget('fileSystemView')) {
    print STDERR "Creating 'Browse File System' sidebar view\n" if $tredDebug;
    $grp->{sidePanel}->init_browse_filesystem($grp);
  }
  unless ($grp->{sidePanel}->widget('macroListView')) {
    print STDERR "Creating 'Macro List' sidebar view\n" if $tredDebug;
    $grp->{sidePanel}->init_macro_list($grp);
  }
  print STDERR "Creating 'Macro List' sidebar view\n" if $tredDebug;
}

# sub update_status_info
#sub update_context_list

#sub update_macro_menus
# sub updateCurrentContextMenu

# sub update_status_line
# sub set_status_line


# tree_pos
sub update_tree_pos {
  my ($grp)=@_;
  my $win=$grp->{focusedWindow}; # only focused window uses the value line
  if ($win->{FSFile}) {
    $grp->{vLineNumLabel}->configure(-text => ($win->{treeNo}+1)."/".($win->{FSFile}->lastTreeNo+1));
  } else {
    $grp->{vLineNumLabel}->configure(-text => "-/-");
  }
#  $grp->{vLineNumLabel}->update();
}

#sub update_value_line
#TODO: wrapper for extensions
sub update_value_line {
    my ($grp, @args) = @_;
    return $grp->{valueLine}->update($grp, @args);
}

# sub get_nodes_win
sub get_nodes_win {
    my ($win, $no_redraw) = @_;
    if (defined $win) {
        return $win->get_nodes($no_redraw);
    }
    return;
}
# node, fsfile
sub get_nodes_fsfile {
  my ($grp,$fsfile)=@_;
  return if $insideEval;
  foreach my $w (fsfileDisplayingWindows($grp,$fsfile)) {
    $w->get_nodes();
  }
  return;
}

# node, fsfile
sub get_nodes_fsfile_tree {
  my ($grp,$fsfile,$tree_no,$no_redraw)=@_;
  return if $insideEval;
  foreach my $w (grep {$_->{treeNo} == $tree_no}
	   fsfileDisplayingWindows($grp,$fsfile)) {
    $w->get_nodes($no_redraw);
  }
  return;
}
# node, stylesheet
sub get_nodes_stylesheet {
  my ($grp,$stylesheet)=@_;
  return if $insideEval;
  foreach (stylesheetUsingWindows($grp,$stylesheet)) {
    $_->get_nodes();
  }
  return;
}

# node
sub get_nodes_all {
  my ($grp)=@_;
  foreach my $w (@{ $grp->{treeWindows} }) {
    $w->get_nodes();
  }
  return;
}

############################################################
############################################################
############################################################
# Filelists
############################################################

#sub selectFilelistNoUpdate
#sub selectFilelist 
#sub selectFilelist 
#sub find_filelist 
#sub addFilelist 

#sub looseFilePositionInFilelist

#sub switchFilelist
#sub createFilelistBrowseEntry 

#sub getFilelistLinePosition

#sub insertToFilelist 
#sub removeFromFilelist
#sub createNewFilelist 

#sub _user_resolve_filelist_conflict
#sub _solve_filelist_conflict 
#sub add_new_filelist 
#sub deleteFilelist 
#sub filelistEntryPath 
#sub feedHListWithFilelist 

#sub selectFilelistDialog 
#sub bookmarkToFilelistDialog 
#sub removeFilelistsDialog 
#sub loadFilelist 
#sub filelistDialog

####
### End of subs related to file list
####



# sub initTTFonts


# print 
sub warnWin32PrintConvert {
  my ($win)=@_;
  return 'Continue' if $^O ne 'MSWin32' or
    (which('convert.exe') ne EMPTY) or $NoConvertWarning;
  TrEd::Query::User::new_query($win,
"This feature requires ImageMagick (http://www.imagemagick.org), which ".
"does not seem to be installed because 'convert.exe' was found in your PATH. ".
"Press 'Continue' if you want to try anyway.\n\n".
"To get rid of this message permanently, add NoConvertWarning=1 to your configuration file.",
	    -title => "Warning",
	    -buttons => ["Continue","Cancel"]);
}

# print
sub warn55PrintConvert {
  my ($win)=@_;
  return 'Continue' if $NoConvertWarning;
  my $version = `$imageMagickConvert -help`;
  ($version) = split /\n/,$version;
  return 'Continue' unless ($version =~ /ImageMagick 5\.5\./);
  TrEd::Query::User::new_query($win,
	    "Your version of ImageMagick ($version) is known to hang when converting from EPS. ".
            "We suggest that you upgrade ImageMagick to version >= 6.0 or downgrade to <= 5.4.7. ".
            "If you are sure you want to continue ".
	    "taking the risk that TrEd will stop responding, press Continue.\n".
	    "It is strongly recommended that you Cancel the operation now.\n\n".
	    "To get rid this message permanently, add NoConvertWarning=1 to your configuration file.",
	    -title => "Warning",
	    -buttons => ["Cancel","Continue anyway"]);
}

# sub updatePrintDialogState

# sub _fix_combo_box_return
# sub _fix_combo_box

# sub savePrintConfig 

# print
#TODO: to TrEd::Print?
sub printThis {
  my ($grp)=@_;
  my $win = $grp->{focusedWindow};
  return unless $win->{FSFile};

## uncomment to get preview (see also below)
#  my $dlg = $grp->{top}->DialogBox(-title=> 'Print Preview',
#				   -buttons=> ['Close']);
#  my $canvas=$dlg->Scrolled('Canvas');

  my $canvas=$grp->{top}->Canvas();
  my ($one_per_file,$range,$print_opts);
  my $err;
  do {{
    $err = 0;
    $print_opts = TrEd::Dialog::Print::printDialog($grp) || return;
    my $one_per_file = delete $print_opts->{-onePerFile};
    if ($print_opts->{-format} eq 'PDF' and (!$grp->{ttfonts} or !$grp->{ttfonts}->{$printOptions->{ttFont}})) {
      plainErrorMessage($win,"You must select TrueType font for PDF!");
      $err = 1;
    }
    if ($one_per_file and ($print_opts->{-filename}!~/[%]\d*n/) and ($print_opts->{-range}=~/[\-,]/)) {
      plainErrorMessage($win,"Use %n in the output filename if you need one tree per file!");
      $err = 1;
    }
  }} while ($err);
  my $range = delete $print_opts->{-range};
  $range = $win->{treeNo}+1 unless (defined($range) and length($range));

  my $stylesheet = $win->{stylesheet};
  my $ss = undef;
  if ($stylesheet ne STYLESHEET_FROM_FILE()) {
    $ss=$grp->{stylesheets}->{$stylesheet};
  }
  my $fsfile = $win->{FSFile};
  my @range = ($one_per_file ? TrEd::Print::parse_print_list($fsfile,$range) : ($range));
  my $max_num_length = $one_per_file ? max(map length, @range) : 0;
  my %std_options =
    map {
      $TrEd::Config::defaultPrintConfig{$_}[0] => $printOptions->{$_}
    } qw(psFontFile psFontAFMFile psFontSize prtFmtWidth prtFmtHeight
	 prtHMargin prtVMargin maximizePrintSize psMedia);

  eval {
  for my $r (@range) {
    my $filename = $print_opts->{-filename};
    my $command = $print_opts->{-command};
    if ($one_per_file) {

      $filename =~ s/[%](\d*)n/sprintf("%".($1 ne EMPTY ? '0'.int($1) : '0'.$max_num_length)."d",$r)/e;
      $command =~ s/[%](\d*)n/sprintf("%".($1 ne EMPTY ? '0'.int($1) : '0'.$max_num_length)."d",$r)/e;
    }
    TrEd::Print::Print({
      %std_options,
      %$print_opts,
      -filename => $filename,
      -command => $command,
      -fsfile => $fsfile,
      -toplevel => $grp->{top},
      -canvas => $canvas,
      -range => $r,
      -hidden =>$win->{treeView}->get_showHidden(),
      -ttFont =>  ($grp->{ttfonts} ? $grp->{ttfonts}->{$printOptions->{ttFont}} : EMPTY),
      -treeViewOpts => $treeViewOpts,
      -styleSheetObject=>$ss,
      -context => $win,
      -onGetNodes => \&printGetNodesCallback,
      -onGetRootStyle => \&onGetRootStyle,
      -onGetNodeStyle => \&onGetNodeStyle,
      -onRedrawDone => \&onRedrawDone,
    });
  } };
  TrEd::Error::Message::error_message($win, $@) if $@;
  $win->get_nodes(); # printGetNodesCallback have fiddled with $win
## uncomment to get preview (see also above)
#  $canvas->pack();
#  ShowDialog($dlg);

  $canvas->destroy();
}


# sub getWindowPatterns
# sub getWindowHint

# sub getWindowContextRE

# stylesheet
sub switchStylesheet {
  my ($grp_or_win,$stylesheet)=@_;
  my ($grp,$win) = grp_win($grp_or_win);
  return unless ref($win);
  my $prevstylesheet=$win->{stylesheet};
  return if $prevstylesheet eq $stylesheet and 
    $stylesheet ne STYLESHEET_FROM_FILE(); # the file might have changed
  if ($stylesheet eq NEW_STYLESHEET()) {
    $stylesheet=TrEd::Query::String::new_query($grp,"Stylesheet name", "Name: ");
    if (!defined($stylesheet)) {
      $stylesheet=$prevstylesheet;
    } elsif (grep /^\Q$stylesheet\E$/i, keys %{$grp->{stylesheets}}) {
      TrEd::Error::Message::error_message($win,
		   "Stylesheet named '$stylesheet' already exists!\n",1);
      $stylesheet=$prevstylesheet;
    } else {
      my ($hint,$context,$patterns) = TrEd::Stylesheet::get_stylesheet_patterns($win);
      $grp->{stylesheets}->{$stylesheet}->{hint}=$hint;
      $grp->{stylesheets}->{$stylesheet}->{context}=$context;
      $grp->{stylesheets}->{$stylesheet}->{patterns}=$patterns;
      $grp->{StylesheetMenu}->update($grp);
      TrEd::Stylesheet::save_stylesheet_file($grp, $stylesheet);
    }
    $win->apply_stylesheet($stylesheet);
    $grp->{selectedStylesheet} = $stylesheet if $win->is_focused();
  } elsif ($stylesheet eq DELETE_STYLESHEET()) {
    if ($prevstylesheet eq STYLESHEET_FROM_FILE()) {
      $grp->{selectedStylesheet} = $prevstylesheet if $win->is_focused();
      return 0;
    }
    $stylesheet=$prevstylesheet;
    my $answer=TrEd::Query::User::new_query($win,
			 "Really delete stylesheet '$stylesheet'?",
			 -bitmap=> 'question',
			 -title => "Delete stylesheet?",
			 -buttons => ['Yes', 'No']);
    if ($answer eq 'Yes') {
      TrEd::Stylesheet::delete_stylesheet($grp,$stylesheet);
    } else {
      $grp->{selectedStylesheet} = $stylesheet if $win->is_focused();
      return 0;
    }
  } else {
    return 0 if (doEvalHook($win,"pre_switch_stylesheet_hook",
			    $prevstylesheet,$stylesheet) eq 'stop');
    $win->apply_stylesheet($stylesheet);
    doEvalHook($win,"switch_stylesheet_hook",$prevstylesheet,$stylesheet);
    if ($win->{FSFile}) {
      $win->get_nodes();
      $win->redraw();
    }
  }
  return 1;
}

# context switch
#######################################################################################
# Usage         : switchContext($grp)
# Purpose       : Update list of contexts in context menu, set $grp->{selectedContext}
#                 according to allowed contexts and switch context
# Returns       : Undef/empty list
# Parameters    : hash_ref $grp -- reference to hash containing TrEd options
# Throws        : No exception
# Comments      : 
# See Also      : is_focused(), fsfileDisplayingWindows()
sub switchContext {
    my ( $win, $context, $noredraw ) = @_;
    my $grp         = cast_to_grp($win);
    my $prev_context = $win->{macroContext};
    $win->{macroContext} = $context;
    my $ret = doEvalHook( $win, "allow_switch_context_hook", $prev_context,
        $context );
    
    # if context switch is not allowed
    if ( $ret eq 'stop' ) {
        $win->{macroContext} = $prev_context;
        if ( $win->is_focused() ) {
            $grp->{selectedContext} = $prev_context;
        }
        return 0;
    }
    
    $win->{macroContext} = $prev_context;
    # should we stop because of pre_switch_stylesheet_hook?
    return 0 if (doEvalHook( $win, "pre_switch_context_hook", 
                             $prev_context, $context, $win 
                            ) eq 'stop');

    $win->{macroContext} = $context;
    if ( $win->is_focused() ) {
        $grp->{selectedContext} = $context;
        $grp->{StylesheetMenu}->update($grp);
        TrEd::List::Macros::update_view($win);
        TrEd::Menu::Macro::updateCurrentContextMenu($grp);
    }
    my ( $l1, $l2 ) = ( $win->{got_nodes}, $win->{redrawn} );
    doEvalHook( $win, "switch_context_hook", $prev_context, $context );
    unless ($noredraw) {
        $win->get_nodes() unless $l1 < $win->{got_nodes};
        if ($l2 >= $win->{redrawn}) {
            # something should be done with display attrs vs windows maybe
            $win->redraw();
        }
    }
}

# hook
sub onGetNodeStyle {
  my ($treeview,$node,$styles,$win)=@_;
  doEvalHook($win,"node_style_hook",$node,$styles);
}
# hook
sub onGetRootStyle {
  my ($treeview,$node,$styles,$opts,$win)=@_;
  doEvalHook($win,"root_style_hook",$node,$styles,$opts);
}
# hook
sub onRedrawDone {
  my ($treeview,$win)=@_;
  doEvalHook($win,"after_redraw_hook",$treeview);
}
# hook
sub onGetNodes {
  my ($treeview,$fsfile,$tree_no,$current,$win)=@_;
  $win->{got_nodes}++;
  doEvalHook($win,"get_nodelist_hook",
	     $fsfile,
	     $tree_no,
	     $current,
	     $treeview->get_showHidden());
}

sub printGetNodesCallback { # called from print_trees
  my ($win,$treeview,$fsfile,$tree_no,$current)=@_;
  local $TrEd::TreeView::on_get_nodes = [\&onGetNodes,$win];
  $win->{treeNo}=$tree_no;
  $win->{root}=$fsfile->treeList->[$tree_no];
  return (($win->{Nodes},$win->{currentNode}) = $treeview->nodes($fsfile,
								 $tree_no,
								 $current));
}

# hook
sub onTreeChange {
  my ($win)=@_;
  return if $insideEval; # we don't want to redraw if called from a macro
  # not only because it is really expensive, but also because
  # calling this many times (say 1K) results in so many afterIdle calls
  # on various places (such as configure(-status=>'disabled') on value line)
  # that TrEd seems stuck when returning from a macro
  my $grp = $win->{framegroup};
  get_nodes_fsfile_tree($grp,$win->{FSFile},$win->{treeNo},1);
  $grp->{valueLine}->update($grp);
  #TrEd::ValueLine::update($grp);
  redraw_fsfile_tree($grp,$win->{FSFile},$win->{treeNo});
  my $tv = $win->treeView;
  $tv->reset_scroll_region;
#  my $node = $win->{currentNode};
#  $tv->canvas->see(-item =>
#		     $tv->get_node_pinfo($node,"Oval"));

  centerTo($win,$win->{currentNode});
  $grp->{top}->idletasks;
}

# hook
sub onNodeChange {
  my ($win,$change,$node)=@_;
  if ($change =~ m/^new_node/ && $win->{FSFile}->schema()) {
    unless (determineNodeType($win,$node)) {
      TrEd::Window::TreeBasics::prune_node($win,$node);
      return;
    }
  }
  get_nodes_fsfile_tree($win->{framegroup},$win->{FSFile},$win->{treeNo});
  redraw_fsfile_tree($win->{framegroup},$win->{FSFile},$win->{treeNo});
}


# hook
sub onCurrentChange {
  my ($win,$node,$prev)=@_;
  my $n;
  my $tv=$win->treeView;
  $win->{framegroup}->{valueLine}->update_current($win, $node);
  foreach $n ($node,$prev) {
    $tv->canvas->itemconfigure($tv->get_node_pinfo($n,"Oval"),
			       nodeOptions($win,$n)
			      );
    if ($tv->get_node_pinfo($n,"NodeHasBox")) {
      $tv->canvas->itemconfigure($tv->get_node_pinfo($n,"TextBox"),
				 nodeBoxOptions($win,$n,0));
    }
    if ($tv->get_node_pinfo($n,"EdgeHasBox")) {
      $tv->canvas->itemconfigure($tv->get_node_pinfo($n,"EdgeTextBox"),
				 nodeBoxOptions($win,$n,1));
    }
    my $item = $tv->get_node_pinfo($n,"Oval");
    $tv->canvas->coords($item, $tv->node_coords($n,$win->{currentNode}));
    $tv->apply_stored_style_opts("Oval",$n);
    $tv->apply_stored_style_opts("TextBox",$n);
    $tv->apply_stored_style_opts("EdgeTextBox",$n);
  }
  $tv->apply_stored_style_opts("CurrentOval",$node);
  $tv->apply_stored_style_opts("CurrentTextBox",$node);
  $tv->apply_stored_style_opts("CurrentEdgeTextBox",$node);

  unless ($prev eq $node) {
    eval {
      my $stripe = $tv->get_node_pinfo($node,"Stripe");
      if (defined($stripe)) {
	$tv->canvas->itemconfigure($stripe, -fill => $tv->get_stripeColor);
	$tv->canvas->itemconfigure("textbg_$node", -fill => undef ) if $tv->get_verticalTree;
      }
    };
    eval {
      my $stripe = $tv->get_node_pinfo($prev,"Stripe");
      if (defined($stripe)) {
	my $col = $tv->realcanvas->cget('-background');
	$tv->canvas->itemconfigure($stripe, -fill =>  $col);
	$tv->canvas->itemconfigure("textbg_$prev", -fill => $col )
	  if $tv->get_verticalTree;
      }
    };
    doEvalHook($win,"current_node_change_hook",$node,$prev) unless $insideEval;
    #TODO: okay, this is a little bit awkward
    $win->{framegroup}->{statusLine}->update_status($win);
  }
}

# font
sub prepareFont {
  my ($grp,$spec,$name)=@_;
  my $mw = $grp->{top};
  my $fonts = $grp->{fonts}||={};

  return $spec if $spec=~/^\s*-/; # X11Font
  my @spec;
  if ($spec!~/^\s*\{/) {
    my @a=split(/\s*,\s*/,$spec);
    my ($option,$value);
    foreach (@a) {
      ($option, $value)= split(/\s*:\s*/, $_, 2);
      push @spec, "-".$option, $value if ($option=~/^(?:size|weight|family|slant|underline|overstrike)$/);
    }
  } else {
    @spec=$mw->fontActual($spec);
  }

  if ($fonts->{$name}) {
    $fonts->{$name}->configure(@spec);
  } else {
    eval { $mw->fontDelete($name) };
    $fonts->{$name} = $mw->fontCreate($name,@spec);
  }
  return $name;
}

# font
sub prepareFonts {
  my ($grp)=@_;
  print STDERR "Preparing fonts.\n" if $tredDebug;

  my %c_font_defaults=(
    small       => 'family:sans,size:7',
    small_bold  => 'family:sans,weight:bold,size:7',
    heading     => 'family:sans,weight:bold,size:11',
    fixed       => 'family:courier,size:9',
    default     => 'family:sans,size:9',
    bold        => 'family:sans,size:9,weight:bold',
    italic      => 'family:sans,size:9,slant:italic',
   );
  my $mw = $grp->{top};
  if ($guiFont) {
    $guiFont = prepareFont($grp,$guiFont,'C_gui');
    eval { $mw->optionAdd("*font",$guiFont); };
  }
  #TODO: z TrEd::Config $treeViewOpts, $font, $vLineFont 
  $treeViewOpts->{font} = $font = prepareFont($grp,$font,'C_normal');
  $vLineFont = prepareFont($grp,$vLineFont,'C_vline');
  for my $name (qw(small small_bold heading fixed default bold italic)) {
    my $fnt = $c_fonts{$name} || $c_font_defaults{$name};
    prepareFont($grp,$fnt,'C_'.$name);
  }
}

# bind
sub addBindTags {
  my $w=shift @_;
  $w->bindtags([@_,$w,ref($w),$w,$w->toplevel,'all']);
}

# sub cascadeMenus

# save button state update
sub saveFileStateUpdate {
  my ($win)=@_;
  my $grp = $win->{framegroup};
  return if $grp->{noSaveFileStateUpdate};
  
  return if (!$win->{framegroup}->{saveButton});
  
  if (eval { $win->isa('TrEd::Window') }) {
      return if (!$win->is_focused());
      $win->{framegroup}->{saveButton}->configure(
        -state => (($win->{FSFile} and $win->{FSFile}->notSaved) ? 'normal' : 'disabled'));
  }
  else {
      return;
  }
  
}

# 
sub About {
  my ($grp)=@_;
  my $message=EMPTY;
  my $contextinfo=EMPTY;
  my $fileinfo=EMPTY;
  my $colinf=EMPTY;
  if ($grp->{focusedWindow}->{FSFile}) {
    $fileinfo=
      "Current file:\n".
	$grp->{focusedWindow}->{FSFile}->filename."\n".
	  "Format: ".$grp->{focusedWindow}->{FSFile}->fileFormat.", ".$grp->{focusedWindow}->{FSFile}->lastTreeNo." trees\n";
    $contextinfo="Current context: ".$grp->{focusedWindow}->{macroContext}."\n";
    my %colinf=(Shadow=> [], Hilite=> [], XHilite=> []);
    my $some_color;
    foreach ($grp->{focusedWindow}->{FSFile}->FS->attributes) {
      my $color = $grp->{focusedWindow}->{FSFile}->FS->color($_);
      unless ($color eq 'normal') {
	push @{$colinf{$color}},$_ ;
	$some_color=1;
      }
    }
    if ($some_color) {
      $colinf="Coloured attributes:".
	"\n    Highlited: ".join(",",@{$colinf{Hilite}}).
	"\n    XHighlited: ".join(",",@{$colinf{XHilite}}).
	"\n    Shadow: ".join(",",@{$colinf{Shadow}})."\n";
    }
  }

  doEvalHook($grp->{focusedWindow},"about_file_hook",\$message);
  my $ver=$VERSION;
  $grp->{top}->toplevel->
    messageBox(-icon=> 'info',
	       -type=> 'ok',
	       -message=>
		 "This is Tree Editor TrEd\nVersion $ver\nRunning Tk $Tk::VERSION\n\n".
	       "\n\n$fileinfo$contextinfo$colinf$message\n".ABOUT."\n",
	       -title=> 'About');
}

#######################################################################################
# Usage         : new_TrEd_Window(\%tred);
# Purpose       : 
# Returns       : nothing
# Parameters    : hash_ref $tred -- tred hash reference
# Throws        : no exception
# Comments      : 
# See Also      : 
# Window
sub new_TrEd_Window {
  my ($grp) = @_;

  my $win= TrEd::Window->new(newTreeView($grp), framegroup => $grp);
  $win->{macroContext} = $init_macro_context && exists($TrEd::Macros::keyBindings{$init_macro_context}) 
    ? $init_macro_context : 'TredMacro';
  $win->{stylesheet} = STYLESHEET_FROM_FILE();
  my $windows = $grp->{treeWindows};
  my $focused_win = $grp->{focusedWindow};
  if ($focused_win) {
    @{$windows} = map { ( $_ == $focused_win) ? ($_,$win) : $_ } @{$windows};
  } else {
    push @{$windows}, $win;
  }
  $grp->{rmsplitButton}->configure(-state => @$windows>1 ? 'normal' : 'disabled')
    if $grp->{rmsplitButton};
  return $win;
}

#######################################################################################
# Usage         : new_TrEd_Window(\%tred);
# Purpose       : 
# Returns       : nothing
# Parameters    : hash_ref $tred -- tred hash reference
# Throws        : no exception
# Comments      : 
# See Also      : 
# TreeView
sub newTreeView {
  my ($grp)=@_;

  my $canvas=
    $grp->{top}->Scrolled('Canvas',
		   -width=> $defCWidth,
		   -height=> $defCHeight,
		   qw /-relief sunken
		       -borderwidth 2
                       -scrollbars se/,
		   -scrollregion=> [qw/0 0 0 0/],
		   $treeViewOpts->{backgroundColor} 
		   ? (-background=> $treeViewOpts->{backgroundColor}) : ()
		  );
  canvasBindMouseWheelVert($canvas,"", $grp);
  canvasBindMouseWheelHoriz($canvas,"Shift", $grp);
  canvasBindMouseScale($grp,$canvas,"Control");
  createCanvasBindings($grp,$canvas);
  addBindTags($canvas,'my');
  addBindTags($canvas->Subwidget('scrolled'),'canvas');

  my $balloon=$grp->{top}->Balloon(-initwait=> $canvasBalloonInitWait,
				  -state=> 'balloon',
				 );
  $balloon->Subwidget('message')->configure(-foreground=> $canvasBalloonForeground);

  $balloon->Tk::Toplevel::configure(-background=> $canvasBalloonBackground);
  $balloon->Subwidget('message')->configure(-justify=> 'left',-font=> $font);
  my $treeView=new TrEd::TreeView($canvas,'CanvasBalloon'=> $balloon);
  $treeView->apply_options($treeViewOpts);
  return $treeView;
}

# menu
sub NavigateMenuByFirstKey {
  my $w = shift;
  my $char = shift;
  return unless (defined $char);
  $char = lc($char);
  my $last = $w->index('last');
  my $active = $w->index('active');
  return if ($last eq 'none');
  $active = 0 if $active eq 'none';
  for my $i ( $active+1..$last, 0..$active ) {
    print STDERR "navigate menu\n" if $tredDebug;
    my $label = eval {local $SIG{__DIE__};  $w->entrycget($i,'-label') };
    next unless defined($label);
    $label = lc($label);
    if ((substr($label,0,1) eq $char) or
	  $label =~ /^[^[:alnum:]]\Q$char\E/) {
      $w->activate($i);
      return;
    }
  }
}

# window, UI
sub findCanvasWindow {
  my ($grp,$canvas)=@_;
  foreach my $w (@{$grp->{treeWindows}}) {
    return $w if $w->contains($canvas);
  }
  return undef;
}
# window, UI
sub focusNextWindow {
  my ($grp)=@_;
  my $windows=$grp->{treeWindows};
  my $idx = Index($windows,$grp->{focusedWindow});
  return focusCanvas($windows->[($idx+1) % @$windows]->canvas,$grp);
}
# window, UI
sub focusPrevWindow {
  my ($grp)=@_;
  my $windows=$grp->{treeWindows};
  my $idx = Index($windows,$grp->{focusedWindow});
  return focusCanvas($windows->[$idx-1]->canvas,$grp);
}
# window, UI
sub clearCanvasFocus {
  my ($grp)=@_;
  if ($grp->{focusedWindow}) {
    $grp->{focusedWindow}->canvas()->configure(@normal_win_opts);
    $grp->{focusedWindow}->canvas()->itemconfigure('stipple',-state=> $stippleInactiveWindows ? 'normal' : 'hidden');
  }
}
# window, UI
sub focusCanvas {
  my ($c,$grp)=@_;
  if ($grp->{focusedWindow}) {
    return if $grp->{focusedWindow}->contains($c);
    clearCanvasFocus($grp);
  }
  if ($c) {
    $c->configure(@focused_win_opts);
    $c->itemconfigure('stipple',-state=> 'hidden');
  }

  my $newfocus=findCanvasWindow($grp,$c);
  if ($newfocus) {
    my $prevcontext = $grp->{selectedContext};
    my $context = $newfocus->{macroContext};
    doEvalHook($grp->{focusedWindow},"pre_switch_context_hook",$prevcontext,$context,$newfocus); # stop is ignored here
    $grp->{selectedContext}=$context;
    my $prevfl=$grp->{focusedWindow}->{currentFilelist};
    $grp->{focusedWindow}=$newfocus;
    $grp->{selectedStylesheet} = $newfocus->{stylesheet};
    $treeViewOpts->{drawBoxes}=$newfocus->{treeView}->get_drawBoxes();
    $treeViewOpts->{drawEdgeBoxes}=$newfocus->{treeView}->get_drawEdgeBoxes();
    $treeViewOpts->{showHidden}=$newfocus->{treeView}->get_showHidden();
    $treeViewOpts->{highlightAttributes}=$newfocus->{treeView}->get_highlightAttributes;
    
    $grp->{valueLine}->update($grp);
    #TrEd::ValueLine::update($grp);
    $grp->{statusLine}->update_status($grp->{focusedWindow});
    $grp->{valueLine}->update_current($newfocus,$newfocus->{currentNode});
    TrEd::MinorModes::update_minor_modes($newfocus);
    update_title_and_buttons($grp);
    updateScaleFactor($grp);
    TrEd::Undo::reset_undo_status($newfocus);
    resetTreePosStatus($grp);
    update_session_status($grp);
    TrEd::List::Macros::update_view($grp);
    TrEd::Menu::Macro::updateCurrentContextMenu($grp);
    $grp->{StylesheetMenu}->update($grp);
    updateNodeMenu($grp);
    my $fl = $newfocus->{currentFilelist};
    #TODO: nie na sipkovu notaciu?
    TrEd::Filelist::View::update($grp,$fl,$fl == $prevfl ? 0 : 1);
    doEvalHook($newfocus,"switch_context_hook",$prevcontext,$context);
  } else {
    print STDERR "DID NOT FIND Window of $c\n";
  }
}

# window, UI, split
sub splitWindow {
  my ($grp,$dir,$opts)=@_;
  $opts ||= {};
  my $twin     = new_TrEd_Window($grp);
  my $canvas=$twin->canvas();
  $canvas->configure($opts->{no_focus} ? @normal_win_opts : @focused_win_opts);
  my $win = $grp->{focusedWindow};
  return unless $win;
  clearCanvasFocus($grp) unless $opts->{no_focus};
  $win->split_frame($canvas,$dir,$opts->{ratio});
  unless ($opts->{no_init}) {
    foreach (qw(FSFile treeNo currentNode currentFileNo macroContext currentFilelist)) {
      $twin->{$_}=$win->{$_};
    }
    $twin->{minorModes}=[ @{$win->{minorModes}||[]} ];
  }
  $twin->apply_stylesheet($grp->{selectedStylesheet});
  focusCanvas($canvas,$grp) unless $opts->{no_focus};
  unless ($opts->{no_redraw}) {
    $twin->get_nodes();
    $twin->redraw();
  }
  return $twin;
}

# window, UI
sub removeWindow {
  my ($grp,$win)=@_;
  $win ||= $grp->{focusedWindow};
  my $windows = $grp->{treeWindows};
  if (@{$windows} > 1) {
    doEvalHook($win,"pre_switch_context_hook",$win->{macroContext},'<NONE>',$win);
    @{$windows}=grep {$_ ne $win} @{$windows};
    $grp->{rmsplitButton}->configure(-state => 'disabled') if $grp->{rmsplitButton} and @{$windows}<=1;
    TrEd::File::closeFile($win,-no_update => 1, -keep_postponed => 1);
    my $brother=$win->canvas_destroy();
    if ($win == $grp->{focusedWindow}) {
      delete $grp->{focusedWindow};
      focusCanvas($brother,$grp);
    }
    $win->{treeView}=undef;
    undef $win;
  }
}

# UI, mouse wheel
sub canvasBindMouseScale {
  my($grp,$w,$modifier)= @_;
  $modifier.="-" if ($modifier);
  my $sub = sub {
    my ($c,$grp,$amount)=@_;
    $amount/=600; # Tk::Ev('D') gives at least 120 on Win32
    my $win;
    if ($c->isa('Tk::Toplevel')) {
      $win=$grp->{focusedWindow};
    } else {
      $win=findCanvasWindow($grp,$c);
    }
    my $tv=$win->treeView;
    my $scale =max2(-2,min2(2,$tv->{scale}+$amount));
    $tv->scale($scale,0);
    updateScaleFactor($grp);
    Tk->break;
  };
  for my $widget ($Tk::platform eq 'MSWin32' ?
		  ($grp->{top},$w) : ($w)) {
    $widget->Tk::bind("<${modifier}MouseWheel>", [ $sub, $grp, Tk::Ev("D")]);
  }
  if ($Tk::platform ne 'MSWin32') {
    $w->CanvasBind("<${modifier}4>", [ $sub, $grp, 60]);
    $w->CanvasBind("<${modifier}5>", [ $sub, $grp, -60]);
  }
}

# UI, mouse wheel
sub canvasBindMouseWheelVert {
    my($w,$modifier, $grp)= @_;
    $modifier||="";
    $modifier.="-" if ($modifier);
    for my $widget ($Tk::platform eq 'MSWin32' ? ($w->toplevel,$w) : ($w)) {
      $widget->Tk::bind("<$modifier"."MouseWheel>",
			[ sub {
			    $grp->{focusedWindow}->canvas()->yview('scroll',-($_[2]/120),'units')
			  }, $w, Tk::Ev("D"), $grp]);
    }
    if ($Tk::platform ne 'MSWin32') {
      $w->CanvasBind("<$modifier"."4>", sub { $_[0]->yview('scroll', -3, 'units')
						unless $Tk::strictMotif; 
					      Tk->break;
					    });
      $w->CanvasBind("<$modifier"."5>", sub { $_[0]->yview('scroll', 3, 'units')
						unless $Tk::strictMotif;
					      Tk->break;
					    });
      if ($modifier eq EMPTY) {
	$w->CanvasBind("<6>", sub { $_[0]->xview('scroll', -3, 'units')
				      unless $Tk::strictMotif; });
	$w->CanvasBind("<7>", sub { $_[0]->xview('scroll', 3, 'units')
				      unless $Tk::strictMotif; });
      }
    }
}

# UI, mouse wheel
sub canvasBindMouseWheelHoriz {
    my($w,$modifier, $grp)= @_;
    $modifier||="";
    $modifier.="-" if ($modifier);
    for my $widget ($Tk::platform eq 'MSWin32' ? ($w->toplevel,$w) : ($w)) {
      $widget->Tk::bind("<$modifier"."MouseWheel>",
			  [ sub {
			  	$grp->{focusedWindow}->canvas()->xview('scroll',-($_[2]/120),'units') }, $w, Tk::Ev("D"),$grp
			  ]);
    }
    if ($Tk::platform ne 'MSWin32') {
      $w->CanvasBind("<$modifier"."4>", sub { $_[0]->xview('scroll', -3, 'units')
						unless $Tk::strictMotif; });
      $w->CanvasBind("<$modifier"."5>", sub { $_[0]->xview('scroll', 3, 'units')
						unless $Tk::strictMotif; });
    }
}

# sub keyBind

# UI, canvas, bind
sub createCanvasBindings {
  my ($grp,$canvas) = @_;
  ## Canvas bindings 
  $canvas->CanvasBind('<ButtonPress>',[\&focusCanvas,$grp]);
  foreach my $tag (qw(text line)) {
    $canvas->bind($tag,
		  '<Any-Enter>'
		    => [sub{
			  my ($c,$grp)=@_;
			  my $win=findCanvasWindow($grp,$c);
			  my $tv=$win->treeView;
			  my ($t)=$tv->find_item('withtag','current');
			  my $node=$tv->get_obj_pinfo($t);
			  $tv->store_node_pinfo($node,"SaveColor",
						$c->itemcget($t,'-fill'));
			  $c->itemconfigure($t,-fill=> $activeTextColor);
			}, $grp]);

    $canvas->bind($tag,
		  '<Any-Leave>'
		    => [sub{
			  my ($c,$grp)=@_;
			  my $win=findCanvasWindow($grp,$c);
			  my $tv=$win->treeView;
			  my ($t)=$tv->find_item('withtag','current');
			  my $node=$tv->get_obj_pinfo($t);
			  $c->itemconfigure('current',
					    -fill=>
					      $tv->get_node_pinfo($node,"SaveColor"));
			}, $grp]);
  }
  # Button-1
  my ($dx,$dy);
  $canvas->CanvasBind('<Control-1>', [sub {
  					my ($c)=@_;
  					return if $c->find(withtag=>'current');
  					($dx,$dy) = ($c->canvasx($c->pointerx-$c->rootx),$c->canvasy($c->pointery-$c->rooty));
  					Tk->break;
  				      }]);
  $canvas->CanvasBind('<ButtonRelease-1>',sub {
			if (defined $dx) {
			  undef $dx; undef $dy;
			  Tk->break;
			}
		      });
  $canvas->CanvasBind('<B1-Motion>',
		      [sub {
			 return unless defined $dx;
			 my ($c,$grp)=@_;
			 return if $c->find(withtag=>'current');
			  my $win = findCanvasWindow($grp,$c);
			  my $tv=$win->treeView;
			  my $t = $tv->get_node_pinfo($win->{currentNode},'Oval');
			  my ($x,$y) = ($c->canvasx($c->pointerx-$c->rootx),$c->canvasy($c->pointery-$c->rooty));
			  if ($t) {
			    my @corners = ( $c->canvasx(0)-10, $c->canvasy(0)-10,
					    $c->canvasx($c->width)+10, $c->canvasy($c->height)+10 );
			    my @scrollregion=@{$c->cget('-scrollregion')};
			    $c->configure(-scrollregion =>
					    [ min($corners[0]-$x+$dx,$scrollregion[0]),
					      min($corners[1]-$y+$dy,$scrollregion[1]),
					      max($corners[2]-$x+$dx,$scrollregion[2]),
					      max($corners[3]-$y+$dy,$scrollregion[3]) ] );
			    $c->xviewCoord($dx,$c->xviewCoord($x));
			    $c->yviewCoord($dy,$c->yviewCoord($y));
			    Tk->break;
			  }
		      },$grp]);
  $canvas->bind('point', '<1>'=> [sub {node_down(@_) },$grp,0]);
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('point', "<$_-Button-1>"=> [sub {node_click_modif(@_)},$grp,$_]);
  }
  $canvas->bind('point', '<ButtonRelease-1>'=> [sub {node_release(@_)},$grp,0]);
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('point', "<$_-ButtonRelease-1>"=> [sub {node_release_modif(@_)},$grp,$_]);
  }
  $canvas->bind('point', '<B1-Motion>'=> [sub {node_move(@_)},$grp]);
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('point', "<$_-B1-Motion>"=> [sub {node_motion_modif(@_)},$grp]);
  }

  # Button-3
  $canvas->bind('point','<3>'=> [sub {node_down(@_)},$grp,1]);
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('point', "<$_-Button-3>"=> [sub {node_click_modif(@_)},$grp,"-3"]);
  }
  $canvas->bind('point', '<ButtonRelease-3>'=> [sub {node_release(@_)},$grp,3]);
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('point', "<$_-ButtonRelease-3>"=> [sub {node_release_modif(@_)},$grp,"$_-3"]);
  }
  $canvas->bind('point','<B3-Motion>'=> [sub {node_move(@_)},$grp,1]);
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('point', "<$_-B3-Motion>"=> [sub {node_motion_modif(@_)},$grp,"$_-3"]);
  }

  # Button-2
  $canvas->CanvasBind('<2>'=> [sub {follow_mouse_press(@_)},$grp]);
  $canvas->CanvasBind('<B2-Motion>'=> [sub {follow_mouse(@_)},$grp]);

  # Button-2
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('point', "<$_-Button-2>"=> [sub {node_click_modif(@_)},$grp,$_,"$_-2"]);
  }
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('point', "<$_-ButtonRelease-2>"=> [sub {node_release_modif(@_)},$grp,"$_-2"]);
  }
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('point', "<$_-B2-Motion>"=> [sub {node_motion_modif(@_)},$grp,"$_-2"]);
  }

  # Text 1
  for my $tag (qw(plaintext text textbg textbox edgebox stripe)) {
    $canvas->bind($tag, '<1>'=> [sub {node_down(@_) },$grp,0]);
    $canvas->bind($tag, '<B1-Motion>'=> [sub {node_move(@_) },$grp,0]);
    $canvas->bind($tag, '<ButtonRelease-1>'=> [sub {node_release(@_)},$grp,0]);
    foreach (qw(Shift Control Alt Meta)) {
      $canvas->bind($tag, "<$_-B1-Motion>"=> [sub {node_motion_modif(@_)},$grp]);
      $canvas->bind($tag, "<$_-B2-Motion>"=> [sub {node_motion_modif(@_)},$grp,"$_-2"]);
      $canvas->bind($tag, "<$_-B3-Motion>"=> [sub {node_motion_modif(@_)},$grp,"$_-3"]);
      $canvas->bind($tag, "<$_-ButtonRelease-1>"=> [sub {node_release_modif(@_)},$grp,$_]);
      $canvas->bind($tag, "<$_-ButtonRelease-2>"=> [sub {node_release_modif(@_)},$grp,"$_-2"]);
      $canvas->bind($tag, "<$_-ButtonRelease-3>"=> [sub {node_release_modif(@_)},$grp,"$_-3"]);
      $canvas->bind($tag, "<$_-Button-1>"=> [sub {text_click_modif(@_)},$grp,$_]);
      $canvas->bind($tag, "<$_-Button-2>"=> [sub {text_click_modif(@_); Tk->break; },$grp,"$_-2"]);
      $canvas->bind($tag, "<$_-Button-3>"=> [sub {text_click_modif(@_); Tk->break; },$grp,"$_-3"]);
    }
  }

  # Text Dobule-1
  for my $tag (qw(text textbg)) {
    $canvas->bind($tag, '<Double-1>'=> [sub { editAttr(@_); Tk->break; },$grp]);
    for my $but (2,3) {
      $canvas->bind($tag, "<Double-$but>"=> [sub {text_doubleclick_modif(@_); Tk->break; },$grp,"$but"]);
    }
    foreach (qw(Shift Control Alt Meta)) {
      $canvas->bind($tag, "<$_-Double-1>"=> [sub {text_doubleclick_modif(@_); Tk->break; },$grp,$_]);
      for my $but (2,3) {
	$canvas->bind($tag, "<$_-Double-$but>"=> [sub {text_doubleclick_modif(@_); Tk->break; },$grp,"$_-$but"]);
      }
    }
  }

  # point Double-1
  $canvas->bind('point', "<Double-1>"=> [sub { editAttrs(@_); Tk->break; },$grp]);
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('point', "<$_-Double-1>"=> [sub { node_doubleclick_modif(@_); Tk->break; },$grp,$_]);
  }

  # Line clicks
  for my $modif (undef,qw(Shift Control Alt Meta)) {
    for my $clicktype (qw(Button Double)) {
      for my $button (1..3) {
	my $event = join '-',grep {defined} ($modif, $clicktype, $button);
	$canvas->bind('line', "<$event>"=> 
			[
			  sub {line_click(@_)},$grp,
			  $button,
			  $clicktype eq 'Double' ? 1 : 0,
			  $modif
			 ]);
      }
    }
  }
}

sub _menu_swaps {
  return (
    ['MENUBAR:NODE:UP_LEVEL'      => 'MENUBAR:NODE:LEFT_SIBLING'],
    ['MENUBAR:NODE:DOWN_LEVEL'    => 'MENUBAR:NODE:RIGHT_SIBLING'],
   );
}

# node, menu
sub updateNodeMenu {
  my ($grp_or_win) = @_;
  my ($grp,$win) = grp_win($grp_or_win);
  my $m = $grp->{main_menu};
  return unless $m and
    (($grp->{main_menu_tree_orientation_state} ? 1 : 0) != (TrEd::Window::TreeBasics::tree_is_vertical($grp) ? 1 : 0));
  $grp->{main_menu_tree_orientation_state}=TrEd::Window::TreeBasics::tree_is_vertical($grp);
  for my $swap (_menu_swaps()) {
    my ($item1,$item2) = @$swap;
    my $accel1 = $m->get_menu_option($item1,'-accelerator');
    my $accel2 = $m->get_menu_option($item2,'-accelerator');
    $m->set_menu_options($item1, -accelerator => $accel2);
    $m->set_menu_options($item2, -accelerator => $accel1);
  }
}

sub _change_orientation {
  my ($grp)=@_;
  my $win=$grp->{focusedWindow};
  $win->treeView->set_displayMode($treeViewOpts->{displayMode});
  $win->redraw();
  $win->ensure_current_is_displayed();
  updateNodeMenu($grp);
}

sub _load_menus {
  my ($grp)=@_;
  my $path = File::Spec->catfile($libDir,'TrEd','Menu','menubar.inc');
  my $code = do $path;
  return $code->($grp);
}

sub _tk_dialog_alternative {
  my ($old) = @_;
  my $d = &$old;
  if ($d) {
    for my $widget ( grep { $_->isa('Tk::Button') } $d->Subwidget ) {
      $widget->configure(-padx=>7, -pady=>2, -width=>0);
    }
  }
  return $d;
};

sub create_split_windows {
  my ($opt_split_window, $opt_filelist, $tred_ref) = @_;
  my $dir=$opt_split_window>0 ? 'vert' : 'horiz';
  my @fl = $opt_filelist=~/,/g;
  my $fl=@fl+1;
  if ($fl>1) {
    $fl=TrEd::MinMax::min($opt_split_window,$fl);
    my $i;
    for (my $i=0;$i<$fl;$i++) {
      focusCanvas($tred_ref->{treeWindows}->[$i]->canvas,$tred_ref);
      TrEd::ManageFilelists::selectFilelist($tred_ref->{treeWindows}->[$i],"CmdLine-".($i+1));
      TrEd::Filelist::Navigation::go_to_file($tred_ref->{treeWindows}->[$i],0);
    }
  }
  else {
    for (my $i=1;$i<$opt_split_window;$i++) {
      focusCanvas($tred_ref->{treeWindows}->[$i]->canvas,$tred_ref);
      $tred_ref->{treeWindows}->[$i]->{currentFilelist} = $tred_ref->{treeWindows}->[0]->{currentFilelist};
      TrEd::Filelist::Navigation::go_to_file($tred_ref->{treeWindows}->[$i],$i);
    }
  }
  focusCanvas($tred_ref->{treeWindows}->[0]->canvas,$tred_ref);
  $tred_ref->{tieWindows}=1;
}

sub populate_recent_files_menu {
  my ($grp_ref, $recent_files_ref) = @_;
  my $recentFileMenu = $grp_ref->{RecentFileMenu};
  
  my $i = 0;
  foreach my $recent_file (@{$recent_files_ref}) {
    $recentFileMenu->command(
          -label      => "$i.  $recent_file",
          -underline  => 0,
          -command    => [\&TrEd::File::openStandaloneFile, $grp_ref, $recent_file]
    );
    $i++;
  }
}

sub create_toolbar_buttons {
    my ($tred_ref) = @_;
  print STDERR "Creating buttons.\n" if $tredDebug;

  $tred_ref->{nextButton}=
    $tred_ref->{Toolbar}->Button(-takefocus=>0,
			  -text=> "Next",
			  -relief=> $buttonsRelief,
			  -image=> icon($tred_ref,"1rightarrow"),
			  -state=> 'disabled',
			  -borderwidth=> $buttonBorderWidth,
			  -command=>
			  [\&tieNextTree,$tred_ref]);
  $tred_ref->{Balloon}->attach($tred_ref->{nextButton},
			  -balloonmsg=> "see the next tree in the file");
  addBindTags($tred_ref->{nextButton},'my');

  $tred_ref->{prevButton}=
    $tred_ref->{Toolbar}->Button(-takefocus=>0, -text=> "Prev",
			  -relief=> $buttonsRelief,
			  -image=> icon($tred_ref,"1leftarrow"),
			  -state=> 'disabled',
			  -borderwidth=> $buttonBorderWidth,
			  -command=>
			  [\&tiePrevTree,$tred_ref]);
  $tred_ref->{Balloon}->attach($tred_ref->{prevButton},
			  -balloonmsg=> "see the previous tree the file");
  addBindTags($tred_ref->{prevButton},'my');

  $tred_ref->{openButton}=
    $tred_ref->{Toolbar}->Button(-takefocus=>0, -text=> "Open",
			  -relief=> $buttonsRelief,
			  -image=>
			  icon($tred_ref,"fileopen"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=>
			  [\&TrEd::Dialog::File::Open::show_dialog,$tred_ref])
      ->pack(-side=>'left');
  $tred_ref->{Balloon}->attach($tred_ref->{openButton},
		 -balloonmsg=> "open file");
  addBindTags($tred_ref->{openButton},'my');
  $tred_ref->{saveButton}=
    $tred_ref->{Toolbar}->Button(-takefocus=>0, -text=> "Save",
			  -relief=> $buttonsRelief,
			  -image=> icon($tred_ref,"filesave"),
			  -state => 'disabled',
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&TrEd::File::saveFile,$tred_ref])->pack(-side=>'left');

  $tred_ref->{Balloon}->attach($tred_ref->{saveButton},
			  -balloonmsg=> "save current file");
  addBindTags($tred_ref->{saveButton},'my');

  $tred_ref->{reloadButton}=
    $tred_ref->{Toolbar}->Button(-takefocus=>0, -text=> "Reload",
			  -relief=> $buttonsRelief,
			  -image=> icon($tred_ref,"reload"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&TrEd::File::reloadFile,$tred_ref])->pack(-side=>'left');

  $tred_ref->{Balloon}->attach($tred_ref->{reloadButton},
			  -balloonmsg=> "reload current file");
  addBindTags($tred_ref->{reloadButton},'my');


  ###################

  $tred_ref->{prevFileButton}=
    $tred_ref->{Toolbar}->Button(-takefocus=>0, -text=> "Prev file",
			  -relief=> $buttonsRelief,
			  -image=> icon($tred_ref,"start"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&TrEd::Filelist::Navigation::tie_prev_file,$tred_ref])->pack(-side=>'left');
  $tred_ref->{Balloon}->attach($tred_ref->{prevFileButton},
			  -balloonmsg=> "visit the previous file in the file-list");
  addBindTags($tred_ref->{prevFileButton},'my');

  $tred_ref->{nextFileButton}=
    $tred_ref->{Toolbar}->Button(-takefocus=>0, -text=> "Next file",
			  -relief=> $buttonsRelief,
			  -image=> icon($tred_ref,"finish"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&TrEd::Filelist::Navigation::tie_next_file,$tred_ref])->pack(-side=>'left');
  $tred_ref->{Balloon}->attach($tred_ref->{nextFileButton},
			  -balloonmsg=> "visit the next file in the file-list");
  addBindTags($tred_ref->{nextFileButton},'my');

  # bind action control
  for my $bind ([nextFileButton => \&TrEd::Filelist::Navigation::next_real_file],
		[prevFileButton => \&TrEd::Filelist::Navigation::prev_real_file]) {
    my $button = $tred_ref->{$bind->[0]};
    my $cmd = $bind->[1];
    $button->bindtags([$button, ref($button), $button->toplevel, 'all']);
    $button->bind($button, '<Control-ButtonRelease-1>',
		  sub {
		    $button->flash();
		    $cmd->($tred_ref);
		    Tk->break;
		  });
  }

  $tred_ref->{printButton}=
    $tred_ref->{Toolbar}->Button(-takefocus=>0, -text=> "Print",
			  -relief=> $buttonsRelief,
			  -image      => icon($tred_ref,"fileprint"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [sub { printThis(@_) },$tred_ref])->pack(-side=>'left');
  $tred_ref->{Balloon}->attach($tred_ref->{printButton},
			  -balloonmsg=> "print ...");
  addBindTags($tred_ref->{printButton},'my');


  #####################
  $tred_ref->{Toolbar}->Frame(-bd => 2, -width => 2, -relief => 'groove')
    ->pack(-side=> 'left', -padx => '3', -fill => 'y', -pady => 3);

  # Undo button

  $tred_ref->{undoButton}=
    $tred_ref->{Toolbar}->Button(-takefocus=>0, -text=> "Undo",
			  -relief=> $buttonsRelief,
			  -image=> icon($tred_ref,"undo"),
			  -state=> 'disabled',
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&TrEd::Undo::undo,$tred_ref])->pack(-side=>'left');
  $tred_ref->{Balloon}->attach($tred_ref->{undoButton},
			  -balloonmsg=> "undo current file");
  addBindTags($tred_ref->{undoButton},'my');

  # Redo button

  $tred_ref->{redoButton}=
    $tred_ref->{Toolbar}->Button(-takefocus=>0, -text=> "Redo",
			  -relief=> $buttonsRelief,
			  -image=> icon($tred_ref,"redo"),
			  -state=> 'disabled',
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&re_do,$tred_ref])->pack(-side=>'left');
    
  $tred_ref->{Balloon}->attach($tred_ref->{redoButton},
			  -balloonmsg=> "redo current file");
  addBindTags($tred_ref->{redoButton},'my');

  #####################
  $tred_ref->{Toolbar}->Frame(-bd => 2, -width => 2, -relief => 'groove')
    ->pack(-side=> 'left', -padx => '3', -fill => 'y', -pady => 3);


  $tred_ref->{findButton}=
    $tred_ref->{Toolbar}->Button(-takefocus=>0, -text=> "Find",
			  -relief=> $buttonsRelief,
			  -image      => icon($tred_ref,"searchtool"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [sub {
					my ($grp)=@_;
					TrEd::Dialog::FindNode::findNodeDialog($grp)
					  if ($grp->{focusedWindow}->{currentNode});
				      },$tred_ref])->pack(-side=>'left');
  $tred_ref->{Balloon}->attach($tred_ref->{findButton},
			  -balloonmsg=> "Find node ...");
  addBindTags($tred_ref->{findButton},'my');

  $tred_ref->{findNextButton}=
    $tred_ref->{Toolbar}->Button(-takefocus=>0, -text=> "Find Next",
			  -relief=> $buttonsRelief,
			  -image      => icon($tred_ref,"searchtool_forward"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&doFindFirstTemplated,$tred_ref,1])
      ->pack(-side=>'left');
  $tred_ref->{Balloon}->attach($tred_ref->{findNextButton},
			  -balloonmsg=> "Find next ...");
  addBindTags($tred_ref->{findNextButton},'my');


  $tred_ref->{findPrevButton}=
    $tred_ref->{Toolbar}->Button(-takefocus=>0, -text=> "Find Previous",
			  -relief=> $buttonsRelief,
			  -image=> icon($tred_ref,"searchtool_backward"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&doFindPrevTemplated,$tred_ref,1])
      ->pack(-side=>'left');
  $tred_ref->{Balloon}->attach($tred_ref->{findPrevButton},
			  -balloonmsg=> "Find previous ...");
  addBindTags($tred_ref->{findPrevButton},'my');

  $tred_ref->{Toolbar}->Frame(-bd => 2, -width => 2, -relief => 'groove')
    ->pack(-side=> 'left', -padx => '3', -fill => 'y', -pady => 3);

  $tred_ref->{prevButton}->pack(-side=> 'left');
  $tred_ref->{nextButton}->pack(-side=> 'left');

  #####################
  $tred_ref->{Toolbar}->Frame(-bd => 2, -width => 2, -relief => 'groove')
    ->pack(-side=> 'left', -padx => '3', -fill => 'y', -pady => 3);

  $tred_ref->{vsplitButton}=
    $tred_ref->{Toolbar}->Button(-takefocus=>0, 
			  -text=> "Split View Vertically",
			  -relief=> $buttonsRelief,
			  -image=> icon($tred_ref,"view_left_right"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&splitWindow,$tred_ref,'vert'])->pack(-side=>'left');
  $tred_ref->{Balloon}->attach($tred_ref->{vsplitButton},
			  -balloonmsg=> "split view vertically");

  $tred_ref->{hsplitButton}=
    $tred_ref->{Toolbar}->Button(-takefocus=>0, 
			  -text=> "Split View Horizontally",
			  -relief=> $buttonsRelief,
			  -image=> icon($tred_ref,"view_top_bottom"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&splitWindow,$tred_ref,'horiz'])->pack(-side=>'left');


  $tred_ref->{Balloon}->attach($tred_ref->{hsplitButton},
			  -balloonmsg=> "split view horizontally");

  $tred_ref->{rmsplitButton}=
    $tred_ref->{Toolbar}->Button(-takefocus=>0, 
			  -text=> "Remove Current View",
			  -relief=> $buttonsRelief,
			  -state => 'disabled',
			  -image=> icon($tred_ref,"view_remove"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&removeWindow,$tred_ref])->pack(-side=>'left');
  $tred_ref->{Balloon}->attach($tred_ref->{rmsplitButton},
			  -balloonmsg=> "remove current view");


  $tred_ref->{tieWinddowsButton}=
    $tred_ref->{Toolbar}->Checkbutton(-takefocus=>0,
			      -text=> "Tie Displayed Windows",
			      -variable=> \$tred_ref->{tieWindows},
			       -relief=> $buttonsRelief,
			      -indicatoron => 0,
			      -image=>icon($tred_ref,"lock"),
			      -borderwidth=> $buttonBorderWidth)->pack(-side=>'left');
  $tred_ref->{Balloon}->attach($tred_ref->{tieWinddowsButton},
			  -balloonmsg=> "tie all views");

  $tred_ref->{Toolbar}->Frame(-bd => 2, -width => 2, -relief => 'groove')
    ->pack(-side=> 'left', -padx => '3', -fill => 'y', -pady => 3);

  $tred_ref->{toggleUserToolbarButton}=
    $tred_ref->{Toolbar}->Menubutton(-takefocus=>0,
				-tearoff=>0,
				-text=> "Toggle User Toolbars",
				-relief=> $buttonsRelief,
				-indicatoron => 0,
				-state => 'disabled',
				-image=>icon($tred_ref,"1downarrow"),
				-borderwidth=> $buttonBorderWidth)->pack(-side=>'left');
  $tred_ref->{Balloon}->attach($tred_ref->{toggleUserToolbarButton},
			  -balloonmsg=> "toggle user-defined toolbars");


  ##########################
    return;
    
}

sub create_stylesheet_menu {
    my ($tred_ref) = @_;
    
    $tred_ref->{StylesheetMenu} = TrEd::Menu::Stylesheet->new($tred_ref);
  
  $tred_ref->{attrButton}=
    $tred_ref->{Toolbar}->Button(-takefocus=>0, -text=> "Edit Stylesheet",
			  -relief=> $buttonsRelief,
			  -image=> icon($tred_ref,"wizard"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [sub { TrEd::Dialog::EditStylesheet::show_dialog(@_) },$tred_ref])->pack(-side=>'right');
  $tred_ref->{Balloon}->attach($tred_ref->{attrButton},
			  -balloonmsg=> "customize display patterns\nof the selected stylesheet\n(e.g. change tree appearance, labels etc.)");
  
  $tred_ref->{StylesheetMenuLabel}=$tred_ref->{Toolbar}->Label(qw/-text Style:
							-font C_small
							-underline 2/)->pack(qw/-side right/);
  
  $tred_ref->{Balloon}->attach($tred_ref->{StylesheetMenu}->get_menu(),
			  -balloonmsg=> "stylesheet (tree appearance)");
  
  

  print STDERR "Packing widgets.\n" if $TrEd::Config::tredDebug;

  $tred_ref->{Toolbar}->pack(-fill=> 'x', -padx=> '1', -pady=> 1);
  return;
}

sub create_value_line_subframe {
    my ($tred_ref) = @_;
    
    my $vlsubframe=$tred_ref->{vLineFrame}->Frame();
  $tred_ref->{vLineNumLabel}=$vlsubframe->Label(-text => '-/-')->pack(qw/-side top -fill x/);
  $tred_ref->{Balloon}->attach($tred_ref->{vLineNumLabel},
			  -balloonmsg=> "position of the current tree\nin the file (current/total)");
  
  $tred_ref->{sentButton}=
    $vlsubframe->Button(-takefocus=>0, -text=> "Sentences",
			-relief=> $buttonsRelief,
			-image=> icon($tred_ref,"contents"),
			-borderwidth=> $buttonBorderWidth,
			-command=> [\&TrEd::View::Sentence::show_sentences, $tred_ref])
      ->pack(qw/-side top -fill x/);
  $tred_ref->{Balloon}->attach($tred_ref->{sentButton},
			  -balloonmsg=> "View all trees as a list of 'sentences'...\nThis dialog also allows export to HTML.");

  $vlsubframe->pack(qw/-fill x -side right -padx 1 -anchor n/);
  
  
  $tred_ref->{valueLine}->value_line_widget()->pack(qw/-side left -fill both -expand yes/);
  $tred_ref->{vLineFrame}->pack(qw/-fill x -expand no/);


  $tred_ref->{vLineSeparator}->packAfter($tred_ref->{vLineFrame},-side => 'top');
 return;
}

sub startMain {
  my $node;
  my $parent;
  my %tred; # gathers TrEd window global data, also referred to as $grp, the 'frame group'
            # since we thought that in the future we'll support multiple windows
            # and windows are called frames in the emacs terminlology

  my $top;
  if ($opt_W) {
    $top=Tk::MainWindow->new(-use => $opt_W);
  } else {
    $top=Tk::MainWindow->new();
  }
  Tk::MiscWorkarounds::apply_workarounds($top);
  $tred{top} = $top;

  $Treex::PML::IO::lwp_user_agent = TrEd::UserAgent->new($top, keep_alive=>1);



  if ($^O eq 'MSWin32') {
    # a workaround for focus being lost after popup menu usage on Win32
    
    # this is already in apply_workarounds function
    # require Tk::Menu;
    # $top->bind('Tk::Menu', '<<MenuSelect>>', sub { if ($Tk::popup) { $Tk::popup->Unpost; } });

    # a workaround for dialog buttons showing only partial labels in Windows
    require Tk::DialogBox;
    {
      my $old=\&Tk::Widget::DialogBox;
      *Tk::Widget::DialogBox = sub {
            my $d = &$old;
            if ($d) {
                for my $w ( grep $_->isa('Tk::Button'), $d->Subwidget ) {
                    $w->configure(-padx=>7, -pady=>2, -width=>0);
                }
            }
            return $d;
      };
    }
    require Tk::Dialog;
    {
      my $old=\&Tk::Widget::Dialog;
      *Tk::Widget::Dialog = sub {
          my $d = &$old;
          if ($d) {
              for my $w ( grep $_->isa('Tk::Button'), $d->Subwidget ) {
                  $w->configure(-padx=>7, -pady=>2, -width=>0);
              }
          }
          return $d;
      };
    }

  }


  for (qw(ROText Text TextUndo Entry LabEntry HistEntry SimpleHistEntry
	  Listbox HList CodeText)) {
    $top->optionAdd("\*$_.background", 'white');
    $top->optionAdd("\*$_.foreground", 'black');
    $top->optionAdd("\*$_.disabledBackground", 'lightgray');
    $top->optionAdd("\*$_.disabledForeground", 'gray20');
  }
  if (!$TrEd::Config::enableTearOff) {
    for (qw(Menu)) {
      $top->optionAdd("\*$_.tearOff",0);
    }
  }

  if ($^O ne 'MSWin32') {
    $top->optionAdd("\*Scrollbar.width","10");
    $top->optionAdd("\*Scrollbar.elementBorderWidth","1");
    $top->optionAdd("\*Scrollbar.borderWidth","1");
    $top->optionAdd("\*Scrollbar.troughColor","gray80");
  }
  #TODO: tie scrollbars sa nejak zresetuju, prid na to, preco a ako!
#  my $bg = $top->optionGet('width','*Scrollbar');
#  my $abg = $top->optionGet('borderWidth','*Scrollbar');
#  print "width: $bg\nborder: $abg\n";
  
  
  {
    # make sure button flashes are visible
    my $bg = $top->optionGet('Button.background','Background');
    my $abg = $top->optionGet('Button.activeBackground','ActiveBackground');
    my $H='[a-z0-9]{2}';
    my $level = 7;
    if (($bg eq $abg) and $abg=~/^\#($H)($H)($H)$/ogi) {
      my ($r,$g,$b) = map { hex } $1,$2,$3;
      if (!first {$_>=255-$level} ($r,$g,$b)) {
        # lighten
        for ($r,$g,$b) {
          $_ += $level;
        }
      } 
      else {
        # darken
        $_-=$level for $r,$g,$b;
      }
      $abg = '#' . join q{}, map { sprintf('%02x', TrEd::MinMax::min(abs($_),255)) } $r,$g,$b;
      $top->optionAdd('*Button.activeBackground', $abg);
    }
  }

  if ($TrEd::Convert::support_unicode) {
    $top->useinputmethods(1);
  }
  my $preparedExtensions = TrEd::Extensions::prepare_extensions($opt_m); #<- sets up new stylesheet, resources, macor paths
  TrEd::Stylesheet::load_stylesheets(\%tred);

  
  Readonly my $milisec_per_min => 60000;
  
  if ($autoSave > 0) {
    $tred{autoSaveCallback}=$top->repeat($autoSave * $milisec_per_min, [\&autoSaveAll, \%tred]) ;
  }

  $tred{folderImage}= icon(\%tred,'folder');
  $tred{fileImage}  = icon(\%tred,'document');
  TrEd::Bookmarks::set_last_action($TrEd::Config::lastAction);
  $tred{selectedContext}=  $init_macro_context || 'TredMacro';
  $tred{buildTGTSfromCSTS}=$opt_R;

  if (!defined $opt_G && defined $TrEd::Config::geometry && length $TrEd::Config::geometry) {
    if ($TrEd::Config::geometry =~ /^(.*)x(.*)\+([0-9]+)\+([0-9]+)/) {
        $TrEd::Config::geometry
	 = "$1x$2+" . TrEd::MinMax::min($3, $top->vrootwidth() - $1).
	    "+" . TrEd::MinMax::min($4, $top->vrootheight() - $2);
    }
    $top->geometry($TrEd::Config::geometry);
  }
  if ($opt_W) {

    $TrEd::Config::geometry = "600x400";
    $top->sizefrom('program');
    $top->geometry($TrEd::Config::geometry);
  }
  prepareFonts(\%tred);
  $tred{treeWindows}=[];
  $tred{focusedWindow}=new_TrEd_Window(\%tred);
  my $canvas = $tred{focusedWindow}->canvas();
  $canvas->configure(@focused_win_opts);

  print STDERR "Main window created.\n" if $tredDebug;

  if (-f $TrEd::Config::appIcon) {
    print STDERR "adding icon-image.\n" if $tredDebug;
    $top->iconimage($top->Pixmap(-file=> "$TrEd::Config::appIcon"));
    print STDERR "done.\n" if $tredDebug;
  }

#  $top->focusFollowsMouse;
  addBindTags($top,'my');

  print STDERR "Asking wm for exit-hook.\n" if $tredDebug;

  $top->protocol('WM_DELETE_WINDOW'=> [\&quit,\%tred]);


  print STDERR "Exit hook created.\n" if $tredDebug;

  $tred{Balloon}=$top->Balloon(-initwait=> $toolbarBalloonInitWait,
				       -balloonposition=> 'mouse',
				       -state=> 'balloon',
				      );
  $tred{Balloon}->Subwidget('message')->configure(-foreground=> $toolbarBalloonForeground);
  $tred{Balloon}->Tk::Toplevel::configure(-background=> $toolbarBalloonBackground);
  $tred{Toolbar}=$top->Frame;

  print STDERR "Creating menubar.\n" if $tredDebug;

  # make old calls work
  require Tk::Menu::Item;
  *Tk::Menu::Item::entryconfigure = sub {
    my ($menu,$name,%args) = @_;
    my $m = $menu->menu;
    $m->entryconfigure($m->index($name),%args);
  };
 


  # We need to pack in an optionmenu, so we cannot use menubar on windows
  # and cannot use Toplevel->configure(-menu) on other systems
  my $main_menu = $tred{main_menu} = TrEd::Menu->new(_load_menus(\%tred));
  my $menubar;
  if ($^O eq 'MSWin32') {
    $menubar = $tred{Menubar} = $tred{MenubarFrame} =
      $tred{main_menu}->create_menu_frame($top, 'MENUBAR', { -relief=> $menubarRelief });
  } else {
    $tred{MenubarFrame}=$top->Frame();
    $menubar = $tred{Menubar} =
      $tred{main_menu}->create_menubar($tred{MenubarFrame}, 'MENUBAR', { -relief=> $menubarRelief });
    $menubar->pack(qw/-fill x -expand 1 -side left/);
  }
  $tred{MenubarFrame}->pack(qw/-fill x/);
  $menubar->bind('Tk::Menu','<Tab>',['NextEntry',1]);
  $menubar->bind('Tk::Menu','<<LeftTab>>',['NextEntry',-1]);
  $top->Frame(qw/-relief sunken -height 2 -borderwidth 2/)->pack(qw/-fill x/);
  addBindTags($menubar,'my');
  {
    my %map = (
      FileMenu=>'MENUBAR:FILE',
      RecentFileMenu=>'MENUBAR:FILE:RECENT',
      NodeMenu => 'MENUBAR:NODE',
      NodeMenu=>'MENUBAR:NODE',
      TreeMenu=>'MENUBAR:TREE',
      ViewMenu=>'MENUBAR:VIEW',
      ToolsMenu=>'MENUBAR:MACROS',
      UserMenu=>'MENUBAR:MACROS:ALL_MODES',
      CurrentContextMacroMenu=> 'MENUBAR:MACROS:CURRENT_MODE',
      MinorModesMainMenu=> 'MENUBAR:VIEW:TOGGLE_MINOR_MODES',
      SetupMenu=> 'MENUBAR:SETUP',
      HelpMenu=> 'MENUBAR:HELP',
      SessionMenu=>'MENUBAR:FILE:FILE_LISTS',
      BookmarkMenu=>'MENUBAR:FILE:BOOKMARKS',
      PostponedFileMenu=>'MENUBAR:FILE:KEPT_IN_MEMORY',
      BookmarksFileMenu=>'MENUBAR:FILE:BOOKMARKS:GO_TO_BOOKMARK',
    );
    my ($k,$v)=@_; #TODO: ???? @_?!
    while (($k,$v) = each %map) {
      $tred{$k}=$main_menu->lookup_menu_item($v);
    }
    
    my @recent_files = TrEd::RecentFiles::recent_files();
    populate_recent_files_menu(\%tred, \@recent_files);
    
  }
  $tred{templateMatchMethod}=$TrEd::Config::defaultTemplateMatchMethod;
  $tred{macroListOrder}=$TrEd::Config::defaultMacroListOrder;
    
    if (!exists $TrEd::Macros::keyBindings{ $tred{selectedContext} }) {
        $tred{selectedContext} =  'TredMacro';
    }
  
  $tred{ContextsMenu} = TrEd::Menu::Context->new($tred{MenubarFrame}, \%tred);  
  $tred{ContextsMenuLabel}=$tred{MenubarFrame}->Label(-text=>'Mode:',
							-font => 'C_small',
							-underline=>1)->pack(qw/-side right/);
  $tred{Balloon}->attach($tred{ContextsMenu}->get_menu(), -balloonmsg=> "Annotation Mode");


  addBindTags($tred{Toolbar},'my');

  TrEd::Bookmarks::update_bookmarks(\%tred);

  $tred{vLineFrame}=$top->Frame();
  $tred{valueLine}=TrEd::ValueLine->new($tred{vLineFrame}, \%tred);
  $tred{vLineSeparator}=$top->Adjuster();
  
    
  my $bf = $tred{bottomFrame}=$top->Frame;
  if ($displayStatusLine) {
    my $sl= $tred{statusLine}=TrEd::StatusLine->new($bf, \%tred);

  }
  {
    $tred{minorModesMenu} = $bf->Menubutton(-image=>icon(\%tred,'puzzle'),-direction=>'above')->pack(-side => 'left',-expand => 'no');
    my $menu = $tred{minorModesMenu}->menu(qw/-tearoff 0/);
    $tred{minorModesMenu}->configure(-menu => $menu);
    $tred{minorModesLabelFrame} = $bf->Frame()->pack(-side => 'left',-expand => 'no',-padx=>5);
    $tred{minorModesLabels}={};
    $tred{Balloon}->attach($tred{minorModesMenu},
			    -balloonmsg=> "Enable/disable additional features\n(a.k.a. minor modes)");
  }
  {
    $tred{canvasScale}=0;
    $tred{canvasScaleLabel} = $bf->Label(-text=>'Scale: 100%')->pack(-side => 'left',-expand => 'no');
    my $slider = $tred{canvasScaleWidget} = $bf->Scale(
      -from => -2,
      -to=>2,
      -font => 'C_small',
      -length => 100,
      -sliderlength => 20,
      -width => 10,
      -showvalue => 0,
      -resolution => 0.1,
      -borderwidth => 1,
      -variable => \$tred{canvasScale},
      -command => [sub {
		     my ($grp,$step) = @_;
		     $grp->{focusedWindow}->treeView->scale($step,$grp->{focusedWindow}->{currentNode});
		     updateScaleFactor($grp);
		   },\%tred],
      -orient => 'horizontal' )->pack(-side => 'left',-expand => 'no');
    $slider->bindtags([$slider,ref($slider),$slider->toplevel,'all']);
    $slider->bind($slider,'<3>', sub{ $slider->set(0); Tk->break; } );
  }

    create_toolbar_buttons(\%tred);  
    
    create_stylesheet_menu(\%tred);
    
    $tred{UserToolbarSep}=$top->Frame(qw/-relief sunken -height 2 -borderwidth 2/);
  $tred{UserToolbars}=$top->Frame();
  addBindTags($tred{UserToolbars},'my');
  
  create_value_line_subframe(\%tred);
  
   
  
    $tred{bodyPane}=$top->Panedwindow();
  $tred{bottomFrame}->pack(qw/-pady 2 -side bottom -fill x -expand no/);
  $tred{bodyPane}->pack(qw/-fill both -expand yes/);
  $tred{windowFrame}=$tred{bodyPane}->Pane();
  $tred{bodyPane}->add($tred{windowFrame});
  
  $tred{focusedWindow}->frame_widget($canvas,[],
				      [qw/-side left/])
    ->pack(qw/-expand yes -fill both/,
	   -in => $tred{windowFrame},
	   -side=>'right');
  # frame canvas here
  
#  $tred{sLineFrame}->pack(qw/-fill x -expand yes/);

  $tred{focusedWindow}->canvas->focus;

  print STDERR "GUI prepared.\n" if $tredDebug;
  $top->update;



  # check if TrEd has been updated
  my $version_file = File::Spec->catfile($tred_d,'last_version');
  my $ver;
  if (open my $fh, '<', $version_file) {
    $ver=<$fh>;
    close $fh;
    chomp $ver;
  }
  if (open my $fh, '>', $version_file) {
    print $fh $VERSION,"\n";
    close $fh;
  } else {
    warn "Could not write version information to $version_file: $!\n";
    $ver = $VERSION; # do not bother the user in this case
  }
  if (!$TrEd::Config::skipStartupVersionCheck && ( !$ver || $ver ne $VERSION )) {
    if (TrEd::Query::User::new_query($top, "TrEd was "
		    .($ver ? "upgraded" : "installed or upgraded")
		    ." recently.\n\n".
		        "Do you want to check for new extensions or updates?",
		  -title => "TrEd Upgraded",
		  -buttons => ["Manage Extensions","Later"]) =~ /Manage/) {
      manage_extensions(\%tred,0);
      $preparedExtensions = TrEd::Extensions::prepare_extensions($opt_m);
    }
  }



  $top->Busy(-recurse=> 1);
  eval { loadMacros(\%tred,{preparedExtensions=>$preparedExtensions}) };
  TrEd::Error::Message::error_message($top,$@) if $@;
  print STDERR "Resource path: $Treex::PML::resourcePath\n";# unless $opt_q;
  print "Starting in context $tred{focusedWindow}->{macroContext}\n" if $tredDebug;
  doEvalHook($tred{focusedWindow},"initialize_bindings_hook");

  TrEd::Menu::Macro::update_macro_menus(\%tred);
  TrEd::MinorModes::update_minor_modes(\%tred);
  $tred{StylesheetMenu}->update(\%tred);
  updatePostponed(\%tred);
  updateHelpMenu(\%tred, {preparedExtensions=>$preparedExtensions});


  if (doEvalHook($tred{focusedWindow},"init_hook") eq 'stop') {
    $top->Unbusy;
    print STDERR "Stopped by init_hook\n";
    exit_tred();
  }
  # STYLESHEET_FROM_FILE is from TrEd::Stylesheet
  my $stylesheet=$opt_s || STYLESHEET_FROM_FILE();
  $tred{selectedStylesheet}=$stylesheet;
  $tred{focusedWindow}->apply_stylesheet($stylesheet);

  toggleSidePanel(\%tred);
  if ($opt_split_window) {
    my $dir=$opt_split_window>0 ? 'vert' : 'horiz';
    for (my $i=1;$i<abs($opt_split_window);$i++) {
      splitWindow(\%tred,$dir);
    }
    focusCanvas($tred{treeWindows}->[0]->canvas,\%tred);
  }
  $top->repeat(1000,sub {1}); # otherwise SIGINT would wait till next focus
  $SIG{PIPE}=sub {
    print STDERR "Caught signal SIGPIPE: $!\n";
  };
  $SIG{USR1}=sub {
    if ($insideEval) {
      print STDERR "Caught signal USR1: stopping current evaluation.\n";
    } else {
      print STDERR "Caught signal USR1: ignoring - not in a macro evaluation.\n";
    }
    print STDERR "Current call stack:\n",
      map { my ($pkg, $f, $line) = caller($_); "  $_: file $f line $line\n" } 1..5;
    $insideEval && die "Caught USR1: stopping current evaluation.\nSee the error output for details...\n"
  };
  $SIG{INT}=sub {
    if ($insideEval) {
      print STDERR "Caught SIGINT, stopping current evaluation\n";
      print STDERR "Current call stack:\n",
	map { my ($pkg, $f, $line) = caller($_); "  $_: file $f line $line\n" } 1..5;
      die "Caught SIGINT, stopping current evaluation.\nSee the error output for details...\n";
    } else {
      print STDERR "Caught SIGINT, closing all files without saving\n";
      TrEd::File::closeAllFiles(\%tred);
      print STDERR "Good bye!\n";
      $top->destroy;
      exit_tred(1);
    }
  };

  if (TrEd::ManageFilelists::find_filelist('Default')->count == 0 
            && TrEd::ManageFilelists::find_filelist('CmdLine-1')) {
    print STDERR "Selecting CmdLine-1 filelist." if $tredDebug;
    TrEd::ManageFilelists::selectFilelist(\%tred,'CmdLine-1');
  } else {
    print STDERR "Selecting Default filelist." if $tredDebug;
    TrEd::ManageFilelists::selectFilelist(\%tred,'Default');
  }
  if ($opt_split_window) {
    create_split_windows($opt_split_window, $opt_filelist, \%tred);
    
  }

  $tred{appenddefault} = 1; #($tred{focusedWindow}{currentFilelist}->count()>0);

  # run start_hook
  if (doEvalHook($tred{focusedWindow},"start_hook") eq 'stop') {
    $top->Unbusy;
    print STDERR "Stopped by start_hook\n";
    exit_tred();
  }

  # Starting ------------------------------------------
  $top->Unbusy;
  $top->focus if ($^O eq 'MSWin32');
  if (defined $opt_e and length $opt_e) {
    my $macro = eval "package $tred{selectedContext}; sub{ $opt_e }";
    die $@ if $@;
    doEvalMacro($tred{focusedWindow},$macro);
  }

##### <<<<<< bindings

  print STDERR "Binding keystrokes...\n" if $tredDebug;
  $menubar->bind('<Escape>', sub { eval{shift->menu->Leave()}; Tk->break; } );
  $top->bind('my','<Menu>'=>
	       [sub {
		  my ($w,$grp)=@_;
		  my $mbar=$grp->{Menubar};
		  $mbar->focus;
		  $mbar->FindMenu('F'); # File
		  if ($^O eq 'MSWin32') {
		    foreach my $child (grep { $_->class eq 'Menubutton' }
					 $mbar->children) {
		      $child->ButtonUp()
		    }
		  }
		},\%tred]);
  foreach my $prefix ('Alt','Meta','Mod4') {
    $top->
      bind('my',"<$prefix-KeyPress>"=>
	   [sub {
	      if (defined(evalMacro(@_))) {
		Tk->break;
	      } else {
		# Actually, this should work by it self. And it realy
		# does, but not under windows :-) Well, do not laugh,
		# too early, Linux users. With menu (not menubutton)
		# this is the same there, only vice versa.
		my ($w,$grp,$mod)=@_;
		my $mbar=$grp->{Menubar};
		$mbar->FindMenu($w->XEvent->K);
		if ($^O eq 'MSWin32') {
		  foreach my $child (grep { $_->class eq 'Menubutton' }
				     $mbar->children) {
		    $child->ButtonUp() 
		  }
		}
		Tk->break;
	      }
	    }, \%tred,uc($prefix).'+']);
  }
  #TODO: bindings to Menu::Context?
  foreach my $prefix ('Alt','Meta','Mod4') {
    $top->
      bind('my',"<$prefix-o>"=>
	   [sub {
	      if (defined(evalMacro(@_))) {
		Tk->break;
	      } else {
		my ($w,$grp)=@_;
		my $but = $grp->{ContextsMenu}->get_menu();
		my $menu = $but->menu();
		my $ctxt = $grp->{selectedContext};
		Tk->break if $ctxt eq EMPTY;
		my $idx = eval { $menu->index($ctxt) } ;
		Tk->break if $idx eq 'none';
		$but->Post();
		eval { $menu->activate($idx) };
		$but->ButtonUp() if $^O eq 'MSWin32';
		Tk->break;
	      }
	    }, \%tred,uc($prefix).'+']);
  }
  #TODO: bindings to Menu::Stylesheet?
  foreach my $prefix ('Alt','Meta','Mod4') {
    $top->
      bind('my',"<$prefix-y>"=>
	   [sub {
	      if (defined(evalMacro(@_))) {
		Tk->break;
	      } else {
		my ($w,$grp)=@_;
		my $but = $grp->{StylesheetMenu}->get_menu();
		my $menu = $but->menu;
		my $stylesheet = $grp->{selectedStylesheet};
		Tk->break if $stylesheet eq EMPTY;
		my $idx = eval { $menu->index($stylesheet) };
		Tk->break if $idx eq 'none';
		$but->Post();
		eval { $menu->activate($idx) };
		$but->ButtonUp() if $^O eq 'MSWin32';
		Tk->break;
	      }
	    }, \%tred,uc($prefix).'+']);
  }
##### <<<<<< binding
# this can not be moved up above loading macros because then 
  # some bindings won't work... (don't ask me why)
  $tred{default_binding} = TrEd::Binding::Default->new(\%tred);
  $tred{default_binding}->setup_default_bindings();
  #  $top->bind('my','<Control-x><KeyPress>'=>
  #			[sub { evalMacro(@_); Tk->break; }, \%tred, 'CTRL-X+' ]);

  

#  $top->bind('all','<Tab>',undef);

  # New Busy window bindings
  $top->Tk::bind('Busy','<Escape>',[\&_search_busy, \%tred]);
  $top->Tk::bind('Busy','<Any-KeyPress>',[\&Tk::Widget::_busy => 1]);
  $top->Tk::bind('Busy','<Any-KeyRelease>',[\&Tk::Widget::_busy => 0]);
  $top->Tk::bind('Busy','<Any-ButtonPress>',[\&Tk::Widget::_busy => 1]);
  $top->Tk::bind('Busy','<Any-ButtonRelease>',[\&Tk::Widget::_busy => 0]);
  $top->Tk::bind('Busy','<Any-Motion>',[\&Tk::Widget::_busy => 0]);
  $top->bind('Tk::Listbox','<KeyPress>',\&list_isearch);
  
  
  #TrEd::Bindings::setup_default_bindings(\%tred);

  print STDERR "done.\nStarting main loop.\n" if $tredDebug;
  print STDERR "Ready.\n" unless $opt_q;
  $SIG{USR2} = sub {
    $tred{top}->afterIdle([\&handleUSR2Signal,\%tred]);
  };

  MainLoop;
  if ($tred{top}) {
    TrEd::RuntimeConfig::save_runtime_config(\%tred);
  }

  # Finished ------------------------------------------
  $top=undef;
  $tred{top} = undef;
  print STDERR "Done.\n" if $tredDebug;
}

# SIGUSR2 (afterIdle) signal handler:
# we use SIGUSR2 to notify TrEd about
# an incomming command (tred -C)
#
sub handleUSR2Signal {
  my ($grp) = @_;
  my $cmd_file = File::Spec->catfile($tred_d, 'cmd_' . $$);
  if (-f $cmd_file) {
    if (((stat($cmd_file))[2] &022) == 0) {
      open my $fh, '<', $cmd_file || return;
      my $cmd = <$fh>;
      unlink $cmd_file || warn("WARN: Failed to unlink $cmd_file\n");
      my @cmd = split("\0",$cmd);
      if (($cmd[0]||'') eq 'open' and @cmd==2) {
	   TrEd::File::openStandaloneFile($grp,$cmd[1]);
	   return;
      } elsif (($cmd[0]||'') eq 'reload' and @cmd==2) {
          #TODO: toto extraktovat do TrEd::File?
	   TrEd::File::reload_on_usr2($grp, $cmd[1]);
	   return;
      } else {
	warn("WARN: Ignoring unknown command from $cmd_file\n");
      }
    } else {
      warn("WARN: Ignoring command from $cmd_file: dangerous file permissions!\n");
    }
  }
  #plainErrorMessage($grp,"USR2 Signal Caught");
}

#sub newUserToolbar

#TODO: sounds like a fn from TrEd::Window::TreeBasics..?!
sub makeCurrentNodeRoot {
  my ($grp)=@_;
  my $win=$grp->{focusedWindow};
  my $node = $win->{currentNode};
  my $fsfile = $win->{FSFile};
  return unless $fsfile and $node;
  return unless ($fsfile->test_tree_type($node) or
		   TrEd::Query::User::new_query($win,"WARNING:\n\n".
			       "The type of the current node is not a permitted root type.\n\n".
				 "The options are:\n\n".
				   "[Proceed anyway] - ignore the type constraints (the tree will be invalid, but may be fixed later)\n".
				     "[Cancel] - cancel the operation\n",
			     -bitmap=> 'question',
			     -title => 'Incompatible node type',
			     -buttons => ['Proceed anyway','Cancel']) eq 'Proceed anyway');
  my $discard=0;
  my $root = $node->root;
  return if $root==$node;
  unless ($node->test_child_type($root)) {
    my $res = TrEd::Query::User::new_query($win,"WARNING:\n\n".
			  "Normally, this operation cuts the subtree of the current node,\n".
			    "makes the current node a new root of the tree and\n".
			      "pastes the old root on the current node.\n\n".
				"However, the type constraints of the current node do not permit the current root ".
				  "as its a child.\nThe resulting tree would be invalid.\n\nThe options are:\n\n".
				    "[Paste anyway] - ignore the type constraints (the tree will be invalid, but may be fixed later)\n".
				      "[Discard root] - discards every node between the current root and the current node\n".
					"[Cancel] - cancel the operation\n",
			-bitmap=> 'question',
			-title => 'Incompatible node type',
			-buttons => ['Paste anyway','Discard root','Cancel']);
    return if $res eq 'Cancel';
    $discard=1 if $res=~/Discard/;
  }
  print STDERR "undo_type_id = |" . TrEd::Undo::undo_type_id('UNDO_ACTIVE_ROOT_AND_TREE_ORDER') . "|\n";
  TrEd::Undo::save_undo($win, TrEd::Undo::prepare_undo($win, 'Make Current Node the Root', TrEd::Undo::undo_type_id('UNDO_ACTIVE_ROOT_AND_TREE_ORDER')));
  TrEd::Window::TreeBasics::make_root($win, $node, $discard );
}

sub quit {
  my ($grp,$win)=grp_win(shift);
  # run user's exit_hook
  doEvalHook($win,"exit_hook");
  return if TrEd::File::ask_save_files_and_close($grp,1) == -1;
 TrEd::RuntimeConfig::save_runtime_config($grp);
  $grp->{top}->destroy;
  $grp->{top}=undef;
}


sub _do_goto_tree {
  my $win=shift;
  my $no=$win->{treeNo};
  $win->{treeNo}=-1;  # this is to force getNodes & redraw
  TrEd::Window::TreeBasics::go_to_tree($win,$no);
  $win->{framegroup}->{IdleTask}=undef;
}

# hook
sub onIdleNextTree {
  my ($grp,$win)=grp_win(shift);
  return unless $win->{FSFile};
  $win->toplevel->afterCancel($grp->{IdleTask}) if ($grp->{IdleTask});
  my $last = $win->{FSFile}->lastTreeNo;
  if ($win->{treeNo}<$last) {
    $win->{treeNo}=max2(0,$win->{treeNo}+1);
    update_tree_pos($grp);
    $grp->{vLineNumLabel}->idletasks();
    $grp->{IdleTask}=$win->toplevel->afterIdle([\&_do_goto_tree,$win]);
  }
  Tk->break;
}

# hook
sub onIdlePrevTree {
  my ($grp,$win)=grp_win(shift);
  return unless $win->{FSFile};
  if ($win->{treeNo}>0) {
    $win->toplevel->afterCancel($grp->{IdleTask}) if ($grp->{IdleTask});
    $win->{treeNo}--;
    update_tree_pos($grp);
    $grp->{vLineNumLabel}->idletasks();
    $grp->{IdleTask}=$win->toplevel->afterIdle([\&_do_goto_tree,$win]);
  }
  Tk->break;
}


  

# wrapper for vallex and remote control
sub ShowDialog {
    return TrEd::Dialog::FocusFix::show_dialog(@_);
}
# wrapper for vallex and remote control
sub RepeatedShowDialog {
    return TrEd::Dialog::FocusFix::repeated_show_dialog(@_);
}

# file, template
#TODO: -->File
sub newFileFromTemplate {
  my ($grp)=@_;
  my @templates;
  my $extensions = TrEd::Extensions::get_extension_list();
  foreach my $ext (@$extensions) {
    my ($dir) = get_extension_template_paths([$ext]);
    if (defined ($dir)) {
      push @templates, map [ $ext, $_ ], grep !/~$|\.lock$/, glob(File::Spec->catfile($dir,'*'));
    }
  }
  if (!@templates) {
    TrEd::Query::User::new_query($grp->{top},
	      "Sorry, the available extensions provide no templates.",
	      -title => "New from templates",
	      -buttons => ["OK"]);
    return;
  }
  my $choices = [map filename($_->[1])." ($_->[0])", @templates];
  my $ret = TrEd::Query::List::new_query(
    $grp->{top},
    'Select a template',
    'browse',
    $choices,
    [$choices->[0]],
   );
  if (ref($ret) and @$ret) {
    return TrEd::File::openStandaloneFile($grp,$templates[$ret->[0]][1],-justheader => 1);
  }
  return;
}

# sub fileDialog
# sub urlDialog 


# sub askSaveReferences
# sub saveFileAs
# sub doSaveFileAs 


# sub renameFileInFilelist

# sub closeAllFiles


# sub askSaveFile


# sub editConfig

# UI
# sub QueryString
# wrapper for PADT, PDT10, PDT15_obsolete
sub QueryString {
    return TrEd::Query::String::new_query(@_);
} 

#
sub Query {
    return TrEd::Query::Simple::new_query(@_);
} 

# sub listQuery
# wrapper for pdt15_obsolete, 
# extensions should use TredMacro::ListQuery instead anyway..
sub listQuery {
    return TrEd::Query::List::new_query(@_);
}

# context
sub autoSelectContext {
  my ($grp)=@_;
  my ($win)=$grp->{focusedWindow};
  if ($win->{FSFile}) {
    my $prevcontext = $win->{macroContext};
    $win->{macroContext}='TredMacro';
    doEvalHook($win,"guess_context_hook","file_resumed_hook");
    if ($win->{macroContext} eq 'TredMacro' and $prevcontext ne 'TredMacro') {
      $win->{macroContext}=$prevcontext;
      switchContext($win,'TredMacro');
    } else {
      $win->get_nodes(); # the hook may have changed something
      $win->redraw();
      centerTo($win,$win->{currentNode});
    }
  } else {
    switchContext($win,'TredMacro');
  }
}

# context
#######################################################################################
# Usage         : get_allowed_contexts($win)
# Purpose       : Get allowed contexts for Window $win
# Returns       : List of allowed context names
# Parameters    : TrEd::Window ref $win -- ref to examined TrEd::Window object
# Throws        : No exception
# Comments      : Runs allow_switch_context_hook.
# See Also      : selectContext(), autoSelectContext()
sub get_allowed_contexts {
    my ($win) = @_;
    my $prevcontext = $win->{macroContext};
    my @all_contexts = TrEd::Macros::get_contexts(); 
    my @ret = grep {
        (   doEvalHook(
                $win,         "allow_switch_context_hook",
                $prevcontext, $win->{macroContext} = $_
                )
                || ''
            ) ne 'stop'
    } @all_contexts;
    $win->{macroContext} = $prevcontext;
    return @ret;
}

# context
sub selectContext {
  my ($grp)=@_;
  my $win = $grp->{focusedWindow};
  my $selection = [$win->{macroContext}];
  TrEd::Query::List::new_query($grp->{top},'Select Mode','browse',[get_allowed_contexts($win)],
	    $selection) || return;
  if (@$selection) {
    switchContext($grp->{focusedWindow},$selection->[0]);
  }
}

# stylesheet
sub selectStylesheet {
  my ($grp_or_win)=@_;
  my $grp = cast_to_grp($grp_or_win);
  my $win = cast_to_grp($grp_or_win);
  my $selection = [$grp->{selectedStylesheet}];
  TrEd::Query::List::new_query($grp->{top},'Select Mode','browse',
	    $grp->{StylesheetMenu}->get_menu_list($grp),
	    $selection) || return;
  if (@$selection) {
    $grp->{selectedStylesheet} = $selection->[0];
    switchStylesheet($grp,$selection->[0]);
  }
}
# stylesheet
sub stylesheetUsingWindows {
  my ($grp,$stylesheet)=@_;
  return 
    grep {
      $_->{stylesheet} eq $stylesheet
    } @{$grp->{treeWindows}};
}

# sub deleteStylesheet


# sub selectValuesDialog
# wrapper for pdt15_obsolete extension
sub selectValuesDialog {
    return TrEd::Dialog::SelectValues::create_dialog(@_);
}

# sentence view
#sub reloadSentenceView 
#sub sentViewSelectAll 
#sub sentViewSelectNone
#sub sentViewGetSelection
#sub sentViewToggleCollapse 
#sub viewSentences
#sub viewSentencesDialog
#sub dumpSentView
#sub populateSentencesDialog

# list attr
sub editListAttr {
  my ($win, $value, $attr,$d, $node)=@_;
  return unless $win->{FSFile};
  my @vals= map { encode($_) } $win->{FSFile}->FS->listValues($attr);
  if ($sortAttrValues) {
    my @v = @vals;
    if (doEvalHook($win,"sort_attr_values_hook",\@v,$attr,$node)) {
      @vals = @v;
    } else {
      @vals = sort @vals
    }
  }
  #print "splitting ",$value{$attr},"\n";
  my @selected= map { encode($_) } split /\|/,$value;
  #print "splitted to ", join ('-',@selected),"\n";

  if (TrEd::Dialog::SelectValues::create_dialog($win->{framegroup},$attr,\@vals,\@selected,0,$d)) {
    return decode(join('|',@selected));
  }
  return undef;
}

sub editAmbiguousAttr {
  my ($win, $value, $attr)=@_;
  my @vals= map { encode($_) }split /\|/,$value;
  my @selected= @vals;
  
  if (TrEd::Dialog::SelectValues::create_dialog($win->{framegroup},$attr,\@vals,\@selected,1,$win->toplevel)) {
    return decode(join('|',@selected));
  }
  return undef;
}

sub focusxEditDn {
  my ($w,$i,$e,$f,$atord)=@_;
  if ($i+1<@$atord) {
    $f->see($e->{$atord->[$i+1]});
    $e->{$atord->[$i+1]}->focus;
  }
  Tk->break;
}

sub focusxEditUp {
  my ($w,$i,$e,$f,$atord)=@_;
  if ($i>0) {
    $f->see($e->{$atord->[$i-1]});
    $e->{$atord->[$i-1]}->focus;
  }
  Tk->break;
}

sub focusxFind {
  my ($w,$i,$e,$f,$atord)=@_;
  my $ev= $w->XEvent;
  my $A= $ev->A;
  if ($A ne EMPTY) {
    my $count=scalar(@$atord);
    for (my $j=$i+1;$j<=$i+$count;$j++) {
      if (($atord->[$j % $count]) =~ /^\Q$A\E/i) {
	$f->see($e->{$atord->[$j % $count]});
	$e->{$atord->[$j % $count]}->focus();
	Tk->break;
	return;
      }
    }
  }
}

# node
sub determineNodeType {
  my ($win,$node)=@_;
  return unless $node;
  my $type = $node->type;
  return $type if $type;
  doEvalHook($win,'determine_node_type_hook',$node);
  $type = $node->type;
  return $type if $type;
  __debug("Determining node type for $node\n");
  eval {
    $win->{FSFile}->determine_node_type($node => {
      choose_command => sub {
	my (undef,undef,$ntypes)=@_;
	my $i = 1;
	my @types = map {($i++)." ".($_->[0])} @$ntypes;
	my $selection = [$types[0]];
	my $top = $win->toplevel;
	my ($highest) = reverse $top->stackorder();
	$top = $top->Widget($highest);
	TrEd::Query::List::new_query($top,'Untyped node: select node-type','browse',
		  \@types,$selection) || return;
	return @$ntypes[$1-1] if $selection->[0]=~/^(\d+) /;
	return;
      }
    });
  };
  plainErrorMessage($win,$@) if $@;
  return $node->type;
}

#sub editFilePropertiesDialog 

# sub editAttrsDialog_schema

#sub editAttrsDialog
# wrapper for ElixirFM
sub editAttrsDialog {
    return TrEd::Dialog::EditAttributes::create_dialog(@_);
}

sub disable_scrollbar_focus {
  my ($scrolled)=@_;
  $scrolled->Subwidget('xscrollbar')->configure(qw(-takefocus 0));
  $scrolled->Subwidget('yscrollbar')->configure(qw(-takefocus 0));
}

# macros, UI
sub showMacrosAsHtml {
  my ($grp, $flags, $order_by) = @_;
  my $context = $grp->{selectedContext};
  use File::Temp;
  my $dir = File::Temp::tempdir( CLEANUP => 1 );
  eval {
    Treex::PML::IO::copy_uri(File::Spec->catfile($libDir,'misc','sorttable.js'),
			File::Spec->catfile($dir,'sorttable.js'));
  };
  warn $@ if $@;
  my $html_file = File::Spec->catfile($dir,"$context.html");
  open(my $html, '>:utf8',$html_file)
    or do {
      TrEd::Error::Message::error_message($grp->{top},
		   "Cannot open temporary file $html_file.");
      return 0;
    };
  my $title = "Annotation Mode $context";
  $title.=" + TredMacro" if ($flags&2);
  print $html "<html>\n";
  print $html "<head>\n";
  print $html "  <title>$title</title>\n";
  print $html "  <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\" />\n";
  print $html "<script src=\"sorttable.js\"></script>\n";
  print $html "</head>\n";
  print $html "<body>\n";
  print $html "<h2>TrEd Macro Reference</h2>\n";
  print $html "<h3>$title</h3>\n";
  print $html "<table class=\"sortable\" preserve_style=\"row\">\n";
  print $html "<thead><tr><th>Keyboard Shortcut</th>";
  print $html "<th>Perl Function</th>" if ($flags&1);
  print $html "<th>Description</th></tr></thead>\n";
  print $html "<tbody>\n";
  my $odd = 0;
  foreach my $entry (TrEd::List::Macros::sorted_macro_table($grp,$context,$flags,$order_by||'N')) {
    my ($name, $key, $macro)=@$entry;
    $name=~s/^_+//;
    print $html "  <tr ",($odd ? 'bgcolor="#ffffff"' : 'bgcolor="#eeeeee"'),
      ">\n    <td>$key</td>\n",
	(($flags&1) ? "<td>$macro</td>\n" : EMPTY),
	  "<td>$name</td>\n",
	    "  </tr>\n";
    $odd = !$odd;
  }
  print $html "</tbody>\n";
  print $html "</table>\n";
  print $html "</body>\n";
  print $html "</html>\n";
  close ($html);
  open_url_in_browser($html_file);
}


sub help_topic {
  my ($top,$section) = @_;
  my $file = $TrEd::Help::HELP_MAP{$section};
  if (defined $file) {
    open_url_in_browser($docDir.'/'.$file."#".$section);
  } else {
    plainErrorMessage($top,"Cannot map '$section' to a documentation page.");
  }
}

sub open_url_in_browser {
  my $url = shift;
  if ( $htmlBrowser eq 'DO_NOT_RUN') {
  } elsif ($^O eq 'MSWin32' and 
	   eval { require ActiveState::Browser; 1 }) {
    print STDERR "ActiveState::Browser::open '$url'\n" if $tredDebug;
    ActiveState::Browser::open("$url");
  } elsif ( $htmlBrowser ne EMPTY) {
    $htmlBrowser.=" %u" unless ($htmlBrowser =~ /\%[uf1]/);
    my $cmd = $htmlBrowser;
    $cmd =~ s/\%1/$url/g;
    $cmd =~ s/\%[fu]\b/"$url"/g;
    print STDERR "$cmd\n" if $tredDebug;
    if ($^O eq 'MSWin32') {
      $cmd = 'start '.$cmd unless $cmd=~/^\s*start\s/;
      if ($cmd=~/iexplore.exe/i) {
	$cmd=~s/ -nohome//g;
	$cmd='start /B '.$cmd;
      }
      return system($cmd);
    } else {
      return system $cmd.' &';
    }
  } else {
    if ($^O eq 'MSWin32') {
      my $browser_key = fetch_from_win32_reg('HKEY_LOCAL_MACHINE',
					     q(SOFTWARE\Classes\.html));
      if ($browser_key ne EMPTY) {
 	$htmlBrowser = fetch_from_win32_reg('HKEY_LOCAL_MACHINE',
					    q(SOFTWARE\Classes\\).
					    $browser_key.
					    q(\shell\open\command));
      }
      unless ($htmlBrowser ne EMPTY) {
	warn "Could not determine default browser.\n".
	  "Contextual help may not jump to the correct paragraph.";
	$htmlBrowser='start /B "%1"';
      }
    }
    elsif ($^O eq 'darwin') {
      $htmlBrowser='open %u';
    }
    elsif ($ENV{DESKTOP_LAUNCH} ne EMPTY) {
      $htmlBrowser=$ENV{DESKTOP_LAUNCH};
    }
    elsif (which('xdg-open') ne EMPTY) {
      $htmlBrowser='xdg-open %u';
    }
    # Otherwise we emulate xdg-open
    # detect KDE
    elsif ($ENV{KDE_FULL_SESSION} eq "true") {
      if (which('kde-open') ne EMPTY) {
	$htmlBrowser='kde-open %u';
      } else {
	$htmlBrowser='kfmclient openURL %u';
      }
    } # detect GNOME
    elsif ($ENV{GNOME_DESKTOP_SESSION_ID} ne EMPTY and
	   which('gnome-open') ne EMPTY) {
      $htmlBrowser='gnome-open %u';
    } # generic
    elsif ($ENV{BROWSER} ne EMPTY and which($ENV{BROWSER}) ne EMPTY) {
      $htmlBrowser=$ENV{BROWSER};
    }
    elsif ($htmlBrowser = first {which($_) ne EMPTY}
	     qw(firefox mozilla netscape opera htmlview)) {
      # already assigned
    } else {
      warn "Did not find any HTML browser.\nPlease set the 'htmlbrowser' configuration option or either of DESKTOP_LAUNCH or BROWSER environment variables.";
      $htmlBrowser='DO_NOT_RUN';
      return undef;
    }
    return open_url_in_browser($url);
  }
}

#sub tred_pod_add_tags
#sub _sytylesheetInsertAttr
#sub editStylesheetDialog
#sub format_tred_pod

#####################################################
#####################################################
#####################################################
# Node searching
#####################################################

#sub findNodeDialog

#####################################
# bound to Escape for busy widgets
#####################################
sub _search_busy {
  my ($w,$grp,$no_break)=@_;
  print STDERR $grp->{focusedWindow}->{currentFileNo}."stopped by user\n" if ($tredDebug);
  $grp->{stopSearch}=1;
  Tk->break unless $no_break;
}

#####################################
# called after file open to process
# event queue and let user interrupt
# the search process
#####################################
sub _quick_update {
  my ($grp,$no_idle)=@_;
  my $g = $grp->{searchGrabWindow};
  my $now = time; #once in a second
  return unless ($now-$grp->{searchGrabWindow_last}>=1);
  $grp->{searchGrabWindow_last}=$now;

  my $win = $grp->{focusedWindow};
  my $f = $win->{FSFile};
  my $current = $win->{currentFileNo}+1;
  my $all = $win->{currentFilelist}->file_count();
  my $fn = $f && filename($f->filename());
  $grp->{searchGrabWindow_status} = "File '$fn'     ( $current / $all )";
  if ($grp->{searchGrabWindow_active}==1) {
    $grp->{searchGrabWindow_active}=2;
    $grp->{searchGrabWindow_last}=0;
    $grp->{top}->Unbusy();
    $g->Popup;
    Tk::catch {
      $g->grab;
    };
    my ($b)=grep { ref($_)=~/Button/ } $g->children;
    $b->focusForce if $b;
    $g->update();
  } elsif ($grp->{searchGrabWindow_active}==2) {
    $g->update();
  }
}

sub _createSearchGrabWindow {
  my ($grp)=@_;
  $grp->{top}->Busy(-recurse=>1);
  if ($grp->{searchFilelist}) {
    $grp->{searchGrabWindow_status}='';
    my $g;
    unless ($grp->{searchGrabWindow}) {
      $g = $grp->{top}->Toplevel(-title=>"Search");
      $g->withdraw();
      $g->Label(-text=>"Search in progress...",-width=>'40')->pack(-pady=>10,-padx=>10);
      $g->Label(-justify=>'left',
		-anchor=>'nw',
		-textvariable=>\$grp->{searchGrabWindow_status})->pack(-pady=>5,-padx=>10,-fill=>'x');
      $g->Button(-text=>'Interrupt',
		 -command => [\&_search_busy,$g,$grp])->pack(-pady=>5,-padx=>10);
      $g->protocol('WM_DELETE_WINDOW' => [\&_search_busy,$g,$grp,0]);
      $g->transient($grp->{top});
      $grp->{searchGrabWindow} = $g;
    }
    $grp->{searchGrabWindow_time}=0;
    $grp->{searchGrabWindow_active} = 1;
  }
}

sub _closeSearchGrabWindow {
  my ($grp)=@_;
  if ($grp->{searchGrabWindow_active}==2) {
    $grp->{searchGrabWindow_active} = undef;
    $grp->{searchGrabWindow_status} = undef;
    my $g = $grp->{searchGrabWindow};
    Tk::catch {
      $g->grabRelease;
    };
    $g->withdraw;
  }
  $grp->{top}->Unbusy();
}

######################################
# start searching for a next node
# and display result unless succeeded
######################################

sub findTemplated {
  my ($grp,$cont,$callback)=@_;
  my $win = $grp->{focusedWindow};
  return undef unless ($win->{currentNode});

  my %save = (
    init_macro_context      => $init_macro_context,
    no_redraw               => $win->{noRedraw},
    no_update_title         => $grp->{noUpdateTitle},
    no_update_postponed     => $grp->{noUpdatePostponed},
    no_recent               => $grp->{noRecent},
    no_upd_stylesheet_menu  => $grp->{StylesheetMenu}->dont_update(),
    no_upd_macrolist_view   => $grp->{noUpdateMacrolistView},
    no_save_filestate_upd   => $grp->{noSaveFileStateUpdate}
   );
  ($init_macro_context,
   $win->{noRedraw},
   $grp->{noUpdateTitle},
   $grp->{noUpdatePostponed},
   $grp->{noRecent},
   $grp->{noUpdateMacrolistView},
   $grp->{noSaveFileStateUpdate}
  )=($win->{macroContext},1,1,1,1,1,1);
  $grp->{StylesheetMenu}->set_dont_update(1);
  
  _createSearchGrabWindow($grp);
  my $result;
  if (!$no_secondary and !$grp->{searchAlwaysSecondary} and $grp->{searchFilelist}) {
    # avoid opening secondary files
    # during search
    my $first_file_no = $win->{currentFileNo};
    $no_secondary = 1;
    my @locks = ($noCheckLocks,$lockFiles);
    $TrEd::Config::noCheckLocks = 1;
    $lockFiles=0;

    eval { $result = $callback->($grp,$cont) };
    $no_secondary = 0;
    ($TrEd::Config::noCheckLocks,$lockFiles)=@locks;
    die $@ if $@;

    my $fsfile = $win->{FSFile};
    if ($win->{currentFileNo} != $first_file_no) {
      TrEd::FileLock::lock_open_file($win,$fsfile);
      # if the initial file and the current file
      # are different, open the secondary files now
      my $status = TrEd::File::openSecondaryFiles($win,$fsfile,undef);
      unless ($status->{ok}) {
	$win->toplevel->ErrorReport(
	  -title => "Error: open failed",
	    -message => "A secondary file '$status->{filename}' is unreadable, empty, corrupted, or does not exist!"."\nPossible problem was:",
	  -body => $status->{report},
	 );
      }
    }
  } else {
    $result = $callback->($grp,$cont);
  }
  _closeSearchGrabWindow($grp);
  $init_macro_context           = $save{init_macro_context};
  $win->{noRedraw}              = $save{no_redraw};
  $grp->{noUpdateTitle}         = $save{no_update_title};
  $grp->{noUpdatePostponed}     = $save{no_update_postponed};
  $grp->{noRecent}              = $save{no_recent};
  $grp->{StylesheetMenu}->set_dont_update($save{no_upd_stylesheet_menu});
  $grp->{noUpdateMacrolistView} = $save{no_upd_macrolist_view};
  $grp->{noSaveFileStateUpdate} = $save{no_save_filestate_upd};


  $win->get_nodes();
  $win->redraw();
  update_title_and_buttons($grp);
  updatePostponed($grp);
  $grp->{StylesheetMenu}->update($grp);
  TrEd::List::Macros::update_view($grp);
  saveFileStateUpdate($win);
  unless ($result) {
#    $win->redraw();
    $grp->{top}->toplevel->
      messageBox(-icon=> 'warning',
		 -message=> $grp->{stopSearch} ? "Interrupted by user!" : "No matching node found!",
		 -title=> 'Find',
		 -default=> 'Ok',
		 -type=> 'ok');
    $grp->{top}->focusForce;
  }
  return $result;
}

######################################
# start searching for a prev node
# and display result unless succeeded
######################################
sub doFindFirstTemplated {
  my ($grp,$cont)=@_;
  return findTemplated($grp,$cont,\&findFirstTemplated);
}
sub doFindPrevTemplated {
  my ($grp,$cont)=@_;
  return findTemplated($grp,$cont,\&findPrevTemplated);
}

######################################
# compare nodes with template
######################################
sub cmpTemplateField {
  my ($grp,$val,$templ)=@_;
  my $method=substr($grp->{templateMatchMethod},0,1);
  return (($val=~ /^$templ$/) ? 1 : 0) if ($method eq 'E');
  return (($val=~ /$templ/) ? 1 : 0) if ($method eq 'R');
  return (($val eq $templ) ? 1 : 0) if ($method eq 'L');
  if ($method eq 'W') {
    $templ=~s/([\[\].^$(){}<>\\])/\\$1/g;
    $templ=~s/\*/.\*/g;
    $templ=~s/\?/./g;
    return (($val=~ /^$templ$/) ? 1 : 0);
  }
  return (($val eq $templ) ? 1 : 0);
}

######################################
# go to next node in searchlist
######################################
sub nextNodeInSearchFilelist {
  my ($grp,$node,$tree)=@_;
  my $win=$grp->{focusedWindow};
  my $haveSearchFL = defined($grp->{searchFilelist});
  my $traverse = $haveSearchFL ? $grp->{searchFilelistTraverse} || 'all' : 'all';

  if ($traverse ne 'node') {
    $node = HNext($win,$node);
    unless ($node) {
      $node = $traverse eq 'all' ? $win->{FSFile}->treeList->[(++$$tree)] : undef;
    }
    return $node if $node || !$haveSearchFL;
  }

  # this realises filelist search
  local $insideEval=1;
  my $result = TrEd::Filelist::Navigation::next_or_prev_file($grp,1,1,$traverse eq 'all' ? 1 : 0);
  _quick_update($grp);
  # wait for Escape
  while (!$grp->{stopSearch} and $result and !$win->{currentNode}) {
    $result = TrEd::Filelist::Navigation::next_or_prev_file($grp,1,1,$traverse eq 'all' ? 1 : 0);
    # wait for Escape
    _quick_update($grp);
  }

  if ($result and !$grp->{stopSearch}) {
    if ($traverse eq 'all') {
      $win->{currentNode} = $win->{FSFile}->treeList->[0];
      $$tree = 0;
    }
    elsif ($traverse eq 'tree') {
      $win->{currentNode} = $win->{root};
      $$tree = $win->{treeNo};
    }
    elsif  ($traverse eq 'node') {
      $$tree = $win->{treeNo};
    }
    $win->{treeNo} = -1; # to force redraw in go_to_tree
    return $win->{currentNode};
  }
  else {
    #$win->{treeNo} = -1 if ($traverse eq 'all'); # to force redraw in go_to_tree
    return undef;
  }
}
######################################
# find next matching node
######################################
sub findFirstTemplated {
  my ($grp,$skipfirst)=@_;

  my $win=$grp->{focusedWindow};
  return unless $win->{FSFile};
  my $search_code = $grp->{searchCode};
  return unless ref($search_code);

  my $node=$win->{currentNode};
  my $tree=$win->{treeNo};
  my $a;
  $grp->{stopSearch}=0;

  $node=nextNodeInSearchFilelist($grp,$node,\$tree) if ($skipfirst);
  while ($node) {
    if ($search_code->($node)) {
      TrEd::Window::TreeBasics::go_to_tree($win,$tree);
      TrEd::Window::TreeBasics::set_current($win, $node);
      centerTo($win,$node);
      return $node;
    }
  } continue {
    $node=nextNodeInSearchFilelist($grp,$node,\$tree);
  }
  return undef;
}

######################################
# go to the last node of a tree
######################################
sub lastSubtreeNode {
  my ($top)=@_;
  return undef unless $top;
  while ($top->firstson) {
    $top=$top->firstson;
    $top=$top->rbrother while ($top->rbrother);
  }
  return $top;
}

######################################
# go to previous node in search list
######################################
sub prevNodeInSearchFilelist {
  my ($grp,$node,$tree)=@_;
  my $win = $grp->{focusedWindow};
  my $haveSearchFL = defined($grp->{searchFilelist});
  my $traverse = $haveSearchFL ? $grp->{searchFilelistTraverse} || 'all' : 'all';

  if ($traverse ne 'node') {
    $node=HPrev($win,$node);
    if (!$node and $$tree!=0 and $traverse eq 'all') {
      $node=lastSubtreeNode($win->{FSFile}->treeList->[(--$$tree)]);
      $node=HPrev($win,$node) unless (isShown($win,$node));
    }
    return $node if $node or !$haveSearchFL;
  }

  # this realises filelist search
  local $insideEval=1;
  my $no_redraw = $win->{noRedraw};
  $win->{noRedraw}=1;
  my $result = TrEd::Filelist::Navigation::next_or_prev_file($grp,-1,1,$traverse eq 'all' ? 1 : 0);

  # wait for Escape
  _quick_update($grp);
  while ($result and !$grp->{stopSearch}
	 and !$win->{FSFile} || $win->{FSFile}->lastTreeNo<0) {
    $result = TrEd::Filelist::Navigation::next_or_prev_file($grp,-1,1,$traverse eq 'all' ? 1 : 0);
    # wait for Escape
    _quick_update($grp);
  }

  $win->{noRedraw}=$no_redraw;

  if ($result and !$grp->{stopSearch}) {
    if ($traverse eq 'all') {
      $$tree=$win->{FSFile}->lastTreeNo;
      $win->{currentNode}=lastSubtreeNode($win->{FSFile}->treeList->[$$tree]);
    }
    elsif ($traverse eq 'tree') {
      $win->{currentNode} = lastSubtreeNode($win->{root});
      $$tree = $win->{treeNo};
    }
    elsif  ($traverse eq 'node') {
      $$tree = $win->{treeNo};
    }
    $win->{treeNo} = -1; # to force redraw in go_to_tree
    return $win->{currentNode};
  }
  else  {
    #$win->{treeNo} = -1 if ($traverse eq 'all'); # to force redraw in go_to_tree
    return undef;
  }
}

######################################
# find previous matching node
######################################
sub findPrevTemplated {
  my ($grp,$skipfirst)=@_;
  my $win = $grp->{focusedWindow};
  return unless $win->{FSFile};
  my $search_code = $grp->{searchCode};
  return unless ref($search_code);

  my $node=$win->{currentNode};
  my $tree=$win->{treeNo};
  my $a;
  $grp->{stopSearch}=0;

  $node=prevNodeInSearchFilelist($grp,$node,\$tree) if ($skipfirst);
  while ($node) {
    if ($search_code->($node)) {
      TrEd::Window::TreeBasics::go_to_tree($win, $tree);
      TrEd::Window::TreeBasics::set_current($win, $node);
      centerTo($win,$node);
      return $node;
    }
  } continue {
    $node=prevNodeInSearchFilelist($grp,$node,\$tree);
  }
  return undef;
}

#############################################
#End of Searching functions
#############################################
#############################################
#############################################


sub node_doubleclick_modif {
  my ($w,$grp,$mod)=@_;
  my $win=findCanvasWindow($grp,$w);
  my $tv=$win->treeView;
  my $node=$tv->get_obj_pinfo($tv->find_item('withtag','current'));
  doEvalHookWithUndo($win,"node_doubleclick_hook",$node,$mod, $w->XEvent);
}

sub node_click_modif {
  my ($w,$grp,$mod)=@_;
  my $win=findCanvasWindow($grp,$w);
  my $tv=$win->treeView;
  my $node=$tv->get_obj_pinfo($tv->find_item('withtag','current'));
  doEvalHookWithUndo($win,"node_click_hook",$node,$mod, $w->XEvent);
}

sub node_motion_modif {
  my ($w,$grp,$mod)=@_;
  my $win=findCanvasWindow($grp,$w);
  my $tv=$win->treeView;
  my $node=$tv->get_obj_pinfo($tv->find_item('withtag','current'));
  doEvalHookWithUndo($win,"node_motion_hook",$node,$mod, $w->XEvent);
}

sub text_doubleclick_modif {
  my ($w,$grp,$mod)=@_;
  my $win=findCanvasWindow($grp,$w);
  return unless($win and $win->{FSFile});
  my $attr;

  my $tv=$win->treeView;
  my ($t)=$tv->find_item('withtag','current');
  my $node=$tv->get_obj_pinfo($t);
  TrEd::Window::TreeBasics::set_current($win,$node);
  $attr=$tv->get_gen_pinfo("attr")||{};

  doEvalHookWithUndo($win,"text_doubleclick_hook",$node,$attr->{$t},$mod, $w->XEvent);
}

sub text_click_modif {
  my ($w,$grp,$mod)=@_;
  my $win=findCanvasWindow($grp,$w);
  return unless($win and $win->{FSFile});
  my $attr;

  my $tv=$win->treeView;
  my ($t)=$tv->find_item('withtag','current');
  my $node=$tv->get_obj_pinfo($t);
  TrEd::Window::TreeBasics::set_current($win,$node);
  $win->ensure_current_is_displayed();
  $attr=$tv->get_gen_pinfo("attr")||{};

  doEvalHookWithUndo($win,"text_click_hook",$node,$attr->{$t},$mod, $w->XEvent);
}

sub line_click {
  my ($w,$grp,$button,$double,$modif)=@_;
  my $win=findCanvasWindow($grp,$w);
  return unless($win and $win->{FSFile});

  my $tv=$win->treeView;
  my ($t)=$tv->find_item('withtag','current');
  my $node=$tv->get_obj_pinfo($t);
  TrEd::Window::TreeBasics::set_current($win,$node);
  $win->ensure_current_is_displayed();
  my $tag=$tv->get_gen_pinfo("tag")||{};
    
  doEvalHookWithUndo($win,"line_click_hook",$node,$tag->{$t},$button, $double,$modif, $w->XEvent);
}


sub editAttrs {
  my ($w,$grp)=@_;
  return if $grp->{inEditAttrs};
  local $grp->{inEditAttrs} = 1;
  my $win=findCanvasWindow($grp,$w);
  my $tv=$win->treeView;
  my $node=$tv->get_obj_pinfo($tv->find_item('withtag','current'));
  TrEd::Dialog::EditAttributes::create_dialog($win,$node);
  $win->ensure_current_is_displayed();
}

sub editAttr {
  my ($w,$grp)=@_;
  return if $grp->{inEditAttrs};
  local $grp->{inEditAttrs} = 1;
  my $win=findCanvasWindow($grp,$w);
  return unless($win and $win->{FSFile});
  my $tv=$win->treeView;
  my ($t)=$tv->find_item('withtag','current');
  my $node=$tv->get_obj_pinfo($t);
  TrEd::Window::TreeBasics::set_current($win,$node);
  $win->ensure_current_is_displayed();
  my $attr=$tv->get_gen_pinfo("attr")||{};
  doEditAttr($win,$node,$attr->{$t}) if defined $attr->{$t};
}


sub doEditAttr {
  my ($win,$node,$attr,$as_type,$focus)=@_;
  my $grp=$win->{framegroup};
  my $result= doEvalHook($win,'do_edit_attr_hook',$attr,$node);
  return 0 if $result eq 'stop';

  return TrEd::Dialog::EditAttributes::dialog_schema($win,$node,$attr,$as_type,$focus)
    if (ref($as_type) or ref($node->type) ||
	$win->{FSFile}->schema() );

  my ($Entry,@Eopts) = get_entry_type();
  my $newvalue;
  if ($win->{FSFile}->FS->isList($attr)) {
    $newvalue= editListAttr($win,$node->get_member($attr),$attr,$grp->{top},$node);
    if (defined($newvalue)) {
      $win->toplevel->Busy(-recurse=> 1);
      $win->{FSFile}->notSaved(1);
      TrEd::Undo::save_undo($win,TrEd::Undo::prepare_undo($win,"Edit Attribute '$attr'",TrEd::Undo::undo_type_id('UNDO_DATA'),$node));
      TrEd::Bookmarks::last_action_bookmark($grp);
      $node->set_member($attr,$newvalue);
      doEvalHook($win,"after_edit_attr_hook",$node,$attr,1);
      get_nodes_fsfile_tree($grp,$win->{FSFile},$win->{treeNo});
      redraw_fsfile_tree($grp,$win->{FSFile},$win->{treeNo});
      $win->toplevel->Unbusy();
      return 1;
    } else {
      doEvalHook($win,"after_edit_attr_hook",$node,$attr,0);
    }
    return;
  }

  if ($node->get_member($attr)=~/^(?:[^\|\\]|\\.)*\|/) {
    $newvalue= editAmbiguousAttr($win,$node->get_member($attr),$attr);
    if (defined $newvalue) {
      $grp->{top}->Busy(-recurse=> 1);
      $win->{FSFile}->notSaved(1);
      TrEd::Undo::save_undo($win,TrEd::Undo::prepare_undo($win,"Edit Attribute '$attr'",TrEd::Undo::undo_type_id('UNDO_DATA'),$node));
      TrEd::Bookmarks::last_action_bookmark($grp);
      $node->set_member($attr,$newvalue);
      doEvalHook($win,"after_edit_attr_hook",$node,$attr,1);
      get_nodes_fsfile_tree($grp,$win->{FSFile},$win->{treeNo});
      redraw_fsfile_tree($grp,$win->{FSFile},$win->{treeNo});
      $grp->{top}->Unbusy();
      return 1;
    } else {
      doEvalHook($win,"after_edit_attr_hook",$node,$attr,0);
    }
    return;
  }

  $grp->{top}->Busy(-recurse=> 1);
  my $enabled=doEvalHook($win,'enable_attr_hook',$attr,"normal") ne 'stop';
  $newvalue=encode($node->get_member($attr));
  my $d= $grp->{top}->DialogBox(-title=> ($enabled ? "Edit Node Attribute" : "Disabled Node Attribute"),
			     -buttons=> [($enabled ? ("OK", "Cancel") : "Cancel")]);
  $d->BindReturn($d,1);
  $d->BindEscape();
  $d->resizable(0,0);
  addBindTags($d,'dialog');
  my $l= $d->Label(-text=> $attr,
		    -anchor=> 'e',
		    -justify=> 'right')->pack(-side=>'left');
  my $e= $d->$Entry(@Eopts,
		    -relief=> 'sunken',
		    -width=> 40,
		    -state=> $enabled ? 'normal' : 'disabled',
		    -takefocus=> 1,
		    -font=> $font,
		    -textvariable=> \$newvalue)->pack();
  set_grp_history($grp, $e, "attr-$attr");
  $e->icursor('end');
  $grp->{top}->Unbusy();
  $result= TrEd::Dialog::FocusFix::show_dialog($d,$e,$grp->{top});
  if ($result=~ /OK/) {
    get_grp_history($grp,$e, "attr-$attr");
    $win->{FSFile}->notSaved(1);
    TrEd::Undo::save_undo($win,TrEd::Undo::prepare_undo($win,"Edit Attribute '$attr'",TrEd::Undo::undo_type_id('UNDO_DATA'),$node));
    TrEd::Bookmarks::last_action_bookmark($grp);
    $node->set_member($attr,decode($newvalue));
    doEvalHook($win,"after_edit_attr_hook",$node,$attr,1);
    get_nodes_fsfile_tree($grp,$win->{FSFile},$win->{treeNo});
    redraw_fsfile_tree($grp,$win->{FSFile},$win->{treeNo});
  } else {
    doEvalHook($win,"after_edit_attr_hook",$node,$attr,0);
  }
  $d->destroy;
  undef $d;
  return ($result =~ /OK/) ? 1 : 0;
}

#############################################
# redraw tree etc.
#############################################

sub nodeOptions {
  my ($win,$node)=@_;
  return unless $win->{FSFile};
  return $win->treeView->node_options($node,
					$win->{FSFile}->FS,
					$win->{currentNode});
}

sub nodeBoxOptions {
  my ($win,$node,$edge)=@_;
  return unless $win->{FSFile};
  return $win->treeView->node_box_options($node,
					 $win->{FSFile}->FS,
					 $win->{currentNode},$edge);
}

# sub redraw_win
sub redraw_win {
    my ($win) = @_;
    if ($win) {
        return $win->redraw();
    }
    return;
}

sub redraw_fsfile {
  my ($grp,$fsfile)=@_;
  return if $insideEval or !$fsfile;
  foreach (fsfileDisplayingWindows($grp,$fsfile)) {
    $_->redraw();
  }
  return;
}

sub redraw_stylesheet {
  my ($grp,$stylesheet)=@_;
  foreach my $win (stylesheetUsingWindows($grp,$stylesheet)) {
    $win->apply_stylesheet($stylesheet);
    $win->redraw();
  }
  return;
}


sub redraw_fsfile_tree {
  my ($grp,$fsfile,$tree_no)=@_;
  return if $insideEval or !$fsfile;
  foreach (grep {$_->{treeNo} == $tree_no}
	   fsfileDisplayingWindows($grp,$fsfile)) {
    $_->redraw();
  }
  return;
}

sub redraw_all {
  my ($grp)=@_;
  foreach (@{ $grp->{treeWindows} }) {
    $_->redraw();
  }
  return;
}

sub follow_mouse {
  my ($w, $grp)= @_;
  my $e= $w->XEvent;
  my $win=findCanvasWindow($grp,$w);
  my($x, $y)= ($e->x,$e->y);
  scrollCanvasToXY($w, $win, $x, $y);
}

sub follow_mouse_press {
  my ($w, $grp)= @_;
  my $win=findCanvasWindow($grp,$w);
  my $e = $w->XEvent;
  initScrollOrigin($w,$win,$e->x,$e->y);
}
sub initScrollOrigin {
  my ($w, $win, $X, $Y)=@_;
  $win->treeView->store_gen_pinfo('scroll_origin',
				  [$X,$Y,$w->canvasx($X),$w->canvasy($Y)]);
}
#
# How this works:
# - initScrollOrigin registeres the initial window position of the mouse
# pointer and the corresponding canvas position
# - when the mouse moves towards an edge of the window,
# the view moves so that when it reaches the edge,
# the corresponding edge of the canvas drawing area
# (0,0,canvasWidth,canvasHeight) is reached.
# - If the mouse returns to the initial window position,
# the initial canvas point is also under the mouse pointer.
# - If the corresponding canvas edge is already visible, we do
# not move towards it.
#
# known bugs: if initially a negative canvas coord is seen
#


sub scrollCanvasToXY {
  my ($w, $win, $X, $Y)=@_;
  no integer;
  my $tv=$win->treeView;
  my @s = $w->cget('-scrollregion');
  if ($w->isa('Scrolled')) {
    $w=$w->Subwidget('scrolled');
  }
  my ($Ht,$ht,$Wd,$wd);
  my $origin = $tv->get_gen_pinfo('scroll_origin');
  return unless defined $origin;
  my ($cx,$cy);
  if ($X<$origin->[0]) {
    unless ($w->canvasx(0)<$s[0]) {
      ($wd,$Wd)=($origin->[0],$origin->[2]-$s[0]);
      $cx=$s[0]+($X/$wd) * $Wd;
    }
  } else {
    my $width = $w->width;
    unless ($w->canvasx($width)>$s[2]) {
      ($wd,$Wd)=($width-$origin->[0],$s[2]-$origin->[2]);
      $cx=$origin->[2]+(($X-$origin->[0])/$wd) * $Wd;
    }
  }
  if ($Y<$origin->[1]) {
    unless ($w->canvasy(0)<$s[1]) {
      ($ht,$Ht)=($origin->[1],$origin->[3]-$s[1]);
      $cy=$s[1]+($Y/$ht) * $Ht;
    }
  } else {
    my $height = $w->height;
    unless ($w->canvasy($height)>$s[3]) {
      ($ht,$Ht)=($height-$origin->[1],$s[3]-$origin->[3]);
      $cy=$origin->[3]+(($Y-$origin->[1])/$ht) * $Ht;
    }
  }
  $w->xviewCoord($cx, $X) if defined $cx and $cx>=$s[0] and $cx<=$s[2];
  $w->yviewCoord($cy, $Y) if defined $cy and $cy>=$s[1] and $cy<=$s[3];
  return;
}

# sub treeIsVertical

# sub treeIsReversed


sub currentLeft {
  my ($grp)=@_;
  my $win=$grp->{focusedWindow};
  return unless $win->{FSFile};
  my $node =$win->{currentNode};
  my $dp=DisplayedAncestor($win,$node);
  $node = PrevDisplayed($win,$node,$dp);
  while ($node) {
    my $ndp = DisplayedAncestor($win,$node);
    last if $ndp == $dp;
    $node = $ndp;
  }
  if ($node) {
    TrEd::Window::TreeBasics::set_current($win,$node);
    centerTo($win,$win->{currentNode});
  }
}

sub currentRight {
  my ($grp)=@_;
  my $win=$grp->{focusedWindow};
  return unless $win->{FSFile};
  my $node =$win->{currentNode};
  my $dp=DisplayedAncestor($win,$node);
  $node = NextDisplayed($win,$node->rightmost_descendant,$dp);
  if ($node and $dp == DisplayedAncestor($win,$node)) {
    TrEd::Window::TreeBasics::set_current($win,$node);
    centerTo($win,$win->{currentNode});
  }
}

sub currentRightLin {
  my ($grp)=@_;
  my $win=$grp->{focusedWindow};
  my $tv =$win->treeView;
  my @nodes = grep { $tv->node_is_displayed($_) } @{$win->{Nodes}};
  my $node = $win->{currentNode};
  my $idx = Index(\@nodes,$node);
  if ($idx<$#nodes) {
    $node = $nodes[$idx+1];
    TrEd::Window::TreeBasics::set_current($win,$node);
    centerTo($win,$win->{currentNode});
  }
}
sub currentLeftLin {
  my ($grp)=@_;
  my $win=$grp->{focusedWindow};
  my $tv =$win->treeView;
  my @nodes = grep { $tv->node_is_displayed($_) } @{$win->{Nodes}};
  my $node = $win->{currentNode};
  my $idx = Index(\@nodes,$node);
  if ($idx>0) {
    $node = $nodes[$idx-1];
    TrEd::Window::TreeBasics::set_current($win,$node);
    centerTo($win,$win->{currentNode});
  }
}

sub currentRightWholeLevel {
  my ($grp)=@_;
  my $win=$grp->{focusedWindow};
  my $tv = $win->treeView;
  return unless $win->{FSFile};
  my @nodes = grep { $tv->node_is_displayed($_) } @{$win->{Nodes}};
  my $node = $win->{currentNode};
  my $level = $tv->get_node_pinfo($node,'Level');
  my $idx = Index(\@nodes,$node);
  while ($idx<$#nodes) {
    $node = $nodes[++$idx];
    if ($level==$tv->get_node_pinfo($node,'Level')) {
      TrEd::Window::TreeBasics::set_current($win,$node);
      centerTo($win,$win->{currentNode});
      return;
    }
  }
  return;
}

sub currentLeftWholeLevel {
  my ($grp)=@_;
  my $win=$grp->{focusedWindow};
  my $tv = $win->treeView;
  return unless $win->{FSFile};
  my @nodes = grep { $tv->node_is_displayed($_) } @{$win->{Nodes}};
  my $node = $win->{currentNode};
  my $level = $tv->get_node_pinfo($node,'Level');
  my $idx = Index(\@nodes,$node);
  while ($idx>0) {
    $node = $nodes[--$idx];
    if ($level==$tv->get_node_pinfo($node,'Level')) {
      TrEd::Window::TreeBasics::set_current($win,$node);
      centerTo($win,$win->{currentNode});
      return
    }
  }
  return;
}

sub currentDown {
  my ($grp)=@_;
  my $win=$grp->{focusedWindow};
  return unless $win->{FSFile};
  my $node = $win->{currentNode}->firstson;
  while ($node and !$win->treeView->node_is_displayed($node)) {
    $node = NextDisplayed($win,$node,$win->{currentNode});
  }
  if ($node) {
    TrEd::Window::TreeBasics::set_current($win,$node);
    centerTo($win,$win->{currentNode});
  }
}

sub currentUp {
  my ($grp)=@_;
  my $win=$grp->{focusedWindow};
  my $node = $win->{currentNode};
  $node = $node && $node->parent;
  while ($node and !$win->treeView->node_is_displayed($node)) {
    $node = $node->parent;
  }
  if ($node) {
    TrEd::Window::TreeBasics::set_current($win,$node);
    centerTo($win,$win->{currentNode});
  }
}

#######################################################################################
# Usage         : center_to_coords($win, $x, $y)
# Purpose       : Adjust scroll region to display point with coordinates $x, $y 
#                 in the center of the Window
# Returns       : Undef/empty list if $node is not defined or if $win->{noRedraw} is set.
#                 1 on success.
# Parameters    : TrEd::Window ref $win      -- reference to TrEd::Window object
#                 Treex::PML::node ref $node -- reference to Node which is supposed to be in the centre of the Window
# Throws        : No exception
# Comments      :  
# See Also      : centerTo()
sub center_to_coords {
    my ( $win, $x, $y ) = @_;
    return if ( !defined $win );
    my $canvas = $win->treeView()->canvas();
    $canvas->xviewCenter( coord => $x );
    $canvas->yviewCenter( coord => $y );
    return 1;
}

#######################################################################################
# Usage         : centerTo($win, $node)
# Purpose       : Adjust scroll region to display node $node in the center of the Window
# Returns       : Undef/empty list if $node is not defined or if $win->{noRedraw} is set.
#                 1 on success.
# Parameters    : TrEd::Window ref $win      -- reference to TrEd::Window object
#                 Treex::PML::node ref $node -- reference to Node which is supposed to be in the centre of the Window
# Throws        : No exception
# Comments      :  
# See Also      : center_to_coords()
# Footnote      : Can not be renamed now, used in ElixirFM, suggested new name: center_to_node()
sub centerTo {
    my ( $win, $node ) = @_;
    return if (!defined $node || !defined $win);
    return if $win->{noRedraw};
    my $tree_view = $win->treeView();
    $tree_view->reset_scroll_region();
    center_to_coords(
        $win,
        $tree_view->get_node_pinfo( $node, "XPOS" ),
        $tree_view->get_node_pinfo( $node, "YPOS" )
    );
    return 1;
}


sub doEvalHookWithUndo {
  _evalHook(1,@_);
}
sub doEvalHook {
  _evalHook(0,@_);
}
sub _evalHook {
  my ($with_undo,$win,$hook)=(shift,shift,shift);
  
  return unless $hook; # and $win->{currentNode};
  return if (!defined $win);
  my $grp = $win->{framegroup};
  # Save current position (as last action position)
  my $bookmark= $with_undo ? TrEd::Bookmarks::actual_position($grp) : undef;


  local $insideEval=1;
  my $old_ctxt = TrEd::Macros::save_ctxt();
  my $context='TredMacro';
  set_macro_variable(
    FileNotSaved => '?',
    libDir => $libDir,
    forceFileSaved => 0
   );
  my $minor_modes;
  if ($win) {
    set_macro_variable(
      this => $win->{currentNode},
      root => $win->{root},
      grp => $win,
     );
    $context = $win->{macroContext} || 'TredMacro';
    $minor_modes = $win->{minorModes};
    if (ref($minor_modes)) {
      my $pre_hooks = $grp->{minorPreHooks}{$hook};
      for my $minor (@$minor_modes) {
	my $pre_hook = $pre_hooks->{$minor};
	if (defined $pre_hook) {
	  print STDERR "running pre-hook $hook for $minor : $pre_hook\n"  if $hookDebug;
	  eval { $pre_hook->(@_) };
	  TrEd::Error::Message::error_message($win,$@) if $@;
	}
      }
    }
  }
  #print "About to run hook $context->$hook: ";
  my $result=do_eval_hook($win,$context,$hook,@_);
  warn "$@\n" if $@;
  if (ref($minor_modes)) {
    my $post_hooks = $grp->{minorPostHooks}{$hook};
    for my $minor (@$minor_modes) {
      my $post_hook = $post_hooks->{$minor};
      if (defined $post_hook) {
	print STDERR "running post-hook $hook for $minor : $post_hook\n" if $hookDebug;
	eval { $post_hook->(@_,$result) };
	TrEd::Error::Message::error_message($win,$@) if $@;
      }
    }
  }
  my $file_changed=get_macro_variable("FileNotSaved");

  if ($win) {
    if ($win->{FSFile}) {
      if ($file_changed ne '?' and $file_changed) {
	if ($with_undo) {
	  my $undo=TrEd::Undo::prepare_undo($win,"Hook $context"."->".$hook,TrEd::Undo::undo_type_id('UNDO_DISPLAYED_TREES')) if ($with_undo and $win and $win->{FSFile});
	  TrEd::Undo::save_undo($win,$undo);
	  TrEd::Bookmarks::last_action_bookmark($win->{framegroup},$bookmark);
	}
	$win->{FSFile}->notSaved(1);
      }
    }
    saveFileStateUpdate($win);
  }

  TrEd::Macros::restore_ctxt($old_ctxt);
  print STDERR "Hook $hook returned $result\n" if $hookDebug;
  return $result;
}


# sub examineEvent
# sub examineBindingsDialog



# macro
sub doEvalMacro {
  my ($win,$macro)=(shift,shift);
  return unless $macro;# and $win->{currentNode};
  return if (!defined $win); # we wouldn't be able to run functions like $win->toplevel, etc..
  my $bookmark=TrEd::Bookmarks::actual_position($win->{framegroup});
  $win->toplevel->Busy(-recurse=> 1);
  $insideEval=1;

  set_macro_variable(
    this => $win->{currentNode},
    root => $win->{root},
    libDir => $libDir,
    FileNotSaved => '?',
    forceFileSaved => 0,
    Redraw => 'file');

  
  my $result=do_eval_macro($win,$macro);
  my $current_win=get_macro_variable("grp");
  if ($win != $current_win and (blessed($current_win) and $current_win->isa('TrEd::Window')) ) {
    $win = $current_win;
  }
  my $current=get_macro_variable("this");
  my $file_not_saved=get_macro_variable("FileNotSaved");
  $file_not_saved=1 if $file_not_saved eq '?';
  if ($win->{FSFile}) {
    if (get_macro_variable("forceFileSaved")) {
      print STDERR "Macro forcedly claims file saved.\n";
      $win->{FSFile}->notSaved($file_not_saved ? 1 : 0);
      TrEd::Bookmarks::last_action_bookmark($win->{framegroup},$bookmark) if $file_not_saved;
    } else {
      if ($file_not_saved) {
        my $undo=TrEd::Undo::prepare_undo($win,TrEd::Macros::findMacroDescription($win,$macro,TrEd::Undo::undo_type_id('UNDO_DISPLAYED_TREES')));
        TrEd::Undo::save_undo($win,$undo);
        $win->{FSFile}->notSaved(1);
        TrEd::Bookmarks::last_action_bookmark($win->{framegroup},$bookmark);
      } else {
	print STDERR "Macro claims file untouched.\n" if $macroDebug;
      }
    }
  }
  $insideEval=0;
  #------------------------------------------------------------
  #use Benchmark;
  #my $t0= new Benchmark;
  #for (my $i=0;$i<=50;$i++) {
  ### ??? 4kb/50 runs memory leaks in redraw (probably in Tk)
  #------------------------------------------------------------
  if (get_macro_variable("Redraw") eq 'all') {
    get_nodes_all($win->{framegroup});
    redraw_all($win->{framegroup});
  } elsif (get_macro_variable("Redraw") eq 'win') {
    $win->get_nodes();
    $win->redraw();
  } elsif (get_macro_variable("Redraw") eq 'tree') {
    get_nodes_fsfile_tree($win->{framegroup},$win->{FSFile},$win->{treeNo});
    redraw_fsfile_tree($win->{framegroup},$win->{FSFile},$win->{treeNo});
  } elsif (get_macro_variable("Redraw") eq 'tie') {
    if ($win->{framegroup}->{tieWindows}) {
      get_nodes_all($win->{framegroup});
      redraw_all($win->{framegroup});
    } else {
      $win->get_nodes();
      $win->redraw();
    }
  } elsif (get_macro_variable("Redraw") eq 'none') {
    # do nothing
  } else {
    get_nodes_fsfile($win->{framegroup},$win->{FSFile});
    redraw_fsfile($win->{framegroup},$win->{FSFile});
  }
  #------------------------------------------------------------
  #}
  #my $t1= new Benchmark;
  #my $td= timediff($t1, $t0);
  #print "${TredMacro::FileNotSaved} the code took:",timestr($td),"\n";
  #------------------------------------------------------------

  # the rest of this routine is:
  # memory ok, speed ok
  TrEd::Window::TreeBasics::set_current($win,$current) if ($current);
  $win->ensure_current_is_displayed();

  set_macro_variable(
    this => undef,
    root => undef,
    grp => undef
   );

  centerTo($win,$win->{currentNode});
  update_title_and_buttons($win->{framegroup});

  $win->toplevel->Unbusy;
  return $result;
}

sub resolveKey {
  my $grp = shift; # other arguments are keys
  my $win = $grp->{focusedWindow};
  my $minor_modes=$win->{minorModes};
  my $bindings;
  if ($minor_modes) {
    foreach my $minor_mode (@$minor_modes) {
      $bindings = $grp->{minorKeyPriorityBindings}{$minor_mode};
      foreach my $key (@_) {
	if ($bindings and exists $bindings->{$key}) {
	  return($bindings->{$key},$key);
	}
      }
    }
  }
  foreach my $context (TrEd::Utils::uniq($win->{macroContext},"TredMacro")) {
    foreach my $key (@_) {
      if (exists ($TrEd::Macros::keyBindings{$context}->{$key})) {
	return($TrEd::Macros::keyBindings{$context}->{$key},$key)
      }
    }
  }
  if ($minor_modes) {
    foreach my $minor_mode (@$minor_modes) {
      $bindings = $grp->{minorKeyBindings}{$minor_mode};
      foreach my $key (@_) {
	if ($bindings and exists $bindings->{$key}) {
	  return($bindings->{$key},$key);
	}
      }
    }
  }
  return undef;
}

sub resolveEvent {
  my ($w,$grp,$prefix)=@_;
  my $key;
  my $e= $w->XEvent;
  my $A= $e->A;
  my $K= $e->K;
  my @possib=();
  my $macro=undef;
  my $rotated = 0;
  if (TrEd::Window::TreeBasics::tree_is_vertical($grp) and exists $TrEd::Config::vertical_key_arrow_map{$K}) {
    print STDERR "vertical tree: translating $K to " if $keyboardDebug;
    $K = $TrEd::Config::vertical_key_arrow_map{$K};
    print STDERR "$K\n" if $keyboardDebug;
    $rotated  = 1;
  }

  print STDERR "Prefix: $prefix\n" if $keyboardDebug;
  $prefix=~s/SHIFT\+//g unless ($K=~/^(?:left|right|up|down|next|prior|space|backspace|insert|delete|return|pause|escape|home|end|begin|select|print|execute|undo|redo|menu|find|cancel|help|break|F[0-9]+|L[0-9]+|R[0-9]+|ISO_Left_Tab)$/i);
  if ($keyboardDebug) {
    print STDERR "Pressed: (".ord($A)."), prefix $prefix, keysym $K/",$e->N,"\n";
    print STDERR "Maybe: $prefix$K\n";
  }
  if ($K =~ /^XF86_Switch_VT_(\d+)$/) {
    print STDERR "Translating $prefix $K to SHIFT+F$1\n" if $keyboardDebug;
    $prefix='SHIFT+';
    $K='F'.$1;
  }
  push @possib, ($prefix.$A,$prefix.$K);

  $macro = doEvalHook($grp->{focusedWindow},"event_hook",$e,$w,@possib);
  if (defined($macro)) {
    if ($macro eq 'stop') {
      print STDERR "Event blocked by event_hook\n" if $macroDebug || $keyboardDebug;
      return (undef,undef,$prefix.$A,$prefix.$K,1,$rotated);
    } else {
      print STDERR "Event translated by event_hook to '$macro'\n" if $macroDebug || $keyboardDebug;
      return ($macro,$key,$prefix.$A,$prefix.$K,1,$rotated);
    }
  } else {
    ($macro,$key)=resolveKey($grp,@possib);
    return ($macro,$key,$prefix.$A,$prefix.$K,undef,$rotated);
  }
}
# macro
sub evalMacro {
  my ($w,$grp,$prefix)=@_;
  my $win=$grp->{focusedWindow};

  my ($macro,$key)=resolveEvent($w,$grp,$prefix);
  if (defined $macro) {
      if ($tredDebug) {
        $grp->{statusLine}->set_text("$key, $macro");
        $grp->{statusLine}->update_status($win)
      }
#    use Benchmark;
#    my $t0= new Benchmark;
#    # ... your code here ...
#    for (my $i=0;$i<=50;$i++) {
    doEvalMacro($win,$macro);
#    }
#    my $t1= new Benchmark;
#    my $td= timediff($t1, $t0);
#    print "the code took:",timestr($td),"\n";

    return 1;
  } else {
    if ($tredDebug) {
        $grp->{statusLine}->set_text($key);
        $grp->{statusLine}->update_status($win);
    }
  }
  return undef;
}

sub tieGotoTree {
  my ($grp,$no)=@_;
  if ($grp->{tieWindows}) {
    my @tied = grep { $_->{FSFile} } @{$grp->{treeWindows}};
    if (@tied) {
      my $result = 1;
      foreach (@tied) {
	$result &&= TrEd::Window::TreeBasics::go_to_tree($_,$no);
      }
      return $result;
    } else {
      return 0
    }
  } else {
    if ($grp->{focusedWindow}->{FSFile}) {
      return TrEd::Window::TreeBasics::go_to_tree($grp->{focusedWindow},$no);
    } else {
      return 0;
    }
  }
}

sub tieNextTree {
  my ($grp)=@_;
  if ($grp->{tieWindows}) {
    my @tied = grep { $_->{FSFile} } @{$grp->{treeWindows}};
    if (@tied) {
      my $result = 1;
      foreach (@tied) {
	$result &&= TrEd::Window::TreeBasics::next_tree($_);
      }
      return $result;
    } else {
      return 0
    }
  } else {
    if ($grp->{focusedWindow}->{FSFile}) {
      my $result = TrEd::Window::TreeBasics::next_tree($grp->{focusedWindow});
      return $result;
    } else {
      return 0;
    }
  }
}

sub tiePrevTree {
  my ($grp)=@_;
  if ($grp->{tieWindows}) {
    my @tied = grep { $_->{FSFile} } @{$grp->{treeWindows}};
    if (@tied) {
      my $result = 1;
      foreach (@tied) {
	$result &&= TrEd::Window::TreeBasics::prev_tree($_);
      }
      return $result;
    } else {
      return 0
    }
  } else {
    if ($grp->{focusedWindow}->{FSFile}) {
      my $result = TrEd::Window::TreeBasics::prev_tree($grp->{focusedWindow});
      return $result;
    } else {
      return 0;
    }
  }
}
# node?
sub currentNext {
  my ($win)=@_;
  my $next=NextDisplayed($win,$win->{currentNode});
  if ($next) {
    TrEd::Window::TreeBasics::set_current($win,$next);
    centerTo($win,$win->{currentNode});
  }
}

# node?
sub currentPrev {
  my ($win)=@_;
  my $prev=PrevDisplayed($win,$win->{currentNode});
  if ($prev) {
    TrEd::Window::TreeBasics::set_current($win,$prev);
    centerTo($win,$win->{currentNode});
  }
}
# node
sub node_select {
  my($w,$grp)= @_;
  my $win=findCanvasWindow($grp,$w);
  my $tv=$win->treeView;
  my $e= $w->XEvent;
  my($x, $y)= ($e->x, $e->y);
  my ($canvas_obj) = $tv->find_item('withtag','current');
  my $node=$tv->get_obj_pinfo($canvas_obj);
  TrEd::Window::TreeBasics::set_current($win,$node);
}
# node
{
  my ($nx,$ny);
sub node_down {
  my($w,$grp,$scroll)= @_;
  my $win=findCanvasWindow($grp,$w);
  my $tv=$win->treeView;
  my $e= $w->XEvent;
  ($nx, $ny)= ($e->x, $e->y);
  if ($scroll) {
    initScrollOrigin($w,$win,$nx,$ny);
  }
  my ($canvas_obj) = $tv->find_item('withtag','current');
  my $node=$tv->get_obj_pinfo($canvas_obj);

  unless (first { $_ eq 'point' } $w->gettags($canvas_obj)) {
    my ($cx,$cy)=($w->canvasx($nx),$w->canvasy($ny));
    $canvas_obj = first {
      first { $_ eq 'point' } $w->gettags($_)
    } $tv->find_item(overlapping => $cx-1,$cy-1,$cx+1,$cy+1);
    if ($canvas_obj and $node!=$tv->get_obj_pinfo($canvas_obj)) {
      undef $canvas_obj;
    }
  }
  TrEd::Window::TreeBasics::set_current($win,$node);
  $w->dtag('selected');
  return unless $canvas_obj;
  $w->addtag('selected', 'withtag', $canvas_obj);
  $w->raise('selected');
  $w->raise("text[$node]");
}				# end plot_down
# node
sub node_move {
  my($w,$grp,$scroll)= @_;
  my $win=findCanvasWindow($grp,$w);
  my $tv=$win->treeView;
  my ($sel)=$tv->find_item('withtag','selected');
  return unless $sel;

  my $e= $w->XEvent;
  my ($deltax,$deltay) = (-$nx,-$ny);
  ($nx,$ny)= ($e->x, $e->y);
  $deltax+=$nx; $deltay+=$ny;
  my ($cx, $cy)= ($w->canvasx($nx),$w->canvasy($ny));
  if ($scroll) {
    $deltax-=$cx; $deltay-=$cy;
    scrollCanvasToXY($w, $win, $nx, $ny);
    ($cx, $cy)= ($w->canvasx($nx),$w->canvasy($ny));
    $deltax+=$cx; $deltay+=$cy;
  }
  $w->move('selected',$deltax,$deltay);
  my $nearest=$tv->get_obj_pinfo($tv->find_item('withtag','nearest'));
  if ($nearest) {
    $w->itemconfigure('nearest',nodeOptions($win,$nearest));
    $tv->apply_stored_style_opts("Oval",$nearest);
    $w->dtag('nearest');
  }

  my @nodes= $w->find('withtag','point');
  my $node=$tv->get_obj_pinfo($sel);
  my $bestDist=10000;
  my $dist;
  $nearest=undef;
  foreach my $p (@nodes) {
    my @b = $w->bbox($p);
    my ($dX,$dY) = (($b[2]+$b[0])/2-$cx,($b[3]+$b[1])/2-$cy);
    my $n=$tv->get_obj_pinfo($p);
    if ($n and $n!=$node) {
      $dist=$dX*$dX+$dY*$dY;
      if ($bestDist>$dist) {
	$bestDist=$dist;
	$nearest=$p;
      }
    }
  }
  if (defined($nearest) and $bestDist<800) {
    $w->addtag('nearest','withtag',$nearest);
    $w->itemconfigure($nearest, -fill=> $tv->get_nearestNodeColor);
  }
}				# end plot_move
}
# node
sub node_release {
  my($w,$grp,$button)= @_;
  my $win=findCanvasWindow($grp,$w);
  return unless $win->{FSFile};

  my $tv=$win->treeView;
  my ($sel)=$tv->find_item('withtag','selected');
  return unless $sel;

  my $e= $w->XEvent;
  my($x, $y)= ($e->x, $e->y);
  my $parent;
  my $node;
  my $center=0;
  $node=$tv->get_obj_pinfo($sel) if (defined ($sel));
  if ($node) {
    my ($p)=$tv->find_item('withtag','nearest');
    $w->dtag('nearest');
    $w->dtag('selected');
    if (defined $p) {
      $parent=$tv->get_obj_pinfo($p);
      $w->itemconfigure($tv->get_node_pinfo($parent,"Oval"),
			  nodeOptions($win,$parent));
      $tv->apply_stored_style_opts("Oval",$parent);
      if (doEvalHookWithUndo($win,"node_release_hook",$node,$parent,"$button",$e) ne 'stop') {
	if ($parent->test_child_type($node) or
	    TrEd::Query::User::new_query($win,"WARNING:\n\n".
			"The target node does not permit the dragged node ".
			  "as a child.\nThe resulting tree will be invalid.\n\n",
		      -bitmap=> 'question',
		      -title => 'Incompatible node type',
		      -buttons => ["Do not paste",'Paste anyway']) eq 'Paste anyway') {
	  my $top=$parent;
	  while ($top) {
	    if ($node eq $top) {
	      undef $parent;
	      last;
	    }
	    $top=$top->parent;
	  }
	  if ($parent and $node->parent!=$top) {
	    TrEd::Undo::save_undo($win,TrEd::Undo::prepare_undo($win, "Cut/Paste node with mouse"),TrEd::Undo::undo_type_id('UNDO_DISPLAYED_TREES'));
	    my $oldparent=$node->parent;
	    $node->cut()->paste_on(
			 $parent,
			 $win->{FSFile}->FS);
	    $win->{FSFile}->notSaved(1);
	    doEvalHook($win,"node_moved_hook",$node,$oldparent);
	    TrEd::Bookmarks::last_action_bookmark($grp);
	    get_nodes_fsfile($grp,$win->{FSFile});
	    redraw_fsfile_tree($grp,$win->{FSFile},$win->{treeNo});
	    centerTo($win,$win->{currentNode});
	    return;
	  }
	}
      }
    }
    # returning node to its position
    $w->coords($sel, $tv->node_coords($node,$win->{currentNode}));
    # print lower;
    $w->lower($sel,'point');
  } else { $win->redraw(); }
}
# node
sub node_release_modif {
  my($w,$grp,$mod)= @_;
  my $win=findCanvasWindow($grp,$w);
  my $tv=$win->treeView;
  return unless $win->{FSFile};
  my $e= $w->XEvent;
  my($x, $y)= ($e->x, $e->y);
  my $parent;
  my $node;
  my $center=0;
  my ($sel)=$tv->find_item('withtag','selected');
  $node=$tv->get_obj_pinfo($sel) if (defined ($sel));
  if ($node) {
    my ($p)=$tv->find_item('withtag','nearest');
    $w->dtag('nearest');
    if (defined $p) {
      $parent=$tv->get_obj_pinfo($p);
      $w->itemconfigure($tv->get_node_pinfo($parent,"Oval"),
			  nodeOptions($win,$parent));
      doEvalHookWithUndo($win,"node_release_hook",$node,$parent,$mod,$e);
    } else {
      doEvalHookWithUndo($win,"node_release_hook",$node,undef,$mod,$e);
    }
    # try to detect that the tree was redrawn
    if ($tv->find_item('withtag','selected')) {
      # returning selected node to its position
      $w->dtag('selected');
      $w->coords($sel, $tv->node_coords($node,$win->{currentNode}));
    }
  } else { redraw_fsfile_tree($grp,$win->{FSFile},$win->{treeNo}); }
}

#sub prepare_undo 
#TODO: only for extensions/macros -- temporary solution
sub prepare_undo {
  return TrEd::Undo::prepare_undo(@_);
}
#sub prepare_redo
#sub save_undo
sub save_undo {
  return TrEd::Undo::save_undo(@_);
}
#sub re_do
sub re_do {
  return TrEd::Undo::re_do(@_);
}
#sub undo
sub undo {
  return TrEd::Undo::undo(@_);
};
#sub resetUndoStatus

sub resetTreePosStatus {
  my ($grp)=@_;
  my $win=$grp->{focusedWindow};
  my $fsfile=$win->{FSFile};

  my $prevstatus=ref($fsfile) && $fsfile->lastTreeNo>=0 && $win->{treeNo}>0;
  my $nextstatus=ref($fsfile) && $fsfile->lastTreeNo>$win->{treeNo};
  if ($win->{framegroup}->{nextButton}) {
    $win->{framegroup}->{nextButton}->
      configure(-state => ($nextstatus ? 'normal' : 'disabled'));
  }
  if ($win->{framegroup}->{prevButton}) {
    $win->{framegroup}->{prevButton}->
      configure(-state => ($prevstatus ? 'normal' : 'disabled'));
  }
}


sub list_isearch {
  my ($w)=@_;
  my $e= $w->XEvent;
  my $A= $e->A;
  if ($A ne EMPTY) {
    my @items=$w->get(0,'end');
    my $count=$w->index('end');
    my $active=$w->index('active');
    for (my $i=$active+1;$i<=$active+$count;$i++) {
      if ($items[$i % $count] =~ /^$A/i) {
	$w->activate($i % $count);
	unless ($w->isa('Tk::Listbox') and
	    $w->cget('-selectmode') eq 'multiple' or
	    $w->cget('-selectmode') eq 'extended') {
	  $w->selectionClear(0,'end');
	  $w->selectionSet($i % $count);
	}
	$w->see($i % $count);
	Tk->break;
	return;
      }
    }
  }
}

# macro
#TODO: do TrEd::Macros
sub cleanup_tredmacro {
  my ($grp)=@_;

  # cleanup
  %TrEd::Macros::defines=(TRED => 1);
  my %packages;

  @packages { ('TredMacro',
	       grep {/\S/} 
	       grep { !/^main$|^TrEd::/ }
	       map  { (/^\s*package\s+([^;\s]+)\s*;/) } 
	       (@TrEd::Macros::macros))
	    } = ();
  my %kept_pkg;
  my %deleted_pkg;
  foreach my $package ( sort { length $b <=>length $a } keys %packages ) {
    no strict qw(refs);
    print STDERR ("Cleaning package $package\n") if $tredDebug;
    my $pkg_file = $package;
    $pkg_file =~ s{::}{/}g;
    $pkg_file .= '.pm';
    my @pkg_vars = grep { !/::$/ } keys %{$package.'::'};
    
    foreach my $var (@pkg_vars) {
        delete ${$package.'::'}{$var};
    }
    if (%{$package.'::'}) {
        undef @kept_pkg{ map { $package.'::'.$_ } keys %{$package.'::'} };
    }
    undef $deleted_pkg{$package.'::'};
    delete $INC{$pkg_file};
    eval("package $package; use UNIVERSAL qw(isa can);");
    print STDERR $@ if $@;
  }
  print STDERR "KEPT: @{[join qq(\n\t),keys %kept_pkg]}.\n",
    "DELETED: @{[join qq(\n\t),keys %deleted_pkg]}\n"
      if $tredDebug;

    # workaround to reinit TredMacro namespace, 
    # since the functions can be overridden by extensions,
    # we have to reinit default behaviour
    delete $INC{'TrEd/ExtensionsAPI.pm'};
    delete $INC{'TrEd/Mac.pm'};
    delete $INC{'TrEd/NtredMak.pm'};

}

# sub declareMinorMode
# sub enableMinorMode
# sub disableMinorMode
# sub toggleMinorMode
# sub _minor_ctxt_abbrev
# sub configure_minor_mode
# sub update_minor_modes

# sub update_minor_mode_menu

#sub valueLineClick

#TODO poslat do TrEd::Extensions, s tym, ze z btredu bude treba doplnit prevzatie arguemntov
# a vypis extensions do nejakeho suboru, odtialto potom odfiltrovat init_extensions
# extensions
#sub prepareExtensions 


# macros
#TODO: skor load_extensions
sub loadMacros {
  my ($grp,$opts)=@_;
  $opts||={};
  use Data::Dumper;
  
  
#  test_tredmacro();
  
  read_macros(); # read macro tred.mac (and tred.def)
  
  require TrEd::ExtensionsAPI; #this loads TredMacro API
  # not sure why, we don't need it here...
  #TredMacro->import;
  TredMacro::init_tredmacro_bindings();
  
  # set minor modes and this stuff, can't do it at compile time, since there is no grp...
    TrEd::Macros::set_macro_variable('grp', $grp->{focusedWindow});
    # minor modes
    require TrEd::MinorMode::Move_Nodes_Freely;
    require TrEd::MinorMode::Show_Neighboring_Sentences;
    require TrEd::MinorMode::Show_Neighboring_Trees;
    
    # minors
    TrEd::MinorMode::Move_Nodes_Freely::init_minor_mode();
    TrEd::MinorMode::Show_Neighboring_Sentences::init_minor_mode();
    TrEd::MinorMode::Show_Neighboring_Trees::init_minor_mode();
  
#print 'before loading macros: ' . Dumper(\%TredMacro::);

  my $preinst_dir = get_preinstalled_extensions_dir();

  my ($extensions,$pre_installed);
  if (ref($opts->{preparedExtensions})) {
    ($extensions,$pre_installed)=@{$opts->{preparedExtensions}}
  } else {
    ($extensions,$pre_installed)=@{ TrEd::Extensions::prepare_extensions($opt_m) };
  }

  foreach my $path (get_extension_sample_data_paths($extensions),
		    get_extension_sample_data_paths($pre_installed,$preinst_dir)) {
    foreach my $extensions_filelist (glob(File::Spec->catfile($path,'*.fl'))) {
      TrEd::ManageFilelists::create_ext_filelist($extensions_filelist);
    }
  }

  print STDERR ("Reading extension macros:") unless $opt_q;
  for my $ext_contrib (get_extension_macro_paths($extensions),
		       get_extension_macro_paths($pre_installed,$preinst_dir)) {
    
    if (-f $ext_contrib) {
      if ($tredDebug) {
	print STDERR ("Reading extension macros from $ext_contrib...\n");
      } elsif (!$opt_q) {
	my $name = $ext_contrib;
	$name=~s{.*/extensions/([^/]+)/contrib.*}{$1};
	print STDERR (" $name");
      }
      push @TrEd::Macros::macros,qq(\n#line 0 "$ext_contrib"\n{\npackage TredMacro;\n);
      read_macros($ext_contrib,$libDir,1);
      push @TrEd::Macros::macros,qq(\n} # end of "$ext_contrib"\n);
    }
  }
  print STDERR " ... done\n" if !$opt_q and !$tredDebug;
  if ($opt_I) {
    print STDERR ("Reading additional macros from $opt_I...") unless $opt_q;
    push @TrEd::Macros::macros,qq(\n#line 0 "$opt_I"\n{\npackage TredMacro;\n);
    read_macros($opt_I,$libDir,1);
    push @TrEd::Macros::macros,qq(\n} # end of "$opt_I"\n);
    print STDERR "done.\n" unless $opt_q;
  }
#test_tredmacro();
}


# macros
sub reloadMacros {
  my ($grp,$opts)=@_;
  doEvalHook($grp->{focusedWindow},"reload_macros_hook");
  delete $grp->{minorModes};
  delete $grp->{minorPreHooks};
  delete $grp->{minorPostHooks};

# this should not be necessary, loadMacros takes care of it
#  %TrEd::Macros::keyBindings=();
#  %TrEd::Macros::menuBindings=();
  TrEd::TreeView->clear_code_caches;
  
  #use Data::Dumper;
  
#  print 'before: ' . Dumper(\%TredMacro::);
  
  cleanup_tredmacro($grp);
  
#  print 'after cleaning: ' . Dumper(\%TredMacro::);
  
  TrEd::Toolbar::User::Manager::reset_user_toolbars($grp);

  loadMacros($grp,$opts);
  doEvalHook($grp->{focusedWindow},"macros_reloaded_hook");
  doEvalHook($grp->{focusedWindow},"initialize_bindings_hook");

  TrEd::Menu::Macro::update_macro_menus($grp);
  TrEd::List::Macros::update_view($grp);
  get_nodes_all($grp);
  redraw_all($grp);
}
# extensions, should it be moved to TrEd::Extensions..?
sub manage_extensions {
  my ($grp,$do_reload) = @_;
  my $reload_macros;
  my $repos = [ split /\s+/, $extensionRepos ];
  TrEd::Extensions::manage_extensions_2($grp, {
    repositories => $repos,
    reload_macros => \$reload_macros,
  });
  my $new = $extensionRepos;
  $new = join ' ', @$repos;
  if ($new=~/\S/ and $new ne $extensionRepos) {
    $extensionRepos=$new;
    TrEd::RuntimeConfig::save_runtime_config($grp,{
      extensionRepos => $extensionRepos,
    });
  }
  if ($do_reload and $reload_macros) {

    # reload stylesheets
    TrEd::Stylesheet::init_stylesheet_paths([split($Treex::PML::resourcePathSplit,$opt_S,-1)]);

    my $preparedExtensions = TrEd::Extensions::prepare_extensions($opt_m);

    TrEd::Stylesheet::load_stylesheets($grp);
    $grp->{StylesheetMenu}->update($grp);
    updateHelpMenu($grp,{preparedExtensions => $preparedExtensions});
    
    # reload macros
    reloadMacros($grp,{preparedExtensions => $preparedExtensions});
  }
}

__END__

=head1 NAME

TrEd - a graphical visualizer and editor of tree graphs

=head1 SYNOPSIS

 tred [-q] [-c <config-file>] [-m|-I <macro-file>] [-t context]
      [-l <filelist>] [-n encoding] [other-options] [file[##N|##N.M|#ID] ...]

or

  tred -C <command>

or

  tred -u          for usage
  tred -h          for help
  tred --man       for the manual page
  tred --version   for version

=head1 DESCRIPTION

TrEd is a graphical visualizer and editor of tree graphs.

=head2 Filename arguments

Each filename on the command-line or in a file list may be optionally
followed by a suffix which identifies a node to be selected when the
file is opened.  The suffix can be of one of the following following
forms:

#ID     where ID is an identifier of a node (for file formats that have
        identifiers, e.g. PML).

##N     where N is a number. This selects the root of the N-th tree

##N.M   where N and M are numbers. This selects the M-th node in 
        the depth-first order in the N-th tree.

=head2 Options

=over 8

=item B<-C> command

Perform a given command on a running instance of TrEd.
Currently only one command is supported:

  open <filename>

If there is no TrEd instance running, the filename is opened in a new
instance.

=item B<--filelist|-l> filename

Read a list of filenames to process from a given file (one filename
per line). Files specified in a file-list are processed prior to files
specified on the command-line. If file-list is a file with .fl
extension, then the first line may contain a file-list name (as in
TrEd). Moreover, unlike in other file-lists, filenames in .fl
file-lists are asssumed to be relative to the file-list file location.

=item B<--macro-file|-m> filename

File with macro definitions to load.  If no macro-file is given,
standard macro file (by default F<tred.mac>) is used.

=item B<--include-macro-file|-I> filename

A file containing additional set of macros to load. This option is
typically used instead of C<--macro-file> to allow loading macros
B<both> from C<filename> B<and> the default macro set (F<tred.mac>).
C<--macro-file> can still be used in combination with
B<--include-macro-file> to supply a replacement for F<tred.mac>.

=item B<--config-file|-c> filename

TrEd configuration file (overrides ~/.tredrc).

=item B<--option|-O> name=value

Override configuration option from the config file with a given
value. This flag can be used several times for different options.

Special syntax of the name part allows some modifications of existing
option values for options that are delimited lists (this cannot be
used to modify default or implicit values):

=over 8

=item nameX=value

Treat the option as a list delimited by the delimiter X and
prepend the value to the list.

=item  nameX+=value

Treat the option as a list delimited by the delimiter X and append the
value to the list.

=item  nameX-=value

Treat the option as a list delimited by the delimiter X and remove the
value from the list (if exists).

=back

Only the following characters can be used as a delimiter:

      ; : , & | / + - \s \t SPACE

where SPACE is a space character, \s matches arbitrary white-space,
and \t matches TAB character.

The options can be combined; for example

  -O "extensionRepos\\s"-=http://foo/bar -O "extensionRepos\\s"+=http://foo/bar

first removes any occurrence of the URL http://foo/bar from the
white-space separated list of extensionRepos and then appends the URL
to the end of the list.

=item B<--stylesheet-file> path

Path may be either a file name, in which case it must point to a TrEd
stylesheet configuration file in the old format or ~/.tred-stylesheets
(obsolete), or a directory, in which case each file in the directory
must be a TrEd stylesheet.

=item B<--resource-dir|-Z> dirnames

Specifies resource path. This option can be repeated and overrides
ResoucePath setting in the TrEd configuration file. 

Individual paths can also be separated by colon (POSIX/Unix) or
semi-colon (Windows) separator. If there is a lone leading or trailing
separator, the default resource path is prepended or appended,
respectively.

=item B<--context|-t> context_name

Initial macro context.

=item B<--show-hidden-nodes|-H> 

Start in the mode where hidden nodes are displayed.

=item B<--stylesheet|-s> stylesheet-name

Initial stylesheet to render the tree according to.

=item B<--split-window|-p> number

Split window to given number of subwindows (horizontally if
positive, vertically if negative) and open n'th file
in n'th subwindow.

=item B<--execute|-e> perl-code

Macro code to evaluate just before the main loop is started.

=item B<--window-embed|-W> window_ID

Embed main window into window with the given window ID.

=item B<--no-geometry|-G>

Do not initially resize window to its last geomtery.

=item B<--extra-backends|-B> backend

Comma separated list of user-defined IO-backend modules to load.

=item B<--file-encoding|-n> encoding

Allows to specify character encoding of input files (does not apply to
XML files).

=item B<--define-symbol> symbol_name

Symbol name or a name=value pair to be used by macro-preprocessor
(equivalent to a C<#define> instruction at the beginning of the macro
file). Multiple definitions symbols may be separated by a comma and
the option may be repeated.

=item B<--no-secondary-files|-Y>

Neither load or save "secondary" files. Normally, secondary files (if
loaded) are saved along with their primary files (the exactly same
file-name prefix/suffix processing and format apply to both the
primary and secondary files). A secondary file is a file required by a
(normal - primary) file to be loaded along with it; this is typical
for files containing some form of a stand-off annotation where one
tree is built upon another. Note however, that this does not include so
called knitting - an operation where the stand-off annotation is
handled by a IO backend and the resulting knitted file appears to
btred as a single unit.

=item B<--enable-extensions|-j> list

Give a comma-separated list of installed TrEd extension names to
temporarily enable if disabled in the extension configuration.
Use '*' to enable all currently enabled extensions.

=item B<--disable-extensions|-J> list

Give a comma-separated list of installed TrEd extension names to
temporarily disable if enabled in the extension configuration.
Use '*' to disable all currently enabled extensions.

=item B<--tectogrammatical-trees|-R>

Build tectogrammatic trees from CSTS files.

=item B<--csts-tree-attributes|-X> gov,ord?,hide?

CSTS format is "many in one"; there may be more tree structures in one
file.  This option can be used to specify which tree structure should
be used.  Provide a comma separated list consisting of names of node
atributes corresponding to CSTS elements that contain the necessary
information to build a tree out of a CSTS file. The first attribute
should be an attribute containing the index of the governing node; the
second one is optional and specifies the ordering attribute; the third
one is also optional and if specified, it should be the attribute used
to mark hidden nodes with the string 'hide'. If the third argument is
specified as empty (i.e. there is a trailing comma), default to
'X_hide' with preset-value 'hide'. 

Examples: 
  -X govTR,dord  - corresponds to elements <TRg> and <tfr>
                   in CSTS

  -X govMD_c,ord,x_MD_c_hide 
                 - corresponds to <MDg src="c">, <r>, 
                   and <x name="MD_c_hide">).

=item B<--no-backups>

Do not generate `tilda' backup files.

=item B<--no-locks>

Do not attempt to create lock files. Lock files are used to prevent
another TrEd instance/user from modifying the same document.

=item B<--autosave> number

Create an auto-save file for each modified document every given number
of minutes. If 0, auto-saving is disabled.

=item B<--quiet|-q>

Print only general processing information on stderr.

=item B<--debugging|-D>

Print a lot of debugging information on the stderr.

=item B<--carp>

Replace 'die' with 'Carp::confess', so that a complete stack trace is
printed upon error. Useful for debugging.

=item B<--version|-v>

Print version and quit.

=item B<--man|-m>

Displays the help as manual page.

=item B<--help|-h>

Prints the help page and exits.

=item B<--usage|-u>

Print a brief help message on usage and exits.

=back

=head1 SEE ALSO

TrEd User Manual at http://ufal.mff.cuni.cz/~pajas/tred/ar01-toc.html
(also located in the documentation directory in the installation of
TrEd).

=head1 LICENSE

This software is distributed under GPL - The General Public Licence.
Full text of the GPL can be found in the LICENSE file distributed with
this program and also on-line at http://www.gnu.org/copyleft/gpl.html .

=head1 AUTHOR

Petr Pajas <pajas@matfyz.cz>

Copyright 2000-2008 Petr Pajas.

=cut

