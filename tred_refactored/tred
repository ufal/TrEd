#!/usr/bin/env perl
# -*- cperl -*-
#
# $Id: tred 4544 2010-12-28 17:42:53Z stepanek $
#
##############################################################################
#
# This is "TrEd" - a viewer and editor of tree graphs, such as
# dependency trees. TrEd uses PerlTk library as a GUI toolkit.
#
##############################################################################

use strict;
#use warnings;
use 5.008;

BEGIN {
############################################################
    # start of BEGIN section
############################################################

    if ( $^V lt 'v5.8.3' ) {
        print STDERR '-' x 50, "\n";
        print STDERR "WARNING: Your version of perl is older than v5.8.3\n";
        print STDERR "THINGS MAY NOT WORK AS EXPECTED OR NOT AT ALL!\n";
        print STDERR '-' x 50, "\n\n";
    }
    use Readonly;

    # from TrEd::Macros
    #%menuBindings %keyBindings

    use vars qw($dev_version $version $opt_u $opt_h $opt_c $opt_y
        $init_macro_context $opt_W $opt_G $opt_R $opt_X $opt_q $opt_B $opt_split_window
        $opt_n $opt_D $opt_v $opt_H $opt_I $opt_Z $opt_e
        $libDir $documentation_dir $list_options $opt_auto_save
        $macroFile
        $treeViewOpts $opt_m
        @ISA @EXPORT $opt_filelist $opt_s
        $opt_S
        $insideEval %pckey_shift_translates $tredDebug
        $appName
        $stderr $stdout

        $debug @normal_win_opts @focused_win_opts
        $locale_charset
        $no_secondary
        %HELP
        $manpage $listoptions $no_backups $no_locks  %optmap $carp
        $tred_d $VERSION
        $command
    );

    # $userlogin
    # $noCheckLocks
    # %vertical_key_arrow_map
    # @recentFiles
    # @filelists
    # %filelist_from_extension
    # @openfiles
    # $ioBackends
    # @backends
    # $NewFileNo
    # %save_types
    # @open_types
    # @save_types -- this is probably forgotten since it is never used
    # $valueLine -- this is probably forgotten since it is never used
    # $enable_extensions $disable_extensions -- moved to TrEd::Extensions
    # $configFile -> RuntimeConfig
    # %backend_map -> Config
    use Exporter;
    use base qw(Exporter);
    @EXPORT = qw($insideEval
        $libDir $stderr $stdout
        &min &max);

    # @openfiles
    # @filelists

    use Getopt::Long;
    use Pod::Usage;

    my $optparser = new Getopt::Long::Parser( config => ['bundling'] );
    %optmap = (
        'quiet|q'           => \$opt_q,
        'macro-file|m=s'    => \$opt_m,
        'config-file|c=s'   => \$TrEd::Config::cmdline_config_file,
        'filelist|l=s'      => \$opt_filelist,
        'context|t=s'       => \$init_macro_context,
        'file-encoding|n=s' => \$opt_n,
        'split-window|p=i'  => \$opt_split_window,
        'version|v'         => \$opt_v,
        'help|h'            => \$opt_h,
        'usage|u'           => \$opt_u,
        'window-embed|W=s'  => \$opt_W,
        'no-geometry|G'     => \$opt_G,
        'include-macro-file|I=s'   => \$opt_I,
        'show-hidden-nodes|H'      => \$opt_H,
        'debugging|D'              => \$opt_D,
        'no-secondary-files|Y'     => \$no_secondary,
        'extra-backends|B=s'       => \$opt_B,
        'tectogrammatical-trees|R' => \$opt_R,
        'csts-tree-attributes|X=s' => \$opt_X,
        'stylesheet|s=s'           => \$opt_s,
        'stylesheet-file|S=s'      => \$opt_S,
        'resource-dir|Z=s'         => \$opt_Z,
        'define-symbol|y=s@'       => \$opt_y,
        'option|O=s@'              => \$TrEd::Config::override_options,
        'execute|e=s'              => \$opt_e,
        'man'                      => \$manpage,
        "list-options"             => \$list_options,
        "no-backups"               => \$no_backups,
        "no-locks"                 => \$no_locks,
        "autosave=i"               => \$opt_auto_save,
        "carp"                     => \$carp,
        "enable-extensions|j=s"    => \$TrEd::Extensions::enable_extensions,
        "disable-extensions|J=s"   => \$TrEd::Extensions::disable_extensions,
        "command|C"                => \$command,
    );
    $optparser->getoptions(%optmap) or $opt_u = 1;

    # Help and usage
    if ($opt_u) {
        pod2usage(
            {   -msg =>
                    'TrEd - a graphical visualizer and editor of tree graphs',
            }
        );

        #  exit 0;
    }
    if ($opt_h) {
        pod2usage( -exitstatus => 0, -verbose => 1 );
    }
    if ($manpage) {
        pod2usage( -exitstatus => 0, -verbose => 2 );
    }
    if ($list_options) {
        foreach my $o ( keys %optmap ) {

            # Removes type Getopt::Long's type information from optmap
            # However, this does not work for 'option|O=s@'
            $o =~ s/=.$//;
            foreach my $oo ( split /\|/, $o ) {
                print sort ( ( length($oo) > 1 ) ? "--$oo\n" : "-$oo\n" );
            }
        }
        exit;
    }

    # userlogin was here

    use Carp;

    use IO::File;
    use IO::Pipe;
    use IO::Socket;
    use Cwd;
    use File::Spec;
    use File::Glob qw(:bsd_glob);
    use URI::file;
    use URI::Escape;
    use Fcntl;
    use Scalar::Util qw(blessed);
    use UNIVERSAL::DOES;

    use constant EMPTY => q{};

    # Once we got rid of them we call getopt to read all the other options

    if ($carp) {
        $SIG{__DIE__} = sub { confess(@_) };
    }

# Default values of $libDir used to search for macro-file (tred.mac)
# and default-macro file (tred.def) are specified here. They may be
# overriden by value of LibDir in tred resource file (tredrc or ~/.tredrc - see above).
# It is also used to find TrEd::Config.pm module.

    use FindBin;
    if ( exists $ENV{TREDHOME} ) {
        $libDir = $ENV{TREDHOME};
    }
    elsif ( -d "$FindBin::RealBin/tredlib" ) {
        $libDir = "$FindBin::RealBin/tredlib";
    }
    elsif ( -d "$FindBin::RealBin/../lib/tredlib" ) {
        $libDir = "$FindBin::RealBin/../lib/tredlib";
    }
    elsif ( -d "$FindBin::RealBin/../lib/tred" ) {
        $libDir = "$FindBin::RealBin/../lib/tred";
    }
    print "Libdir: $libDir\n" if ( $libDir and $opt_D );

    $macroFile = undef;

########## Config file #############
    # this must be done before read_config is first used

# We *must* at least find TrEd::Version, TrEd::Utils and TrEd::Config module to learn the correct libDir!!.
    unshift @INC, $libDir if -d $libDir;

    require TrEd::Utils;
    import TrEd::Utils qw(:all);

    # set HOME environment variable on Windows to user's AppData
    TrEd::Utils::find_win_home();

    # set output encoding to utf8 on stdout and stderr
    TrEd::Utils::set_fh_encoding( \*STDERR, ':utf8', "STDERR" );
    TrEd::Utils::set_fh_encoding( \*STDOUT, ':utf8', "STDOUT" );

    {
        my $ld = $libDir;
        require TrEd::Version;
        import TrEd::Version;
        $VERSION = TrEd::Version::TRED_VERSION();

        require TrEd::Config;
        import TrEd::Config;
        import TrEd::Config
            qw(&read_config &apply_config &set_default_config_file_search_list);
        $libDir              = $ld;
        $TrEd::Config::quiet = $opt_q;
    }

    # custom configuration file
    if ( defined $opt_c ) {
        @TrEd::Config::config_file_search_list
            = ($opt_c);    # override any other possible config files
    }
    else {
        TrEd::Config::set_default_config_file_search_list();
    }

    print "TrEd version: $VERSION\n" unless $opt_q;
    my $configFile = TrEd::Config::read_config(); # could change libdir

    unless ( -d $libDir ) {
        print <<'EOL';
 TrEd could not find a tredlib directory. You may need to point
 to its location by the TREDHOME variable or add a correct LibDir
 field to your ~/.tredrc.

EOL
        die "Error: Couldn\'t find lib-directory.";
    }

    unshift @INC, $libDir unless ( grep( $_ eq $libDir, @INC ) );
    {
        my $libs = File::Spec->catfile( $libDir, 'libs' );
        if ( -d $libs ) {
            unshift @INC, glob( File::Spec->catfile( $libs, '*', '' ) );
        }
    }

    use XML::LibXML;    # this is for Darwin (we want to load our libxml2
                        # before some dependency of Tk loads the system one)
    use Tk;
    use Tk::Config ();

    # process the standard arguments for X resources
    Tk::CmdLine::SetArguments();

    require Treex::PML;
    import Treex::PML;
    import Treex::PML qw(&Index $FSError);
    import Treex::PML::Schema qw(:constants);
    require TrEd::UserAgent;

    # require Fslib; # compatibility

    # import min and max functions
    require TrEd::MinMax;
    import TrEd::MinMax;

############################################################
    # end of BEGIN section
############################################################
}

Readonly my $MILISEC_PER_MIN => 60000;

# pdt20 and pmltq extensions use this variable
*openfiles = \@TrEd::File::openfiles;

if ($opt_v) {
    print <<"EOF";
TrEd $VERSION
Perl: $]
Platform: $^O
Tk: $Tk::VERSION
Treex::PML: $Treex::PML::VERSION
Treex::PML-API: $Treex::PML::API_VERSION
EOF
    exit;
}

Readonly my $ABOUT => "Copyright (c) 2000-2010 by Petr Pajas\n"
        . "This software is distributed under GPL - The General Public Licence\n"
        . 'Full text of the GPL can be found at http://www.gnu.org/copyleft/gpl.html';

apply_initial_config();


{

    # ensure ~/.tred.d exists
    $tred_d = File::Spec->catdir( $ENV{HOME}, '.tred.d' );
    if ( !-d $tred_d ) {
        mkdir $tred_d
            || warn
            "Could not create tred configuration directory: $tred_d: $!\n";
    }
}

my $pid_file = File::Spec->catfile( $tred_d, 'tred.pid' );

# handle -C argument passed to tred -- for now it can only open file in already opened TrEd...
if ($command) {
    if ( open( my $fh, '<', $pid_file ) ) {
        my $pid = <$fh>;
        close $fh;
        if ( $pid and kill( 0, $pid ) ) {
            my $cmd_file = File::Spec->catfile( $tred_d, 'cmd_' . $pid );
            if (sysopen(
                    my $fh, $cmd_file, O_TRUNC | O_CREAT | O_WRONLY, oct(600)
                )
                )
            {
                my ( $command, @args ) = @ARGV;
                if ( $command eq 'open' ) {
                 require Treex::PML::IO;
                    @args = map {
                        my ( $filename, $suffix )
                            = TrEd::Utils::parse_file_suffix($_);
                        Treex::PML::IO::make_abs_URI($filename)->as_string
                            . $suffix
                    } @args;
                }
                print $fh join( "\0", $command, @args );
                close $fh;
                kill "USR2", $pid;
            }
            exit(0);
        }
    }
    if ( $ARGV[0] eq 'open' ) {
        shift;
    }
    else {
        exit(1);
    }
}

# write PID to $pid_file
if ( open( my $fh, '>', $pid_file ) ) {
    print $fh $$;
    close $fh;
}

# import encode and decode functions
require TrEd::Convert;
import TrEd::Convert;

$TrEd::Convert::inputenc                  = $opt_n if $opt_n;
$TrEd::Config::treeViewOpts->{showHidden} = 1      if $opt_H;
if ( !defined $TrEd::Config::iconPath ) {
    $TrEd::Config::iconPath                   = "$libDir/icons/crystal";
}

if ( defined $opt_m ) {
    $macroFile = $opt_m;
}

# don't die on error in Treex::PML::Instance::Reader, just warn...
$Treex::PML::Instance::Reader::STRICT = 0;

my $cmdline_stylesheets = defined $opt_S ? $opt_S : q{};
TrEd::Stylesheet::init_stylesheet_paths(
    [ split( $Treex::PML::resourcePathSplit, $cmdline_stylesheets, -1 ) ] );

# well, setter would be nicer..
$Treex::PML::resourcePath = join( $Treex::PML::resourcePathSplit,
    map { length($_) ? $_ : $Treex::PML::resourcePath }
        split( $Treex::PML::resourcePathSplit, $opt_Z, -1 ) )
    if $opt_Z;

# not very convenient... at least group to a fn
$tredDebug = 1 if $opt_D;

$TrEd::TreeView::Debug = 1 if $opt_D;
$Treex::PML::Debug     = 1 if $opt_D;
$Treex::PML::IO::Debug = 1 if $opt_D;

# find documentation dir
$documentation_dir = TrEd::MinMax::first { -d $_ } (
    "$FindBin::RealBin/documentation", "$FindBin::RealBin/../doc/tred",
    "$libDir/../doc/tred",             "$libDir/../documentation",
);
if ( $documentation_dir ne EMPTY ) {
    $documentation_dir = 'file://' . $documentation_dir;
}
else {
    #TODO this is quite ugly
    $documentation_dir = $TrEd::Config::documentation_dir;
}

# make Alt_L and Alt_R work correctly on Darwin
if ( $^O eq 'darwin' ) {
    my $xmodmap = File::Spec->catfile( $libDir, 'xmodmap.darwin' );
    warn "Using xmodmap: $xmodmap\n" unless $opt_q;
    system( 'xmodmap', $xmodmap ) if -f $xmodmap;
}

require Tk::widgets;
import Tk::widgets qw(Frame Pane LabFrame Listbox HList Menu
    ItemStyle DialogBox Tiler BrowseEntry Panedwindow Dialog
    Scale Adjuster Entry Text);

# duplicate import entry DialogBox
require Tk::Font;

# import read_macros etc.
use TrEd::Macros;

#import TrEd::Macros;

TrEd::Macros::define_symbol('TRED');

#opt_y -- define symbol
if ($opt_y) {
    foreach my $def (@$opt_y) {
        foreach my $sym ( split( /,/, $def ) ) {
            if ( $sym =~ /=/ ) {
                TrEd::Macros::define_symbol( split( /=/, $sym, 2 ) );
            }
            else {
                TrEd::Macros::define_symbol($sym);
            }
        }
    }
}

require TrEd::Extensions;
import TrEd::Extensions qw(:all);

# tree drawing module
require TrEd::TreeView;

# tree view windowing module
require TrEd::Window;

# tree printing module
require TrEd::Print;

# basic tree operations
use TrEd::Window::TreeBasics;

$TrEd::Window::TreeBasics::on_tree_change    = \&onTreeChange;
$TrEd::Window::TreeBasics::on_node_change    = \&onNodeChange;
$TrEd::Window::TreeBasics::on_current_change = \&onCurrentChange;

eval { require TrEd::Help; };

#### new additions ###
use Readonly;

# maybe use similar approach as Padre here, require/use everything *.pm in tredlib/TrEd?
require TrEd::Stylesheet;
import TrEd::Stylesheet qw(:all);

use TrEd::List::Macros;
use TrEd::HTML::Simple;

use TrEd::Filelist::View;
use TrEd::FileLock;

use TrEd::Binding::Default;
use TrEd::Filelist::Navigation;
use TrEd::ValueLine;
use TrEd::StatusLine;
use TrEd::Undo;
use TrEd::View::Sentence;
use TrEd::RecentFiles;
use TrEd::ManageFilelists;
use TrEd::Bookmarks;
use TrEd::Menu::Stylesheet;
use TrEd::Menu::Context;
use TrEd::Toolbar::User::Manager;
use TrEd::Error::Message;

use TrEd::Dialog::Filelist;
use TrEd::Dialog::File::Open;
use TrEd::Dialog::FileProperties;
use TrEd::Dialog::Print;
use TrEd::Dialog::FindNode;
use TrEd::Dialog::ExamineBindings;
use TrEd::Dialog::EditStylesheet;
use TrEd::Dialog::EditConfig;
use TrEd::Dialog::Text;
use TrEd::Dialog::FocusFix;
use TrEd::Dialog::URL;
use TrEd::Dialog::SelectValues;
use TrEd::Dialog::CopyTrees;
use TrEd::Dialog::EditAttributes;
use TrEd::Dialog::MacroList;

use TrEd::Menu::Macro;
use TrEd::MinorModes;

require TrEd::Query::List;
require TrEd::Query::User;
require TrEd::Query::String;
require TrEd::Query::Simple;


# instead of contrib/node_groups/node_groups.mak
require TrEd::NodeGroups;

# we need to have command line options already prepared
require TrEd::File;
import TrEd::File;

TrEd::File::init_backends($opt_B);

### eof new additions ###

# @backends

require Filelist;

require Tk::MiscWorkarounds;
require Tk::MyFileSelect;
require Tk::ImgButton;
require Tk::BindButtons;
require Tk::BindMouseWheel;
require Tk::DialogReturn;
require Tk::ErrorReport;
require Tk::Balloon;
require Tk::JComboBox_0_02;
require Tk::TrEdNodeEdit;
require Tk::TextSearchLine;

require TrEd::Menu;

require Data::Snapshot;
import Data::Snapshot;

*which = eval {
    require File::Which;
    \&File::Which::which;
} || sub { };
warn $@ if $@;

$stdout = \*STDOUT;
$stderr = \*STDERR;

# this only inits focused_win_opts and normal_win_opts now
ApplyGlobalConfig();

$lockFiles = 0 if $no_locks;

# it seems, that under Windoze setting LC_NUMERIC back to us does not
# work, so I recommend not to use czech locales there, unless you
# really want the decimal points to be replaced by commas in
# postscript:-)
use locale;
use POSIX qw(locale_h);

set_locales();

eval {
    require I18N::Langinfo;
    $locale_charset = I18N::Langinfo::langinfo( I18N::Langinfo::CODESET() );
};

TrEd::ManageFilelists::create_filelists($opt_filelist);

$insideEval = 0;


if ($opt_R) {
    Csts2fs::setupTR();
}

if ( defined $opt_X && $opt_X ne EMPTY ) {
    Csts2fs::setupSpec( split ',', $opt_X, -1 );
    Fs2csts::setupSpec( split ',', $opt_X, -1 );
}

# print STDERR "Reading macros from $macroFile...\n" unless $opt_q;

startMain();    # start the whole thing

print STDERR "TrEd ended.\n" if !$opt_q;

exit_tred();

############################################################
#
# Implementation and auxiliary functions
#
############################################################

sub set_locales {
    eval {
        ($TrEd::Config::useLocales) && do {
            $ENV{LC_ALL} = undef;
            setlocale( LC_ALL, undef );

            if ($TrEd::Convert::support_unicode) {
                my $lc_collate = setlocale(LC_COLLATE);
                if ( $lc_collate !~ /\.utf-?8/i ) {
                    setlocale( LC_COLLATE, $lc_collate . ".UTF-8" );
                }
                my $lc_ctype = setlocale(LC_CTYPE);
                $lc_ctype =~ s/\.utf-?8//i;    # Tk doesn't support this
                setlocale( LC_CTYPE, $lc_ctype );
            }
            setlocale( LC_NUMERIC, "C" );
        };

        (   $TrEd::Config::useCzechLocales
                or setlocale('LANG') =~ /^cs_CZ|^czech/
            )
            && do {
            $ENV{LC_ALL} = undef;
            setlocale( LC_ALL, undef );

            if ($TrEd::Convert::support_unicode) {
                setlocale( LC_COLLATE, "cs_CZ.UTF-8" );
                setlocale( 'LANG',     "cs_CZ.UTF-8" );
                setlocale( 'LC_CTYPE', "cs_CZ" );
            }
            else {
                setlocale( LC_COLLATE, "cs_CZ" );
                setlocale( 'LANG',     "cs_CZ" );
            }
            setlocale( LC_NUMERIC, "C" );
            };

        setlocale( LC_MESSAGES, "C" );
    };
    if ($@) {
        carp $@;
    }
}

# sub create_filelists
# sub create_cmdline_filelists

#sub createBookmarksFilelist

# tags: treeView
sub gotoFirstDisplayedNode {
    my $win  = cast_to_win( $_[0] );
    my $tv   = $win->treeView;
    my $node = TrEd::MinMax::first { $tv->node_is_displayed($_) } @{ $win->{Nodes} };
    if ($node) {
        TrEd::Window::TreeBasics::set_current( $win, $node );
        centerTo( $win, $node );
    }
    return;
}

# tags: treeView
sub gotoLastDisplayedNode {
    my $win = cast_to_win( $_[0] );
    my $tv  = $win->treeView;
    my $node
        = TrEd::MinMax::first { $tv->node_is_displayed($_) } reverse @{ $win->{Nodes} };
    if ($node) {
        TrEd::Window::TreeBasics::set_current( $win, $node );
        centerTo( $win, $node );
    }
    return;
}

# main
sub exit_tred {
    if ( open( my $fh, '<', $pid_file ) ) {
        my $pid = <$fh>;
        if ( $pid == $$ ) {
            unlink $pid_file;
        }
    }
    if (@_) {
        POSIX::_exit(@_);
    }
    else {
        exit();
    }
}

# encode, locale
# same in btred, into lib?
sub conv_from_locale {
    my ($str) = @_;
    if ( $locale_charset and $TrEd::Convert::support_unicode ) {
        require Encode;
        return Encode::decode( $locale_charset, $str );
    }
    else {
        return $str;
    }
}

# UI, icon
sub icon {
    my ( $grp, $name ) = @_;
    if ( !exists $grp->{icon}{$name} ) {
        my @extensions = qw(gif xpm);
        eval { require Tk::PNG };
        if ( not($@) ) {
            unshift @extensions, 'png';
        }
        else {
            warn "PNG icons not supported by running Tk\n" if $tredDebug;
        }

        # prepend $libDir to relative paths
        my $default = 0;
        my $split   = ( $^O eq "MSWin32" ) ? ',' : ':';
        my @paths   = (
            map {
                my $p
                    = m{^\s*\Q${TrEd::File::dir_separator}\E}
                    ? $_
                    : $libDir . "/icons/" . $_;
                $default = 1 if $p eq $libDir . "/icons/crystal";
                $p;
                } split( /$split/o, $iconPath )
        );

        # add default theme, unless already in the list
        push @paths, $libDir . "/icons/crystal" unless $default;
    DIR: for my $dir (@paths) {
            for my $ext (@extensions) {
                my $file = "$dir/$name.$ext";
                if ( -f $file ) {
                    if ( $ext eq 'xpm' ) {

                        #print "Loading pixmap icon $file\n" if $tredDebug;
                        $grp->{icon}{$name}
                            = $grp->{top}->Pixmap( -file => $file );
                    }
                    else {
                        require Tk::PNG if $ext eq 'png';

                        #print "Loading photo icon $file\n" if $tredDebug;
                        $grp->{icon}{$name} = $grp->{top}
                            ->Photo( -format => $ext, -file => $file );
                    }
                    last DIR;
                }
                else {

                    #print "Icon not found $file\n" if $tredDebug;
                }
            }
        }
    }
    print "No icon found for $name\n"
        if ( not $grp->{icon}{$name} and $tredDebug );
    return $grp->{icon}{$name};
}

sub __debug {
    print STDERR @_, "\n" if $tredDebug;
}

# wrapper for extensions
sub get_open_filename {
    return TrEd::Dialog::File::Open::get_open_filename(@_);
}

#TODO: consider moving in the same place as get_open_filename?
# file, current?, top
sub get_save_filename {
    my $w    = shift;
    my %opts = @_;
    if ($saveFilenameCommand) {
        my $c     = $saveFilenameCommand;
        my $types = ref( $opts{-filetypes} )
            ? join " ",
            map { "*" . $_ } map { @{ $_->[1] } } @{ $opts{-filetypes} }
            : "*";
        my $title = $opts{-title} || 'Open';
        my $initialdir = $opts{-initialdir} . $TrEd::File::dir_separator
            || EMPTY;
        my $initialfile = $opts{-initialfile} || EMPTY;
        $c =~ s/\%t/"$title"/g;
        $c =~ s/\%m/"$types"/g;
        $c =~ s/\%d/"$initialdir"/g;
        $c =~ s/\%f/"$initialfile"/g;
        my $ret = `$c`;
        s/\s+$// for $ret;
        return $ret;
    }
    else {
        $w->getSaveFile(%opts);
    }
}

# widget, UI
sub get_widget_descendants {
    my ($w) = @_;
    if ( blessed($w) and $w->isa('Tk::Widget') ) {
        return ( $w, map { get_widget_descendants($_) } $w->children );
    }
    else {
        return ();
    }
}

# widget, UI, top
sub get_all_widgets {
    my ($grp) = @_;
    get_widget_descendants( $grp->{top} );
}

# HistEntry
sub get_entry_type {
    my $Entry = "Entry";
    my @Eopts;
    eval {
        require Tk::HistEntry;
        $Entry = "SimpleHistEntry";
        @Eopts = qw(-case 0 -match 1);
    };
    undef $@;
    return ( $Entry, @Eopts );
}

####
#TODO: TrEd/History?
####
# history
sub set_grp_history {
    my ( $grp, $e, $h, $list ) = @_;
    if ( $e->can('history') ) {
        push @$list, [ $e, $h ]
            if ( ref($list) );    # just maintains a list of histories
        my $hist = $grp->{"hist_$h"} ||= [];
        $e->history($hist);
    }
}

# history
sub get_grp_history {
    my ( $grp, $e, $h ) = @_;
    if ( $e->can('historyAdd') ) {
        $grp->{"hist_$h"} = [] unless ref( $grp->{"hist_$h"} );
        my $v = $e->get;
        $e->historyAdd($v) if $v ne EMPTY;
        @{ $grp->{"hist_$h"} } = $e->history();
    }
}

# history
sub get_grp_histories {
    my ( $grp, $list ) = @_;
    foreach my $E (@$list) {
        get_grp_history( $grp, @$E );
    }
}

#sub bookmarkFilelist

#######################################################################################
# Usage         : apply_initial_config($configs)
# Purpose       : Load recently opened files and set autoSave according to value from config
# Returns       : nothing
# Parameters    : hash_ref \%confs
# Throws        : no exceptions
# Comments      :
# See Also      : TrEd::ManageFilelists::add_new_filelist(), $autoSave
# TODO: tests
# was main::set_config
sub apply_initial_config {

    TrEd::RecentFiles::init_recent_files();

    TrEd::ManageFilelists::load_filelists_from_conf();

    #TODO: what does autosave do? What does it saves automatically?
    $autoSave = $opt_auto_save if defined $opt_auto_save;
    print STDERR "Applying configuration.\n" if $tredDebug;
}

#######################################################################################
# Usage         : ApplyGlobalConfig($configs)
# Purpose       :
# Returns       :
# Parameters    :
# Throws        : no exceptions
# Comments      :
# See Also      :
# TODO: tests
sub ApplyGlobalConfig {
    my ($grp) = @_;

    my $bg    = $treeViewOpts->{backgroundColor}        || 'white';
    my $bgoff = $treeViewOpts->{backgroundColorNofocus} || $bg;    #'#fbfbfb';
    @normal_win_opts = (
        qw/-relief flat -borderwidth 0/,
        -background          => $bgoff,
        -highlightbackground => $bgoff,
        -highlightthickness =>
            $highlightWindowWidth,    # must be the same as below
    );
    @focused_win_opts = (
        qw/-relief flat -borderwidth 0/,
        -highlightthickness  => $highlightWindowWidth,
        -highlightbackground => $highlightWindowColor,
        -bg                  => $bg
    );
    return unless $grp;

    delete $grp->{icon};
    foreach my $button ( grep { blessed($_) and $_->isa('Tk::Button') }
                         get_all_widgets($grp) )
    {
        my $icon = $button->cget('-image');
        if ( defined $icon ) {
            my $f = TrEd::File::filename( $icon->cget('-file') );
            $f =~ s/\..*//;
            my $new = icon( $grp, $f );
            Tk::catch {
                $button->configure( -image => $new ) if $new;
            };
        }
    }

    $grp->{valueLine}->update($grp);

    #TrEd::ValueLine::update($grp);
    $grp->{statusLine}->update_status( $grp->{focusedWindow} );
    print STDERR $@ if $@;
    update_treeviews($grp);
    $grp->{top}->afterCancel( $grp->{autoSaveCallback} );
    $grp->{autoSaveCallback}
        = $grp->{top}->repeat( $autoSave * $MILISEC_PER_MIN, [ \&autoSaveAll, $grp ] )
        if $autoSave > 0;
}

# config
sub reconfigure {
    my ($grp) = @_;
    TrEd::RecentFiles::add_file($grp);
    prepareFonts($grp);
    update_title_and_buttons($grp);
    $grp->{top}->optionAdd( "*font", $TrEd::Config::guiFont )
        if $TrEd::Config::guiFont;
    $grp->{valueLine}->value_line_widget()
        ->configure( -font => $TrEd::Config::vLineFont );
    if ( defined $grp->{statusLine} ) {
        $grp->{statusLine}->configure( -font => $TrEd::Config::vLineFont );
    }
    foreach ( @{ $grp->{treeWindows} } ) {
        $_->treeView->apply_options($TrEd::Config::treeViewOpts);
    }

    ApplyGlobalConfig($grp);
}

# treeView, UI
sub update_treeviews {
    my ($grp) = @_;
    foreach my $w ( @{ $grp->{treeWindows} } ) {
        if ( $w->{treeView} ) {
            my $c = $w->{treeView}->canvas;
            if ( $grp->{focusedWindow} == $w ) {
                $c->configure(@focused_win_opts);
                $c->itemconfigure( 'stipple', -state => 'hidden' );
            }
            else {
                $c->configure(@normal_win_opts);
                $c->itemconfigure( 'stipple',
                    -state => $stippleInactiveWindows ? 'normal' : 'hidden' );
            }
        }
    }
}

# sub lastFileNo

# sub currentFileNo

# Window, UI?
sub cast_to_win {
    my ($gw) = @_;
    return
        ( blessed($gw) and $gw->isa('TrEd::Window') ) ? $gw
        : (
        ref $gw ? $gw->{focusedWindow}
        : undef
        );
}

# Window
sub cast_to_grp {
    my ($gw) = @_;
    return ( blessed($gw) and $gw->isa('TrEd::Window') )
        ? $gw->{framegroup}
        : $gw;
}

# grp?
sub grp_win {
    my ($gw) = @_;
    return ( cast_to_grp($gw), cast_to_win($gw) );
}

# TrEd::Window ? should openFile in focusedWindow
# file, filelist
sub gotoFile {
    return TrEd::Filelist::Navigation::go_to_file(@_);
}

# filelist, UI
sub update_filelist_views {
    my ( $grp_or_win, $fl, $reload ) = @_;
    my ( $grp, $win ) = grp_win($grp_or_win);
    my $filelist_widget = TrEd::Dialog::Filelist::filelist_widget();
    if ( $filelist_widget
        && ( TrEd::Dialog::Filelist::get_current_filelist() == $fl ) )
    {
        TrEd::Filelist::View::update_a_filelist_view( $grp, $filelist_widget,
            $fl, $win->{currentFileNo}, $reload );
    }

    #TODO: nie na sipkovu notaciu?
    TrEd::Filelist::View::update( $grp, $fl, $reload );
}

#######################################################################################
# Usage         : fsfileDisplayingWindows($grp, $fsfile)
# Purpose       : Find all the windows which display $fsfile
# Returns       : A list of windows (TrEd::Window objects) that display $fsfile
# Parameters    : hash_ref $grp                -- reference to hash containing TrEd options
#                 Treex::PML::Document $fsfile -- reference to file
# Throws        : No exception
# Comments      :
# See Also      :
sub fsfileDisplayingWindows {
    my ( $grp, $fsfile ) = @_;
    return grep { $_->{FSFile} eq $fsfile } @{ $grp->{treeWindows} };
}

# sub is_focused
# sub initAppData

# sub setFSLockInfo

sub _clear_err {
    undef $!;
    undef $@;
}

sub _last_err {
    my ($ret)
        = grep { defined $_ && $_ ne EMPTY }
        ( $_[0], "$@", conv_from_locale($!) );
    return $ret;
}

# sub setLock
# sub readLock
# sub removeLock
# sub checkLock

# sub closeFileInWindow

# file, UI, fsfile
sub filePartOfADisplayedFile {
    my ( $grp, $fsfile ) = @_;
    return unless $fsfile;
    my $part_of = $fsfile->appData('fs-part-of');
    return unless ref($part_of) and @$part_of;
    return 1 if TrEd::MinMax::first {
        fsfileDisplayingWindows( $grp, $_ ) > 0
            or filePartOfADisplayedFile( $grp, $_ );
    }
    @$part_of;
    return 0;
}

# file, UI, fsfi
sub findToplevelFileFor {
    my ( $grp, $fsfile ) = @_;
    return unless $fsfile;
    my $part_of = $fsfile->appData('fs-part-of');
    if ( ref($part_of) and @$part_of ) {
        return TrEd::Utils::uniq( map findToplevelFileFor( $grp, $_ ),
            @$part_of );
    }
    else {
        return $fsfile;
    }
}

# sub close_file

# UI, Error
sub plainErrorMessage {
    my ( $grp, $msg ) = @_;
    my $top;
    if ( ref($grp) =~ /^Tk::/ ) {
        $top = $grp->toplevel;
    }
    elsif ( ref($grp) ) {
        my $win = cast_to_win($grp);
        $top = $win->toplevel if ref $win;
    }
    if ( ref($top) ) {
        $top->messageBox(
            -icon    => 'error',
            -message => $msg,
            -title   => 'Error',
            -type    => 'ok'
        );
    }
    else {
        print STDERR "$msg\n";
    }
}

sub _deleteMenu {
    my ( $menu, $item ) = @_;

    if ($tredDebug) {
        print STDERR "_deleteMenu $item\n";
    }
    my $entry = $menu->entrycget( $item, '-menu' );

    $menu->delete($item);
    if ($entry) {
        $entry->destroy();
    }
}

# sub textDialog
#TODO: wrapper for extensions..
sub textDialog {
    return TrEd::Dialog::Text::show_dialog(@_);
}

# sub userQuery
# wrapper for Elixir and PADT
sub userQuery {
    require TrEd::Query::User;
    return TrEd::Query::User::new_query(@_);
}

#sub TrEd::RecentFiles::add_file {

# node
# sub getNodeNo -> TrEd::Window::TreeBasics

# bookmarks
#sub bookmarkThis

#sub addBookmark
#sub lastActionBookmark

#######################################################################################
# Usage         : update_session_status($win, $fsfile)
# Purpose       : Set tree number, current node and FSFile for Window $win to values
#                 obtained from $fsfile
# Returns       : Undef/empty list
# Parameters    : TrEd::Window ref $win -- ref to TrEd::Window object which is to be altered
#                 Treex::PML::Document ref $fsfile -- ref to Document which is set as current for the Window
# Throws        : No exception
# Comments      : If $fsfile is not defined, all the beforementioned values are set to undef.
#                 If Windows is focused, session status is updated.
# See Also      : is_focused(), fsfileDisplayingWindows()
sub update_session_status {
    my ($grp) = @_;
    my $win = $grp->{focusedWindow};
    $grp->{ContextsMenu}->update_context_list($grp);
    $grp->{keepcurrentfile}
        = ( defined $win->{FSFile} && $win->{FSFile}->appData('noautoclose') )
        ? 1
        : 0;
}

# sub updateBookmarks

#TODO: docs:
#######################################################################################
# Usage         : postpone_update($grp, $menu)
# Purpose       : Fill postponed menu with opened files
# Returns       : Undef/empty list
# Parameters    : hash_ref $grp  -- reference to hash containing TrEd options
#                 Tk::Menu $menu -- reference to posponed menu
# Throws        : No exception
# Comments      : This function is a part of USR2 signal handler
# See Also      : main::handleUSR2Signal()
sub postponed_update_menu {
    my ( $grp, $menu ) = @_;
    my $i         = 0;
    my @openfiles = TrEd::File::get_openfiles();
    foreach my $opened_file (@openfiles) {
        $menu->command(
            -label     => "$i.  " . $opened_file->filename(),
            -underline => 0,
            -command   => [
                \&TrEd::File::open_standalone_file, $grp,
                $opened_file->filename(), -keep => 1
            ]
        );
        $i++;
    }
    if ( !@openfiles ) {
        $menu->command(
            -label => 'none',
            -state => 'disabled'
        );
    }
    return;
}

sub updatePostponed {
    my ($grp) = @_;
    return if $grp->{noUpdatePostponed};
    if ( $grp->{PostponedFileMenu} ) {
        print STDERR "Updating session menu\n" if $tredDebug;
        my $menu = $grp->{PostponedFileMenu};
        $menu->delete( 0, 'end' );
        $_->destroy for $menu->children;

        #TODO: extract to TrEd::File & callback...
        main::postponed_update_menu( $grp, $menu );

        {
            my $menu = $grp->{FileListMenu};
            if ($menu) {
                $menu->delete( 0, 'end' );
                $_->destroy for $menu->children;
                TrEd::ManageFilelists::createFilelistsMenu( $grp, $menu,
                    [ \&TrEd::ManageFilelists::selectFilelist, $grp ] );
            }
        }
        {
            my $menu = $grp->{AddBookmarkMenu};
            if ($menu) {
                $menu->delete( 0, 'end' );
                $_->destroy for $menu->children;
                TrEd::ManageFilelists::createFilelistsMenu( $grp, $menu,
                    [ \&TrEd::Bookmarks::bookmark_actual_position, $grp ],
                    1 );
            }
        }
    }
}

#sub createFilelistsMenu
#sub _makeNewFilelist

sub updateScaleFactor {
    my ($grp) = @_;
    my $factor = $grp->{focusedWindow}->treeView()->scale_factor();
    $grp->{canvasScaleLabel}
        ->configure( -text => 'Scale: ' . int( 100 * $factor ) . '%' );
    $grp->{canvasScale} = ( $grp->{focusedWindow}->treeView->get_scale || 0 );
}

# enable/disable buttons depending on the position in the filelist
sub _update_buttons {
    my ( $grp, $win ) = @_;
    if ( ref( $win->{FSFile} ) ) {
        if ( defined( $win->{currentFileNo} ) and $win->{currentFilelist} ) {
            my $current_file_num = $win->{currentFileNo} + 1;
            my $no_of_files      = $win->{currentFilelist}->file_count();

            $grp->{prevFileButton}
                ->configure( -state => ( $current_file_num <= 1 )
                ? 'disabled'
                : 'normal' );
            $grp->{nextFileButton}->configure(
                -state => ( $current_file_num >= $no_of_files )
                ? 'disabled'
                : 'normal'
            );
        }
        else {
            for my $button (qw(nextFileButton prevFileButton)) {
                $grp->{$button}->configure( -state => 'disabled' );
            }
        }
        for my $button (
            qw(printButton reloadButton findButton
            findNextButton findPrevButton sentButton)
            )
        {
            $grp->{$button}->configure( -state => 'normal' );
        }
    }
    else {
        for my $button (
            qw(nextFileButton prevFileButton
            printButton reloadButton findButton
            findNextButton findPrevButton sentButton)
            )
        {
            if ( defined $grp->{$button} ) {
                $grp->{$button}->configure( -state => 'disabled' );
            }
        }
    }
}

#######################################################################################
# Usage         : update_title_and_buttons($grp)
# Purpose       : Update the title of the program and (de)activate buttons/icons according
#                 to the position in the filelist
# Returns       : Undef/empty list
# Parameters    : hash_ref $grp  -- reference to hash containing TrEd options
# Throws        : No exception
# Comments      :
# See Also      : _update_buttons()
sub update_title_and_buttons {
    my ($grp) = @_;
    return if ( !ref($grp) );
    return if $grp->{noUpdateTitle};
    my $win = $grp->{focusedWindow};
    _update_buttons( $grp, $win );
    if ( ref( $win->{FSFile} ) ) {

        #TODO: vyhutaj pouzitie TrEd::Utils::EMPTY_STR
        my $filelist_info = EMPTY;
        if ( defined $win->{currentFileNo} && $win->{currentFilelist} ) {
            my $current = $win->{currentFileNo} + 1;
            my $all     = $win->{currentFilelist}->file_count();
            $filelist_info
                = $win->{currentFilelist}->name() . "($current/$all): ";
        }
        $grp->{top}->title(
            "$appName    " . $filelist_info . $win->{FSFile}->filename() );
    }
    else {
        $grp->{top}->title("$appName");
    }
    return;
}

# UI, menu
sub updateHelpMenu {
    my ( $grp, $opts ) = @_;
    $opts ||= {};
    my $hm = $grp->{main_menu}
        ->lookup_menu_item('MENUBAR:HELP:EXTENSION_MANUALS');
    return unless $hm;
    if ( $Tk::platform eq 'unix' ) {

        # this is a very lame work around a probable bug in Tk
        # n'th menu created (where exact n I don't know)
        # will behave strangely: first attempt to post it by clicking on it
        # will post the menu at or near the top left screen cornder
        # rather than on a given x,y; next time, the menu works fine
        #
        # Currently this affects this particular menu,
        # which we now programmatedly post and unpost
        #
        $hm->post( 0, 0 );
        $hm->unpost;
    }
    $hm->delete( 0, 'end' );
    $_->destroy for $hm->children;
    my $preinst_dir = TrEd::Extensions::get_preinstalled_extensions_dir();
    my ( $extensions, $pre_installed )
        = @{   $opts->{preparedExtensions}
            || TrEd::Extensions::prepare_extensions($opt_m)
            || [ [], [] ] };
    my %m;
    foreach my $m (
        (   map [ $_, TrEd::Extensions::get_extension_doc_paths( [$_] ) ],
            @$extensions
        ),
        (   map [ $_,
                TrEd::Extensions::get_extension_doc_paths(
                    [$_], $preinst_dir
                    ) ],
            @$pre_installed
        )
        )
    {
        $m{ $m->[0] } = $m->[1] unless exists $m{ $m->[0] };
    }
    for my $ext ( sort keys %m ) {
        my $index = File::Spec->catfile( $m{$ext}, 'index.html' );
        if ( -f $index ) {
            my $url = URI::file->new($index);
            $hm->add(
                'command',
                -label   => $ext,
                -command => [ \&open_url_in_browser, $url ]
            );
        }
    }
}

# sub new_file_from_current

#sub open_standalone_file

# sub reload_file
# wrapper for PADT extension
sub reloadFile {
    return TrEd::File::reload_file(@_);
}

# sub _new_status

# sub loadFile

# sub merge_status

# sub openFile

# wrapper for extensions that use this function
# we can't change them until refactored tred is functional
sub lockOpenFile {
    my ( $win, $fsfile ) = @_;
    return TrEd::FileLock::lock_open_file( $win, $fsfile );
}

# sub open_secondary_files

#######################################################################################
# Usage         : unhide_current_node($win)
# Purpose       : Show current node if it is hidden
# Returns       : Undef/empty list
# Parameters    : TrEd::Window ref $win -- reference to TrEd::Window object
# Throws        : No exception
# Comments      : Sets showHidden value to 1 for the Window's TrEd::TreeView object
sub unhide_current_node {
    my ($win) = @_;
    if ( $win->{currentNode} ) {
        if ( !isShown( $win, $win->{currentNode} ) ) {
            $win->treeView()->set_showHidden(1);
        }
    }
    return;
}

# autosave, file
sub autosave_filename {
    my ($f) = @_;
    my $base = TrEd::File::filename($f);
    return unless ( $f =~ s/\Q${base}\E$/#$base#.#tred#/ );
    return $f;
}

# autosave, file? to TrEd::File?
sub autoSaveAll {
    my ($grp) = @_;
    my $top = $grp->{top};
    my @files = grep { ( $_->notSaved == 1 ) and !$_->appData('noautosave') }
        TrEd::File::get_openfiles();
    return unless @files;
    $top->title("Autosaving...");
    $top->update;
    $top->Busy( -recurse => 1 ) if ( !$insideEval );
    foreach my $fsfile (@files) {
        my $f = autosave_filename( $fsfile->filename );
        print STDERR "auto-saving recovery file "
            . $fsfile->filename
            . " to '$f'\n"
            if $tredDebug;

        # this is not a kosher implementation but
        # there is no way to call a hook on fsfile
        # not owned by any windows, sigh!
        my ($win) = fsfileDisplayingWindows( $grp, $fsfile );
        $win = $grp->{focusedWindow} unless $win;
        return if doEvalHook( $win, "file_autosave_hook", $fsfile ) eq 'stop';

        my $ok = 0;
        eval {
            $fsfile->changeAppData( 'refs_save', {} );
            my $status = $fsfile->writeFile($f);
            $ok = 1
                unless doEvalHook( $win, "after_autosave_hook", $f, $status )
                    eq 'stop';
            $fsfile->changeAppData( 'refs_save', undef );
        };
        unless ($ok) {
            $fsfile->changeAppData( 'refs_save', undef );
            print STDERR "Error auto-saving file to '$f'\n("
                . _last_err() . "\n";
            next;
        }
        $fsfile->notSaved(2);
    }
    update_title_and_buttons($grp);
    $top->Unbusy() unless $insideEval;
}

# sub save_file

# node
sub isShown {    # test if node is shown (always 1 if $showHidden)
    my ( $win, $node, $show ) = @_;
    $show = $win->treeView->get_showHidden() unless defined $show;
    return 0 unless ( $node and $win->{FSFile} );
    return ( !$show and $win->{FSFile}->FS->isHidden($node) ) ? 0 : 1;
}

# node
sub HNext {      # same as Next but obey $showHidden
    my ( $win, $node, $top ) = @_;
    $node = $node->following($top);
    while ($node) {
        return $node if ( isShown( $win, $node ) );
        $node = $node->following($top);
    }
    return 0;
}

# node
sub HPrev {      # same as Prev? but obey $showHidden
    my ( $win, $node, $top ) = @_;
    $node = $node->previous($top);
    while ($node) {
        return $node if ( isShown( $win, $node ) );
        $node = $node->previous($top);
    }
    return 0;
}

# node
sub DisplayedAncestor {
    my ( $win, $node ) = @_;
    my $tv = $win->treeView;
    $node = $node->parent;
    while ( $node and !$tv->node_is_displayed($node) ) {
        $node = $node->parent;
    }
    return $node;
}

# node
sub NextDisplayed {    # same as Next but obey $showHidden
    my ( $win, $node, $top ) = @_;
    my $tv = $win->treeView;
    $node = $node->following($top);
    while ($node) {
        return $node if ( $tv->node_is_displayed($node) );
        $node = $node->following($top);
    }
    return 0;
}

# node
sub PrevDisplayed {    # same as Next but obey $showHidden
    my ( $win, $node, $top ) = @_;
    my $tv = $win->treeView;
    $node = $node->previous($top);
    while ($node) {
        return $node if ( $tv->node_is_displayed($node) );
        $node = $node->previous($top);
    }
    return 0;
}

# sub get_value_line {

sub reverseWrapLines {
    my ( $widget, $font, $text, $width ) = @_;
    use integer;
    my @toks;
    if ( ref($text) ) {
        @toks = @$text;
    }
    else {
        @toks = map { [ $_, EMPTY ] } split /\s+/, $text;
    }
    my @result;
    my $wd = 0;
    my $w;
    my $t     = pop(@toks);
    my @lines = ();
    while ($t) {
        $w = $widget->fontMeasure( $font, " $t->[0]" );
        if ( ( $wd + $w >= $width ) && ( @result > 0 ) ) {
            push @lines, ( @result, [ "\n", 'space' ] );
            @result = ($t);
            $wd = $widget->fontMeasure( $font, $t->[0] );
        }
        else {
            $wd += $w;
            unshift @result, $t;
        }
        $t = pop(@toks);
    }
    push @lines, @result;
    return \@lines;
}

#sub set_value_line

# sidepanel
sub toggleSidePanel {
    my ($grp) = @_;
    unless ( defined $grp->{sidePanelFrame} ) {
        initSidePanel($grp);
    }
    if ($showSidePanel) {
        if ( !$grp->{sidePanelPacked} ) {
            $grp->{bodyPane}->add(
                $grp->{sidePanelFrame},
                -before => $grp->{windowFrame},
                -width  => $grp->{bodyPane}->width / 6
            );
            $grp->{sidePanelPacked} = 1;
        }
    }
    else {
        if ( $grp->{sidePanelPacked} ) {
            $grp->{bodyPane}->forget( $grp->{sidePanelFrame} );
            $grp->{sidePanelPacked} = 0;
        }
    }
}

# sidepanel
sub initSidePanel {
    my ($grp) = @_;
    require TrEd::SidePanel;
    if ( not $grp->{sidePanel} ) {
        $grp->{sidePanel}      = TrEd::SidePanel->new( $grp->{bodyPane} );
        $grp->{sidePanelFrame} = $grp->{sidePanel}->frame();
    }

    if ( not $grp->{sidePanel}->widget('attrsView') ) {
        print STDERR "Creating 'Attribute' sidebar view\n" if $tredDebug;
        $grp->{sidePanel}->init_node_attributes($grp);
    }
    unless ( $grp->{sidePanel}->widget('filelistView') ) {
        print STDERR "Creating 'File List' sidebar view\n" if $tredDebug;
        $grp->{sidePanel}->init_filelist_view($grp);
    }
    unless ( $grp->{sidePanel}->widget('fileSystemView') ) {
        print STDERR "Creating 'Browse File System' sidebar view\n"
            if $tredDebug;
        $grp->{sidePanel}->init_browse_filesystem($grp);
    }
    unless ( $grp->{sidePanel}->widget('macroListView') ) {
        print STDERR "Creating 'Macro List' sidebar view\n" if $tredDebug;
        $grp->{sidePanel}->init_macro_list($grp);
    }
    print STDERR "Creating 'Macro List' sidebar view\n" if $tredDebug;
}

# sub update_status_info
#sub update_context_list

#sub update_macro_menus
# sub updateCurrentContextMenu

# sub update_status_line
# sub set_status_line

# tree_pos
sub update_tree_pos {
    my ($grp) = @_;
    my $win = $grp->{focusedWindow}; # only focused window uses the value line
    if ( $win->{FSFile} ) {
        $grp->{vLineNumLabel}
            ->configure( -text => ( $win->{treeNo} + 1 ) . "/"
                . ( $win->{FSFile}->lastTreeNo + 1 ) );
    }
    else {
        $grp->{vLineNumLabel}->configure( -text => "-/-" );
    }

    #  $grp->{vLineNumLabel}->update();
}

#sub update_value_line
#TODO: wrapper for extensions
sub update_value_line {
    my ( $grp, @args ) = @_;
    return $grp->{valueLine}->update( $grp, @args );
}

# sub get_nodes_win
sub get_nodes_win {
    my ( $win, $no_redraw ) = @_;
    if ( defined $win ) {
        return $win->get_nodes($no_redraw);
    }
    return;
}

# node, fsfile
sub get_nodes_fsfile {
    my ( $grp, $fsfile ) = @_;
    return if $insideEval;
    foreach my $w ( fsfileDisplayingWindows( $grp, $fsfile ) ) {
        $w->get_nodes();
    }
    return;
}

# node, fsfile
sub get_nodes_fsfile_tree {
    my ( $grp, $fsfile, $tree_no, $no_redraw ) = @_;
    return if $insideEval;
    foreach my $w ( grep { $_->{treeNo} == $tree_no }
        fsfileDisplayingWindows( $grp, $fsfile ) )
    {
        $w->get_nodes($no_redraw);
    }
    return;
}

# node, stylesheet
sub get_nodes_stylesheet {
    my ( $grp, $stylesheet ) = @_;
    return if $insideEval;
    foreach ( windows_using_stylesheet( $grp, $stylesheet ) ) {
        $_->get_nodes();
    }
    return;
}

# node
sub get_nodes_all {
    my ($grp) = @_;
    foreach my $w ( @{ $grp->{treeWindows} } ) {
        $w->get_nodes();
    }
    return;
}

############################################################
############################################################
############################################################
# Filelists
############################################################

#sub selectFilelistNoUpdate
#sub selectFilelist
#sub selectFilelist
#sub find_filelist
#sub addFilelist

#sub looseFilePositionInFilelist

#sub switchFilelist
#sub createFilelistBrowseEntry

#sub getFilelistLinePosition

#sub insertToFilelist
#sub removeFromFilelist
#sub createNewFilelist

#sub _user_resolve_filelist_conflict
#sub _solve_filelist_conflict
#sub add_new_filelist
#sub deleteFilelist
#sub filelistEntryPath
#sub feedHListWithFilelist

#sub selectFilelistDialog
#sub bookmarkToFilelistDialog
#sub removeFilelistsDialog
#sub loadFilelist
#sub filelistDialog

####
### End of subs related to file list
####

# sub initTTFonts

# print
sub warnWin32PrintConvert {
    my ($win) = @_;
    return 'Continue'
        if $^O ne 'MSWin32'
            or ( which('convert.exe') ne EMPTY )
            or $NoConvertWarning;
    TrEd::Query::User::new_query(
        $win,
        "This feature requires ImageMagick (http://www.imagemagick.org), which "
            . "does not seem to be installed because 'convert.exe' was found in your PATH. "
            . "Press 'Continue' if you want to try anyway.\n\n"
            . "To get rid of this message permanently, add NoConvertWarning=1 to your configuration file.",
        -title   => "Warning",
        -buttons => [ "Continue", "Cancel" ]
    );
}

# print
sub warn55PrintConvert {
    my ($win) = @_;
    return 'Continue' if $NoConvertWarning;
    my $version = `$imageMagickConvert -help`;
    ($version) = split /\n/, $version;
    return 'Continue' unless ( $version =~ /ImageMagick 5\.5\./ );
    TrEd::Query::User::new_query(
        $win,
        "Your version of ImageMagick ($version) is known to hang when converting from EPS. "
            . "We suggest that you upgrade ImageMagick to version >= 6.0 or downgrade to <= 5.4.7. "
            . "If you are sure you want to continue "
            . "taking the risk that TrEd will stop responding, press Continue.\n"
            . "It is strongly recommended that you Cancel the operation now.\n\n"
            . "To get rid this message permanently, add NoConvertWarning=1 to your configuration file.",
        -title   => "Warning",
        -buttons => [ "Cancel", "Continue anyway" ]
    );
}

# sub updatePrintDialogState

# sub _fix_combo_box_return
# sub _fix_combo_box

# sub savePrintConfig

# print
#TODO: move to TrEd::Print?
sub printThis {
    my ($grp) = @_;
    my $win = $grp->{focusedWindow};
    return unless $win->{FSFile};

## uncomment to get preview (see also below)
    #  my $dlg = $grp->{top}->DialogBox(-title=> 'Print Preview',
    #				   -buttons=> ['Close']);
    #  my $canvas=$dlg->Scrolled('Canvas');

    my $canvas = $grp->{top}->Canvas();
    my ( $one_per_file, $print_opts );
    my $err;
    do {
        {
            $err = 0;
            $print_opts = TrEd::Dialog::Print::show_dialog($grp) || return;
            $one_per_file = delete $print_opts->{-onePerFile};
            if ( $print_opts->{-format} eq 'PDF'
                 && (  !$grp->{ttfonts}
                    || !$grp->{ttfonts}->{ $printOptions->{ttFont} } )
                )
            {
                plainErrorMessage( $win,
                    "You must select TrueType font for PDF!" );
                $err = 1;
            }
            if (    $one_per_file
                and ( $print_opts->{-filename} !~ /[%]\d*n/ )
                and ( $print_opts->{-range} =~ /[\-,]/ ) )
            {
                plainErrorMessage( $win,
                    "Use %n in the output filename if you need one tree per file!"
                );
                $err = 1;
            }
        }
    } while ($err);
    my $range = delete $print_opts->{-range};
    $range = $win->{treeNo} + 1 unless ( defined($range) and length($range) );

    my $stylesheet = $win->{stylesheet};
    my $ss         = undef;
    if ( $stylesheet ne STYLESHEET_FROM_FILE() ) {
        $ss = $grp->{stylesheets}->{$stylesheet};
    }
    my $fsfile = $win->{FSFile};
    my @range
        = ( $one_per_file
        ? TrEd::Print::parse_print_list( $fsfile, $range )
        : ($range) );
    my $max_num_length = $one_per_file ? max( map length, @range ) : 0;
    my %std_options
        = map {
        $TrEd::Config::defaultPrintConfig{$_}[0] => $printOptions->{$_}
        } qw(psFontFile psFontAFMFile psFontSize prtFmtWidth prtFmtHeight
        prtHMargin prtVMargin maximizePrintSize psMedia);

    eval {
        for my $r (@range)
        {
            my $filename = $print_opts->{-filename};
            my $command  = $print_opts->{-command};
            if ($one_per_file) {

                $filename
                    =~ s/[%](\d*)n/sprintf("%".($1 ne EMPTY ? '0'.int($1) : '0'.$max_num_length)."d",$r)/e;
                $command
                    =~ s/[%](\d*)n/sprintf("%".($1 ne EMPTY ? '0'.int($1) : '0'.$max_num_length)."d",$r)/e;
            }
            TrEd::Print::Print(
                {   %std_options,
                    %$print_opts,
                    -filename => $filename,
                    -command  => $command,
                    -fsfile   => $fsfile,
                    -toplevel => $grp->{top},
                    -canvas   => $canvas,
                    -range    => $r,
                    -hidden   => $win->{treeView}->get_showHidden(),
                    -ttFont   => (
                          $grp->{ttfonts}
                        ? $grp->{ttfonts}->{ $printOptions->{ttFont} }
                        : EMPTY
                    ),
                    -treeViewOpts     => $treeViewOpts,
                    -styleSheetObject => $ss,
                    -context          => $win,
                    -onGetNodes       => \&printGetNodesCallback,
                    -onGetRootStyle   => \&onGetRootStyle,
                    -onGetNodeStyle   => \&onGetNodeStyle,
                    -onRedrawDone     => \&onRedrawDone,
                }
            );
        }
    };
    TrEd::Error::Message::error_message( $win, $@ ) if $@;
    $win->get_nodes();    # printGetNodesCallback have fiddled with $win
## uncomment to get preview (see also above)
    #  $canvas->pack();
    #  ShowDialog($dlg);

    $canvas->destroy();
    return;
}

# sub getWindowPatterns
# sub getWindowHint

# sub getWindowContextRE

# stylesheet
sub switchStylesheet {
    my ( $grp_or_win, $stylesheet ) = @_;
    my ( $grp,        $win )        = grp_win($grp_or_win);
    return unless ref($win);
    my $prevstylesheet = $win->{stylesheet};
    return
        if $prevstylesheet eq $stylesheet
            and $stylesheet ne STYLESHEET_FROM_FILE()
    ;    # the file might have changed
    if ( $stylesheet eq NEW_STYLESHEET() ) {
        $stylesheet = TrEd::Query::String::new_query( $grp, "Stylesheet name",
            "Name: " );
        if ( !defined($stylesheet) ) {
            $stylesheet = $prevstylesheet;
        }
        elsif ( grep { /^\Q$stylesheet\E$/i }
                keys %{ $grp->{stylesheets} } )
        {
            TrEd::Error::Message::error_message( $win,
                "Stylesheet named '$stylesheet' already exists!\n", 1 );
            $stylesheet = $prevstylesheet;
        }
        else {
            my ( $hint, $context, $patterns )
                = TrEd::Stylesheet::get_stylesheet_patterns($win);
            $grp->{stylesheets}->{$stylesheet}->{hint}     = $hint;
            $grp->{stylesheets}->{$stylesheet}->{context}  = $context;
            $grp->{stylesheets}->{$stylesheet}->{patterns} = $patterns;
            $grp->{StylesheetMenu}->update($grp);
            TrEd::Stylesheet::save_stylesheet_file( $grp, $stylesheet );
        }
        $win->apply_stylesheet($stylesheet);
        $grp->{selectedStylesheet} = $stylesheet if $win->is_focused();
    }
    elsif ( $stylesheet eq DELETE_STYLESHEET() ) {
        if ( $prevstylesheet eq STYLESHEET_FROM_FILE() ) {
            $grp->{selectedStylesheet} = $prevstylesheet
                if $win->is_focused();
            return 0;
        }
        $stylesheet = $prevstylesheet;
        my $answer = TrEd::Query::User::new_query(
            $win,
            "Really delete stylesheet '$stylesheet'?",
            -bitmap  => 'question',
            -title   => "Delete stylesheet?",
            -buttons => [ 'Yes', 'No' ]
        );
        if ( $answer eq 'Yes' ) {
            TrEd::Stylesheet::delete_stylesheet( $grp, $stylesheet );
        }
        else {
            $grp->{selectedStylesheet} = $stylesheet if $win->is_focused();
            return 0;
        }
    }
    else {
        my $hook_result = doEvalHook( $win, "pre_switch_stylesheet_hook",
                                      $prevstylesheet, $stylesheet);
        return 0 if (defined $hook_result && $hook_result eq 'stop');
        $win->apply_stylesheet($stylesheet);
        doEvalHook( $win, "switch_stylesheet_hook", $prevstylesheet,
            $stylesheet );
        if ( $win->{FSFile} ) {
            $win->get_nodes();
            $win->redraw();
        }
    }
    return 1;
}

# context switch
#######################################################################################
# Usage         : switchContext($grp)
# Purpose       : Update list of contexts in context menu, set $grp->{selectedContext}
#                 according to allowed contexts and switch context
# Returns       : Undef/empty list
# Parameters    : hash_ref $grp -- reference to hash containing TrEd options
# Throws        : No exception
# Comments      :
# See Also      : is_focused(), fsfileDisplayingWindows()
sub switchContext {
    my ( $win, $context, $noredraw ) = @_;
    my $grp          = cast_to_grp($win);
    my $prev_context = $win->{macroContext};
    $win->{macroContext} = $context;
    my $hook_res = doEvalHook( $win, "allow_switch_context_hook", $prev_context,
        $context );

    # if context switch is not allowed
    if ( defined $hook_res && $hook_res eq 'stop' ) {
        $win->{macroContext} = $prev_context;
        if ( $win->is_focused() ) {
            $grp->{selectedContext} = $prev_context;
        }
        return 0;
    }

    $win->{macroContext} = $prev_context;

    # should we stop because of pre_switch_stylesheet_hook?
    my $hook_result = doEvalHook( $win, "pre_switch_context_hook",
        $prev_context, $context, $win );
    return 0 if ( defined $hook_result && $hook_result eq 'stop' );

    $win->{macroContext} = $context;
    if ( $win->is_focused() ) {
        $grp->{selectedContext} = $context;
        $grp->{StylesheetMenu}->update($grp);
        TrEd::List::Macros::update_view($win);
        TrEd::Menu::Macro::updateCurrentContextMenu($grp);
    }
    my ( $l1, $l2 ) = ( $win->{got_nodes}, $win->{redrawn} );
    doEvalHook( $win, "switch_context_hook", $prev_context, $context );
    unless ($noredraw) {
        $win->get_nodes() unless $l1 < $win->{got_nodes};
        if ( $l2 >= $win->{redrawn} ) {

            # something should be done with display attrs vs windows maybe
            $win->redraw();
        }
    }
    return;
}

# hook
sub onGetNodeStyle {
    my ( $treeview, $node, $styles, $win ) = @_;
    return doEvalHook( $win, "node_style_hook", $node, $styles );
}

# hook
sub onGetRootStyle {
    my ( $treeview, $node, $styles, $opts, $win ) = @_;
    return doEvalHook( $win, "root_style_hook", $node, $styles, $opts );
}

# hook
sub onRedrawDone {
    my ( $treeview, $win ) = @_;
    return doEvalHook( $win, "after_redraw_hook", $treeview );
}

# hook
sub onGetNodes {
    my ( $treeview, $fsfile, $tree_no, $current, $win ) = @_;
    $win->{got_nodes}++;
    return doEvalHook( $win, "get_nodelist_hook", $fsfile, $tree_no,
        $current, $treeview->get_showHidden() );
}

sub printGetNodesCallback {    # called from print_trees
    my ( $win, $treeview, $fsfile, $tree_no, $current ) = @_;
    local $TrEd::TreeView::on_get_nodes = [ \&onGetNodes, $win ];
    $win->{treeNo} = $tree_no;
    $win->{root}   = $fsfile->treeList->[$tree_no];
    return ( ( $win->{Nodes}, $win->{currentNode} )
        = $treeview->nodes( $fsfile, $tree_no, $current ) );
}

# hook
sub onTreeChange {
    my ($win) = @_;
    return if $insideEval;    # we don't want to redraw if called from a macro
         # not only because it is really expensive, but also because
         # calling this many times (say 1K) results in so many afterIdle calls
      # on various places (such as configure(-status=>'disabled') on value line)
      # that TrEd seems stuck when returning from a macro
    my $grp = $win->{framegroup};
    get_nodes_fsfile_tree( $grp, $win->{FSFile}, $win->{treeNo}, 1 );
    $grp->{valueLine}->update($grp);

    #TrEd::ValueLine::update($grp);
    redraw_fsfile_tree( $grp, $win->{FSFile}, $win->{treeNo} );
    my $tv = $win->treeView;
    $tv->reset_scroll_region;

    #  my $node = $win->{currentNode};
    #  $tv->canvas->see(-item =>
    #		     $tv->get_node_pinfo($node,"Oval"));

    centerTo( $win, $win->{currentNode} );
    $grp->{top}->idletasks;
    return;
}

# hook
sub onNodeChange {
    my ( $win, $change, $node ) = @_;
    if ( $change =~ m/^new_node/ && $win->{FSFile}->schema() ) {
        unless ( determineNodeType( $win, $node ) ) {
            TrEd::Window::TreeBasics::prune_node( $win, $node );
            return;
        }
    }
    get_nodes_fsfile_tree( $win->{framegroup}, $win->{FSFile},
        $win->{treeNo} );
    redraw_fsfile_tree( $win->{framegroup}, $win->{FSFile}, $win->{treeNo} );
    return;
}

# hook
sub onCurrentChange {
    my ( $win, $node, $prev ) = @_;
#    my $n;
    my $tv = $win->treeView;
    $win->{framegroup}->{valueLine}->update_current( $win, $node );
    foreach my $n ( $node, $prev ) {
        $tv->canvas->itemconfigure( $tv->get_node_pinfo( $n, "Oval" ),
            nodeOptions( $win, $n ) );
        if ( $tv->get_node_pinfo( $n, "NodeHasBox" ) ) {
            $tv->canvas->itemconfigure(
                $tv->get_node_pinfo( $n, "TextBox" ),
                nodeBoxOptions( $win, $n, 0 )
            );
        }
        if ( $tv->get_node_pinfo( $n, "EdgeHasBox" ) ) {
            $tv->canvas->itemconfigure(
                $tv->get_node_pinfo( $n, "EdgeTextBox" ),
                nodeBoxOptions( $win, $n, 1 ) );
        }
        my $item = $tv->get_node_pinfo( $n, "Oval" );
        $tv->canvas->coords( $item,
            $tv->node_coords( $n, $win->{currentNode} ) );
        $tv->apply_stored_style_opts( "Oval",        $n );
        $tv->apply_stored_style_opts( "TextBox",     $n );
        $tv->apply_stored_style_opts( "EdgeTextBox", $n );
    }
    $tv->apply_stored_style_opts( "CurrentOval",        $node );
    $tv->apply_stored_style_opts( "CurrentTextBox",     $node );
    $tv->apply_stored_style_opts( "CurrentEdgeTextBox", $node );

    unless ( $prev eq $node ) {
        eval {
            my $stripe = $tv->get_node_pinfo( $node, "Stripe" );
            if ( defined($stripe) ) {
                $tv->canvas->itemconfigure( $stripe,
                    -fill => $tv->get_stripeColor );
                $tv->canvas->itemconfigure( "textbg_$node", -fill => undef )
                    if $tv->get_verticalTree;
            }
        };
        eval {
            my $stripe = $tv->get_node_pinfo( $prev, "Stripe" );
            if ( defined($stripe) ) {
                my $col = $tv->realcanvas->cget('-background');
                $tv->canvas->itemconfigure( $stripe,        -fill => $col );
                $tv->canvas->itemconfigure( "textbg_$prev", -fill => $col )
                    if $tv->get_verticalTree;
            }
        };
        doEvalHook( $win, "current_node_change_hook", $node, $prev )
            unless $insideEval;

        #TODO: okay, this is a little bit awkward
        $win->{framegroup}->{statusLine}->update_status($win);
    }
}

# font
sub prepareFont {
    my ( $grp, $spec, $name ) = @_;
    my $mw = $grp->{top};
    my $fonts = $grp->{fonts} ||= {};

    return $spec if $spec =~ /^\s*-/;    # X11Font
    my @spec;
    if ( $spec !~ /^\s*\{/ ) {
        my @a = split( /\s*,\s*/, $spec );
        my ( $option, $value );
        foreach (@a) {
            ( $option, $value ) = split( /\s*:\s*/, $_, 2 );
            push @spec, "-" . $option, $value
                if ( $option
                =~ /^(?:size|weight|family|slant|underline|overstrike)$/ );
        }
    }
    else {
        @spec = $mw->fontActual($spec);
    }

    if ( $fonts->{$name} ) {
        $fonts->{$name}->configure(@spec);
    }
    else {
        eval { $mw->fontDelete($name) };
        $fonts->{$name} = $mw->fontCreate( $name, @spec );
    }
    return $name;
}

# font
sub prepareFonts {
    my ($grp) = @_;
    print STDERR "Preparing fonts.\n" if $tredDebug;

    my %c_font_defaults = (
        small      => 'family:sans,size:7',
        small_bold => 'family:sans,weight:bold,size:7',
        heading    => 'family:sans,weight:bold,size:11',
        fixed      => 'family:courier,size:9',
        default    => 'family:sans,size:9',
        bold       => 'family:sans,size:9,weight:bold',
        italic     => 'family:sans,size:9,slant:italic',
    );
    my $mw = $grp->{top};
    if ($guiFont) {
        $guiFont = prepareFont( $grp, $guiFont, 'C_gui' );
        eval { $mw->optionAdd( "*font", $guiFont ); };
    }

    #TODO: z TrEd::Config $treeViewOpts, $font, $vLineFont
    $treeViewOpts->{font} = $font = prepareFont( $grp, $font, 'C_normal' );
    $vLineFont = prepareFont( $grp, $vLineFont, 'C_vline' );
    for my $name (qw(small small_bold heading fixed default bold italic)) {
        my $fnt = $c_fonts{$name} || $c_font_defaults{$name};
        prepareFont( $grp, $fnt, 'C_' . $name );
    }
}

# bind
sub addBindTags {
    my $w = shift @_;
    $w->bindtags( [ @_, $w, ref($w), $w, $w->toplevel, 'all' ] );
}

# sub cascadeMenus

# save button state update
sub saveFileStateUpdate {
    my ($win) = @_;
    my $grp = $win->{framegroup};
    return if $grp->{noSaveFileStateUpdate};

    return if ( !$win->{framegroup}->{saveButton} );

    if ( eval { $win->isa('TrEd::Window') } ) {
        return if ( !$win->is_focused() );
        $win->{framegroup}->{saveButton}->configure(
            -state => (
                ( $win->{FSFile} and $win->{FSFile}->notSaved )
                ? 'normal'
                : 'disabled'
            )
        );
    }
    else {
        return;
    }

}

#
sub About {
    my ($grp)       = @_;
    my $message     = EMPTY;
    my $contextinfo = EMPTY;
    my $fileinfo    = EMPTY;
    my $colinf      = EMPTY;
    if ( $grp->{focusedWindow}->{FSFile} ) {
        $fileinfo
            = "Current file:\n"
            . $grp->{focusedWindow}->{FSFile}->filename . "\n"
            . "Format: "
            . $grp->{focusedWindow}->{FSFile}->fileFormat . ", "
            . $grp->{focusedWindow}->{FSFile}->lastTreeNo
            . " trees\n";
        $contextinfo = "Current context: "
            . $grp->{focusedWindow}->{macroContext} . "\n";
        my %colinf = ( Shadow => [], Hilite => [], XHilite => [] );
        my $some_color;
        foreach ( $grp->{focusedWindow}->{FSFile}->FS->attributes ) {
            my $color = $grp->{focusedWindow}->{FSFile}->FS->color($_);
            unless ( $color eq 'normal' ) {
                push @{ $colinf{$color} }, $_;
                $some_color = 1;
            }
        }
        if ($some_color) {
            $colinf
                = "Coloured attributes:"
                . "\n    Highlited: "
                . join( ",", @{ $colinf{Hilite} } )
                . "\n    XHighlited: "
                . join( ",", @{ $colinf{XHilite} } )
                . "\n    Shadow: "
                . join( ",", @{ $colinf{Shadow} } ) . "\n";
        }
    }

    doEvalHook( $grp->{focusedWindow}, "about_file_hook", \$message );
    my $ver = $VERSION;
    $grp->{top}->toplevel->messageBox(
        -icon => 'info',
        -type => 'ok',
        -message =>
            "This is Tree Editor TrEd\nVersion $ver\nRunning Tk $Tk::VERSION\n\n"
            . "\n\n$fileinfo$contextinfo$colinf$message\n"
            . $ABOUT . "\n",
        -title => 'About'
    );
}

#######################################################################################
# Usage         : new_TrEd_Window(\%tred);
# Purpose       :
# Returns       : nothing
# Parameters    : hash_ref $tred -- tred hash reference
# Throws        : no exception
# Comments      :
# See Also      :
# Window
sub new_TrEd_Window {
    my ($grp) = @_;

    my $win = TrEd::Window->new( newTreeView($grp), framegroup => $grp );
    $win->{macroContext}
        = $init_macro_context
        && exists( $TrEd::Macros::keyBindings{$init_macro_context} )
        ? $init_macro_context
        : 'TredMacro';
    $win->{stylesheet} = STYLESHEET_FROM_FILE();
    my $windows     = $grp->{treeWindows};
    my $focused_win = $grp->{focusedWindow};
    if ($focused_win) { # insert new window after focused window
        @{$windows}
            = map { ( $_ == $focused_win ) ? ( $_, $win ) : $_ } @{$windows};
    }
    else {
        push @{$windows}, $win;
    }
    $grp->{rmsplitButton}
        ->configure( -state => @{$windows} > 1 ? 'normal' : 'disabled' )
        if $grp->{rmsplitButton};
    return $win;
}

#######################################################################################
# Usage         : new_TrEd_Window(\%tred);
# Purpose       :
# Returns       : nothing
# Parameters    : hash_ref $tred -- tred hash reference
# Throws        : no exception
# Comments      :
# See Also      :
# TreeView
sub newTreeView {
    my ($grp) = @_;

    my $canvas = $grp->{top}->Scrolled(
        'Canvas',
        -width  => $defCWidth,
        -height => $defCHeight,
        qw /-relief sunken
            -borderwidth 2
            -scrollbars se/,
        -scrollregion => [qw/0 0 0 0/],
        $treeViewOpts->{backgroundColor}
        ? ( -background => $treeViewOpts->{backgroundColor} )
        : ()
    );
    canvasBindMouseWheelVert( $canvas, "", $grp );
    canvasBindMouseWheelHoriz( $canvas, "Shift", $grp );
    canvasBindMouseScale( $grp, $canvas, "Control" );
    createCanvasBindings( $grp, $canvas );
    addBindTags( $canvas,                        'my' );
    addBindTags( $canvas->Subwidget('scrolled'), 'canvas' );

    my $balloon = $grp->{top}->Balloon(
        -initwait => $canvasBalloonInitWait,
        -state    => 'balloon',
    );
    $balloon->Subwidget('message')
        ->configure( -foreground => $canvasBalloonForeground );

    $balloon->Tk::Toplevel::configure(
        -background => $canvasBalloonBackground );
    $balloon->Subwidget('message')
        ->configure( -justify => 'left', -font => $font );
    my $treeView = new TrEd::TreeView( $canvas, 'CanvasBalloon' => $balloon );
    $treeView->apply_options($treeViewOpts);
    return $treeView;
}

# menu
sub NavigateMenuByFirstKey {
    my $w    = shift;
    my $char = shift;
    return unless ( defined $char );
    $char = lc($char);
    my $last   = $w->index('last');
    my $active = $w->index('active');
    return if ( $last eq 'none' );
    $active = 0 if $active eq 'none';

    for my $i ( $active + 1 .. $last, 0 .. $active ) {
        print STDERR "navigate menu\n" if $tredDebug;
        my $label
            = eval { local $SIG{__DIE__}; $w->entrycget( $i, '-label' ) };
        next unless defined($label);
        $label = lc($label);
        if ( ( substr( $label, 0, 1 ) eq $char )
            or $label =~ /^[^[:alnum:]]\Q$char\E/ )
        {
            $w->activate($i);
            return;
        }
    }
}

# window, UI
sub findCanvasWindow {
    my ( $grp, $canvas ) = @_;
    foreach my $w ( @{ $grp->{treeWindows} } ) {
        return $w if $w->contains($canvas);
    }
    return;
}

# window, UI
sub focusNextWindow {
    my ($grp) = @_;
    my $windows = $grp->{treeWindows};
    my $idx = Index( $windows, $grp->{focusedWindow} );
    return focusCanvas( $windows->[ ( $idx + 1 ) % @$windows ]->canvas,
        $grp );
}

# window, UI
sub focusPrevWindow {
    my ($grp) = @_;
    my $windows = $grp->{treeWindows};
    my $idx = Index( $windows, $grp->{focusedWindow} );
    return focusCanvas( $windows->[ $idx - 1 ]->canvas, $grp );
}

# window, UI
sub clearCanvasFocus {
    my ($grp) = @_;
    if ( $grp->{focusedWindow} ) {
        $grp->{focusedWindow}->canvas()->configure(@normal_win_opts);
        $grp->{focusedWindow}->canvas()
            ->itemconfigure( 'stipple',
            -state => $stippleInactiveWindows ? 'normal' : 'hidden' );
    }
}

# window, UI
sub focusCanvas {
    my ( $c, $grp ) = @_;
    if ( $grp->{focusedWindow} ) {
        return if $grp->{focusedWindow}->contains($c);
        clearCanvasFocus($grp);
    }
    if ($c and eval { $c->isa('Tk::Canvas') } ) {
        $c->configure(@focused_win_opts);
        $c->itemconfigure( 'stipple', -state => 'hidden' );
    }

    my $newfocus = findCanvasWindow( $grp, $c );
    if ($newfocus) {
        my $prevcontext = $grp->{selectedContext};
        my $context     = $newfocus->{macroContext};
        doEvalHook( $grp->{focusedWindow}, "pre_switch_context_hook",
            $prevcontext, $context, $newfocus );    # stop is ignored here
        $grp->{selectedContext} = $context;
        my $prevfl = $grp->{focusedWindow}->{currentFilelist};
        $grp->{focusedWindow}      = $newfocus;
        $grp->{selectedStylesheet} = $newfocus->{stylesheet};
        $treeViewOpts->{drawBoxes} = $newfocus->{treeView}->get_drawBoxes();
        $treeViewOpts->{drawEdgeBoxes}
            = $newfocus->{treeView}->get_drawEdgeBoxes();
        $treeViewOpts->{showHidden} = $newfocus->{treeView}->get_showHidden();
        $treeViewOpts->{highlightAttributes}
            = $newfocus->{treeView}->get_highlightAttributes;

        $grp->{valueLine}->update($grp);

        #TrEd::ValueLine::update($grp);
        $grp->{statusLine}->update_status( $grp->{focusedWindow} );
        $grp->{valueLine}
            ->update_current( $newfocus, $newfocus->{currentNode} );
        TrEd::MinorModes::update_minor_modes($newfocus);
        update_title_and_buttons($grp);
        updateScaleFactor($grp);
        TrEd::Undo::reset_undo_status($newfocus);
        resetTreePosStatus($grp);
        update_session_status($grp);
        TrEd::List::Macros::update_view($grp);
        TrEd::Menu::Macro::updateCurrentContextMenu($grp);
        $grp->{StylesheetMenu}->update($grp);
        updateNodeMenu($grp);
        my $fl = $newfocus->{currentFilelist};

        #TODO: nie na sipkovu notaciu?
        TrEd::Filelist::View::update( $grp, $fl, $fl == $prevfl ? 0 : 1 );
        doEvalHook( $newfocus, "switch_context_hook", $prevcontext,
            $context );
    }
    else {
        print STDERR "DID NOT FIND Window of $c\n";
    }
}

# window, UI, split
sub splitWindow {
    my ( $grp, $dir, $opts ) = @_;
    $opts ||= {};
    my $twin   = new_TrEd_Window($grp);
    my $canvas = $twin->canvas();
    $canvas->configure(
        $opts->{no_focus} ? @normal_win_opts : @focused_win_opts );
    my $win = $grp->{focusedWindow};
    return unless $win;
    clearCanvasFocus($grp) unless $opts->{no_focus};
    $win->split_frame( $canvas, $dir, $opts->{ratio} );

    unless ( $opts->{no_init} ) {
        foreach (
            qw(FSFile treeNo currentNode currentFileNo macroContext currentFilelist)
            )
        {
            $twin->{$_} = $win->{$_};
        }
        $twin->{minorModes} = [ @{ $win->{minorModes} || [] } ];
    }
    $twin->apply_stylesheet( $grp->{selectedStylesheet} );
    focusCanvas( $canvas, $grp ) unless $opts->{no_focus};
    unless ( $opts->{no_redraw} ) {
        $twin->get_nodes();
        $twin->redraw();
    }
    return $twin;
}

# window, UI
sub removeWindow {
    my ( $grp, $win ) = @_;
    $win ||= $grp->{focusedWindow};
    my $windows = $grp->{treeWindows};
    if ( @{$windows} > 1 ) {
        doEvalHook( $win, "pre_switch_context_hook", $win->{macroContext},
            '<NONE>', $win );
        @{$windows} = grep { $_ ne $win } @{$windows};
        $grp->{rmsplitButton}->configure( -state => 'disabled' )
            if $grp->{rmsplitButton} and @{$windows} <= 1;
        TrEd::File::close_file( $win, -no_update => 1, -keep_postponed => 1 );
        my $brother = $win->canvas_destroy();
        if ( $win == $grp->{focusedWindow} ) {
            delete $grp->{focusedWindow};
            focusCanvas( $brother, $grp );
        }
        $win->{treeView} = undef;
        undef $win;
    }
}

# UI, mouse wheel
sub canvasBindMouseScale {
    my ( $grp, $w, $modifier ) = @_;
    $modifier .= "-" if ($modifier);
    my $sub = sub {
        my ( $c, $grp, $amount ) = @_;
        $amount /= 600;    # Tk::Ev('D') gives at least 120 on Win32
        my $win;
        if ( $c->isa('Tk::Toplevel') ) {
            $win = $grp->{focusedWindow};
        }
        else {
            $win = findCanvasWindow( $grp, $c );
        }
        my $tv = $win->treeView;
        my $scale = max2( -2, min2( 2, $tv->{scale} + $amount ) );
        $tv->scale( $scale, 0 );
        updateScaleFactor($grp);
        Tk->break;
    };
    for my $widget ( $Tk::platform eq 'MSWin32' ? ( $grp->{top}, $w ) : ($w) )
    {
        $widget->Tk::bind( "<${modifier}MouseWheel>",
            [ $sub, $grp, Tk::Ev("D") ] );
    }
    if ( $Tk::platform ne 'MSWin32' ) {
        $w->CanvasBind( "<${modifier}4>", [ $sub, $grp, 60 ] );
        $w->CanvasBind( "<${modifier}5>", [ $sub, $grp, -60 ] );
    }
}

# UI, mouse wheel
sub canvasBindMouseWheelVert {
    my ( $w, $modifier, $grp ) = @_;
    $modifier ||= "";
    $modifier .= "-" if ($modifier);
    for my $widget (
        $Tk::platform eq 'MSWin32' ? ( $w->toplevel, $w ) : ($w) )
    {
        $widget->Tk::bind(
            "<$modifier" . "MouseWheel>",
            [   sub {
                    $grp->{focusedWindow}->canvas()
                        ->yview( 'scroll', -( $_[2] / 120 ), 'units' );
                },
                $w,
                Tk::Ev("D"),
                $grp
            ]
        );
    }
    if ( $Tk::platform ne 'MSWin32' ) {
        $w->CanvasBind(
            "<$modifier" . "4>",
            sub {
                $_[0]->yview( 'scroll', -3, 'units' )
                    unless $Tk::strictMotif;
                Tk->break;
            }
        );
        $w->CanvasBind(
            "<$modifier" . "5>",
            sub {
                $_[0]->yview( 'scroll', 3, 'units' )
                    unless $Tk::strictMotif;
                Tk->break;
            }
        );
        if ( $modifier eq EMPTY ) {
            $w->CanvasBind(
                "<6>",
                sub {
                    $_[0]->xview( 'scroll', -3, 'units' )
                        unless $Tk::strictMotif;
                }
            );
            $w->CanvasBind(
                "<7>",
                sub {
                    $_[0]->xview( 'scroll', 3, 'units' )
                        unless $Tk::strictMotif;
                }
            );
        }
    }
}

# UI, mouse wheel
sub canvasBindMouseWheelHoriz {
    my ( $w, $modifier, $grp ) = @_;
    $modifier ||= "";
    $modifier .= "-" if ($modifier);
    for my $widget (
        $Tk::platform eq 'MSWin32' ? ( $w->toplevel, $w ) : ($w) )
    {
        $widget->Tk::bind(
            "<$modifier" . "MouseWheel>",
            [   sub {
                    $grp->{focusedWindow}->canvas()
                        ->xview( 'scroll', -( $_[2] / 120 ), 'units' );
                },
                $w,
                Tk::Ev("D"),
                $grp
            ]
        );
    }
    if ( $Tk::platform ne 'MSWin32' ) {
        $w->CanvasBind(
            "<$modifier" . "4>",
            sub {
                $_[0]->xview( 'scroll', -3, 'units' )
                    unless $Tk::strictMotif;
            }
        );
        $w->CanvasBind(
            "<$modifier" . "5>",
            sub {
                $_[0]->xview( 'scroll', 3, 'units' )
                    unless $Tk::strictMotif;
            }
        );
    }
}

# sub keyBind

# UI, canvas, bind
sub createCanvasBindings {
    my ( $grp, $canvas ) = @_;
    ## Canvas bindings
    $canvas->CanvasBind( '<ButtonPress>', [ \&focusCanvas, $grp ] );
    foreach my $tag (qw(text line)) {
        $canvas->bind(
            $tag,
            '<Any-Enter>' => [
                sub {
                    my ( $c, $grp ) = @_;
                    my $win = findCanvasWindow( $grp, $c );
                    my $tv = $win->treeView;
                    my ($t) = $tv->find_item( 'withtag', 'current' );
                    my $node = $tv->get_obj_pinfo($t);
                    $tv->store_node_pinfo( $node, "SaveColor",
                        $c->itemcget( $t, '-fill' ) );
                    $c->itemconfigure( $t, -fill => $activeTextColor );
                },
                $grp
            ]
        );

        $canvas->bind(
            $tag,
            '<Any-Leave>' => [
                sub {
                    my ( $c, $grp ) = @_;
                    my $win = findCanvasWindow( $grp, $c );
                    my $tv = $win->treeView;
                    my ($t) = $tv->find_item( 'withtag', 'current' );
                    my $node = $tv->get_obj_pinfo($t);
                    $c->itemconfigure( 'current',
                        -fill => $tv->get_node_pinfo( $node, "SaveColor" ) );
                },
                $grp
            ]
        );
    }

    # Button-1
    my ( $dx, $dy );
    $canvas->CanvasBind(
        '<Control-1>',
        [   sub {
                my ($c) = @_;
                return if $c->find( withtag => 'current' );
                ( $dx, $dy ) = (
                    $c->canvasx( $c->pointerx - $c->rootx ),
                    $c->canvasy( $c->pointery - $c->rooty )
                );
                Tk->break;
                }
        ]
    );
    $canvas->CanvasBind(
        '<ButtonRelease-1>',
        sub {
            if ( defined $dx ) {
                undef $dx;
                undef $dy;
                Tk->break;
            }
        }
    );
    $canvas->CanvasBind(
        '<B1-Motion>',
        [   sub {
                return unless defined $dx;
                my ( $c, $grp ) = @_;
                return if $c->find( withtag => 'current' );
                my $win = findCanvasWindow( $grp, $c );
                my $tv  = $win->treeView;
                my $t   = $tv->get_node_pinfo( $win->{currentNode}, 'Oval' );
                my ( $x, $y ) = (
                    $c->canvasx( $c->pointerx - $c->rootx ),
                    $c->canvasy( $c->pointery - $c->rooty )
                );
                if ($t) {
                    my @corners = (
                        $c->canvasx(0) - 10,
                        $c->canvasy(0) - 10,
                        $c->canvasx( $c->width ) + 10,
                        $c->canvasy( $c->height ) + 10
                    );
                    my @scrollregion = @{ $c->cget('-scrollregion') };
                    $c->configure(
                        -scrollregion => [
                            min( $corners[0] - $x + $dx, $scrollregion[0] ),
                            min( $corners[1] - $y + $dy, $scrollregion[1] ),
                            max( $corners[2] - $x + $dx, $scrollregion[2] ),
                            max( $corners[3] - $y + $dy, $scrollregion[3] )
                        ]
                    );
                    $c->xviewCoord( $dx, $c->xviewCoord($x) );
                    $c->yviewCoord( $dy, $c->yviewCoord($y) );
                    Tk->break;
                }
            },
            $grp
        ]
    );
    $canvas->bind( 'point', '<1>' => [ sub { node_down(@_) }, $grp, 0 ] );
    foreach (qw(Shift Control Alt Meta)) {
        $canvas->bind( 'point',
            "<$_-Button-1>" => [ sub { node_click_modif(@_) }, $grp, $_ ] );
    }
    $canvas->bind( 'point',
        '<ButtonRelease-1>' => [ sub { node_release(@_) }, $grp, 0 ] );
    foreach (qw(Shift Control Alt Meta)) {
        $canvas->bind( 'point',
            "<$_-ButtonRelease-1>" =>
                [ sub { node_release_modif(@_) }, $grp, $_ ] );
    }
    $canvas->bind( 'point',
        '<B1-Motion>' => [ sub { node_move(@_) }, $grp ] );
    foreach (qw(Shift Control Alt Meta)) {
        $canvas->bind( 'point',
            "<$_-B1-Motion>" => [ sub { node_motion_modif(@_) }, $grp ] );
    }

    # Button-3
    $canvas->bind( 'point', '<3>' => [ sub { node_down(@_) }, $grp, 1 ] );
    foreach (qw(Shift Control Alt Meta)) {
        $canvas->bind( 'point',
            "<$_-Button-3>" => [ sub { node_click_modif(@_) }, $grp, "-3" ] );
    }
    $canvas->bind( 'point',
        '<ButtonRelease-3>' => [ sub { node_release(@_) }, $grp, 3 ] );
    foreach (qw(Shift Control Alt Meta)) {
        $canvas->bind( 'point',
            "<$_-ButtonRelease-3>" =>
                [ sub { node_release_modif(@_) }, $grp, "$_-3" ] );
    }
    $canvas->bind( 'point',
        '<B3-Motion>' => [ sub { node_move(@_) }, $grp, 1 ] );
    foreach (qw(Shift Control Alt Meta)) {
        $canvas->bind( 'point',
            "<$_-B3-Motion>" =>
                [ sub { node_motion_modif(@_) }, $grp, "$_-3" ] );
    }

    # Button-2
    $canvas->CanvasBind( '<2>' => [ sub { follow_mouse_press(@_) }, $grp ] );
    $canvas->CanvasBind(
        '<B2-Motion>' => [ sub { follow_mouse(@_) }, $grp ] );

    # Button-2
    foreach (qw(Shift Control Alt Meta)) {
        $canvas->bind( 'point',
            "<$_-Button-2>" =>
                [ sub { node_click_modif(@_) }, $grp, $_, "$_-2" ] );
    }
    foreach (qw(Shift Control Alt Meta)) {
        $canvas->bind( 'point',
            "<$_-ButtonRelease-2>" =>
                [ sub { node_release_modif(@_) }, $grp, "$_-2" ] );
    }
    foreach (qw(Shift Control Alt Meta)) {
        $canvas->bind( 'point',
            "<$_-B2-Motion>" =>
                [ sub { node_motion_modif(@_) }, $grp, "$_-2" ] );
    }

    # Text 1
    for my $tag (qw(plaintext text textbg textbox edgebox stripe)) {
        $canvas->bind( $tag, '<1>' => [ sub { node_down(@_) }, $grp, 0 ] );
        $canvas->bind( $tag,
            '<B1-Motion>' => [ sub { node_move(@_) }, $grp, 0 ] );
        $canvas->bind( $tag,
            '<ButtonRelease-1>' => [ sub { node_release(@_) }, $grp, 0 ] );
        foreach (qw(Shift Control Alt Meta)) {
            $canvas->bind( $tag,
                "<$_-B1-Motion>" => [ sub { node_motion_modif(@_) }, $grp ] );
            $canvas->bind( $tag,
                "<$_-B2-Motion>" =>
                    [ sub { node_motion_modif(@_) }, $grp, "$_-2" ] );
            $canvas->bind( $tag,
                "<$_-B3-Motion>" =>
                    [ sub { node_motion_modif(@_) }, $grp, "$_-3" ] );
            $canvas->bind( $tag,
                "<$_-ButtonRelease-1>" =>
                    [ sub { node_release_modif(@_) }, $grp, $_ ] );
            $canvas->bind( $tag,
                "<$_-ButtonRelease-2>" =>
                    [ sub { node_release_modif(@_) }, $grp, "$_-2" ] );
            $canvas->bind( $tag,
                "<$_-ButtonRelease-3>" =>
                    [ sub { node_release_modif(@_) }, $grp, "$_-3" ] );
            $canvas->bind( $tag,
                "<$_-Button-1>" => [ sub { text_click_modif(@_) }, $grp, $_ ]
            );
            $canvas->bind(
                $tag,
                "<$_-Button-2>" => [
                    sub { text_click_modif(@_); Tk->break; }, $grp, "$_-2"
                ]
            );
            $canvas->bind(
                $tag,
                "<$_-Button-3>" => [
                    sub { text_click_modif(@_); Tk->break; }, $grp, "$_-3"
                ]
            );
        }
    }

    # Text Dobule-1
    for my $tag (qw(text textbg)) {
        $canvas->bind( $tag,
            '<Double-1>' => [ sub { editAttr(@_); Tk->break; }, $grp ] );
        for my $but ( 2, 3 ) {
            $canvas->bind(
                $tag,
                "<Double-$but>" => [
                    sub { text_doubleclick_modif(@_); Tk->break; }, $grp,
                    "$but"
                ]
            );
        }
        foreach (qw(Shift Control Alt Meta)) {
            $canvas->bind(
                $tag,
                "<$_-Double-1>" => [
                    sub { text_doubleclick_modif(@_); Tk->break; },
                    $grp, $_
                ]
            );
            for my $but ( 2, 3 ) {
                $canvas->bind(
                    $tag,
                    "<$_-Double-$but>" => [
                        sub { text_doubleclick_modif(@_); Tk->break; },
                        $grp, "$_-$but"
                    ]
                );
            }
        }
    }

    # point Double-1
    $canvas->bind( 'point',
        "<Double-1>" => [ sub { editAttrs(@_); Tk->break; }, $grp ] );
    foreach (qw(Shift Control Alt Meta)) {
        $canvas->bind( 'point',
            "<$_-Double-1>" =>
                [ sub { node_doubleclick_modif(@_); Tk->break; }, $grp, $_ ]
        );
    }

    # Line clicks
    for my $modif ( undef, qw(Shift Control Alt Meta) ) {
        for my $clicktype (qw(Button Double)) {
            for my $button ( 1 .. 3 ) {
                my $event = join '-',
                    grep {defined} ( $modif, $clicktype, $button );
                $canvas->bind(
                    'line',
                    "<$event>" => [
                        sub { line_click(@_) },
                        $grp, $button, $clicktype eq 'Double' ? 1 : 0, $modif
                    ]
                );
            }
        }
    }
}

sub _menu_swaps {
    return (
        [ 'MENUBAR:NODE:UP_LEVEL'   => 'MENUBAR:NODE:LEFT_SIBLING' ],
        [ 'MENUBAR:NODE:DOWN_LEVEL' => 'MENUBAR:NODE:RIGHT_SIBLING' ],
    );
}

# node, menu
sub updateNodeMenu {
    my ($grp_or_win) = @_;
    my ( $grp, $win ) = grp_win($grp_or_win);
    my $m = $grp->{main_menu};
    return
        unless $m
            and ( ( $grp->{main_menu_tree_orientation_state} ? 1 : 0 )
                != (TrEd::Window::TreeBasics::tree_is_vertical($grp) ? 1 : 0 )
            );
    $grp->{main_menu_tree_orientation_state}
        = TrEd::Window::TreeBasics::tree_is_vertical($grp);
    for my $swap ( _menu_swaps() ) {
        my ( $item1, $item2 ) = @$swap;
        my $accel1 = $m->get_menu_option( $item1, '-accelerator' );
        my $accel2 = $m->get_menu_option( $item2, '-accelerator' );
        $m->set_menu_options( $item1, -accelerator => $accel2 );
        $m->set_menu_options( $item2, -accelerator => $accel1 );
    }
}

sub _change_orientation {
    my ($grp) = @_;
    my $win = $grp->{focusedWindow};
    $win->treeView->set_displayMode( $treeViewOpts->{displayMode} );
    $win->redraw();
    $win->ensure_current_is_displayed();
    updateNodeMenu($grp);
}

sub _load_menus {
    my ($grp) = @_;
    my $path = File::Spec->catfile( $libDir, 'TrEd', 'Menu', 'menubar.inc' );
    my $code = do $path;
    return $code->($grp);
}

sub _tk_dialog_alternative {
    my ($old) = @_;
    my $d = &$old;
    if ($d) {
        for my $widget ( grep { $_->isa('Tk::Button') } $d->Subwidget ) {
            $widget->configure( -padx => 7, -pady => 2, -width => 0 );
        }
    }
    return $d;
}

sub create_split_windows {
    my ( $opt_split_window, $opt_filelist, $tred_ref ) = @_;
    my $dir = $opt_split_window > 0 ? 'vert' : 'horiz';
    my @fl = $opt_filelist =~ /,/g;
    my $fl = @fl + 1;
    if ( $fl > 1 ) {
        $fl = TrEd::MinMax::min( $opt_split_window, $fl );
        my $i;
        for ( my $i = 0; $i < $fl; $i++ ) {
            focusCanvas( $tred_ref->{treeWindows}->[$i]->canvas, $tred_ref );
            TrEd::ManageFilelists::selectFilelist(
                $tred_ref->{treeWindows}->[$i],
                "CmdLine-" . ( $i + 1 ) );
            TrEd::Filelist::Navigation::go_to_file(
                $tred_ref->{treeWindows}->[$i], 0 );
        }
    }
    else {
        for ( my $i = 1; $i < $opt_split_window; $i++ ) {
            focusCanvas( $tred_ref->{treeWindows}->[$i]->canvas, $tred_ref );
            $tred_ref->{treeWindows}->[$i]->{currentFilelist}
                = $tred_ref->{treeWindows}->[0]->{currentFilelist};
            TrEd::Filelist::Navigation::go_to_file(
                $tred_ref->{treeWindows}->[$i], $i );
        }
    }
    focusCanvas( $tred_ref->{treeWindows}->[0]->canvas, $tred_ref );
    $tred_ref->{tieWindows} = 1;
    return;
}

sub populate_recent_files_menu {
    my ( $grp_ref, $recent_files_ref ) = @_;
    my $recentFileMenu = $grp_ref->{RecentFileMenu};

    my $i = 0;
    foreach my $recent_file ( @{$recent_files_ref} ) {
        $recentFileMenu->command(
            -label     => "$i.  $recent_file",
            -underline => 0,
            -command =>
                [ \&TrEd::File::open_standalone_file, $grp_ref, $recent_file ]
        );
        $i++;
    }
    return;
}

sub create_toolbar_buttons {
    my ($tred_ref) = @_;
    print STDERR "Creating buttons.\n" if $tredDebug;

    $tred_ref->{nextButton} = $tred_ref->{Toolbar}->Button(
        -takefocus   => 0,
        -text        => "Next",
        -relief      => $buttonsRelief,
        -image       => icon( $tred_ref, "1rightarrow" ),
        -state       => 'disabled',
        -borderwidth => $buttonBorderWidth,
        -command     => [ \&tieNextTree, $tred_ref ]
    );
    $tred_ref->{Balloon}->attach( $tred_ref->{nextButton},
        -balloonmsg => "see the next tree in the file" );
    addBindTags( $tred_ref->{nextButton}, 'my' );

    $tred_ref->{prevButton} = $tred_ref->{Toolbar}->Button(
        -takefocus   => 0,
        -text        => "Prev",
        -relief      => $buttonsRelief,
        -image       => icon( $tred_ref, "1leftarrow" ),
        -state       => 'disabled',
        -borderwidth => $buttonBorderWidth,
        -command     => [ \&tiePrevTree, $tred_ref ]
    );
    $tred_ref->{Balloon}->attach( $tred_ref->{prevButton},
        -balloonmsg => "see the previous tree the file" );
    addBindTags( $tred_ref->{prevButton}, 'my' );

    $tred_ref->{openButton} = $tred_ref->{Toolbar}->Button(
        -takefocus   => 0,
        -text        => "Open",
        -relief      => $buttonsRelief,
        -image       => icon( $tred_ref, "fileopen" ),
        -borderwidth => $buttonBorderWidth,
        -command     => [ \&TrEd::Dialog::File::Open::show_dialog, $tred_ref ]
    )->pack( -side => 'left' );
    $tred_ref->{Balloon}
        ->attach( $tred_ref->{openButton}, -balloonmsg => "open file" );
    addBindTags( $tred_ref->{openButton}, 'my' );
    $tred_ref->{saveButton} = $tred_ref->{Toolbar}->Button(
        -takefocus   => 0,
        -text        => "Save",
        -relief      => $buttonsRelief,
        -image       => icon( $tred_ref, "filesave" ),
        -state       => 'disabled',
        -borderwidth => $buttonBorderWidth,
        -command     => [ \&TrEd::File::save_file, $tred_ref ]
    )->pack( -side => 'left' );

    $tred_ref->{Balloon}->attach( $tred_ref->{saveButton},
        -balloonmsg => "save current file" );
    addBindTags( $tred_ref->{saveButton}, 'my' );

    $tred_ref->{reloadButton} = $tred_ref->{Toolbar}->Button(
        -takefocus   => 0,
        -text        => "Reload",
        -relief      => $buttonsRelief,
        -image       => icon( $tred_ref, "reload" ),
        -borderwidth => $buttonBorderWidth,
        -command     => [ \&TrEd::File::reload_file, $tred_ref ]
    )->pack( -side => 'left' );

    $tred_ref->{Balloon}->attach( $tred_ref->{reloadButton},
        -balloonmsg => "reload current file" );
    addBindTags( $tred_ref->{reloadButton}, 'my' );

    ###################

    $tred_ref->{prevFileButton} = $tred_ref->{Toolbar}->Button(
        -takefocus   => 0,
        -text        => "Prev file",
        -relief      => $buttonsRelief,
        -image       => icon( $tred_ref, "start" ),
        -borderwidth => $buttonBorderWidth,
        -command => [ \&TrEd::Filelist::Navigation::tie_prev_file, $tred_ref ]
    )->pack( -side => 'left' );
    $tred_ref->{Balloon}->attach( $tred_ref->{prevFileButton},
        -balloonmsg => "visit the previous file in the file-list" );
    addBindTags( $tred_ref->{prevFileButton}, 'my' );

    $tred_ref->{nextFileButton} = $tred_ref->{Toolbar}->Button(
        -takefocus   => 0,
        -text        => "Next file",
        -relief      => $buttonsRelief,
        -image       => icon( $tred_ref, "finish" ),
        -borderwidth => $buttonBorderWidth,
        -command => [ \&TrEd::Filelist::Navigation::tie_next_file, $tred_ref ]
    )->pack( -side => 'left' );
    $tred_ref->{Balloon}->attach( $tred_ref->{nextFileButton},
        -balloonmsg => "visit the next file in the file-list" );
    addBindTags( $tred_ref->{nextFileButton}, 'my' );

    # bind action control
    for my $bind (
        [ nextFileButton => \&TrEd::Filelist::Navigation::next_real_file ],
        [ prevFileButton => \&TrEd::Filelist::Navigation::prev_real_file ]
        )
    {
        my $button = $tred_ref->{ $bind->[0] };
        my $cmd    = $bind->[1];
        $button->bindtags(
            [ $button, ref($button), $button->toplevel, 'all' ] );
        $button->bind(
            $button,
            '<Control-ButtonRelease-1>',
            sub {
                $button->flash();
                $cmd->($tred_ref);
                Tk->break;
            }
        );
    }

    $tred_ref->{printButton} = $tred_ref->{Toolbar}->Button(
        -takefocus   => 0,
        -text        => "Print",
        -relief      => $buttonsRelief,
        -image       => icon( $tred_ref, "fileprint" ),
        -borderwidth => $buttonBorderWidth,
        -command     => [ sub { printThis(@_) }, $tred_ref ]
    )->pack( -side => 'left' );
    $tred_ref->{Balloon}
        ->attach( $tred_ref->{printButton}, -balloonmsg => "print ..." );
    addBindTags( $tred_ref->{printButton}, 'my' );

    #####################
    $tred_ref->{Toolbar}->Frame( -bd => 2, -width => 2, -relief => 'groove' )
        ->pack( -side => 'left', -padx => '3', -fill => 'y', -pady => 3 );

    # Undo button

    $tred_ref->{undoButton} = $tred_ref->{Toolbar}->Button(
        -takefocus   => 0,
        -text        => "Undo",
        -relief      => $buttonsRelief,
        -image       => icon( $tred_ref, "undo" ),
        -state       => 'disabled',
        -borderwidth => $buttonBorderWidth,
        -command     => [ \&TrEd::Undo::undo, $tred_ref ]
    )->pack( -side => 'left' );
    $tred_ref->{Balloon}->attach( $tred_ref->{undoButton},
        -balloonmsg => "undo current file" );
    addBindTags( $tred_ref->{undoButton}, 'my' );

    # Redo button

    $tred_ref->{redoButton} = $tred_ref->{Toolbar}->Button(
        -takefocus   => 0,
        -text        => "Redo",
        -relief      => $buttonsRelief,
        -image       => icon( $tred_ref, "redo" ),
        -state       => 'disabled',
        -borderwidth => $buttonBorderWidth,
        -command     => [ \&re_do, $tred_ref ]
    )->pack( -side => 'left' );

    $tred_ref->{Balloon}->attach( $tred_ref->{redoButton},
        -balloonmsg => "redo current file" );
    addBindTags( $tred_ref->{redoButton}, 'my' );

    #####################
    $tred_ref->{Toolbar}->Frame( -bd => 2, -width => 2, -relief => 'groove' )
        ->pack( -side => 'left', -padx => '3', -fill => 'y', -pady => 3 );

    $tred_ref->{findButton} = $tred_ref->{Toolbar}->Button(
        -takefocus   => 0,
        -text        => "Find",
        -relief      => $buttonsRelief,
        -image       => icon( $tred_ref, "searchtool" ),
        -borderwidth => $buttonBorderWidth,
        -command     => [
            sub {
                my ($grp) = @_;
                TrEd::Dialog::FindNode::show_dialog($grp)
                    if ( $grp->{focusedWindow}->{currentNode} );
            },
            $tred_ref
        ]
    )->pack( -side => 'left' );
    $tred_ref->{Balloon}
        ->attach( $tred_ref->{findButton}, -balloonmsg => "Find node ..." );
    addBindTags( $tred_ref->{findButton}, 'my' );

    $tred_ref->{findNextButton} = $tred_ref->{Toolbar}->Button(
        -takefocus   => 0,
        -text        => "Find Next",
        -relief      => $buttonsRelief,
        -image       => icon( $tred_ref, "searchtool_forward" ),
        -borderwidth => $buttonBorderWidth,
        -command     => [ \&doFindFirstTemplated, $tred_ref, 1 ]
    )->pack( -side => 'left' );
    $tred_ref->{Balloon}->attach( $tred_ref->{findNextButton},
        -balloonmsg => "Find next ..." );
    addBindTags( $tred_ref->{findNextButton}, 'my' );

    $tred_ref->{findPrevButton} = $tred_ref->{Toolbar}->Button(
        -takefocus   => 0,
        -text        => "Find Previous",
        -relief      => $buttonsRelief,
        -image       => icon( $tred_ref, "searchtool_backward" ),
        -borderwidth => $buttonBorderWidth,
        -command     => [ \&doFindPrevTemplated, $tred_ref, 1 ]
    )->pack( -side => 'left' );
    $tred_ref->{Balloon}->attach( $tred_ref->{findPrevButton},
        -balloonmsg => "Find previous ..." );
    addBindTags( $tred_ref->{findPrevButton}, 'my' );

    $tred_ref->{Toolbar}->Frame( -bd => 2, -width => 2, -relief => 'groove' )
        ->pack( -side => 'left', -padx => '3', -fill => 'y', -pady => 3 );

    $tred_ref->{prevButton}->pack( -side => 'left' );
    $tred_ref->{nextButton}->pack( -side => 'left' );

    #####################
    $tred_ref->{Toolbar}->Frame( -bd => 2, -width => 2, -relief => 'groove' )
        ->pack( -side => 'left', -padx => '3', -fill => 'y', -pady => 3 );

    $tred_ref->{vsplitButton} = $tred_ref->{Toolbar}->Button(
        -takefocus   => 0,
        -text        => "Split View Vertically",
        -relief      => $buttonsRelief,
        -image       => icon( $tred_ref, "view_left_right" ),
        -borderwidth => $buttonBorderWidth,
        -command     => [ \&splitWindow, $tred_ref, 'vert' ]
    )->pack( -side => 'left' );
    $tred_ref->{Balloon}->attach( $tred_ref->{vsplitButton},
        -balloonmsg => "split view vertically" );

    $tred_ref->{hsplitButton} = $tred_ref->{Toolbar}->Button(
        -takefocus   => 0,
        -text        => "Split View Horizontally",
        -relief      => $buttonsRelief,
        -image       => icon( $tred_ref, "view_top_bottom" ),
        -borderwidth => $buttonBorderWidth,
        -command     => [ \&splitWindow, $tred_ref, 'horiz' ]
    )->pack( -side => 'left' );

    $tred_ref->{Balloon}->attach( $tred_ref->{hsplitButton},
        -balloonmsg => "split view horizontally" );

    $tred_ref->{rmsplitButton} = $tred_ref->{Toolbar}->Button(
        -takefocus   => 0,
        -text        => "Remove Current View",
        -relief      => $buttonsRelief,
        -state       => 'disabled',
        -image       => icon( $tred_ref, "view_remove" ),
        -borderwidth => $buttonBorderWidth,
        -command     => [ \&removeWindow, $tred_ref ]
    )->pack( -side => 'left' );
    $tred_ref->{Balloon}->attach( $tred_ref->{rmsplitButton},
        -balloonmsg => "remove current view" );

    $tred_ref->{tieWinddowsButton} = $tred_ref->{Toolbar}->Checkbutton(
        -takefocus   => 0,
        -text        => "Tie Displayed Windows",
        -variable    => \$tred_ref->{tieWindows},
        -relief      => $buttonsRelief,
        -indicatoron => 0,
        -image       => icon( $tred_ref, "lock" ),
        -borderwidth => $buttonBorderWidth
    )->pack( -side => 'left' );
    $tred_ref->{Balloon}->attach( $tred_ref->{tieWinddowsButton},
        -balloonmsg => "tie all views" );

    $tred_ref->{Toolbar}->Frame( -bd => 2, -width => 2, -relief => 'groove' )
        ->pack( -side => 'left', -padx => '3', -fill => 'y', -pady => 3 );

    $tred_ref->{toggleUserToolbarButton} = $tred_ref->{Toolbar}->Menubutton(
        -takefocus   => 0,
        -tearoff     => 0,
        -text        => "Toggle User Toolbars",
        -relief      => $buttonsRelief,
        -indicatoron => 0,
        -state       => 'disabled',
        -image       => icon( $tred_ref, "1downarrow" ),
        -borderwidth => $buttonBorderWidth
    )->pack( -side => 'left' );
    $tred_ref->{Balloon}->attach(
        $tred_ref->{toggleUserToolbarButton},
        -balloonmsg => "toggle user-defined toolbars"
    );

    ##########################
    return;
}

sub create_stylesheet_menu {
    my ($tred_ref) = @_;

    $tred_ref->{StylesheetMenu} = TrEd::Menu::Stylesheet->new($tred_ref);

    $tred_ref->{attrButton} = $tred_ref->{Toolbar}->Button(
        -takefocus   => 0,
        -text        => "Edit Stylesheet",
        -relief      => $buttonsRelief,
        -image       => icon( $tred_ref, "wizard" ),
        -borderwidth => $buttonBorderWidth,
        -command     => [
            sub { TrEd::Dialog::EditStylesheet::show_dialog(@_) }, $tred_ref
        ]
    )->pack( -side => 'right' );
    $tred_ref->{Balloon}->attach( $tred_ref->{attrButton},
        -balloonmsg =>
            "customize display patterns\nof the selected stylesheet\n(e.g. change tree appearance, labels etc.)"
    );

    $tred_ref->{StylesheetMenuLabel} = $tred_ref->{Toolbar}->Label(
        qw/-text Style:
            -font C_small
            -underline 2/
    )->pack(qw/-side right/);

    $tred_ref->{Balloon}->attach(
        $tred_ref->{StylesheetMenu}->get_menu(),
        -balloonmsg => "stylesheet (tree appearance)"
    );

    print STDERR "Packing widgets.\n" if $TrEd::Config::tredDebug;

    $tred_ref->{Toolbar}->pack( -fill => 'x', -padx => '1', -pady => 1 );
    return;
}

sub create_value_line_subframe {
    my ($tred_ref) = @_;

    my $vlsubframe = $tred_ref->{vLineFrame}->Frame();
    $tred_ref->{vLineNumLabel}
        = $vlsubframe->Label( -text => '-/-' )->pack(qw/-side top -fill x/);
    $tred_ref->{Balloon}->attach( $tred_ref->{vLineNumLabel},
        -balloonmsg =>
            "position of the current tree\nin the file (current/total)" );

    $tred_ref->{sentButton} = $vlsubframe->Button(
        -takefocus   => 0,
        -text        => "Sentences",
        -relief      => $buttonsRelief,
        -image       => icon( $tred_ref, "contents" ),
        -borderwidth => $buttonBorderWidth,
        -command     => [ \&TrEd::View::Sentence::show_sentences, $tred_ref ]
    )->pack(qw/-side top -fill x/);
    $tred_ref->{Balloon}->attach( $tred_ref->{sentButton},
        -balloonmsg =>
            "View all trees as a list of 'sentences'...\nThis dialog also allows export to HTML."
    );

    $vlsubframe->pack(qw/-fill x -side right -padx 1 -anchor n/);

    $tred_ref->{valueLine}->value_line_widget()
        ->pack(qw/-side left -fill both -expand yes/);
    $tred_ref->{vLineFrame}->pack(qw/-fill x -expand no/);

    $tred_ref->{vLineSeparator}
        ->packAfter( $tred_ref->{vLineFrame}, -side => 'top' );
    return;
}

sub set_default_widget_options {
    my ($top) = @_;
    for (
        qw(ROText Text TextUndo Entry LabEntry HistEntry SimpleHistEntry
        Listbox HList CodeText)
        )
    {
        $top->optionAdd( "\*$_.background",         'white' );
        $top->optionAdd( "\*$_.foreground",         'black' );
        $top->optionAdd( "\*$_.disabledBackground", 'lightgray' );
        $top->optionAdd( "\*$_.disabledForeground", 'gray20' );
    }
    if ( !$TrEd::Config::enableTearOff ) {
        for (qw(Menu)) {
            $top->optionAdd( "\*$_.tearOff", 0 );
        }
    }

    if ( $^O ne 'MSWin32' ) {
        $top->optionAdd( "\*Scrollbar.width",              "10" );
        $top->optionAdd( "\*Scrollbar.elementBorderWidth", "1" );
        $top->optionAdd( "\*Scrollbar.borderWidth",        "1" );
        $top->optionAdd( "\*Scrollbar.troughColor",        "gray80" );
    }
    return;
}

# make sure button flashes are visible
sub set_button_flashes {
    my ($top) = @_;
    my $bg = $top->optionGet( 'Button.background', 'Background' );
    my $abg = $top->optionGet( 'Button.activeBackground',
        'ActiveBackground' );
    my $H     = '[a-z0-9]{2}';
    my $level = 7;
    if ( ( $bg eq $abg ) and $abg =~ /^\#($H)($H)($H)$/ogi ) {
        my ( $r, $g, $b ) = map {hex} $1, $2, $3;
        if ( !TrEd::MinMax::first { $_ >= 255 - $level } ( $r, $g, $b ) ) {

            # lighten
            for ( $r, $g, $b ) {
                $_ += $level;
            }
        }
        else {

            # darken
            $_ -= $level for $r, $g, $b;
        }
        $abg = '#' . join q{},
            map { sprintf( '%02x', TrEd::MinMax::min( abs($_), 255 ) ) }
            $r, $g, $b;
        $top->optionAdd( '*Button.activeBackground', $abg );
    }
    return;
}

sub set_geometry {
    my ($top) = @_;
    if (  !defined $opt_G
        && defined $TrEd::Config::geometry
        && length $TrEd::Config::geometry )
    {
        if ( $TrEd::Config::geometry =~ /^(.*)x(.*)\+([0-9]+)\+([0-9]+)/ ) {
            $TrEd::Config::geometry
                = "$1x$2+"
                . TrEd::MinMax::min( $3, $top->vrootwidth() - $1 ) . "+"
                . TrEd::MinMax::min( $4, $top->vrootheight() - $2 );
        }
        $top->geometry($TrEd::Config::geometry);
    }
    if ($opt_W) {

        $TrEd::Config::geometry = "600x400";
        $top->sizefrom('program');
        $top->geometry($TrEd::Config::geometry);
    }
    return;
}

sub set_up_signal_handling {
    my ($tred_ref) = @_;

    # otherwise SIGINT would wait till next focus
    my $top = $tred_ref->{top};
    $top->repeat( 1000, sub {1} );

    $SIG{PIPE} = sub {
        print STDERR "Caught signal SIGPIPE: $!\n";
    };
    $SIG{USR1} = sub {
        if ($insideEval) {
            print STDERR "Caught signal USR1: stopping current evaluation.\n";
        }
        else {
            print STDERR
                "Caught signal USR1: ignoring - not in a macro evaluation.\n";
        }
        print STDERR "Current call stack:\n", map {
            my ( $pkg, $f, $line ) = caller($_);
            "  $_: file $f line $line\n"
        } 1 .. 5;
        $insideEval
            && die
            "Caught USR1: stopping current evaluation.\nSee the error output for details...\n";
    };
    $SIG{INT} = sub {
        if ($insideEval) {
            print STDERR "Caught SIGINT, stopping current evaluation\n";
            print STDERR "Current call stack:\n", map {
                my ( $pkg, $f, $line ) = caller($_);
                "  $_: file $f line $line\n"
            } 1 .. 5;
            die
                "Caught SIGINT, stopping current evaluation.\nSee the error output for details...\n";
        }
        else {
            print STDERR "Caught SIGINT, closing all files without saving\n";
            TrEd::File::close_all_files( $tred_ref );
            print STDERR "Good bye!\n";
            $top->destroy;
            exit_tred(1);
        }
    };
    return;
}

sub set_up_menubindigs {
    my ($tred_ref, $menubar) = @_;
    my $top = $tred_ref->{top};
    print STDERR "Binding keystrokes...\n" if $tredDebug;
    $menubar->bind(
        '<Escape>',
        sub {
            eval { shift->menu->Leave() };
            Tk->break;
        }
    );
    $top->bind(
        'my',
        '<Menu>' => [
            sub {
                my ( $w, $grp ) = @_;
                my $mbar = $grp->{Menubar};
                $mbar->focus;
                $mbar->FindMenu('F');    # File
                if ( $^O eq 'MSWin32' ) {
                    foreach my $child ( grep { $_->class eq 'Menubutton' }
                        $mbar->children )
                    {
                        $child->ButtonUp();
                    }
                }
            },
            $tred_ref
        ]
    );
    foreach my $prefix ( 'Alt', 'Meta', 'Mod4' ) {
        $top->bind(
            'my',
            "<$prefix-KeyPress>" => [
                sub {
                    if ( defined( evalMacro(@_) ) ) {
                        Tk->break;
                    }
                    else {

                        # Actually, this should work by it self. And it realy
                        # does, but not under windows :-) Well, do not laugh,
                        # too early, Linux users. With menu (not menubutton)
                        # this is the same there, only vice versa.
                        my ( $w, $grp, $mod ) = @_;
                        my $mbar = $grp->{Menubar};
                        $mbar->FindMenu( $w->XEvent->K );
                        if ( $^O eq 'MSWin32' ) {
                            foreach
                                my $child ( grep { $_->class eq 'Menubutton' }
                                $mbar->children )
                            {
                                $child->ButtonUp();
                            }
                        }
                        Tk->break;
                    }
                },
                $tred_ref,
                uc($prefix) . '+'
            ]
        );
    }

    #TODO: move bindings to Menu::Context?
    foreach my $prefix ( 'Alt', 'Meta', 'Mod4' ) {
        $top->bind(
            'my',
            "<$prefix-o>" => [
                sub {
                    if ( defined( evalMacro(@_) ) ) {
                        Tk->break;
                    }
                    else {
                        my ( $w, $grp ) = @_;
                        my $but  = $grp->{ContextsMenu}->get_menu();
                        my $menu = $but->menu();
                        my $ctxt = $grp->{selectedContext};
                        Tk->break if $ctxt eq EMPTY;
                        my $idx = eval { $menu->index($ctxt) };
                        Tk->break if $idx eq 'none';
                        $but->Post();
                        eval { $menu->activate($idx) };
                        $but->ButtonUp() if $^O eq 'MSWin32';
                        Tk->break;
                    }
                },
                $tred_ref,
                uc($prefix) . '+'
            ]
        );
    }

    #TODO: move bindings to Menu::Stylesheet?
    foreach my $prefix ( 'Alt', 'Meta', 'Mod4' ) {
        $top->bind(
            'my',
            "<$prefix-y>" => [
                sub {
                    if ( defined( evalMacro(@_) ) ) {
                        Tk->break;
                    }
                    else {
                        my ( $w, $grp ) = @_;
                        my $but        = $grp->{StylesheetMenu}->get_menu();
                        my $menu       = $but->menu;
                        my $stylesheet = $grp->{selectedStylesheet};
                        Tk->break if $stylesheet eq EMPTY;
                        my $idx = eval { $menu->index($stylesheet) };
                        Tk->break if $idx eq 'none';
                        $but->Post();
                        eval { $menu->activate($idx) };
                        $but->ButtonUp() if $^O eq 'MSWin32';
                        Tk->break;
                    }
                },
                $tred_ref,
                uc($prefix) . '+'
            ]
        );
    }
    return;
}

sub version_during_last_startup {
    my $version_file = File::Spec->catfile( $tred_d, 'last_version' );
    my $ver = q{};
    if ( open my $fh, '<', $version_file ) {
        $ver = <$fh>;
        close $fh;
        chomp $ver;
    }
    if ( open my $fh, '>', $version_file ) {
        print $fh $VERSION, "\n";
        close $fh;
    }
    else {
        warn "Could not write version information to $version_file: $!\n";
        $ver = $VERSION;    # do not bother the user in this case
    }
    return $ver;
}

sub load_extensions {
    my ($tred_ref, $preparedExtensions) = @_;
    my $top = $tred_ref->{top};
    # check if TrEd has been updated
    my $ver = version_during_last_startup();

    if ( !$TrEd::Config::skipStartupVersionCheck
        && ( !$ver || $ver ne $VERSION ) )
    {
        if (TrEd::Query::User::new_query(
                $top, "TrEd was "
                    . ( $ver ? "upgraded" : "installed or upgraded" )
                    . " recently.\n\n"
                    . "Do you want to check for new extensions or updates?",
                -title   => "TrEd Upgraded",
                -buttons => [ "Manage Extensions", "Later" ]
            ) =~ /Manage/
            )
        {
            manage_extensions( $tred_ref, 0 );
            $preparedExtensions
                = TrEd::Extensions::prepare_extensions($opt_m);
        }
    }

    $top->Busy( -recurse => 1 );
    eval {
        loadMacros( $tred_ref, { preparedExtensions => $preparedExtensions } );
    };
    TrEd::Error::Message::error_message( $top, $@ ) if $@;
    print STDERR
        "Resource path: $Treex::PML::resourcePath\n";    # unless $opt_q;
    print 'Starting in context ' . $tred_ref->{focusedWindow}->{macroContext} . "\n"
        if $tredDebug;
    return $preparedExtensions;
}

sub create_minor_modes_menu {
    my ($tred_ref, $bottom_frame) = @_;
    $tred_ref->{minorModesMenu} = $bottom_frame->Menubutton(
        -image     => icon( $tred_ref, 'puzzle' ),
        -direction => 'above'
    )->pack( -side => 'left', -expand => 'no' );
    my $menu = $tred_ref->{minorModesMenu}->menu(qw/-tearoff 0/);
    $tred_ref->{minorModesMenu}->configure( -menu => $menu );
    $tred_ref->{minorModesLabelFrame} = $bottom_frame->Frame()
        ->pack( -side => 'left', -expand => 'no', -padx => 5 );
    $tred_ref->{minorModesLabels} = {};
    $tred_ref->{Balloon}->attach( $tred_ref->{minorModesMenu},
        -balloonmsg =>
            "Enable/disable additional features\n(a.k.a. minor modes)" );
    return;
}

sub create_canvas_scale {
    my ($tred_ref, $bottom_frame) = @_;
    $tred_ref->{canvasScale} = 0;
    $tred_ref->{canvasScaleLabel}
        = $bottom_frame->Label( -text => 'Scale: 100%' )
        ->pack( -side => 'left', -expand => 'no' );
    my $slider = $tred_ref->{canvasScaleWidget} = $bottom_frame->Scale(
        -from         => -2,
        -to           => 2,
        -font         => 'C_small',
        -length       => 100,
        -sliderlength => 20,
        -width        => 10,
        -showvalue    => 0,
        -resolution   => 0.1,
        -borderwidth  => 1,
        -variable     => \$tred_ref->{canvasScale},
        -command      => [
            sub {
                my ( $grp, $step ) = @_;
                $grp->{focusedWindow}->treeView->scale( $step,
                    $grp->{focusedWindow}->{currentNode} );
                updateScaleFactor($grp);
            },
            $tred_ref
        ],
        -orient => 'horizontal'
    )->pack( -side => 'left', -expand => 'no' );
    $slider->bindtags(
        [ $slider, ref $slider, $slider->toplevel, 'all' ] );
    $slider->bind( $slider, '<3>', sub { $slider->set(0); Tk->break; } );
    return;
}

sub prepare_gui {
    my ($tred_ref) = @_;

    my $top;
    if ($opt_W) {
        $top = Tk::MainWindow->new( -use => $opt_W );
    }
    else {
        $top = Tk::MainWindow->new();
    }
    Tk::MiscWorkarounds::apply_workarounds($top);
    $tred_ref->{top} = $top;

    $Treex::PML::IO::lwp_user_agent
        = TrEd::UserAgent->new( $top, keep_alive => 1 );

    set_default_widget_options($top);

    set_button_flashes($top);

    if ($TrEd::Convert::support_unicode) {
        $top->useinputmethods(1);
    }

    # sets up new stylesheet, resources, macor paths
    my $preparedExtensions = TrEd::Extensions::prepare_extensions($opt_m);

    TrEd::Stylesheet::load_stylesheets( $tred_ref );


    if ( $autoSave > 0 ) {
        $tred_ref->{autoSaveCallback} = $top->repeat( $autoSave * $MILISEC_PER_MIN,
            [ \&autoSaveAll, $tred_ref ] );
    }

    $tred_ref->{folderImage} = icon( $tred_ref, 'folder' );
    $tred_ref->{fileImage}   = icon( $tred_ref, 'document' );

    TrEd::Bookmarks::set_last_action($TrEd::Config::lastAction);

    $tred_ref->{selectedContext} = $init_macro_context || 'TredMacro';
    $tred_ref->{buildTGTSfromCSTS} = $opt_R;

    set_geometry($top);

    prepareFonts( $tred_ref );
    $tred_ref->{treeWindows}   = [];
    $tred_ref->{focusedWindow} = new_TrEd_Window( $tred_ref );
    my $canvas = $tred_ref->{focusedWindow}->canvas();
    $canvas->configure(@focused_win_opts);

    print STDERR "Main window created.\n" if $tredDebug;

    if ( -f $TrEd::Config::appIcon ) {
        print STDERR "adding icon-image.\n" if $tredDebug;
        $top->iconimage( $top->Pixmap( -file => "$TrEd::Config::appIcon" ) );
        print STDERR "done.\n" if $tredDebug;
    }

    #  $top->focusFollowsMouse;
    addBindTags( $top, 'my' );

    print STDERR "Asking wm for exit-hook.\n" if $tredDebug;

    $top->protocol( 'WM_DELETE_WINDOW' => [ \&quit, $tred_ref ] );

    print STDERR "Exit hook created.\n" if $tredDebug;

    $tred_ref->{Balloon} = $top->Balloon(
        -initwait        => $toolbarBalloonInitWait,
        -balloonposition => 'mouse',
        -state           => 'balloon',
    );
    $tred_ref->{Balloon}->Subwidget('message')
        ->configure( -foreground => $toolbarBalloonForeground );
    $tred_ref->{Balloon}
        ->Tk::Toplevel::configure( -background => $toolbarBalloonBackground );
    $tred_ref->{Toolbar} = $top->Frame;

    print STDERR "Creating menubar.\n" if $tredDebug;

    # make old calls work
    require Tk::Menu::Item;
    *Tk::Menu::Item::entryconfigure = sub {
        my ( $menu, $name, %args ) = @_;
        my $m = $menu->menu;
        $m->entryconfigure( $m->index($name), %args );
    };

    # We need to pack in an optionmenu, so we cannot use menubar on windows
    # and cannot use Toplevel->configure(-menu) on other systems
    my $main_menu = $tred_ref->{main_menu}
        = TrEd::Menu->new( _load_menus( $tred_ref ) );
    my $menubar;
    if ( $^O eq 'MSWin32' ) {
        $menubar = $tred_ref->{Menubar} = $tred_ref->{MenubarFrame}
            = $tred_ref->{main_menu}->create_menu_frame( $top, 'MENUBAR',
            { -relief => $menubarRelief } );
    }
    else {
        $tred_ref->{MenubarFrame} = $top->Frame();
        $menubar = $tred_ref->{Menubar}
            = $tred_ref->{main_menu}
            ->create_menubar( $tred_ref->{MenubarFrame}, 'MENUBAR',
            { -relief => $menubarRelief } );
        $menubar->pack(qw/-fill x -expand 1 -side left/);
    }
    $tred_ref->{MenubarFrame}->pack(qw/-fill x/);
    $menubar->bind( 'Tk::Menu', '<Tab>',       [ 'NextEntry', 1 ] );
    $menubar->bind( 'Tk::Menu', '<<LeftTab>>', [ 'NextEntry', -1 ] );
    $top->Frame(qw/-relief sunken -height 2 -borderwidth 2/)
        ->pack(qw/-fill x/);
    addBindTags( $menubar, 'my' );
    {
        my %map = (
            FileMenu                => 'MENUBAR:FILE',
            RecentFileMenu          => 'MENUBAR:FILE:RECENT',
            NodeMenu                => 'MENUBAR:NODE',
            NodeMenu                => 'MENUBAR:NODE',
            TreeMenu                => 'MENUBAR:TREE',
            ViewMenu                => 'MENUBAR:VIEW',
            ToolsMenu               => 'MENUBAR:MACROS',
            UserMenu                => 'MENUBAR:MACROS:ALL_MODES',
            CurrentContextMacroMenu => 'MENUBAR:MACROS:CURRENT_MODE',
            MinorModesMainMenu      => 'MENUBAR:VIEW:TOGGLE_MINOR_MODES',
            SetupMenu               => 'MENUBAR:SETUP',
            HelpMenu                => 'MENUBAR:HELP',
            SessionMenu             => 'MENUBAR:FILE:FILE_LISTS',
            BookmarkMenu            => 'MENUBAR:FILE:BOOKMARKS',
            PostponedFileMenu       => 'MENUBAR:FILE:KEPT_IN_MEMORY',
            BookmarksFileMenu => 'MENUBAR:FILE:BOOKMARKS:GO_TO_BOOKMARK',
        );
        my ( $k, $v ) = @_;    #TODO: ???? @_?!
        while ( ( $k, $v ) = each %map ) {
            $tred_ref->{$k} = $main_menu->lookup_menu_item($v);
        }
        my @recent_files = TrEd::RecentFiles::recent_files();
        populate_recent_files_menu( $tred_ref, \@recent_files );
    }

    $tred_ref->{templateMatchMethod} = $TrEd::Config::defaultTemplateMatchMethod;
    $tred_ref->{macroListOrder}      = $TrEd::Config::defaultMacroListOrder;

    if ( !exists $TrEd::Macros::keyBindings{ $tred_ref->{selectedContext} } ) {
        $tred_ref->{selectedContext} = 'TredMacro';
    }

    $tred_ref->{ContextsMenu}
        = TrEd::Menu::Context->new( $tred_ref->{MenubarFrame}, $tred_ref );
    $tred_ref->{ContextsMenuLabel} = $tred_ref->{MenubarFrame}->Label(
        -text      => 'Mode:',
        -font      => 'C_small',
        -underline => 1
    )->pack(qw/-side right/);
    $tred_ref->{Balloon}->attach( $tred_ref->{ContextsMenu}->get_menu(),
        -balloonmsg => "Annotation Mode" );

    addBindTags( $tred_ref->{Toolbar}, 'my' );

    TrEd::Bookmarks::update_bookmarks( $tred_ref );

    $tred_ref->{vLineFrame}     = $top->Frame();
    $tred_ref->{valueLine}      = TrEd::ValueLine->new( $tred_ref->{vLineFrame}, $tred_ref );
    $tred_ref->{vLineSeparator} = $top->Adjuster();

    my $bf = $tred_ref->{bottomFrame} = $top->Frame;
    if ($displayStatusLine) {
        my $sl = $tred_ref->{statusLine} = TrEd::StatusLine->new( $bf, $tred_ref );

    }

    create_minor_modes_menu($tred_ref, $bf);
    create_canvas_scale($tred_ref, $bf);

    create_toolbar_buttons( $tred_ref );

    create_stylesheet_menu( $tred_ref );

    $tred_ref->{UserToolbarSep}
        = $top->Frame(qw/-relief sunken -height 2 -borderwidth 2/);
    $tred_ref->{UserToolbars} = $top->Frame();
    addBindTags( $tred_ref->{UserToolbars}, 'my' );

    create_value_line_subframe( $tred_ref );

    $tred_ref->{bodyPane} = $top->Panedwindow();
    $tred_ref->{bottomFrame}->pack(qw/-pady 2 -side bottom -fill x -expand no/);
    $tred_ref->{bodyPane}->pack(qw/-fill both -expand yes/);
    $tred_ref->{windowFrame} = $tred_ref->{bodyPane}->Pane();
    $tred_ref->{bodyPane}->add( $tred_ref->{windowFrame} );

    $tred_ref->{focusedWindow}->frame_widget( $canvas, [], [qw/-side left/] )->pack(
        qw/-expand yes -fill both/,
        -in   => $tred_ref->{windowFrame},
        -side => 'right'
    );

    # frame canvas here

    #  $tred_ref->{sLineFrame}->pack(qw/-fill x -expand yes/);

    $tred_ref->{focusedWindow}->canvas->focus;
    return $preparedExtensions;
}

sub startMain {
    my $node;
    my $parent;
    my %tred
        ; # gathers TrEd window global data, also referred to as $grp, the 'frame group'
          # since we thought that in the future we'll support multiple windows
          # and windows are called frames in the emacs terminlology
    my $preparedExtensions = prepare_gui(\%tred);
    my $top = $tred{top};
    my $menubar = $tred{Menubar};

    print STDERR "GUI prepared.\n" if $tredDebug;
    $top->update;

    $preparedExtensions = load_extensions(\%tred, $preparedExtensions);

    doEvalHook( $tred{focusedWindow}, "initialize_bindings_hook" );

    TrEd::Menu::Macro::update_macro_menus( \%tred );
    TrEd::MinorModes::update_minor_modes( \%tred );
    $tred{StylesheetMenu}->update( \%tred );
    updatePostponed( \%tred );
    updateHelpMenu( \%tred, { preparedExtensions => $preparedExtensions } );

    my $hook_result = doEvalHook( $tred{focusedWindow}, "init_hook" );
    if ( defined $hook_result && $hook_result eq 'stop' ) {
        $top->Unbusy;
        print STDERR "Stopped by init_hook\n";
        exit_tred();
    }

    # STYLESHEET_FROM_FILE is from TrEd::Stylesheet
    my $stylesheet = $opt_s || STYLESHEET_FROM_FILE();
    $tred{selectedStylesheet} = $stylesheet;
    $tred{focusedWindow}->apply_stylesheet($stylesheet);

    toggleSidePanel( \%tred );
    if ($opt_split_window) {
        my $dir = $opt_split_window > 0 ? 'vert' : 'horiz';
        for ( my $i = 1; $i < abs($opt_split_window); $i++ ) {
            splitWindow( \%tred, $dir );
        }
        focusCanvas( $tred{treeWindows}->[0]->canvas, \%tred );
    }

    set_up_signal_handling(\%tred);

    if (   TrEd::ManageFilelists::find_filelist('Default')->count == 0
        && TrEd::ManageFilelists::find_filelist('CmdLine-1') )
    {
        print STDERR "Selecting CmdLine-1 filelist." if $tredDebug;
        TrEd::ManageFilelists::selectFilelist( \%tred, 'CmdLine-1' );
    }
    else {
        print STDERR "Selecting Default filelist." if $tredDebug;
        TrEd::ManageFilelists::selectFilelist( \%tred, 'Default' );
    }

    if ($opt_split_window) {
        create_split_windows( $opt_split_window, $opt_filelist, \%tred );

    }

    # by default TrEd adds files to default filelist
    $tred{append_files_to_default_fl} = 1;

    # run start_hook
    $hook_result = doEvalHook( $tred{focusedWindow}, "start_hook" );
    if ( defined $hook_result && $hook_result eq 'stop' ) {
        $top->Unbusy;
        print STDERR "Stopped by start_hook\n";
        exit_tred();
    }

    # Starting ------------------------------------------
    $top->Unbusy;
    $top->focus if ( $^O eq 'MSWin32' );
    if ( defined $opt_e and length $opt_e ) {
        my $macro = eval "package $tred{selectedContext}; sub{ $opt_e }";
        die $@ if $@;
        doEvalMacro( $tred{focusedWindow}, $macro );
    }

    set_up_menubindigs(\%tred, $menubar);

    # this can not be moved up above loading macros because then
    # some bindings won't work... (don't ask me why)
    $tred{default_binding} = TrEd::Binding::Default->new( \%tred );
    $tred{default_binding}->setup_default_bindings();

    # New Busy window bindings
    $top->Tk::bind( 'Busy', '<Escape>', [ \&_search_busy, \%tred ] );
    $top->Tk::bind( 'Busy', '<Any-KeyPress>', [ \&Tk::Widget::_busy => 1 ] );
    $top->Tk::bind( 'Busy', '<Any-KeyRelease>',
        [ \&Tk::Widget::_busy => 0 ] );
    $top->Tk::bind( 'Busy', '<Any-ButtonPress>',
        [ \&Tk::Widget::_busy => 1 ] );
    $top->Tk::bind( 'Busy', '<Any-ButtonRelease>',
        [ \&Tk::Widget::_busy => 0 ] );
    $top->Tk::bind( 'Busy', '<Any-Motion>', [ \&Tk::Widget::_busy => 0 ] );
    $top->bind( 'Tk::Listbox', '<KeyPress>', \&list_isearch );

    print STDERR "done.\nStarting main loop.\n" if $tredDebug;
    print STDERR "Ready.\n" unless $opt_q;
    $SIG{USR2} = sub {
        $tred{top}->afterIdle( [ \&handleUSR2Signal, \%tred ] );
    };


    MainLoop;
    if ( $tred{top} ) {
        TrEd::Config::save_runtime_config( \%tred );
    }

    # Finished ------------------------------------------
    $top = undef;
    $tred{top} = undef;
    print STDERR "Done.\n" if $tredDebug;
    return;
}

# SIGUSR2 (afterIdle) signal handler:
# we use SIGUSR2 to notify TrEd about
# an incomming command (tred -C)
#
sub handleUSR2Signal {
    my ($grp) = @_;
    my $cmd_file = File::Spec->catfile( $tred_d, 'cmd_' . $$ );
    if ( -f $cmd_file ) {
        if ( ( ( stat($cmd_file) )[2] & oct(22) ) == 0 ) {
            open my $fh, '<', $cmd_file || return;
            my $cmd = <$fh>;
            unlink $cmd_file || warn("WARN: Failed to unlink $cmd_file\n");
            my @cmd = split( "\0", $cmd );
            if ( ( $cmd[0] || '' ) eq 'open' and @cmd == 2 ) {
                TrEd::File::open_standalone_file( $grp, $cmd[1] );
                return;
            }
            elsif ( ( $cmd[0] || '' ) eq 'reload' and @cmd == 2 ) {

                #TODO: toto extraktovat do TrEd::File?
                TrEd::File::reload_on_usr2( $grp, $cmd[1] );
                return;
            }
            else {
                warn("WARN: Ignoring unknown command from $cmd_file\n");
            }
        }
        else {
            warn(
                "WARN: Ignoring command from $cmd_file: dangerous file permissions!\n"
            );
        }
    }
    return;
    #plainErrorMessage($grp,"USR2 Signal Caught");
}

#sub newUserToolbar

#TODO: sounds like a fn from TrEd::Window::TreeBasics..?!
sub makeCurrentNodeRoot {
    my ($grp)  = @_;
    my $win    = $grp->{focusedWindow};
    my $node   = $win->{currentNode};
    my $fsfile = $win->{FSFile};
    return unless $fsfile and $node;
    return
        unless (
        $fsfile->test_tree_type($node)
        or TrEd::Query::User::new_query(
            $win, "WARNING:\n\n"
                . "The type of the current node is not a permitted root type.\n\n"
                . "The options are:\n\n"
                . "[Proceed anyway] - ignore the type constraints (the tree will be invalid, but may be fixed later)\n"
                . "[Cancel] - cancel the operation\n",
            -bitmap  => 'question',
            -title   => 'Incompatible node type',
            -buttons => [ 'Proceed anyway', 'Cancel' ]
        ) eq 'Proceed anyway'
        );
    my $discard = 0;
    my $root    = $node->root;
    return if $root == $node;

    if ( !$node->test_child_type($root) ) {
        my $res = TrEd::Query::User::new_query(
            $win, "WARNING:\n\n"
                . "Normally, this operation cuts the subtree of the current node,\n"
                . "makes the current node a new root of the tree and\n"
                . "pastes the old root on the current node.\n\n"
                . "However, the type constraints of the current node do not permit the current root "
                . "as its a child.\nThe resulting tree would be invalid.\n\nThe options are:\n\n"
                . "[Paste anyway] - ignore the type constraints (the tree will be invalid, but may be fixed later)\n"
                . "[Discard root] - discards every node between the current root and the current node\n"
                . "[Cancel] - cancel the operation\n",
            -bitmap  => 'question',
            -title   => 'Incompatible node type',
            -buttons => [ 'Paste anyway', 'Discard root', 'Cancel' ]
        );
        return if $res eq 'Cancel';
        if ($res =~ /Discard/) {
            $discard = 1;
        }
    }
    print STDERR "undo_type_id = |"
        . TrEd::Undo::undo_type_id('UNDO_ACTIVE_ROOT_AND_TREE_ORDER') . "|\n";
    TrEd::Undo::save_undo(
        $win,
        TrEd::Undo::prepare_undo(
            $win,
            'Make Current Node the Root',
            TrEd::Undo::undo_type_id('UNDO_ACTIVE_ROOT_AND_TREE_ORDER')
        )
    );
    return TrEd::Window::TreeBasics::make_root( $win, $node, $discard );
}

sub quit {
    my ( $grp, $win ) = grp_win(shift);

    # run user's exit_hook
    doEvalHook( $win, "exit_hook" );
    return if TrEd::File::ask_save_files_and_close( $grp, 1 ) == -1;
    TrEd::Config::save_runtime_config($grp);
    $grp->{top}->destroy;
    $grp->{top} = undef;
    return;
}

sub _do_goto_tree {
    my $win = shift;
    my $no  = $win->{treeNo};
    $win->{treeNo} = -1;    # this is to force getNodes & redraw
    TrEd::Window::TreeBasics::go_to_tree( $win, $no );
    $win->{framegroup}->{IdleTask} = undef;
    return;
}

# hook
sub onIdleNextTree {
    my ( $grp, $win ) = grp_win(shift);
    return unless $win->{FSFile};
    $win->toplevel->afterCancel( $grp->{IdleTask} ) if ( $grp->{IdleTask} );
    my $last = $win->{FSFile}->lastTreeNo;
    if ( $win->{treeNo} < $last ) {
        $win->{treeNo} = max2( 0, $win->{treeNo} + 1 );
        update_tree_pos($grp);
        $grp->{vLineNumLabel}->idletasks();
        $grp->{IdleTask}
            = $win->toplevel->afterIdle( [ \&_do_goto_tree, $win ] );
    }
    Tk->break;
    return;
}

# hook
sub onIdlePrevTree {
    my ( $grp, $win ) = grp_win(shift);
    return unless $win->{FSFile};
    if ( $win->{treeNo} > 0 ) {
        $win->toplevel->afterCancel( $grp->{IdleTask} )
            if ( $grp->{IdleTask} );
        $win->{treeNo}--;
        update_tree_pos($grp);
        $grp->{vLineNumLabel}->idletasks();
        $grp->{IdleTask}
            = $win->toplevel->afterIdle( [ \&_do_goto_tree, $win ] );
    }
    Tk->break;
    return;
}

# wrapper for vallex and remote control
sub ShowDialog {
    return TrEd::Dialog::FocusFix::show_dialog(@_);
}

# wrapper for vallex and remote control
sub RepeatedShowDialog {
    return TrEd::Dialog::FocusFix::repeated_show_dialog(@_);
}

# file, template
#TODO: consider moving to TrEd::File
sub newFileFromTemplate {
    my ($grp) = @_;
    my @templates;
    my $extensions = TrEd::Extensions::get_extension_list();
    foreach my $ext (@$extensions) {
        my ($dir) = get_extension_template_paths( [$ext] );
        if ( defined($dir) ) {
            push @templates, map { [ $ext, $_ ] }
                             grep { !/~$|\.lock$/ }
                             glob( File::Spec->catfile( $dir, '*' ) );
        }
    }
    if ( !@templates ) {
        TrEd::Query::User::new_query(
            $grp->{top},
            "Sorry, the available extensions provide no templates.",
            -title   => "New from templates",
            -buttons => ["OK"]
        );
        return;
    }
    my $choices = [ map { filename( $_->[1] ) . " ($_->[0])" } @templates ];
    my $ret = TrEd::Query::List::new_query(
        $grp->{top}, 'Select a template',
        'browse', $choices, [ $choices->[0] ],
    );
    if ( ref($ret) and @$ret ) {
        return TrEd::File::open_standalone_file(
            $grp,
            $templates[ $ret->[0] ][1],
            -justheader => 1
        );
    }
    return;
}

# sub fileDialog
# sub urlDialog

# sub ask_save_references
# sub save_file_as
# sub do_save_file_as

# sub renameFileInFilelist

# sub close_all_files

# sub askSaveFile

# sub editConfig

# UI
# sub QueryString
# wrapper for PADT, PDT10, PDT15_obsolete
sub QueryString {
    return TrEd::Query::String::new_query(@_);
}

#
sub Query {
    return TrEd::Query::Simple::new_query(@_);
}

# sub listQuery
# wrapper for pdt15_obsolete,
# extensions should use TredMacro::ListQuery instead anyway..
sub listQuery {
    return TrEd::Query::List::new_query(@_);
}

# context
sub autoSelectContext {
    my ($grp) = @_;
    my ($win) = $grp->{focusedWindow};
    if ( $win->{FSFile} ) {
        my $prevcontext = $win->{macroContext};
        $win->{macroContext} = 'TredMacro';
        doEvalHook( $win, "guess_context_hook", "file_resumed_hook" );
        if (    $win->{macroContext} eq 'TredMacro'
            and $prevcontext ne 'TredMacro' )
        {
            $win->{macroContext} = $prevcontext;
            switchContext( $win, 'TredMacro' );
        }
        else {
            $win->get_nodes();    # the hook may have changed something
            $win->redraw();
            centerTo( $win, $win->{currentNode} );
        }
    }
    else {
        switchContext( $win, 'TredMacro' );
    }
    return;
}

# context
#######################################################################################
# Usage         : get_allowed_contexts($win)
# Purpose       : Get allowed contexts for Window $win
# Returns       : List of allowed context names
# Parameters    : TrEd::Window ref $win -- ref to examined TrEd::Window object
# Throws        : No exception
# Comments      : Runs allow_switch_context_hook.
# See Also      : selectContext(), autoSelectContext()
sub get_allowed_contexts {
    my ($win)        = @_;
    my $prevcontext  = $win->{macroContext};
    my @all_contexts = TrEd::Macros::get_contexts();
    my @ret          = grep {
        (   doEvalHook(
                $win,         "allow_switch_context_hook",
                $prevcontext, $win->{macroContext} = $_
                )
                || ''
            ) ne 'stop'
    } @all_contexts;
    $win->{macroContext} = $prevcontext;
    return @ret;
}

# context
sub selectContext {
    my ($grp)     = @_;
    my $win       = $grp->{focusedWindow};
    my $selection = [ $win->{macroContext} ];
    TrEd::Query::List::new_query( $grp->{top}, 'Select Mode', 'browse',
        [ get_allowed_contexts($win) ], $selection )
        || return;
    if (@{$selection}) {
        switchContext( $grp->{focusedWindow}, $selection->[0] );
    }
    return;
}

# stylesheet
sub selectStylesheet {
    my ($grp_or_win) = @_;
    my $grp          = cast_to_grp($grp_or_win);
    my $win          = cast_to_grp($grp_or_win);
    my $selection    = [ $grp->{selectedStylesheet} ];
    TrEd::Query::List::new_query( $grp->{top}, 'Select Mode', 'browse',
        $grp->{StylesheetMenu}->get_menu_list($grp), $selection )
        || return;
    if (@{$selection}) {
        $grp->{selectedStylesheet} = $selection->[0];
        switchStylesheet( $grp, $selection->[0] );
    }
    return;
}

# stylesheet
# was stylesheetUsingWindows
sub windows_using_stylesheet {
    my ( $grp, $stylesheet ) = @_;
    return grep { $_->{stylesheet} eq $stylesheet } @{ $grp->{treeWindows} };
}

# sub deleteStylesheet

# sub selectValuesDialog
# wrapper for pdt15_obsolete extension
sub selectValuesDialog {
    return TrEd::Dialog::SelectValues::show_dialog(@_);
}

# sentence view
#sub reloadSentenceView
#sub sentViewSelectAll
#sub sentViewSelectNone
#sub sentViewGetSelection
#sub sentViewToggleCollapse
#sub viewSentences
#sub viewSentencesDialog
#sub dumpSentView
#sub populateSentencesDialog

# list attr
sub editListAttr {
    my ( $win, $value, $attr, $d, $node ) = @_;
    return unless $win->{FSFile};
    my @vals = map { encode($_) } $win->{FSFile}->FS->listValues($attr);
    if ($sortAttrValues) {
        my @v = @vals;
        if ( doEvalHook( $win, "sort_attr_values_hook", \@v, $attr, $node ) )
        {
            @vals = @v;
        }
        else {
            @vals = sort @vals;
        }
    }

    #print "splitting ",$value{$attr},"\n";
    my @selected = map { encode($_) } split /\|/, $value;

    #print "splitted to ", join ('-',@selected),"\n";

    if (TrEd::Dialog::SelectValues::show_dialog(
            $win->{framegroup}, $attr, \@vals, \@selected, 0, $d
        )
        )
    {
        return decode( join( '|', @selected ) );
    }
    return;
}

sub editAmbiguousAttr {
    my ( $win, $value, $attr ) = @_;
    my @vals = map { encode($_) } split /\|/, $value;
    my @selected = @vals;

    if (TrEd::Dialog::SelectValues::show_dialog(
            $win->{framegroup}, $attr, \@vals,
            \@selected,         1,     $win->toplevel
        )
        )
    {
        return decode( join( '|', @selected ) );
    }
    return;
}

sub focusxEditDn {
    my ( $w, $i, $e, $f, $atord ) = @_;
    if ( $i + 1 < @$atord ) {
        $f->see( $e->{ $atord->[ $i + 1 ] } );
        $e->{ $atord->[ $i + 1 ] }->focus;
    }
    Tk->break;
    return;
}

sub focusxEditUp {
    my ( $w, $i, $e, $f, $atord ) = @_;
    if ( $i > 0 ) {
        $f->see( $e->{ $atord->[ $i - 1 ] } );
        $e->{ $atord->[ $i - 1 ] }->focus;
    }
    Tk->break;
    return;
}

sub focusxFind {
    my ( $w, $i, $e, $f, $atord ) = @_;
    my $ev = $w->XEvent;
    my $A  = $ev->A;
    if ( $A ne EMPTY ) {
        my $count = scalar(@$atord);
        for ( my $j = $i + 1; $j <= $i + $count; $j++ ) {
            if ( ( $atord->[ $j % $count ] ) =~ /^\Q$A\E/i ) {
                $f->see( $e->{ $atord->[ $j % $count ] } );
                $e->{ $atord->[ $j % $count ] }->focus();
                Tk->break;
                return;
            }
        }
    }
    return;
}

# node
sub determineNodeType {
    my ( $win, $node ) = @_;
    return unless $node;
    my $type = $node->type;
    return $type if $type;
    doEvalHook( $win, 'determine_node_type_hook', $node );
    $type = $node->type;
    return $type if $type;
    __debug("Determining node type for $node\n");
    eval {
        $win->{FSFile}->determine_node_type(
            $node => {
                choose_command => sub {
                    my ( undef, undef, $ntypes ) = @_;
                    my $i = 1;
                    my @types = map { ( $i++ ) . " " . ( $_->[0] ) } @$ntypes;
                    my $selection = [ $types[0] ];
                    my $top       = $win->toplevel;
                    my ($highest) = reverse $top->stackorder();
                    $top = $top->Widget($highest);
                    TrEd::Query::List::new_query( $top,
                        'Untyped node: select node-type',
                        'browse', \@types, $selection )
                        || return;
                    return @$ntypes[ $1 - 1 ] if $selection->[0] =~ /^(\d+) /;
                    return;
                    }
            }
        );
    };
    plainErrorMessage( $win, $@ ) if $@;
    return $node->type;
}

#sub editFilePropertiesDialog

# sub editAttrsDialog_schema

#sub editAttrsDialog
# wrapper for ElixirFM
sub editAttrsDialog {
    return TrEd::Dialog::EditAttributes::show_dialog(@_);
}

sub disable_scrollbar_focus {
    my ($scrolled) = @_;
    $scrolled->Subwidget('xscrollbar')->configure(qw(-takefocus 0));
    $scrolled->Subwidget('yscrollbar')->configure(qw(-takefocus 0));
    return;
}

# macros, UI
sub showMacrosAsHtml {
    my ( $grp, $flags, $order_by ) = @_;
    my $context = $grp->{selectedContext};
    use File::Temp;
    my $dir = File::Temp::tempdir( CLEANUP => 1 );
    eval {
        Treex::PML::IO::copy_uri(
            File::Spec->catfile( $libDir, 'misc', 'sorttable.js' ),
            File::Spec->catfile( $dir,    'sorttable.js' )
        );
    };
    warn $@ if $@;
    my $html_file = File::Spec->catfile( $dir, "$context.html" );
    open( my $html, '>:encoding(utf8)', $html_file )
        or do {
        TrEd::Error::Message::error_message( $grp->{top},
            "Cannot open temporary file $html_file." );
        return 0;
        };
    my $title = "Annotation Mode $context";
    $title .= " + TredMacro" if ( $flags & 2 );
    print $html "<html>\n";
    print $html "<head>\n";
    print $html "  <title>$title</title>\n";
    print $html
        "  <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\" />\n";
    print $html "<script src=\"sorttable.js\"></script>\n";
    print $html "</head>\n";
    print $html "<body>\n";
    print $html "<h2>TrEd Macro Reference</h2>\n";
    print $html "<h3>$title</h3>\n";
    print $html "<table class=\"sortable\" preserve_style=\"row\">\n";
    print $html "<thead><tr><th>Keyboard Shortcut</th>";
    print $html "<th>Perl Function</th>" if ( $flags & 1 );
    print $html "<th>Description</th></tr></thead>\n";
    print $html "<tbody>\n";
    my $odd = 0;

    foreach my $entry (
        TrEd::List::Macros::sorted_macro_table(
            $grp, $context, $flags, $order_by || 'N'
        )
        )
    {
        my ( $name, $key, $macro ) = @$entry;
        $name =~ s/^_+//;
        print $html "  <tr ",
            ( $odd ? 'bgcolor="#ffffff"' : 'bgcolor="#eeeeee"' ),
            ">\n    <td>$key</td>\n",
            ( ( $flags & 1 ) ? "<td>$macro</td>\n" : EMPTY ),
            "<td>$name</td>\n",
            "  </tr>\n";
        $odd = !$odd;
    }
    print $html "</tbody>\n";
    print $html "</table>\n";
    print $html "</body>\n";
    print $html "</html>\n";
    close($html);
    return open_url_in_browser($html_file);
}

sub help_topic {
    my ( $top, $section ) = @_;
    my $file = $TrEd::Help::HELP_MAP{$section};
    if ( defined $file ) {
        open_url_in_browser( $documentation_dir . '/' . $file . "#" . $section );
    }
    else {
        plainErrorMessage( $top,
            "Cannot map '$section' to a documentation page." );
    }
    return;
}

sub open_url_in_browser {
    my $url = shift;
    if ( $htmlBrowser eq 'DO_NOT_RUN' ) {
    }
    elsif ( $^O eq 'MSWin32' )
    {
        $url =~ s{^file:[/]*([^/])}{file:///$1};
        $url =~ s{[ ]}{%20}g;
        my $cmd = "start /B $url";
        print STDERR "$cmd\n" if $tredDebug;
        return system($cmd);
    }
    elsif ( $htmlBrowser ne EMPTY ) {
        $htmlBrowser .= " %u" unless ( $htmlBrowser =~ /\%[uf1]/ );
        my $cmd = $htmlBrowser;
        $cmd =~ s/\%1/$url/g;
        $cmd =~ s/\%[fu]\b/"$url"/g;
        print STDERR "$cmd\n" if $tredDebug;
        return system $cmd. ' &';
    }
    else {
        if ( $^O eq 'darwin' ) {
            $htmlBrowser = 'open %u';
        }
        elsif ( $ENV{DESKTOP_LAUNCH} ne EMPTY ) {
            $htmlBrowser = $ENV{DESKTOP_LAUNCH};
        }
        elsif ( which('xdg-open') ne EMPTY ) {
            $htmlBrowser = 'xdg-open %u';
        }

        # Otherwise we emulate xdg-open
        # detect KDE
        elsif ( $ENV{KDE_FULL_SESSION} eq "true" ) {
            if ( which('kde-open') ne EMPTY ) {
                $htmlBrowser = 'kde-open %u';
            }
            else {
                $htmlBrowser = 'kfmclient openURL %u';
            }
        }    # detect GNOME
        elsif ( $ENV{GNOME_DESKTOP_SESSION_ID} ne EMPTY
            and which('gnome-open') ne EMPTY )
        {
            $htmlBrowser = 'gnome-open %u';
        }    # generic
        elsif ( $ENV{BROWSER} ne EMPTY and which( $ENV{BROWSER} ) ne EMPTY ) {
            $htmlBrowser = $ENV{BROWSER};
        }
        elsif ( $htmlBrowser = TrEd::MinMax::first { which($_) ne EMPTY }
                                qw(firefox mozilla netscape opera htmlview chromium chromium-browser) )
        {

            # already assigned
        }
        else {
            warn
                "Did not find any HTML browser.\nPlease set the 'htmlbrowser' configuration option or either of DESKTOP_LAUNCH or BROWSER environment variables.";
            $htmlBrowser = 'DO_NOT_RUN';
            return;
        }
        return open_url_in_browser($url);
    }
}

#sub tred_pod_add_tags
#sub _sytylesheetInsertAttr
#sub editStylesheetDialog
#sub format_tred_pod

#####################################################
#####################################################
#####################################################
# Node searching
#####################################################

#sub findNodeDialog

#####################################
# bound to Escape for busy widgets
#####################################
sub _search_busy {
    my ( $w, $grp, $no_break ) = @_;
    print STDERR $grp->{focusedWindow}->{currentFileNo} . "stopped by user\n"
        if ($tredDebug);
    $grp->{stopSearch} = 1;
    if (!$no_break) {
        Tk->break;
    }
    return;
}

#####################################
# called after file open to process
# event queue and let user interrupt
# the search process
#####################################
sub _quick_update {
    my ( $grp, $no_idle ) = @_;
    my $g   = $grp->{searchGrabWindow};
    my $now = time;                       #once in a second
    return unless ( $now - $grp->{searchGrabWindow_last} >= 1 );
    $grp->{searchGrabWindow_last} = $now;

    my $win     = $grp->{focusedWindow};
    my $f       = $win->{FSFile};
    my $current = $win->{currentFileNo} + 1;
    my $all     = $win->{currentFilelist}->file_count();
    my $fn      = $f && filename( $f->filename() );
    $grp->{searchGrabWindow_status} = "File '$fn'     ( $current / $all )";
    if ( $grp->{searchGrabWindow_active} == 1 ) {
        $grp->{searchGrabWindow_active} = 2;
        $grp->{searchGrabWindow_last}   = 0;
        $grp->{top}->Unbusy();
        $g->Popup;
        Tk::catch {
            $g->grab;
        };
        my ($b) = grep { ref($_) =~ /Button/ } $g->children;
        $b->focusForce if $b;
        $g->update();
    }
    elsif ( $grp->{searchGrabWindow_active} == 2 ) {
        $g->update();
    }
    return;
}

sub _createSearchGrabWindow {
    my ($grp) = @_;
    $grp->{top}->Busy( -recurse => 1 );
    if ( $grp->{searchFilelist} ) {
        $grp->{searchGrabWindow_status} = '';
        my $g;
        unless ( $grp->{searchGrabWindow} ) {
            $g = $grp->{top}->Toplevel( -title => "Search" );
            $g->withdraw();
            $g->Label( -text => "Search in progress...", -width => '40' )
                ->pack( -pady => 10, -padx => 10 );
            $g->Label(
                -justify      => 'left',
                -anchor       => 'nw',
                -textvariable => \$grp->{searchGrabWindow_status}
            )->pack( -pady => 5, -padx => 10, -fill => 'x' );
            $g->Button(
                -text    => 'Interrupt',
                -command => [ \&_search_busy, $g, $grp ]
            )->pack( -pady => 5, -padx => 10 );
            $g->protocol(
                'WM_DELETE_WINDOW' => [ \&_search_busy, $g, $grp, 0 ] );
            $g->transient( $grp->{top} );
            $grp->{searchGrabWindow} = $g;
        }
        $grp->{searchGrabWindow_time}   = 0;
        $grp->{searchGrabWindow_active} = 1;
    }
    return;
}

sub _closeSearchGrabWindow {
    my ($grp) = @_;
    if ( $grp->{searchGrabWindow_active} == 2 ) {
        $grp->{searchGrabWindow_active} = undef;
        $grp->{searchGrabWindow_status} = undef;
        my $g = $grp->{searchGrabWindow};
        Tk::catch {
            $g->grabRelease;
        };
        $g->withdraw;
    }
    $grp->{top}->Unbusy();
    return;
}

######################################
# start searching for a next node
# and display result unless succeeded
######################################

sub findTemplated {
    my ( $grp, $cont, $callback ) = @_;
    my $win = $grp->{focusedWindow};
    return if ( !$win->{currentNode} );

    my %save = (
        init_macro_context     => $init_macro_context,
        no_redraw              => $win->{noRedraw},
        no_update_title        => $grp->{noUpdateTitle},
        no_update_postponed    => $grp->{noUpdatePostponed},
        no_recent              => $grp->{noRecent},
        no_upd_stylesheet_menu => $grp->{StylesheetMenu}->dont_update(),
        no_upd_macrolist_view  => $grp->{noUpdateMacrolistView},
        no_save_filestate_upd  => $grp->{noSaveFileStateUpdate}
    );
    (   $init_macro_context,   $win->{noRedraw},
        $grp->{noUpdateTitle}, $grp->{noUpdatePostponed},
        $grp->{noRecent},      $grp->{noUpdateMacrolistView},
        $grp->{noSaveFileStateUpdate}
    ) = ( $win->{macroContext}, 1, 1, 1, 1, 1, 1 );
    $grp->{StylesheetMenu}->set_dont_update(1);

    _createSearchGrabWindow($grp);
    my $result;
    if ( !$no_secondary && !$grp->{searchAlwaysSecondary}
         && $grp->{searchFilelist} )
    {

        # avoid opening secondary files
        # during search
        my $first_file_no = $win->{currentFileNo};
        $no_secondary = 1;
        my @locks = ( $noCheckLocks, $lockFiles );
        $TrEd::Config::noCheckLocks = 1;
        $lockFiles = 0;

        eval { $result = $callback->( $grp, $cont ) };
        $no_secondary = 0;
        ( $TrEd::Config::noCheckLocks, $lockFiles ) = @locks;
        die $@ if $@;

        my $fsfile = $win->{FSFile};
        if ( $win->{currentFileNo} != $first_file_no ) {
            TrEd::FileLock::lock_open_file( $win, $fsfile );

            # if the initial file and the current file
            # are different, open the secondary files now
            my $status
                = TrEd::File::open_secondary_files( $win, $fsfile, undef );
            unless ( $status->{ok} ) {
                $win->toplevel->ErrorReport(
                    -title => "Error: open failed",
                    -message =>
                        "A secondary file '$status->{filename}' is unreadable, empty, corrupted, or does not exist!"
                        . "\nPossible problem was:",
                    -body => $status->{report},
                );
            }
        }
    }
    else {
        $result = $callback->( $grp, $cont );
    }
    _closeSearchGrabWindow($grp);
    $init_macro_context       = $save{init_macro_context};
    $win->{noRedraw}          = $save{no_redraw};
    $grp->{noUpdateTitle}     = $save{no_update_title};
    $grp->{noUpdatePostponed} = $save{no_update_postponed};
    $grp->{noRecent}          = $save{no_recent};
    $grp->{StylesheetMenu}->set_dont_update( $save{no_upd_stylesheet_menu} );
    $grp->{noUpdateMacrolistView} = $save{no_upd_macrolist_view};
    $grp->{noSaveFileStateUpdate} = $save{no_save_filestate_upd};

    $win->get_nodes();
    $win->redraw();
    update_title_and_buttons($grp);
    updatePostponed($grp);

    $grp->{StylesheetMenu}->update($grp);

    TrEd::List::Macros::update_view($grp);
    saveFileStateUpdate($win);
    unless ($result) {

        #    $win->redraw();
        $grp->{top}->toplevel->messageBox(
            -icon    => 'warning',
            -message => $grp->{stopSearch}
            ? "Interrupted by user!"
            : "No matching node found!",
            -title   => 'Find',
            -default => 'Ok',
            -type    => 'ok'
        );
        $grp->{top}->focusForce;
    }
    return $result;
}

######################################
# start searching for a prev node
# and display result unless succeeded
######################################
sub doFindFirstTemplated {
    my ( $grp, $cont ) = @_;
    return findTemplated( $grp, $cont, \&findFirstTemplated );
}

sub doFindPrevTemplated {
    my ( $grp, $cont ) = @_;
    return findTemplated( $grp, $cont, \&findPrevTemplated );
}

######################################
# compare nodes with template
######################################
sub cmpTemplateField {
    my ( $grp, $val, $templ ) = @_;
    my $method = substr( $grp->{templateMatchMethod}, 0, 1 );
    return ( ( $val =~ /^$templ$/ ) ? 1 : 0 ) if ( $method eq 'E' );
    return ( ( $val =~ /$templ/ )   ? 1 : 0 ) if ( $method eq 'R' );
    return ( ( $val eq $templ ) ? 1 : 0 ) if ( $method eq 'L' );
    if ( $method eq 'W' ) {
        $templ =~ s/([\[\].^$(){}<>\\])/\\$1/g;
        $templ =~ s/\*/.\*/g;
        $templ =~ s/\?/./g;
        return ( ( $val =~ /^$templ$/ ) ? 1 : 0 );
    }
    return ( ( $val eq $templ ) ? 1 : 0 );
}

######################################
# go to next node in searchlist
######################################
sub nextNodeInSearchFilelist {
    my ( $grp, $node, $tree ) = @_;
    my $win          = $grp->{focusedWindow};
    my $haveSearchFL = defined( $grp->{searchFilelist} );
    my $traverse     = $haveSearchFL
        ? $grp->{searchFilelistTraverse} || 'all'
        : 'all';

    if ( $traverse ne 'node' ) {
        $node = HNext( $win, $node );
        unless ($node) {
            $node
                = $traverse eq 'all'
                ? $win->{FSFile}->treeList->[ ( ++$$tree ) ]
                : undef;
        }
        return $node if $node || !$haveSearchFL;
    }

    # this realises filelist search
    local $insideEval = 1;
    my $result = TrEd::Filelist::Navigation::next_or_prev_file( $grp, 1, 1,
        $traverse eq 'all' ? 1 : 0 );
    _quick_update($grp);

    # wait for Escape
    while ( !$grp->{stopSearch} && $result && !$win->{currentNode} ) {
        $result = TrEd::Filelist::Navigation::next_or_prev_file( $grp, 1, 1,
            $traverse eq 'all' ? 1 : 0 );

        # wait for Escape
        _quick_update($grp);
    }

    if ( $result and !$grp->{stopSearch} ) {
        if ( $traverse eq 'all' ) {
            $win->{currentNode} = $win->{FSFile}->treeList->[0];
            $$tree = 0;
        }
        elsif ( $traverse eq 'tree' ) {
            $win->{currentNode} = $win->{root};
            $$tree = $win->{treeNo};
        }
        elsif ( $traverse eq 'node' ) {
            $$tree = $win->{treeNo};
        }
        $win->{treeNo} = -1;    # to force redraw in go_to_tree
        return $win->{currentNode};
    }
    else {

 #$win->{treeNo} = -1 if ($traverse eq 'all'); # to force redraw in go_to_tree
        return;
    }
}
######################################
# find next matching node
######################################
sub findFirstTemplated {
    my ( $grp, $skipfirst ) = @_;

    my $win = $grp->{focusedWindow};
    return unless $win->{FSFile};
    my $search_code = $grp->{searchCode};
    return unless ref($search_code);

    my $node = $win->{currentNode};
    my $tree = $win->{treeNo};
    my $a;
    $grp->{stopSearch} = 0;

    $node = nextNodeInSearchFilelist( $grp, $node, \$tree ) if ($skipfirst);
    while ($node) {
        if ( $search_code->($node) ) {
            TrEd::Window::TreeBasics::go_to_tree( $win, $tree );
            TrEd::Window::TreeBasics::set_current( $win, $node );
            centerTo( $win, $node );
            return $node;
        }
    }
    continue {
        $node = nextNodeInSearchFilelist( $grp, $node, \$tree );
    }
    return;
}

######################################
# go to the last node of a tree
######################################
sub lastSubtreeNode {
    my ($top) = @_;
    return if !$top;
    while ( $top->firstson ) {
        $top = $top->firstson;
        $top = $top->rbrother while ( $top->rbrother );
    }
    return $top;
}

######################################
# go to previous node in search list
######################################
sub prevNodeInSearchFilelist {
    my ( $grp, $node, $tree ) = @_;
    my $win          = $grp->{focusedWindow};
    my $haveSearchFL = defined( $grp->{searchFilelist} );
    my $traverse     = $haveSearchFL
        ? $grp->{searchFilelistTraverse} || 'all'
        : 'all';

    if ( $traverse ne 'node' ) {
        $node = HPrev( $win, $node );
        if ( !$node && $$tree != 0 && $traverse eq 'all' ) {
            $node = lastSubtreeNode(
                $win->{FSFile}->treeList->[ ( --$$tree ) ] );
            $node = HPrev( $win, $node ) unless ( isShown( $win, $node ) );
        }
        return $node if $node || !$haveSearchFL;
    }

    # this realises filelist search
    local $insideEval = 1;
    my $no_redraw = $win->{noRedraw};
    $win->{noRedraw} = 1;
    my $result = TrEd::Filelist::Navigation::next_or_prev_file( $grp, -1, 1,
        $traverse eq 'all' ? 1 : 0 );

    # wait for Escape
    _quick_update($grp);
    while ( $result
            && !$grp->{stopSearch}
            && (!$win->{FSFile} || $win->{FSFile}->lastTreeNo < 0) )
    {
        $result = TrEd::Filelist::Navigation::next_or_prev_file( $grp, -1, 1,
            $traverse eq 'all' ? 1 : 0 );

        # wait for Escape
        _quick_update($grp);
    }

    $win->{noRedraw} = $no_redraw;

    if ( $result && !$grp->{stopSearch} ) {
        if ( $traverse eq 'all' ) {
            $$tree = $win->{FSFile}->lastTreeNo;
            $win->{currentNode}
                = lastSubtreeNode( $win->{FSFile}->treeList->[$$tree] );
        }
        elsif ( $traverse eq 'tree' ) {
            $win->{currentNode} = lastSubtreeNode( $win->{root} );
            $$tree = $win->{treeNo};
        }
        elsif ( $traverse eq 'node' ) {
            $$tree = $win->{treeNo};
        }
        $win->{treeNo} = -1;    # to force redraw in go_to_tree
        return $win->{currentNode};
    }
    else {

 #$win->{treeNo} = -1 if ($traverse eq 'all'); # to force redraw in go_to_tree
        return;
    }
}

######################################
# find previous matching node
######################################
sub findPrevTemplated {
    my ( $grp, $skipfirst ) = @_;
    my $win = $grp->{focusedWindow};
    return unless $win->{FSFile};
    my $search_code = $grp->{searchCode};
    return unless ref($search_code);

    my $node = $win->{currentNode};
    my $tree = $win->{treeNo};
    my $a;
    $grp->{stopSearch} = 0;

    $node = prevNodeInSearchFilelist( $grp, $node, \$tree ) if ($skipfirst);
    while ($node) {
        if ( $search_code->($node) ) {
            TrEd::Window::TreeBasics::go_to_tree( $win, $tree );
            TrEd::Window::TreeBasics::set_current( $win, $node );
            centerTo( $win, $node );
            return $node;
        }
    }
    continue {
        $node = prevNodeInSearchFilelist( $grp, $node, \$tree );
    }
    return;
}

#############################################
#End of Searching functions
#############################################
#############################################
#############################################

sub node_doubleclick_modif {
    my ( $w, $grp, $mod ) = @_;
    my $win  = findCanvasWindow( $grp, $w );
    my $tv   = $win->treeView;
    my $node = $tv->get_obj_pinfo( $tv->find_item( 'withtag', 'current' ) );
    return doEvalHookWithUndo( $win, "node_doubleclick_hook", $node, $mod,
        $w->XEvent );
}

sub node_click_modif {
    my ( $w, $grp, $mod ) = @_;
    my $win  = findCanvasWindow( $grp, $w );
    my $tv   = $win->treeView;
    my $node = $tv->get_obj_pinfo( $tv->find_item( 'withtag', 'current' ) );
    return doEvalHookWithUndo( $win, "node_click_hook", $node, $mod,
        $w->XEvent );
}

sub node_motion_modif {
    my ( $w, $grp, $mod ) = @_;
    my $win  = findCanvasWindow( $grp, $w );
    my $tv   = $win->treeView;
    my $node = $tv->get_obj_pinfo( $tv->find_item( 'withtag', 'current' ) );
    return doEvalHookWithUndo( $win, "node_motion_hook", $node, $mod,
        $w->XEvent );
}

sub text_doubleclick_modif {
    my ( $w, $grp, $mod ) = @_;
    my $win = findCanvasWindow( $grp, $w );
    return unless ( $win and $win->{FSFile} );
    my $attr;

    my $tv = $win->treeView;
    my ($t) = $tv->find_item( 'withtag', 'current' );
    my $node = $tv->get_obj_pinfo($t);
    TrEd::Window::TreeBasics::set_current( $win, $node );
    $attr = $tv->get_gen_pinfo("attr") || {};

    return doEvalHookWithUndo( $win, "text_doubleclick_hook", $node,
        $attr->{$t}, $mod, $w->XEvent );
}

sub text_click_modif {
    my ( $w, $grp, $mod ) = @_;
    my $win = findCanvasWindow( $grp, $w );
    return unless ( $win and $win->{FSFile} );
    my $attr;

    my $tv = $win->treeView;
    my ($t) = $tv->find_item( 'withtag', 'current' );
    my $node = $tv->get_obj_pinfo($t);
    TrEd::Window::TreeBasics::set_current( $win, $node );
    $win->ensure_current_is_displayed();
    $attr = $tv->get_gen_pinfo("attr") || {};

    return doEvalHookWithUndo( $win, "text_click_hook", $node, $attr->{$t},
        $mod, $w->XEvent );
}

sub line_click {
    my ( $w, $grp, $button, $double, $modif ) = @_;
    my $win = findCanvasWindow( $grp, $w );
    return unless ( $win and $win->{FSFile} );

    my $tv = $win->treeView;
    my ($t) = $tv->find_item( 'withtag', 'current' );
    my $node = $tv->get_obj_pinfo($t);
    TrEd::Window::TreeBasics::set_current( $win, $node );
    $win->ensure_current_is_displayed();
    my $tag = $tv->get_gen_pinfo("tag") || {};

    return doEvalHookWithUndo( $win, "line_click_hook", $node, $tag->{$t},
        $button, $double, $modif, $w->XEvent );
}

sub editAttrs {
    my ( $w, $grp ) = @_;
    return if $grp->{inEditAttrs};
    local $grp->{inEditAttrs} = 1;
    my $win  = findCanvasWindow( $grp, $w );
    my $tv   = $win->treeView;
    my $node = $tv->get_obj_pinfo( $tv->find_item( 'withtag', 'current' ) );
    TrEd::Dialog::EditAttributes::show_dialog( $win, $node );
    $win->ensure_current_is_displayed();
    return;
}

sub editAttr {
    my ( $w, $grp ) = @_;
    return if $grp->{inEditAttrs};
    local $grp->{inEditAttrs} = 1;
    my $win = findCanvasWindow( $grp, $w );
    return unless ( $win and $win->{FSFile} );
    my $tv = $win->treeView;
    my ($t) = $tv->find_item( 'withtag', 'current' );
    my $node = $tv->get_obj_pinfo($t);
    TrEd::Window::TreeBasics::set_current( $win, $node );
    $win->ensure_current_is_displayed();
    my $attr = $tv->get_gen_pinfo("attr") || {};
    return doEditAttr( $win, $node, $attr->{$t} ) if defined $attr->{$t};
}

sub doEditAttr {
    my ( $win, $node, $attr, $as_type, $focus ) = @_;
    my $grp = $win->{framegroup};
    my $result = doEvalHook( $win, 'do_edit_attr_hook', $attr, $node );
    return 0 if $result eq 'stop';

    if ( ref($as_type) || ref( $node->type ) || $win->{FSFile}->schema() ) {
        return TrEd::Dialog::EditAttributes::dialog_schema( $win, $node,
                    $attr, $as_type, $focus );
    }

    my ( $Entry, @Eopts ) = get_entry_type();
    my $newvalue;
    if ( $win->{FSFile}->FS->isList($attr) ) {
        $newvalue = editListAttr( $win, $node->get_member($attr),
            $attr, $grp->{top}, $node );
        if ( defined($newvalue) ) {
            $win->toplevel->Busy( -recurse => 1 );
            $win->{FSFile}->notSaved(1);
            TrEd::Undo::save_undo(
                $win,
                TrEd::Undo::prepare_undo(
                    $win,
                    "Edit Attribute '$attr'",
                    TrEd::Undo::undo_type_id('UNDO_DATA'), $node
                )
            );
            TrEd::Bookmarks::last_action_bookmark($grp);
            $node->set_member( $attr, $newvalue );
            doEvalHook( $win, "after_edit_attr_hook", $node, $attr, 1 );
            get_nodes_fsfile_tree( $grp, $win->{FSFile}, $win->{treeNo} );
            redraw_fsfile_tree( $grp, $win->{FSFile}, $win->{treeNo} );
            $win->toplevel->Unbusy();
            return 1;
        }
        else {
            doEvalHook( $win, "after_edit_attr_hook", $node, $attr, 0 );
        }
        return;
    }

    if ( $node->get_member($attr) =~ /^(?:[^\|\\]|\\.)*\|/ ) {
        $newvalue
            = editAmbiguousAttr( $win, $node->get_member($attr), $attr );
        if ( defined $newvalue ) {
            $grp->{top}->Busy( -recurse => 1 );
            $win->{FSFile}->notSaved(1);
            TrEd::Undo::save_undo(
                $win,
                TrEd::Undo::prepare_undo(
                    $win,
                    "Edit Attribute '$attr'",
                    TrEd::Undo::undo_type_id('UNDO_DATA'), $node
                )
            );
            TrEd::Bookmarks::last_action_bookmark($grp);
            $node->set_member( $attr, $newvalue );
            doEvalHook( $win, "after_edit_attr_hook", $node, $attr, 1 );
            get_nodes_fsfile_tree( $grp, $win->{FSFile}, $win->{treeNo} );
            redraw_fsfile_tree( $grp, $win->{FSFile}, $win->{treeNo} );
            $grp->{top}->Unbusy();
            return 1;
        }
        else {
            doEvalHook( $win, "after_edit_attr_hook", $node, $attr, 0 );
        }
        return;
    }

    $grp->{top}->Busy( -recurse => 1 );
    my $enabled
        = doEvalHook( $win, 'enable_attr_hook', $attr, "normal" ) ne 'stop';
    $newvalue = encode( $node->get_member($attr) );
    my $d = $grp->{top}->DialogBox(
        -title =>
            ( $enabled ? "Edit Node Attribute" : "Disabled Node Attribute" ),
        -buttons => [ ( $enabled ? ( "OK", "Cancel" ) : "Cancel" ) ]
    );
    $d->BindReturn( $d, 1 );
    $d->BindEscape();
    $d->resizable( 0, 0 );
    addBindTags( $d, 'dialog' );
    my $l = $d->Label(
        -text    => $attr,
        -anchor  => 'e',
        -justify => 'right'
    )->pack( -side => 'left' );
    my $e = $d->$Entry(
        @Eopts,
        -relief       => 'sunken',
        -width        => 40,
        -state        => $enabled ? 'normal' : 'disabled',
        -takefocus    => 1,
        -font         => $font,
        -textvariable => \$newvalue
    )->pack();
    set_grp_history( $grp, $e, "attr-$attr" );
    $e->icursor('end');
    $grp->{top}->Unbusy();
    $result = TrEd::Dialog::FocusFix::show_dialog( $d, $e, $grp->{top} );

    if ( $result =~ /OK/ ) {
        get_grp_history( $grp, $e, "attr-$attr" );
        $win->{FSFile}->notSaved(1);
        TrEd::Undo::save_undo(
            $win,
            TrEd::Undo::prepare_undo(
                $win,
                "Edit Attribute '$attr'",
                TrEd::Undo::undo_type_id('UNDO_DATA'), $node
            )
        );
        TrEd::Bookmarks::last_action_bookmark($grp);
        $node->set_member( $attr, decode($newvalue) );
        doEvalHook( $win, "after_edit_attr_hook", $node, $attr, 1 );
        get_nodes_fsfile_tree( $grp, $win->{FSFile}, $win->{treeNo} );
        redraw_fsfile_tree( $grp, $win->{FSFile}, $win->{treeNo} );
    }
    else {
        doEvalHook( $win, "after_edit_attr_hook", $node, $attr, 0 );
    }
    $d->destroy;
    undef $d;
    return ( $result =~ /OK/ ) ? 1 : 0;
}

#############################################
# redraw tree etc.
#############################################

sub nodeOptions {
    my ( $win, $node ) = @_;
    return unless $win->{FSFile};
    return $win->treeView->node_options( $node, $win->{FSFile}->FS,
        $win->{currentNode} );
}

sub nodeBoxOptions {
    my ( $win, $node, $edge ) = @_;
    return unless $win->{FSFile};
    return $win->treeView->node_box_options( $node, $win->{FSFile}->FS,
        $win->{currentNode}, $edge );
}

# sub redraw_win
sub redraw_win {
    my ($win) = @_;
    if ($win) {
        return $win->redraw();
    }
    return;
}

sub redraw_fsfile {
    my ( $grp, $fsfile ) = @_;
    return if ($insideEval || !$fsfile);
    foreach ( fsfileDisplayingWindows( $grp, $fsfile ) ) {
        $_->redraw();
    }
    return;
}

sub redraw_stylesheet {
    my ( $grp, $stylesheet ) = @_;
    foreach my $win ( windows_using_stylesheet( $grp, $stylesheet ) ) {
        $win->apply_stylesheet($stylesheet);
        $win->redraw();
    }
    return;
}

sub redraw_fsfile_tree {
    my ( $grp, $fsfile, $tree_no ) = @_;
    return if ($insideEval || !$fsfile);
    foreach ( grep { $_->{treeNo} == $tree_no }
        fsfileDisplayingWindows( $grp, $fsfile ) )
    {
        $_->redraw();
    }
    return;
}

sub redraw_all {
    my ($grp) = @_;
    foreach ( @{ $grp->{treeWindows} } ) {
        $_->redraw();
    }
    return;
}

sub follow_mouse {
    my ( $w, $grp ) = @_;
    my $e = $w->XEvent;
    my $win = findCanvasWindow( $grp, $w );
    my ( $x, $y ) = ( $e->x, $e->y );
    scrollCanvasToXY( $w, $win, $x, $y );
    return;
}

sub follow_mouse_press {
    my ( $w, $grp ) = @_;
    my $win = findCanvasWindow( $grp, $w );
    my $e = $w->XEvent;
    initScrollOrigin( $w, $win, $e->x, $e->y );
    return;
}

sub initScrollOrigin {
    my ( $w, $win, $X, $Y ) = @_;
    $win->treeView->store_gen_pinfo( 'scroll_origin',
        [ $X, $Y, $w->canvasx($X), $w->canvasy($Y) ] );
    return;
}

#
# How this works:
# - initScrollOrigin registeres the initial window position of the mouse
# pointer and the corresponding canvas position
# - when the mouse moves towards an edge of the window,
# the view moves so that when it reaches the edge,
# the corresponding edge of the canvas drawing area
# (0,0,canvasWidth,canvasHeight) is reached.
# - If the mouse returns to the initial window position,
# the initial canvas point is also under the mouse pointer.
# - If the corresponding canvas edge is already visible, we do
# not move towards it.
#
# known bugs: if initially a negative canvas coord is seen
#

sub scrollCanvasToXY {
    my ( $w, $win, $X, $Y ) = @_;
    no integer;
    my $tv = $win->treeView;
    my @s  = $w->cget('-scrollregion');
    if ( $w->isa('Scrolled') ) {
        $w = $w->Subwidget('scrolled');
    }
    my ( $Ht, $ht, $Wd, $wd );
    my $origin = $tv->get_gen_pinfo('scroll_origin');
    return unless defined $origin;
    my ( $cx, $cy );
    if ( $X < $origin->[0] ) {
        unless ( $w->canvasx(0) < $s[0] ) {
            ( $wd, $Wd ) = ( $origin->[0], $origin->[2] - $s[0] );
            $cx = $s[0] + ( $X / $wd ) * $Wd;
        }
    }
    else {
        my $width = $w->width;
        unless ( $w->canvasx($width) > $s[2] ) {
            ( $wd, $Wd ) = ( $width - $origin->[0], $s[2] - $origin->[2] );
            $cx = $origin->[2] + ( ( $X - $origin->[0] ) / $wd ) * $Wd;
        }
    }
    if ( $Y < $origin->[1] ) {
        unless ( $w->canvasy(0) < $s[1] ) {
            ( $ht, $Ht ) = ( $origin->[1], $origin->[3] - $s[1] );
            $cy = $s[1] + ( $Y / $ht ) * $Ht;
        }
    }
    else {
        my $height = $w->height;
        unless ( $w->canvasy($height) > $s[3] ) {
            ( $ht, $Ht ) = ( $height - $origin->[1], $s[3] - $origin->[3] );
            $cy = $origin->[3] + ( ( $Y - $origin->[1] ) / $ht ) * $Ht;
        }
    }
    $w->xviewCoord( $cx, $X )
        if defined $cx
            and $cx >= $s[0]
            and $cx <= $s[2];
    $w->yviewCoord( $cy, $Y )
        if defined $cy
            and $cy >= $s[1]
            and $cy <= $s[3];
    return;
}

# sub treeIsVertical

# sub treeIsReversed

sub currentLeft {
    my ($grp) = @_;
    my $win = $grp->{focusedWindow};
    return unless $win->{FSFile};
    my $node = $win->{currentNode};
    my $dp = DisplayedAncestor( $win, $node );
    $node = PrevDisplayed( $win, $node, $dp );
    while ($node) {
        my $ndp = DisplayedAncestor( $win, $node );
        last if $ndp == $dp;
        $node = $ndp;
    }
    if ($node) {
        TrEd::Window::TreeBasics::set_current( $win, $node );
        centerTo( $win, $win->{currentNode} );
    }
    return;
}

sub currentRight {
    my ($grp) = @_;
    my $win = $grp->{focusedWindow};
    return unless $win->{FSFile};
    my $node = $win->{currentNode};
    my $dp = DisplayedAncestor( $win, $node );
    $node = NextDisplayed( $win, $node->rightmost_descendant, $dp );
    if ( $node and $dp == DisplayedAncestor( $win, $node ) ) {
        TrEd::Window::TreeBasics::set_current( $win, $node );
        centerTo( $win, $win->{currentNode} );
    }
    return;
}

sub currentRightLin {
    my ($grp) = @_;
    my $win   = $grp->{focusedWindow};
    my $tv    = $win->treeView;
    my @nodes = grep { $tv->node_is_displayed($_) } @{ $win->{Nodes} };
    my $node  = $win->{currentNode};
    my $idx   = Index( \@nodes, $node );
    if ( $idx < $#nodes ) {
        $node = $nodes[ $idx + 1 ];
        TrEd::Window::TreeBasics::set_current( $win, $node );
        centerTo( $win, $win->{currentNode} );
    }
    return;
}

sub currentLeftLin {
    my ($grp) = @_;
    my $win   = $grp->{focusedWindow};
    my $tv    = $win->treeView;
    my @nodes = grep { $tv->node_is_displayed($_) } @{ $win->{Nodes} };
    my $node  = $win->{currentNode};
    my $idx   = Index( \@nodes, $node );
    if ( $idx > 0 ) {
        $node = $nodes[ $idx - 1 ];
        TrEd::Window::TreeBasics::set_current( $win, $node );
        centerTo( $win, $win->{currentNode} );
    }
    return;
}

sub currentRightWholeLevel {
    my ($grp) = @_;
    my $win   = $grp->{focusedWindow};
    my $tv    = $win->treeView;
    return unless $win->{FSFile};
    my @nodes = grep { $tv->node_is_displayed($_) } @{ $win->{Nodes} };
    my $node  = $win->{currentNode};
    my $level = $tv->get_node_pinfo( $node, 'Level' );
    my $idx   = Index( \@nodes, $node );
    while ( $idx < $#nodes ) {
        $node = $nodes[ ++$idx ];
        if ( $level == $tv->get_node_pinfo( $node, 'Level' ) ) {
            TrEd::Window::TreeBasics::set_current( $win, $node );
            centerTo( $win, $win->{currentNode} );
            return;
        }
    }
    return;
}

sub currentLeftWholeLevel {
    my ($grp) = @_;
    my $win   = $grp->{focusedWindow};
    my $tv    = $win->treeView;
    return unless $win->{FSFile};
    my @nodes = grep { $tv->node_is_displayed($_) } @{ $win->{Nodes} };
    my $node  = $win->{currentNode};
    my $level = $tv->get_node_pinfo( $node, 'Level' );
    my $idx   = Index( \@nodes, $node );
    while ( $idx > 0 ) {
        $node = $nodes[ --$idx ];
        if ( $level == $tv->get_node_pinfo( $node, 'Level' ) ) {
            TrEd::Window::TreeBasics::set_current( $win, $node );
            centerTo( $win, $win->{currentNode} );
            return;
        }
    }
    return;
}

sub currentDown {
    my ($grp) = @_;
    my $win = $grp->{focusedWindow};
    return unless $win->{FSFile};
    my $node = $win->{currentNode}->firstson;
    while ( $node and !$win->treeView->node_is_displayed($node) ) {
        $node = NextDisplayed( $win, $node, $win->{currentNode} );
    }
    if ($node) {
        TrEd::Window::TreeBasics::set_current( $win, $node );
        centerTo( $win, $win->{currentNode} );
    }
    return;
}

sub currentUp {
    my ($grp) = @_;
    my $win   = $grp->{focusedWindow};
    my $node  = $win->{currentNode};
    $node = $node && $node->parent;
    while ( $node && !$win->treeView->node_is_displayed($node) ) {
        $node = $node->parent;
    }
    if ($node) {
        TrEd::Window::TreeBasics::set_current( $win, $node );
        centerTo( $win, $win->{currentNode} );
    }
    return;
}

#######################################################################################
# Usage         : center_to_coords($win, $x, $y)
# Purpose       : Adjust scroll region to display point with coordinates $x, $y
#                 in the center of the Window
# Returns       : Undef/empty list if $node is not defined or if $win->{noRedraw} is set.
#                 1 on success.
# Parameters    : TrEd::Window ref $win      -- reference to TrEd::Window object
#                 Treex::PML::node ref $node -- reference to Node which is supposed to be in the centre of the Window
# Throws        : No exception
# Comments      :
# See Also      : centerTo()
sub center_to_coords {
    my ( $win, $x, $y ) = @_;
    return if ( !defined $win );
    my $canvas = $win->treeView()->canvas();
    $canvas->xviewCenter( coord => $x );
    $canvas->yviewCenter( coord => $y );
    return 1;
}

#######################################################################################
# Usage         : centerTo($win, $node)
# Purpose       : Adjust scroll region to display node $node in the center of the Window
# Returns       : Undef/empty list if $node is not defined or if $win->{noRedraw} is set.
#                 1 on success.
# Parameters    : TrEd::Window ref $win      -- reference to TrEd::Window object
#                 Treex::PML::node ref $node -- reference to Node which is supposed to be in the centre of the Window
# Throws        : No exception
# Comments      :
# See Also      : center_to_coords()
# Footnote      : Can not be renamed now, used in ElixirFM, suggested new name: center_to_node()
sub centerTo {
    my ( $win, $node ) = @_;
    return if ( !defined $node || !defined $win );
    return if $win->{noRedraw};
    my $tree_view = $win->treeView();
    $tree_view->reset_scroll_region();
    center_to_coords(
        $win,
        $tree_view->get_node_pinfo( $node, "XPOS" ),
        $tree_view->get_node_pinfo( $node, "YPOS" )
    );
    return 1;
}

sub doEvalHookWithUndo {
    return _evalHook( 1, @_ );
}

sub doEvalHook {
    return _evalHook( 0, @_ );
}

sub _evalHook {
    my ( $with_undo, $win, $hook ) = ( shift, shift, shift );

    return unless $hook;    # and $win->{currentNode};
    return if ( !defined $win );
    my $grp = $win->{framegroup};

    # Save current position (as last action position)
    my $bookmark
        = $with_undo ? TrEd::Bookmarks::actual_position($grp) : undef;
    my $undo;
    if ($with_undo) {
        if ( $with_undo && $win && $win->{FSFile} ) {
            my $context = $win->{macroContext} || 'TredMacro';
            $undo = TrEd::Undo::prepare_undo(
                $win,
                "Hook $context" . "->" . $hook,
                TrEd::Undo::undo_type_id('UNDO_DISPLAYED_TREES')
            );
        }
    }

    local $insideEval = 1;
    my $old_ctxt = TrEd::Macros::save_ctxt();
    my $context  = 'TredMacro';
    set_macro_variable(
        FileNotSaved   => '?',
        libDir         => $libDir,
        forceFileSaved => 0
    );
    my $minor_modes;
    if ($win) {
        set_macro_variable(
            this => $win->{currentNode},
            root => $win->{root},
            grp  => $win,
        );
        $context = $win->{macroContext} || 'TredMacro';
        $minor_modes = $win->{minorModes};
        if ( ref $minor_modes ) {
            my $pre_hooks = $grp->{minorPreHooks}{$hook};
            for my $minor (@{$minor_modes}) {
                my $pre_hook = $pre_hooks->{$minor};
                if ( defined $pre_hook ) {
                    print STDERR
                        "running pre-hook $hook for $minor : $pre_hook\n"
                        if $hookDebug;
                    eval { $pre_hook->(@_) };
                    TrEd::Error::Message::error_message( $win, $@ ) if $@;
                }
            }
        }
    }

    #print "About to run hook $context->$hook: ";
    my $result = do_eval_hook( $win, $context, $hook, @_ );
    warn "$@\n" if $@;

    # run post hooks
    if ( ref $minor_modes ) {
        my $post_hooks = $grp->{minorPostHooks}{$hook};
        for my $minor (@$minor_modes) {
            my $post_hook = $post_hooks->{$minor};
            if ( defined $post_hook ) {
                print STDERR
                    "running post-hook $hook for $minor : $post_hook\n"
                    if $hookDebug;
                    #a bug in show neighboring sentences after macros are reloaded, resolve...
#                use Data::Dumper;
#                $Data::Dumper::Maxdepth = 1;
#                $Data::Dumper::Deparse = 1;
#                print "post hook $hook for $minor :" . Dumper($post_hook);
#                print "passing (" . Dumper(@_) . ", $result) to hook\n\n";
#
#                print "current file: " . Dumper($win->{FSFile}) . "\n";
#                print "win z main: $win\n";
#                print "win z macro: " . TrEd::Macros::get_macro_variable('grp') . "\n";
#                print "CurrentFile: " . TredMacro::CurrentFile() . "\n";
                eval { $post_hook->( @_, $result ) };
                TrEd::Error::Message::error_message( $win, $@ ) if $@;
            }
        }
    }

    # handle file changing
    my $file_changed = get_macro_variable("FileNotSaved");
    if ($win) {
        if ( $win->{FSFile} ) {
            if ( $file_changed ne '?' and $file_changed ) {
                if ($undo) {
                    TrEd::Undo::save_undo( $win, $undo );
                    TrEd::Bookmarks::last_action_bookmark( $win->{framegroup},
                        $bookmark );
                }
                $win->{FSFile}->notSaved(1);
            }
        }
        saveFileStateUpdate($win);
    }

    TrEd::Macros::restore_ctxt($old_ctxt);
    print STDERR "Hook $hook returned $result\n" if $hookDebug;
    return $result;
}

# sub examineEvent
# sub examineBindingsDialog

# macro
sub doEvalMacro {
    my ( $win, $macro ) = ( shift, shift );
    return unless $macro;    # and $win->{currentNode};
    # we wouldn't be able to run functions like $win->toplevel, etc..
    return if ( !defined $win );
    my $bookmark = TrEd::Bookmarks::actual_position( $win->{framegroup} );
    $win->toplevel->Busy( -recurse => 1 );
    $insideEval = 1;

    set_macro_variable(
        this           => $win->{currentNode},
        root           => $win->{root},
        libDir         => $libDir,
        FileNotSaved   => '?',
        forceFileSaved => 0,
        Redraw         => 'file'
    );

    my $undo = TrEd::Undo::prepare_undo(
                    $win,
                    TrEd::Macros::findMacroDescription(
                        $win, $macro,
                        TrEd::Undo::undo_type_id('UNDO_DISPLAYED_TREES')
                    )
                );
    my $result = do_eval_macro( $win, $macro );
    my $current_win = get_macro_variable('grp');
    if ( $win != $current_win
        and ( blessed($current_win) and $current_win->isa('TrEd::Window') ) )
    {
        $win = $current_win;
    }
    my $current        = get_macro_variable("this");
    my $file_not_saved = get_macro_variable("FileNotSaved");
    $file_not_saved = 1 if $file_not_saved eq '?';
    if ( $win->{FSFile} ) {
        if ( get_macro_variable("forceFileSaved") ) {
            print STDERR "Macro forcedly claims file saved.\n";
            $win->{FSFile}->notSaved( $file_not_saved ? 1 : 0 );
            TrEd::Bookmarks::last_action_bookmark( $win->{framegroup},
                $bookmark )
                if $file_not_saved;
        }
        else {
            if ($file_not_saved) {
                TrEd::Undo::save_undo( $win, $undo );
                $win->{FSFile}->notSaved(1);
                TrEd::Bookmarks::last_action_bookmark( $win->{framegroup},
                    $bookmark );
            }
            else {
                print STDERR "Macro claims file untouched.\n" if $macroDebug;
            }
        }
    }
    $insideEval = 0;

    #------------------------------------------------------------
    #use Benchmark;
    #my $t0= new Benchmark;
    #for (my $i=0;$i<=50;$i++) {
    ### ??? 4kb/50 runs memory leaks in redraw (probably in Tk)
    #------------------------------------------------------------
    if ( get_macro_variable("Redraw") eq 'all' ) {
        get_nodes_all( $win->{framegroup} );
        redraw_all( $win->{framegroup} );
    }
    elsif ( get_macro_variable("Redraw") eq 'win' ) {
        $win->get_nodes();
        $win->redraw();
    }
    elsif ( get_macro_variable("Redraw") eq 'tree' ) {
        get_nodes_fsfile_tree( $win->{framegroup}, $win->{FSFile},
            $win->{treeNo} );
        redraw_fsfile_tree( $win->{framegroup}, $win->{FSFile},
            $win->{treeNo} );
    }
    elsif ( get_macro_variable("Redraw") eq 'tie' ) {
        if ( $win->{framegroup}->{tieWindows} ) {
            get_nodes_all( $win->{framegroup} );
            redraw_all( $win->{framegroup} );
        }
        else {
            $win->get_nodes();
            $win->redraw();
        }
    }
    elsif ( get_macro_variable("Redraw") eq 'none' ) {

        # do nothing
    }
    else {
        get_nodes_fsfile( $win->{framegroup}, $win->{FSFile} );
        redraw_fsfile( $win->{framegroup}, $win->{FSFile} );
    }

    #------------------------------------------------------------
    #}
    #my $t1= new Benchmark;
    #my $td= timediff($t1, $t0);
    #print "${TredMacro::FileNotSaved} the code took:",timestr($td),"\n";
    #------------------------------------------------------------

    # the rest of this routine is:
    # memory ok, speed ok
    TrEd::Window::TreeBasics::set_current( $win, $current ) if ($current);
    $win->ensure_current_is_displayed();

    set_macro_variable(
        this => undef,
        root => undef,
        grp  => undef
    );

    centerTo( $win, $win->{currentNode} );
    update_title_and_buttons( $win->{framegroup} );

    $win->toplevel->Unbusy;
    return $result;
}

sub resolveKey {
    my $grp         = shift;                   # other arguments are keys
    my $win         = $grp->{focusedWindow};
    my $minor_modes = $win->{minorModes};
    my $bindings;
    if ($minor_modes) {
        foreach my $minor_mode (@$minor_modes) {
            $bindings = $grp->{minorKeyPriorityBindings}{$minor_mode};
            foreach my $key (@_) {
                if ( $bindings and exists $bindings->{$key} ) {
                    return ( $bindings->{$key}, $key );
                }
            }
        }
    }
    foreach
        my $context ( TrEd::Utils::uniq( $win->{macroContext}, "TredMacro" ) )
    {
        foreach my $key (@_) {
            if ( exists( $TrEd::Macros::keyBindings{$context}->{$key} ) ) {
                return ( $TrEd::Macros::keyBindings{$context}->{$key}, $key );
            }
        }
    }
    if ($minor_modes) {
        foreach my $minor_mode (@$minor_modes) {
            $bindings = $grp->{minorKeyBindings}{$minor_mode};
            foreach my $key (@_) {
                if ( $bindings and exists $bindings->{$key} ) {
                    return ( $bindings->{$key}, $key );
                }
            }
        }
    }
    return;
}

sub resolve_event {
    my ( $w, $grp, $prefix ) = @_;
    my $key;
    my $e       = $w->XEvent;
    my $A       = $e->A;
    my $K       = $e->K;
    my @possib  = ();
    my $macro   = undef;
    my $rotated = 0;
    if ( TrEd::Window::TreeBasics::tree_is_vertical($grp)
        and exists $TrEd::Config::vertical_key_arrow_map{$K} )
    {
        print STDERR "vertical tree: translating $K to " if $keyboardDebug;
        $K = $TrEd::Config::vertical_key_arrow_map{$K};
        print STDERR "$K\n" if $keyboardDebug;
        $rotated = 1;
    }

    print STDERR "Prefix: $prefix\n" if $keyboardDebug;
    $prefix =~ s/SHIFT\+//g
        unless ( $K
        =~ /^(?:left|right|up|down|next|prior|space|backspace|insert|delete|return|pause|escape|home|end|begin|select|print|execute|undo|redo|menu|find|cancel|help|break|F[0-9]+|L[0-9]+|R[0-9]+|ISO_Left_Tab)$/i
        );
    if ($keyboardDebug) {
        print STDERR "Pressed: (" . ord($A) . "), prefix $prefix, keysym $K/",
            $e->N, "\n";
        print STDERR "Maybe: $prefix$K\n";
    }
    if ( $K =~ /^XF86_Switch_VT_(\d+)$/ ) {
        print STDERR "Translating $prefix $K to SHIFT+F$1\n"
            if $keyboardDebug;
        $prefix = 'SHIFT+';
        $K      = 'F' . $1;
    }
    push @possib, ( $prefix . $A, $prefix . $K );

    $macro
        = doEvalHook( $grp->{focusedWindow}, "event_hook", $e, $w, @possib );
    if ( defined($macro) ) {
        if ( $macro eq 'stop' ) {
            print STDERR "Event blocked by event_hook\n"
                if $macroDebug || $keyboardDebug;
            return ( undef, undef, $prefix . $A, $prefix . $K, 1, $rotated );
        }
        else {
            print STDERR "Event translated by event_hook to '$macro'\n"
                if $macroDebug || $keyboardDebug;
            return ( $macro, $key, $prefix . $A, $prefix . $K, 1, $rotated );
        }
    }
    else {
        ( $macro, $key ) = resolveKey( $grp, @possib );
        return ( $macro, $key, $prefix . $A, $prefix . $K, undef, $rotated );
    }
}

# macro
sub evalMacro {
    my ( $w, $grp, $prefix ) = @_;
    my $win = $grp->{focusedWindow};

    my ( $macro, $key ) = resolve_event( $w, $grp, $prefix );
    if ( defined $macro ) {
        if ($tredDebug) {
            $grp->{statusLine}->set_text("$key, $macro");
            $grp->{statusLine}->update_status($win);
        }

        #    use Benchmark;
        #    my $t0= new Benchmark;
        #    # ... your code here ...
        #    for (my $i=0;$i<=50;$i++) {
        doEvalMacro( $win, $macro );

        #    }
        #    my $t1= new Benchmark;
        #    my $td= timediff($t1, $t0);
        #    print "the code took:",timestr($td),"\n";

        return 1;
    }
    else {
        if ($tredDebug) {
            $grp->{statusLine}->set_text($key);
            $grp->{statusLine}->update_status($win);
        }
    }
    return;
}

sub tieGotoTree {
    my ( $grp, $no ) = @_;
    if ( $grp->{tieWindows} ) {
        my @tied = grep { $_->{FSFile} } @{ $grp->{treeWindows} };
        if (@tied) {
            my $result = 1;
            foreach (@tied) {
                $result &&= TrEd::Window::TreeBasics::go_to_tree( $_, $no );
            }
            return $result;
        }
        else {
            return 0;
        }
    }
    else {
        if ( $grp->{focusedWindow}->{FSFile} ) {
            return TrEd::Window::TreeBasics::go_to_tree(
                $grp->{focusedWindow}, $no );
        }
        else {
            return 0;
        }
    }
}

sub tieNextTree {
    my ($grp) = @_;
    if ( $grp->{tieWindows} ) {
        my @tied = grep { $_->{FSFile} } @{ $grp->{treeWindows} };
        if (@tied) {
            my $result = 1;
            foreach (@tied) {
                $result &&= TrEd::Window::TreeBasics::next_tree($_);
            }
            return $result;
        }
        else {
            return 0;
        }
    }
    else {
        if ( $grp->{focusedWindow}->{FSFile} ) {
            my $result = TrEd::Window::TreeBasics::next_tree(
                $grp->{focusedWindow} );
            return $result;
        }
        else {
            return 0;
        }
    }
}

sub tiePrevTree {
    my ($grp) = @_;
    if ( $grp->{tieWindows} ) {
        my @tied = grep { $_->{FSFile} } @{ $grp->{treeWindows} };
        if (@tied) {
            my $result = 1;
            foreach (@tied) {
                $result &&= TrEd::Window::TreeBasics::prev_tree($_);
            }
            return $result;
        }
        else {
            return 0;
        }
    }
    else {
        if ( $grp->{focusedWindow}->{FSFile} ) {
            my $result = TrEd::Window::TreeBasics::prev_tree(
                $grp->{focusedWindow} );
            return $result;
        }
        else {
            return 0;
        }
    }
}

# node?
sub currentNext {
    my ($win) = @_;
    my $next = NextDisplayed( $win, $win->{currentNode} );
    if ($next) {
        TrEd::Window::TreeBasics::set_current( $win, $next );
        centerTo( $win, $win->{currentNode} );
    }
    return;
}

# node?
sub currentPrev {
    my ($win) = @_;
    my $prev = PrevDisplayed( $win, $win->{currentNode} );
    if ($prev) {
        TrEd::Window::TreeBasics::set_current( $win, $prev );
        centerTo( $win, $win->{currentNode} );
    }
    return;
}

# node
sub node_select {
    my ( $w, $grp ) = @_;
    my $win = findCanvasWindow( $grp, $w );
    my $tv  = $win->treeView;
    my $e   = $w->XEvent;
    my ( $x, $y ) = ( $e->x, $e->y );
    my ($canvas_obj) = $tv->find_item( 'withtag', 'current' );
    my $node = $tv->get_obj_pinfo($canvas_obj);
    return TrEd::Window::TreeBasics::set_current( $win, $node );
}

# node
{
    my ( $nx, $ny );

    sub node_down {
        my ( $w, $grp, $scroll ) = @_;
        my $win = findCanvasWindow( $grp, $w );
        my $tv  = $win->treeView;
        my $e   = $w->XEvent;
        ( $nx, $ny ) = ( $e->x, $e->y );
        if ($scroll) {
            initScrollOrigin( $w, $win, $nx, $ny );
        }
        my ($canvas_obj) = $tv->find_item( 'withtag', 'current' );
        my $node = $tv->get_obj_pinfo($canvas_obj);

        unless ( TrEd::MinMax::first { $_ eq 'point' } $w->gettags($canvas_obj) ) {
            my ( $cx, $cy ) = ( $w->canvasx($nx), $w->canvasy($ny) );
            $canvas_obj = TrEd::MinMax::first {
                TrEd::MinMax::first { $_ eq 'point' } $w->gettags($_);
            }
            $tv->find_item(
                overlapping => $cx - 1,
                $cy - 1, $cx + 1, $cy + 1
            );
            if ( $canvas_obj and $node != $tv->get_obj_pinfo($canvas_obj) ) {
                undef $canvas_obj;
            }
        }
        TrEd::Window::TreeBasics::set_current( $win, $node );
        $w->dtag('selected');
        return unless $canvas_obj;
        $w->addtag( 'selected', 'withtag', $canvas_obj );
        $w->raise('selected');
        $w->raise("text[$node]");
        return;
    }    # end node_down

    # node
    sub node_move {
        my ( $w, $grp, $scroll ) = @_;
        my $win = findCanvasWindow( $grp, $w );
        my $tv = $win->treeView;
        my ($sel) = $tv->find_item( 'withtag', 'selected' );
        return unless $sel;

        my $e = $w->XEvent;
        my ( $deltax, $deltay ) = ( -$nx, -$ny );
        ( $nx, $ny ) = ( $e->x, $e->y );
        $deltax += $nx;
        $deltay += $ny;
        my ( $cx, $cy ) = ( $w->canvasx($nx), $w->canvasy($ny) );
        if ($scroll) {
            $deltax -= $cx;
            $deltay -= $cy;
            scrollCanvasToXY( $w, $win, $nx, $ny );
            ( $cx, $cy ) = ( $w->canvasx($nx), $w->canvasy($ny) );
            $deltax += $cx;
            $deltay += $cy;
        }
        $w->move( 'selected', $deltax, $deltay );
        my $nearest
            = $tv->get_obj_pinfo( $tv->find_item( 'withtag', 'nearest' ) );
        if ($nearest) {
            $w->itemconfigure( 'nearest', nodeOptions( $win, $nearest ) );
            $tv->apply_stored_style_opts( "Oval", $nearest );
            $w->dtag('nearest');
        }

        my @nodes    = $w->find( 'withtag', 'point' );
        my $node     = $tv->get_obj_pinfo($sel);
        my $bestDist = 10000;
        my $dist;
        $nearest = undef;
        foreach my $p (@nodes) {
            my @b = $w->bbox($p);
            my ( $dX, $dY )
                = ( ( $b[2] + $b[0] ) / 2 - $cx,
                ( $b[3] + $b[1] ) / 2 - $cy );
            my $n = $tv->get_obj_pinfo($p);
            if ( $n and $n != $node ) {
                $dist = $dX * $dX + $dY * $dY;
                if ( $bestDist > $dist ) {
                    $bestDist = $dist;
                    $nearest  = $p;
                }
            }
        }
        if ( defined($nearest) and $bestDist < 800 ) {
            $w->addtag( 'nearest', 'withtag', $nearest );
            $w->itemconfigure( $nearest, -fill => $tv->get_nearestNodeColor );
        }
        return;
    }    # end node_move
}

# node
sub node_release {
    my ( $w, $grp, $button ) = @_;
    my $win = findCanvasWindow( $grp, $w );
    return if !$win->{FSFile};

    my $tv = $win->treeView;
    my ($sel) = $tv->find_item( 'withtag', 'selected' );
    return if !$sel;

    my $e = $w->XEvent;
    my ( $x, $y ) = ( $e->x, $e->y );
    my $parent;
    my $node;
    my $center = 0;
    $node = $tv->get_obj_pinfo($sel) if ( defined($sel) );
    if ($node) {
        my ($p) = $tv->find_item( 'withtag', 'nearest' );
        $w->dtag('nearest');
        $w->dtag('selected');
        if ( defined $p ) {
            $parent = $tv->get_obj_pinfo($p);
            $w->itemconfigure( $tv->get_node_pinfo( $parent, "Oval" ),
                nodeOptions( $win, $parent ) );
            $tv->apply_stored_style_opts( "Oval", $parent );
            if (doEvalHookWithUndo(
                    $win,      "node_release_hook",
                    $node,     $parent,
                    "$button", $e
                ) ne 'stop'
                )
            {
                if ($parent->test_child_type($node)
                    or TrEd::Query::User::new_query(
                        $win, "WARNING:\n\n"
                            . "The target node does not permit the dragged node "
                            . "as a child.\nThe resulting tree will be invalid.\n\n",
                        -bitmap  => 'question',
                        -title   => 'Incompatible node type',
                        -buttons => [ "Do not paste", 'Paste anyway' ]
                    ) eq 'Paste anyway'
                    )
                {
                    my $top = $parent;
                    while ($top) {
                        if ( $node eq $top ) {
                            undef $parent;
                            last;
                        }
                        $top = $top->parent;
                    }
                    if ( $parent and $node->parent != $top ) {
                        TrEd::Undo::save_undo(
                            $win,
                            TrEd::Undo::prepare_undo(
                                $win, "Cut/Paste node with mouse"
                            ),
                            TrEd::Undo::undo_type_id('UNDO_DISPLAYED_TREES')
                        );
                        my $oldparent = $node->parent;
                        $node->cut()->paste_on( $parent, $win->{FSFile}->FS );
                        $win->{FSFile}->notSaved(1);
                        doEvalHook( $win, "node_moved_hook", $node,
                            $oldparent );
                        TrEd::Bookmarks::last_action_bookmark($grp);
                        get_nodes_fsfile( $grp, $win->{FSFile} );
                        redraw_fsfile_tree( $grp, $win->{FSFile},
                            $win->{treeNo} );
                        centerTo( $win, $win->{currentNode} );
                        return;
                    }
                }
            }
        }

        # returning node to its position
        $w->coords( $sel, $tv->node_coords( $node, $win->{currentNode} ) );

        # print lower;
        $w->lower( $sel, 'point' );
    }
    else {
        $win->redraw();
    }
    return;
}

# node
sub node_release_modif {
    my ( $w, $grp, $mod ) = @_;
    my $win = findCanvasWindow( $grp, $w );
    my $tv = $win->treeView;
    return if !$win->{FSFile};
    my $e = $w->XEvent;
    my ( $x, $y ) = ( $e->x, $e->y );
    my $parent;
    my $node;
    my $center = 0;
    my ($sel) = $tv->find_item( 'withtag', 'selected' );
    $node = $tv->get_obj_pinfo($sel) if ( defined($sel) );

    if ($node) {
        my ($p) = $tv->find_item( 'withtag', 'nearest' );
        $w->dtag('nearest');
        if ( defined $p ) {
            $parent = $tv->get_obj_pinfo($p);
            $w->itemconfigure( $tv->get_node_pinfo( $parent, "Oval" ),
                nodeOptions( $win, $parent ) );
            doEvalHookWithUndo( $win, 'node_release_hook', $node, $parent,
                $mod, $e );
        }
        else {
            doEvalHookWithUndo( $win, 'node_release_hook', $node, undef,
                $mod, $e );
        }

        # try to detect that the tree was redrawn
        if ( $tv->find_item( 'withtag', 'selected' ) ) {

            # returning selected node to its position
            $w->dtag('selected');
            $w->coords( $sel,
                $tv->node_coords( $node, $win->{currentNode} ) );
        }
    }
    else {
        redraw_fsfile_tree( $grp, $win->{FSFile}, $win->{treeNo} );
    }
    return;
}

#sub prepare_undo
#wrapper only for extensions/macros (vallex)
sub prepare_undo {
    return TrEd::Undo::prepare_undo(@_);
}

#sub prepare_redo
#sub save_undo
sub save_undo {
    return TrEd::Undo::save_undo(@_);
}

#sub re_do
sub re_do {
    return TrEd::Undo::re_do(@_);
}

#sub undo
sub undo {
    return TrEd::Undo::undo(@_);
}

#sub resetUndoStatus

sub resetTreePosStatus {
    my ($grp)  = @_;
    my $win    = $grp->{focusedWindow};
    my $fsfile = $win->{FSFile};

    my $prevstatus
        = ref($fsfile) && $fsfile->lastTreeNo >= 0 && $win->{treeNo} > 0;
    my $nextstatus = ref($fsfile) && $fsfile->lastTreeNo > $win->{treeNo};
    if ( $win->{framegroup}->{nextButton} ) {
        $win->{framegroup}->{nextButton}
            ->configure( -state => ( $nextstatus ? 'normal' : 'disabled' ) );
    }
    if ( $win->{framegroup}->{prevButton} ) {
        $win->{framegroup}->{prevButton}
            ->configure( -state => ( $prevstatus ? 'normal' : 'disabled' ) );
    }
    return;
}

sub list_isearch {
    my ($w) = @_;
    my $e   = $w->XEvent;
    my $A   = $e->A;
    if ( $A ne EMPTY ) {
        my @items  = $w->get( 0, 'end' );
        my $count  = $w->index('end');
        my $active = $w->index('active');
        for ( my $i = $active + 1; $i <= $active + $count; $i++ ) {
            if ( $items[ $i % $count ] =~ /^$A/i ) {
                $w->activate( $i % $count );
                unless ($w->isa('Tk::Listbox')
                    and $w->cget('-selectmode') eq 'multiple'
                    or $w->cget('-selectmode')  eq 'extended' )
                {
                    $w->selectionClear( 0, 'end' );
                    $w->selectionSet( $i % $count );
                }
                $w->see( $i % $count );
                Tk->break;
                return;
            }
        }
    }
    return;
}

# macro
#TODO: do TrEd::Macros
sub cleanup_tredmacro {
    my ($grp) = @_;

    # cleanup
    %TrEd::Macros::defines = ( TRED => 1 );
    my %packages;

    @packages{
        (   'TredMacro',
            grep     {/\S/}
                grep { !/^main$|^TrEd::/ }
                map  { (/^\s*package\s+([^;\s]+)\s*;/) }
                (@TrEd::Macros::macros)
        )
        }
        = ();
    my %kept_pkg;
    my %deleted_pkg;
    foreach my $package ( sort { length $b <=> length $a } keys %packages ) {
        no strict qw(refs);
        print STDERR ("Cleaning package $package\n") if $tredDebug;
        my $pkg_file = $package;
        $pkg_file =~ s{::}{/}g;
        $pkg_file .= '.pm';
        my @pkg_vars = grep { !/::$/ } keys %{ $package . '::' };

        foreach my $var (@pkg_vars) {
            delete ${ $package . '::' }{$var};
        }
        if ( %{ $package . '::' } ) {
            undef @kept_pkg{ map { $package . '::' . $_ }
                    keys %{ $package . '::' } };
        }
        undef $deleted_pkg{ $package . '::' };
        delete $INC{$pkg_file};
        eval("package $package; use UNIVERSAL qw(isa can);");
        print STDERR $@ if $@;
    }
    print STDERR "KEPT: @{[join qq(\n\t),keys %kept_pkg]}.\n",
        "DELETED: @{[join qq(\n\t),keys %deleted_pkg]}\n"
        if $tredDebug;

    # workaround to reinit TredMacro namespace,
    # since the functions can be overridden by extensions,
    # we have to reinit default behaviour
    delete $INC{'TrEd/MacroAPI/Default.pm'};
    delete $INC{'TrEd/MacroAPI/Extended.pm'};
    delete $INC{'TrEd/NtredMak.pm'};
    return;

#    use Data::Dumper;
#    print Dumper(\%INC);

}

# sub declareMinorMode
# sub enableMinorMode
# sub disableMinorMode
# sub toggleMinorMode
# sub _minor_ctxt_abbrev
# sub configure_minor_mode
# sub update_minor_modes

# sub update_minor_mode_menu

#sub valueLineClick

#TODO poslat do TrEd::Extensions, s tym, ze z btredu bude treba doplnit prevzatie arguemntov
# a vypis extensions do nejakeho suboru, odtialto potom odfiltrovat init_extensions
# extensions
#sub prepareExtensions

# macros
#TODO: uz skor load_extensions
sub loadMacros {
    my ( $grp, $opts ) = @_;
    $opts ||= {};

    # this used to read macro tred.mac (and tred.def), now only init
    TrEd::Macros::read_macros($macroFile,$libDir);

    require TrEd::MacroAPI::Default;    #this loads TredMacro API
    # we need it for loading minor modes... not any more

    TredMacro::init_tredmacro_bindings();

    # set minor modes and this stuff, can't do it at compile time,
    # since there is no grp yet
    TrEd::Macros::set_macro_variable( 'grp', $grp->{focusedWindow} );

    # minor modes
    require TrEd::MinorMode::Move_Nodes_Freely;
    require TrEd::MinorMode::Show_Neighboring_Sentences;
    require TrEd::MinorMode::Show_Neighboring_Trees;

    # minors
    TrEd::MinorMode::Move_Nodes_Freely::init_minor_mode($grp);
    TrEd::MinorMode::Show_Neighboring_Sentences::init_minor_mode($grp);
    TrEd::MinorMode::Show_Neighboring_Trees::init_minor_mode($grp);

    #print 'before loading macros: ' . Dumper(\%TredMacro::);
    my $preinst_dir = get_preinstalled_extensions_dir();

    my ( $extensions, $pre_installed );
    if ( ref( $opts->{preparedExtensions} ) ) {
        ( $extensions, $pre_installed ) = @{ $opts->{preparedExtensions} };
    }
    else {
        ( $extensions, $pre_installed )
            = @{ TrEd::Extensions::prepare_extensions($opt_m) };
    }

    foreach my $path ( get_extension_sample_data_paths($extensions),
        get_extension_sample_data_paths( $pre_installed, $preinst_dir ) )
    {
        foreach my $extensions_filelist (
            glob( File::Spec->catfile( $path, '*.fl' ) ) )
        {
            TrEd::ManageFilelists::create_ext_filelist($extensions_filelist);
        }
    }

    print STDERR ("Reading extension macros:") unless $opt_q;
    for my $ext_contrib ( get_extension_macro_paths($extensions),
        get_extension_macro_paths( $pre_installed, $preinst_dir ) )
    {

        if ( -f $ext_contrib ) {
            if ($tredDebug) {
                print STDERR (
                    "Reading extension macros from $ext_contrib...\n");
            }
            elsif ( !$opt_q ) {
                my $name = $ext_contrib;
                $name =~ s{.*/extensions/([^/]+)/contrib.*}{$1};
                print STDERR (" $name");
            }
            push @TrEd::Macros::macros,
                qq(\n#line 0 "$ext_contrib"\n{\npackage TredMacro;\n);
            read_macros( $ext_contrib, $libDir, 1 );
            push @TrEd::Macros::macros, qq(\n} # end of "$ext_contrib"\n);
        }
    }
    print STDERR " ... done\n" if !$opt_q && !$tredDebug;
    if ($opt_I) {
        print STDERR ("Reading additional macros from $opt_I...")
            unless $opt_q;
        push @TrEd::Macros::macros,
            qq(\n#line 0 "$opt_I"\n{\npackage TredMacro;\n);
        read_macros( $opt_I, $libDir, 1 );
        push @TrEd::Macros::macros, qq(\n} # end of "$opt_I"\n);
        print STDERR "done.\n" unless $opt_q;
    }
    return;
}

# macros
sub reloadMacros {
    my ( $grp, $opts ) = @_;
    doEvalHook( $grp->{focusedWindow}, 'reload_macros_hook' );
    my $win = $grp->{focusedWindow};

    my $activated_minor_modes = $grp->{focusedWindow}->{minorModes};

    delete $win->{minorModes};
    delete $grp->{minorModes};
    delete $grp->{minorPreHooks};
    delete $grp->{minorPostHooks};

    # this should not be necessary, loadMacros takes care of it
    #  %TrEd::Macros::keyBindings=();
    #  %TrEd::Macros::menuBindings=();
    TrEd::TreeView->clear_code_caches;

    cleanup_tredmacro($grp);

    TrEd::Toolbar::User::Manager::reset_user_toolbars($grp);

    loadMacros( $grp, $opts );
    doEvalHook( $grp->{focusedWindow}, 'macros_reloaded_hook' );
    doEvalHook( $grp->{focusedWindow}, 'initialize_bindings_hook' );

    TrEd::Menu::Macro::update_macro_menus($grp);
    TrEd::List::Macros::update_view($grp);

    foreach my $minor_mode (@{$activated_minor_modes}) {
        TrEd::MinorModes::toggle_minor_mode($grp, $minor_mode);
    }

    get_nodes_all($grp);
    redraw_all($grp);

    # maybe we should update filelists here,
    # because some filelists may disappear/appear
    # during installation/removing of extensions
    return;
}

# extensions, should it be moved to TrEd::Extensions..?
sub manage_extensions {
    my ( $grp, $do_reload ) = @_;
    my $reload_macros;
    my $repos = [ split /\s+/, $extensionRepos ];
    TrEd::Extensions::manage_extensions_dialog(
        $grp,
        {   repositories  => $repos,
            reload_macros => \$reload_macros,
        }
    );
    my $new = $extensionRepos;
    $new = join ' ', @$repos;
    if ( $new =~ /\S/ and $new ne $extensionRepos ) {
        $extensionRepos = $new;
        TrEd::Config::save_runtime_config( $grp,
            { extensionRepos => $extensionRepos, } );
    }
    if ( $do_reload and $reload_macros ) {

        # reload stylesheets
        TrEd::Stylesheet::init_stylesheet_paths(
            [ split( $Treex::PML::resourcePathSplit, $opt_S, -1 ) ] );

        my $preparedExtensions = TrEd::Extensions::prepare_extensions($opt_m);

        TrEd::Stylesheet::load_stylesheets($grp);
        $grp->{StylesheetMenu}->update($grp);
        updateHelpMenu( $grp, { preparedExtensions => $preparedExtensions } );

        # reload macros
        reloadMacros( $grp, { preparedExtensions => $preparedExtensions } );
    }
    return;
}

__END__

=head1 NAME

TrEd - a graphical visualizer and editor of tree graphs

=head1 SYNOPSIS

 tred [-q] [-c <config-file>] [-m|-I <macro-file>] [-t context]
      [-l <filelist>] [-n encoding] [other-options] [file[##N|##N.M|#ID] ...]

or

  tred -C <command>

or

  tred -u          for usage
  tred -h          for help
  tred --man       for the manual page
  tred --version   for version

=head1 DESCRIPTION

TrEd is a graphical visualizer and editor of tree graphs.

=head2 Filename arguments

Each filename on the command-line or in a file list may be optionally
followed by a suffix which identifies a node to be selected when the
file is opened.  The suffix can be of one of the following following
forms:

#ID     where ID is an identifier of a node (for file formats that have
        identifiers, e.g. PML).

##N     where N is a number. This selects the root of the N-th tree

##N.M   where N and M are numbers. This selects the M-th node in
        the depth-first order in the N-th tree.

=head2 Options

=over 8

=item B<-C> command

Perform a given command on a running instance of TrEd.
Currently only one command is supported:

  open <filename>

If there is no TrEd instance running, the filename is opened in a new
instance.

=item B<--filelist|-l> filename

Read a list of filenames to process from a given file (one filename
per line). Files specified in a file-list are processed prior to files
specified on the command-line. If file-list is a file with .fl
extension, then the first line may contain a file-list name (as in
TrEd). Moreover, unlike in other file-lists, filenames in .fl
file-lists are assumed to be relative to the file-list file location.

=item B<--macro-file|-m> filename

File with macro definitions to load.  If no macro-file is given,
standard macro file (by default F<tred.mac>) is used.

=item B<--include-macro-file|-I> filename

A file containing additional set of macros to load. This option is
typically used instead of C<--macro-file> to allow loading macros
B<both> from C<filename> B<and> the default macro set (F<tred.mac>).
C<--macro-file> can still be used in combination with
B<--include-macro-file> to supply a replacement for F<tred.mac>.

=item B<--config-file|-c> filename

TrEd configuration file (overrides ~/.tredrc).

=item B<--option|-O> name=value

Override configuration option from the config file with a given
value. This flag can be used several times for different options.

Special syntax of the name part allows some modifications of existing
option values for options that are delimited lists (this cannot be
used to modify default or implicit values):

=over 8

=item nameX=value

Treat the option as a list delimited by the delimiter X and
prepend the value to the list.

=item  nameX+=value

Treat the option as a list delimited by the delimiter X and append the
value to the list.

=item  nameX-=value

Treat the option as a list delimited by the delimiter X and remove the
value from the list (if exists).

=back

Only the following characters can be used as a delimiter:

      ; : , & | / + - \s \t SPACE

where SPACE is a space character, \s matches arbitrary white-space,
and \t matches TAB character.

The options can be combined; for example

  -O "extensionRepos\\s"-=http://foo/bar -O "extensionRepos\\s"+=http://foo/bar

first removes any occurrence of the URL http://foo/bar from the
white-space separated list of extensionRepos and then appends the URL
to the end of the list.

=item B<--stylesheet-file> path

Path may be either a file name, in which case it must point to a TrEd
stylesheet configuration file in the old format or ~/.tred-stylesheets
(obsolete), or a directory, in which case each file in the directory
must be a TrEd stylesheet.

=item B<--resource-dir|-Z> dirnames

Specifies resource path. This option can be repeated and overrides
ResoucePath setting in the TrEd configuration file.

Individual paths can also be separated by colon (POSIX/Unix) or
semi-colon (Windows) separator. If there is a lone leading or trailing
separator, the default resource path is prepended or appended,
respectively.

=item B<--context|-t> context_name

Initial macro context.

=item B<--show-hidden-nodes|-H>

Start in the mode where hidden nodes are displayed.

=item B<--stylesheet|-s> stylesheet-name

Initial stylesheet to render the tree according to.

=item B<--split-window|-p> number

Split window to given number of subwindows (horizontally if
positive, vertically if negative) and open n'th file
in n'th subwindow.

=item B<--execute|-e> perl-code

Macro code to evaluate just before the main loop is started.

=item B<--window-embed|-W> window_ID

Embed main window into window with the given window ID.

=item B<--no-geometry|-G>

Do not initially resize window to its last geometry.

=item B<--extra-backends|-B> backend

Comma separated list of user-defined IO-backend modules to load.

=item B<--file-encoding|-n> encoding

Allows to specify character encoding of input files (does not apply to
XML files).

=item B<--define-symbol> symbol_name

Symbol name or a name=value pair to be used by macro-preprocessor
(equivalent to a C<#define> instruction at the beginning of the macro
file). Multiple definitions symbols may be separated by a comma and
the option may be repeated.

=item B<--no-secondary-files|-Y>

Neither load or save "secondary" files. Normally, secondary files (if
loaded) are saved along with their primary files (the exactly same
file-name prefix/suffix processing and format apply to both the
primary and secondary files). A secondary file is a file required by a
(normal - primary) file to be loaded along with it; this is typical
for files containing some form of a stand-off annotation where one
tree is built upon another. Note however, that this does not include so
called knitting - an operation where the stand-off annotation is
handled by a IO backend and the resulting knitted file appears to
btred as a single unit.

=item B<--enable-extensions|-j> list

Give a comma-separated list of installed TrEd extension names to
temporarily enable if disabled in the extension configuration.
Use '*' to enable all currently enabled extensions.

=item B<--disable-extensions|-J> list

Give a comma-separated list of installed TrEd extension names to
temporarily disable if enabled in the extension configuration.
Use '*' to disable all currently enabled extensions.

=item B<--tectogrammatical-trees|-R>

Build tectogrammatic trees from CSTS files.

=item B<--csts-tree-attributes|-X> gov,ord?,hide?

CSTS format is "many in one"; there may be more tree structures in one
file.  This option can be used to specify which tree structure should
be used.  Provide a comma separated list consisting of names of node
attributes corresponding to CSTS elements that contain the necessary
information to build a tree out of a CSTS file. The first attribute
should be an attribute containing the index of the governing node; the
second one is optional and specifies the ordering attribute; the third
one is also optional and if specified, it should be the attribute used
to mark hidden nodes with the string 'hide'. If the third argument is
specified as empty (i.e. there is a trailing comma), default to
'X_hide' with preset-value 'hide'.

Examples:
  -X govTR,dord  - corresponds to elements <TRg> and <tfr>
                   in CSTS

  -X govMD_c,ord,x_MD_c_hide
                 - corresponds to <MDg src="c">, <r>,
                   and <x name="MD_c_hide">).

=item B<--no-backups>

Do not generate `tilda' backup files.

=item B<--no-locks>

Do not attempt to create lock files. Lock files are used to prevent
another TrEd instance/user from modifying the same document.

=item B<--autosave> number

Create an auto-save file for each modified document every given number
of minutes. If 0, auto-saving is disabled.

=item B<--quiet|-q>

Print only general processing information on stderr.

=item B<--debugging|-D>

Print a lot of debugging information on the stderr.

=item B<--carp>

Replace 'die' with 'Carp::confess', so that a complete stack trace is
printed upon error. Useful for debugging.

=item B<--version|-v>

Print version and quit.

=item B<--man|-m>

Displays the help as manual page.

=item B<--help|-h>

Prints the help page and exits.

=item B<--usage|-u>

Print a brief help message on usage and exits.

=back

=head1 SEE ALSO

TrEd User Manual at http://ufal.mff.cuni.cz/tred/documentation/ar01-toc.html
(also located in the documentation directory in the installation of
TrEd).

=head1 LICENSE

This software is distributed under GPL - The General Public Licence.
Full text of the GPL can be found in the LICENSE file distributed with
this program and also on-line at http://www.gnu.org/copyleft/gpl.html .

=head1 AUTHOR

Petr Pajas <pajas@matfyz.cz>

Copyright 2000-2008 Petr Pajas.

=cut

