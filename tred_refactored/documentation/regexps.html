<?xml version="1.0"?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Regualar Expressions</title>
    <link href="blue.css" rel="stylesheet"/>
  </head>
  <body>
    <h1>Regular Expressions</h1>
    <p>
      Because regular expressions that may be used in TrEd are the
      same as regular expressions that are defined in Perl, the
      following text is an extraction from Perl documentation.
    </p>
    <p>
      The following metacharacters have their standard
      *egrep*-ish meanings:
    </p>
    <dl>
      <dt><tt>\</tt></dt>	
      <dd><p>Quote the next metacharacter</p></dd>
      <dt><tt>^</tt></dt>
      <dd><p>Match the beginning of the string</p></dd>
      <dt><tt>.</tt></dt>	
      <dd><p>Match any character</p></dd>
      <dt><tt>$</tt></dt>
      <dd><p>Match the end of the string</p></dd>
      <dt><tt>|</tt></dt>	
      <dd><p>Alternation</p></dd>
      <dt><tt>()</tt></dt>
      <dd><p>Grouping</p></dd>
      <dt><tt>[]</tt></dt>
      <dd><p> Character class</p></dd>
    </dl>
    <p>
      The following standard quantifiers are recognized:
    </p>
    <dl>
      <dt><tt>*</tt></dt>
      <dd><p> Match 0 or more times</p></dd>
      <dt><tt>+</tt></dt>
      <dd><p>Match 1 or more times</p></dd>
      <dt><tt>?</tt></dt>
      <dd><p>Match 1 or 0 times</p></dd>
      <dt><tt>{n}</tt></dt>
      <dd><p>Match exactly n times</p></dd>
      <dt><tt>{n,}</tt></dt>
      <dd><p>Match at least n times</p></dd>
      <dt><tt>{n,m}</tt></dt>
      <dd><p>Match at least n but not more than m times</p></dd>
    </dl>
    <p>
      (If a curly bracket occurs in any other context, it is treated as a
      regular character.)  The "*" modifier is equivalent to `{0,}', the "+"
      modifier to `{1,}', and the "?" modifier to `{0,1}'.  n and m are
      limited to integral values less than 65536.
    </p>
    <p>
      By default, a quantified subpattern is "greedy", that is, it will match
      as many times as possible (given a particular starting location) while
      still allowing the rest of the pattern to match.  If you want it to
      match the minimum number of times possible, follow the quantifier with a
      "?".  Note that the meanings don't change, just the "greediness":
    </p>
    <dl>      
      <dt>*?</dt>      
      <dd><p>Match 0 or more times</p></dd>
      <dt><tt>+?</tt></dt>
      <dd><p>Match 1 or more times</p></dd>
      <dt><tt>??</tt></dt>
      <dd><p>Match 0 or 1 time</p></dd>
      <dt><tt>{n}?</tt></dt>
      <dd><p>Match exactly n times</p></dd>
      <dt><tt>{n,}?</tt></dt>
      <dd><p>Match at least n times</p></dd>
      <dt><tt>{n,m}?</tt></dt>
      <dd><p>Match at least n but not more than m times</p></dd>
    </dl>
    <p>
      Because patterns are processed as double quoted strings, the following
      also work:
    </p>
    <dl>
      <dt><tt>\t</tt></dt>
      <dd><p>tab                   (HT, TAB)</p></dd>
      <dt><tt>\n</tt></dt>
      <dd><p>newline               (LF, NL)</p></dd>
      <dt><tt>\r</tt></dt>
      <dd><p>return                (CR)</p></dd>
      <dt><tt>\f</tt></dt>
      <dd><p>form feed             (FF)</p></dd>
      <dt><tt>\a</tt></dt>
      <dd><p>alarm (bell)          (BEL)</p></dd>
      <dt><tt>\e</tt></dt>
      <dd><p>escape (think troff)  (ESC)</p></dd>
      <dt><tt>\033</tt></dt>
      <dd><p>octal char (think of a PDP-11)</p></dd>
      <dt><tt>\x1B</tt></dt>
      <dd><p>hex char</p></dd>
      <dt><tt>\c[</tt></dt>
      <dd><p>control char</p></dd>
      <dt><tt>\l</tt></dt>
      <dd><p>lowercase next char</p></dd>
      <dt><tt>\u</tt></dt>
      <dd><p>uppercase next char</p></dd>
      <dt><tt>\L</tt></dt>
      <dd><p>lowercase till \E</p></dd>
      <dt><tt>\U</tt></dt>
      <dd><p>uppercase till \E</p></dd>
      <dt><tt>\E</tt></dt>
      <dd><p>end case modification</p></dd>
      <dt><tt>\Q</tt></dt>
      <dd><p>quote regexp metacharacters till \E</p></dd>
    </dl>
    <p>
      If <tt>UseCzechLocales</tt> is set to non-zero value in TrEd's
      configuration, the list of alphabetic characters generated by
      `\l',`\u',`\L',`\U' is taken
      from the Czech locale.
      In addition, the following characters are defined:
    </p>
    <dl>
      <dt><tt>\w</tt></dt>
      <dd><p>Match a "word" character (alphanumeric plus "_")</p></dd>
      <dt><tt>\W</tt></dt>
      <dd><p>Match a non-word character</p></dd>
      <dt><tt>\s</tt></dt>
      <dd><p>Match a whitespace character</p></dd>
      <dt><tt>\S</tt></dt>
      <dd><p>Match a non-whitespace character</p></dd>
      <dt><tt>\d</tt></dt>
      <dd><p>Match a digit character</p></dd>
      <dt><tt>\D</tt></dt>
      <dd><p>Match a non-digit character</p></dd>
    </dl>
    <p>Note that `\w' matches a single alphanumeric character, not a whole
      word.  To match a word you'd need to say `\w+'.
      If <tt>UseCzechLocales</tt> is set to non-zero value in TrEd's
      configuration, the list of alphabetic characters generated by `\w' is taken
      from the Czech locale.  You may use
      `\w', `\W', `\s', `\S', `\d', and `\D' within character classes (though
      not as either end of a range).
    </p>
    <p>
      The following zero-width assertions are defined:
    </p>
    <dl>
      <dt><tt>\b</tt></dt>
      <dd><p>Match a word boundary</p></dd>
      <dt><tt>\B</tt></dt>
      <dd><p>Match a non-(word boundary)</p></dd>
      <dt><tt>\A</tt></dt>
      <dd><p>Match at only beginning of string</p></dd>
      <dt><tt>\Z</tt></dt>
      <dd><p>Match at only end of string (or before newline at the end)</p></dd>
    </dl>
    <p>A word boundary (`\b') is defined as a spot between two characters that
      has a `\w' on one side of it and a `\W' on the other side of it (in
      either order), counting the imaginary characters off the beginning and
      end of the string as matching a `\W'.  (Within character classes `\b'
      represents backspace rather than a word boundary.)  The `\A' and `\Z'
      are just like "^" and "$".
    </p>
    <p>
      When the bracketing construct `<tt>( ... )</tt>' is used,
      <tt>\&lt;digit&gt;</tt>
      matches the
      digit'th substring. If you want
      to use parentheses to delimit a subpattern (e.g., a set of alternatives)
      without saving it as a subpattern, follow the <tt>(</tt> with a <tt>?:</tt>.
    </p>
    <p>
      You may have as many parentheses as you wish. 
      Within the pattern, <tt>\10</tt>, <tt>\11</tt>, etc. refer back to substrings
      if there have been at least that many left parentheses before the
      backreference.  Otherwise (for backward compatibility) <tt>\10</tt> is the same
      as <tt>\010</tt>, a backspace, and <tt>\11</tt> the same as
      <tt>\011</tt>,
      a tab.  And so on.  (<tt>\1</tt> through <tt>\9</tt> are always backreferences.)
    </p>
    <p><tt>$+</tt> returns whatever the last bracket match matched. 
      <tt>$&amp;</tt> returns the
      entire matched string.  (<tt>$0</tt> used to return the same thing, but not any
      more.)  `<tt>$`</tt>' returns everything before the matched
      string. 
      `<tt>$'</tt>' returns
      everything after the matched string. 
    </p>
    <p>
      TrEd defines a consistent extension syntax for regular expressions.  The
      syntax is a pair of parentheses with a question mark as the first thing
      within the parentheses (this was a syntax error in older versions of
      Perl).  The character after the question mark gives the function of the
      extension.  Several extensions are already supported:
    </p>
    
    <dl>
      <dt><tt>(?#text)</tt></dt>
      <dd><p>
	A comment.  The text is ignored.  If the `<tt>/x</tt>' switch is used to
	enable whitespace formatting, a simple `<tt>#</tt>' will suffice.</p>
      </dd>
      <dt><tt>(?:regexp)</tt></dt>
      <dd><p>
	This groups things like "<tt>()</tt>" but doesn't make backreferences like
	"<tt>()</tt>" does.</p>
      </dd>
      
      <dt>(?!regexp)</dt>
      <dd> <p>
	A zero-width negative lookahead assertion.  For example
	`<tt>foo(?!bar)</tt>' matches any occurrence of "foo" that isn't followed
	by "bar".  Note however that lookahead and lookbehind are NOT the
	same thing.  You cannot use this for lookbehind: `/(?!foo)bar/'
	will not find an occurrence of "bar" that is preceded by something
	which is not "foo".  That's because the `(?!foo)' is just saying
	that the next thing cannot be "foo"--and it's not, it's a "bar", so
	"foobar" will match.  You would have to do something like
	`<tt>(?!foo)...bar</tt>' for that. We say "like" because there's the case
	of your "bar" not having three characters before it.  You could
	cover that this way: `<tt>(?:(?!foo)...|^..?)bar</tt>'.</p>
      </dd>
      <dt>(?ix)</dt>
      <dd><p>
	One or more embedded pattern-match modifiers. If you need a
	case insensitive pattern you only need to include 
	`<tt>(?i)</tt>' at the front of	the pattern.
	</p>
	<dl>
	  <dt>x</dt>
	  <dd><p>Use extended regular expressions.</p></dd>
	  <dt>i</dt>
	  <dd><p>Do case-insensitive pattern matching.</p></dd>
	</dl>
      </dd>
    </dl>
</body>
</html>
