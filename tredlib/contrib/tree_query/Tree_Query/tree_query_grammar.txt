    {
      $skip = '\s*(?:[#][^\n]*\s*)?';

      {
	package Tree_Query::ParserError;
	use overload '""' => \&as_text;
	sub new {
	  my $class=shift;
	  my $array_ref = shift;
	  bless $array_ref, $class;
	}
	sub as_text {
	  my $self = shift;
	  return 'Parse error at line '.$self->line.': '.$self->message;
	}
	sub message { return $_[0]->[0] }
	sub line    { return $_[0]->[1] }
      }

      sub report_error {
        my ($thisparser,$rule,$text)=@_;
        die
        Tree_Query::ParserError->new($thisparser->{errors}[0]||['Syntax error in '.$rule.' near '.substr($$text,0,20).'...',1]);
      }
      sub new_node {
        my ($hash,$children)=@_;
        my $new = FSNode->new($hash,1);
        if ($children) {
          if (ref($children) eq 'ARRAY') {
             for (reverse @$children) {
                if (ref($_) eq 'FSNode') {
                  $_->paste_on($new)
                } else {
                   warn "new_node: child of $hash->{'#name'} is not a node:\n".
                        Data::Dumper::Dumper([$_]);
                }
             }
          } else {
            warn "new_node: 2nd argument of constructor to $hash->{'#name'} is not an ARRAYref:\n".
            Data::Dumper::Dumper([$children]);
          }
        }
        return $new;
      }
      sub new_struct {
        return Fslib::Struct->new($_[0],1);
      }
      sub new_relation {
        my ($type,$opts)=@_;
	$opts||={};
	$opts->{label}||=$type;
	return Fslib::Seq->new([
          Fslib::Seq::Element->new( 
            $type => Fslib::Container->new(undef,$opts)
          )
        ]);
      }
    }

    parse_query: <leftop: node ';' node> (';')(?) return(s?) /\Z/ 
           { $return=new_node({ @{$item[3]} ? 
	   ('output-filters' => Fslib::List->new(@{$item[3]})) : () },$item[1]); 1 }
         | { report_error($thisparser,'query',\$text); }

    parse_node: (child|opt_child) /\Z/ { $item[1] }
         | { report_error($thisparser,'node',\$text); }

    parse_test: test /\Z/ { $item[1] }
         | { report_error($thisparser,'test',\$text); }

    parse_expression: expression /\Z/ { $item[1] }
         | { report_error($thisparser,'expression',\$text); }

    parse_conditions: lone_conditions(?) /,?\s*\Z/ { $item[1][0] }
         |   { report_error($thisparser,'condition',\$text); }

    parse_column_expression: column_expression /\Z/ { $item[1] }
         | { report_error($thisparser,'column_expression',\$text); }

    node: type(?) var_def(?) '[' <commit> conditions(?) /,?\s*]/ 
          { new_node({ '#name' => 'node', 'node-type' => $item[1][0], name => $item[2][0]}, $item[5][0]) }
        | <error>

    return: '>>' <commit> return_spec (';')(?) { $item[3] } 
          | <error>

    return_spec: group_by(?) ('distinct')(?) columns sort_by(?)
                 { $return=Fslib::Struct->new({ 
		    'return'   => $item[3],
                    'distinct' => scalar(@{$item[2]}),
		    'group-by' => $item[1][0],
		    'sort-by'  => $item[4][0],
		   },1) 
		 }
  
    columns: <leftop: flat_column_expression ',' flat_column_expression> 
                { $return=Fslib::List->new_from_ref($item[1],1) }

    group_by: 'for' columns 'give' { $item[2] } 

    sort_by: 'sort by' columns { $item[2] }

    column_expression: <leftop: column_exp OP column_exp>
                       { @{$item[1]}>1 ? ['EXP',@{$item[1]}] : $item[1][0] }

    flat_column_expression: <rulevar: ($start,$t)> 
              | { ($start,$t)=($thisoffset,$text) } <leftop: column_exp OP column_exp>
                { $return=substr($t,0,$thisoffset-$start); $return=~s/^\s*//; 1 }

    column_exp: column_term | analytic_function

    column_term: '(' <commit> column_expression ')' { $return=$item[3] }
                 | /^\$\d+/ <commit>  { $return=$item[1] }
                 | result_function  { $return=$item[1] }
		 | ref_attribute    { $return=$item[1] }
                 | VARIABLE         { $return='$'.$item[1] }
		 | literal          { $return=$item[1] }
		 | <error>

    result_function: FUNC <skip: ''> '(' <commit> <skip: '\s*(?:[#][^\n]*\s*)?'> result_arguments(?) ')'
                     { ['FUNC', $item[1],$item[6][0] ] }

    analytic_function: ANALYTIC_FUNC <skip: ''> '(' <commit> <skip: '\s*(?:[#][^\n]*\s*)?'> 
		     column_expression(?)
                     over(?) ')'
                     { ['ANALYTIC_FUNC', $item[1], $item[6][0], $item[7][0] ? @{$item[7][0]} : () ] }

    over: 'over' 'all' { ['ALL'] } 
        | 'over' <leftop: column_term ',' column_term> { $item[2] }

    result_arguments: <leftop: column_expression ',' column_expression>
              { $item[1] }

    type: XMLNAME .../\$|\[/
          { $return = $item[1] }

    var_def: VARIABLE ':=' <commit> ...'['
             { $return = $item[1] }

    lone_conditions: condition .../,?\s*\Z/ <commit>         { $return = [$item[1]] }
              | condition /and|,/ <commit> conditions  { $return = [$item[1],@{$item[4]}] }
              | <error>

    conditions: condition .../,?\s*]/ <commit>         { $return = [$item[1]] }
              | condition /and|,/ <commit> conditions  { $return = [$item[1],@{$item[4]}] }
              | <error>

    condition: simple_test { $return = $item[1] }
             | opt_child   { $return = $item[1] }
             | subquery    { $return = $item[1] }
             | child    { $return = $item[1] }
             | ref

    child: RELATION(?) node { $return = $item[2]; $return->{relation}=$item[1][0]; 1 }

    ref: (RELATION|EXTRA_RELATION)(?) VARIABLE
         { $return = new_node({ '#name' => 'ref', target=>$item[2], relation=>$item[1][0] });
         }

    opt_child: '?' <commit> RELATION(?) node
             { $return=$item[4]; $return->{optional}=1; $return->{relation}=$item[3][0]; 1 }

    simple_test: predicate | or_clause | not_clause | and_clause

    test: simple_test 
        | subquery_test
        | ref

    or_clause: '(' <leftop: test 'or' test> ')'
               { new_node({ '#name' => 'or' }, $item[2]) }

    and_clause: '(' <leftop: test /,|and/ test> ')'
              { new_node({ '#name' => 'and'}, $item[2]) }

    not_clause: '!' ( test | or_clause | and_clause )
              {  $return = $item[2];
                 if ($return->{'#name'} eq 'and') {
                   $return->{'#name'} = 'not';
                 } else {
                   $return = new_node({ '#name' => 'not'}, [$return])
                 }
              }

    predicate: VAR_OR_SELF '=' <commit> VAR_OR_SELF
               { new_node({ '#name' => 'test', a=>'$'.$item[1], operator=>$item[2], b=>'$'.$item[4] }) }
             | flat_expression 'in' <commit> flat_set_expression
             | flat_expression CMP <commit> flat_expression
               { new_node({ '#name' => 'test', a=>$item[1], operator=>$item[2], b=>$item[4] }) }

    flat_set_expression: <rulevar: ($start,$t)> 
                       | { ($start,$t)=($thisoffset,$text) } 
                         '{' <leftop: flat_expression ',' flat_expression> '}'
                         { $return=substr($t,0,$thisoffset-$start); $return=~s/^\s*//; 1 }

    flat_expression: <rulevar: ($start,$t)> 
              | { ($start,$t)=($thisoffset,$text) } <leftop: term OP term>
                { $return=substr($t,0,$thisoffset-$start); $return=~s/^\s*//; 1 }

    expression: '{' <commit> <leftop: expression ',' expression> '}'
                { ['SET',@{$item[3]}] }
              | <leftop: term OP term>
                { @{$item[1]}>1 ? ['EXP',@{$item[1]}] : $item[1][0] }
              | VAR_OR_SELF { '$'.$item[1] }

    term: '(' <commit> expression ')' { $return=$item[3] }
        | function         { $return=$item[1] }
        | simple_attribute { $return=$item[1] }
        | ref_attribute    { $return=$item[1] }
        | literal          { $return=$item[1] }
        | <error>

    simple_attribute: XMLNAME ('/' XMLNAME)(s?)
                      { ['ATTR',$item[1],@{$item[2]}] }

    ref_attribute: VARIABLE <skip: ''> '.'  simple_attribute
                   { ['REF_ATTR',$item[1],$item[4]] }

    function: FUNC <skip: ''> '(' <skip: '\s*(?:[#][^\n]*\s*)?'> arguments(?) ')'
              { ['FUNC', $item[1],$item[5][0] ] }

    arguments: <leftop: argument ',' argument>
              { $item[1] }

    argument: expression { $item[1] }
            | VAR_OR_SELF { '$'.$item[1] }

    subquery_test: subquery { $item[1] }
                 | RELATION(?) node { $return=$item[2];
                          $return->{'#name'}='subquery';
                          $return->{relation}=$item[1][0];
                          $return->{occurrences}=new_struct({ min=>1 });
			  1; }

    subquery: occurrences RELATION(?) node
              { $return=$item[3]; 
                $return->{'#name'}='subquery';
                $return->{relation}=$item[2][0];
                $return->{occurrences}=$item[1];
                1;
              }

    occurrences: NUMBER 'x' <commit> 
                 { $return = new_struct({ min=>$item[1], max=>$item[1] }) }
               | NUMBER /[-+]/ <commit> 'x'
                 { $return = new_struct({ ($item[2] eq '-' ? 'max' : 'min') =>$item[1] }) }
               | NUMBER '..' <commit> NUMBER 'x' 
                 { $return = new_struct({ min=>$item[1], max=>$item[4] }) }
               | <error?> <reject>

    literal: NUMBER | 
             STRING

    VAR_OR_SELF: '$$' { $return='$' }
               | VARIABLE

    VARIABLE: /\$[[:alpha:]_][[:alnum:]_]*/
              { $return=$item[1]; $return=~s/^\$//; 1 }

    RELATION: /descendant|ancestor/ <skip:''> '{' 
              <commit> <skip:'\s*(?:[#][^\n]*\s*)?'> NUMBER ',' NUMBER '}'
              { new_relation($item[1],{min_length=>$item[6],max_length=>$item[8]}) }
            | /child|parent|descendant|ancestor/ 
              { new_relation($item[1]) }
            | /${Tree_Query::user_defined}/o
              { new_relation('user-defined',{label => $item[1]}) }
    EXTRA_RELATION: /depth-first-precedes|depth-first-follows|order-precedes|order-follows/
              { new_relation($item[1]) }

    FUNC: /(descendants|lbrothers|rbrothers|sons|depth_first_order|depth|lower|upper|length|substr|ciel|floor|round|trunc|percnt|name|file|tree_no|position)\b/

    ANALYTIC_FUNC: /min|max|sum|avg|count|ratio/

    CMP: /=|~\*?|[<>]=?|in/

    OP: /[-+*&]|div|mod/

    STRING: /'([^'\\]+|\\.)*'/

    NUMBER: /-?[0-9]+(\.[0-9]+)?/

    XMLNAME: /${PMLSchema::CDATA::Name}/o
