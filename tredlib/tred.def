## This is macro file for Tred                           -*-perl-*-
## author: Petr Pajas
## created: Fri Mar 17 14:48:42 CET 2000

###########################################################
# Default macro definitions to make
# calls to global subroutines less humble

my $_NoSuchTree; # for compatibility with Graph2Tred

sub GotoTree {
  my $to=shift;
  $_NoSuchTree=($to != max(0,min($to,$#trees)));
  my $result=gotoTree($to,$grp);
  $this=$root;
  return $result;
}

sub NextTree {
  my $result=nextTree($grp);
  $this=$root;
  $_NoSuchTree=!$result;
  return $result;
}

sub PrevTree { 
  my $result=prevTree($grp);
  $this=$root; 
  $_NoSuchTree=!$result;
  return $result;
}

sub GetOrd { return Ord(shift,\%attribs); }
sub PasteNode { my $node=shift; Paste($node,shift,\%attribs); return $node; }
sub CutNode {
  my $node=shift;
  my $parent=Parent($node);
  $result=Cut($node);
  $this=$parent if ($result and $this==$node);
  return $result;
}

###########################################################
# Macros used by Graph2Tred macro convertor

sub PlainNewSon {
## Adds new son to a given parent
  my $parent=shift;
  return unless ($parent);
  my $nd={};
  NewNode($nd); # blessing NewNode
  PasteNode($nd,$this);
  return $this=$nd;
}

sub PlainDeleteNode {
## Deletes given node
  my $node=shift;
  return undef unless ($node and Parent($node));

  $this=Parent($this) if ($node == $this);
  return DeleteLeaf($node);
}

sub PrintToFile {
  my $file=shift;
  if (open(PTF,">>$file")) {
    print PTF join("",map { s/\\\|/\|/g } @_);
    print PTF "\n";
    close(PTF);
  }
}

sub ValNo {
## return n'th of given string (separated by |); 
  my $n=shift;
  my @val=ListSplit(shift);
  return $val[$n];
}

sub AtrNo {
  return @atord[shift];
}

sub Union {
# make (pairwise disjoint, i.e. set-like) union
# of two lists ( strings with |-delimited elements )
  my @c=();
  my $s;
  my $t;
  element: foreach $s (ListSplit(shift),ListSplit(shift)) {
    for ($t=0;$t<=$#c;$t++) {
      next element if ($c[$t] eq $s);
    }
    push @c,$s;
  }
  return join '|',@c;
}

sub Interjection {
# make interjection of two lists
# ( strings with |-delimited elements )
  my @a=ListSplit(shift);
  my @c=();
  my $s;
  my $t;
  element: foreach $s (ListSplit(Union(shift,""))) {
    for ($t=0;$t<=$#a;$t++) {
      if ($a[$t] eq $s) {
	push(@c,$s);
	next element;
      }
    }
  }
  return join '|',@c;
}

sub ListSplit {
# split |-delimited string to a list
 return split(/\|/, shift);
}

sub ListJoin {
# split |-delimited string to a list
 return join '|', @_;
}

sub ListEq {
# test if two given lists ( strings with |-delimited elements )
# contain the same elements
  my ($a,$b)=(shift,shift);
  $a=Union($a,""); # make them uniqe
  $b=Union($b,""); # make them uniqe
  my @a=ListSplit($a);
  my @b=ListSplit($b);

  return 0 unless ($#a == $#b);

  my @c=ListSplit(Union($a,$b));

  return ($#a == $#c);
}

sub ListAssign {
# args: list, n, value
# assign (string) value to the n'th position in a list
# represented as |-delimited string

  my @a=ListSplit(shift);
  my ($n,$value)=(shift,shift);

  @a[$n]=ValNo(0,$value);
  return join '|',@a;
}

sub SubStr {
  my ($str, $pos, $len)=(shift, shift, shift);

  return "" if ($pos > length($str));
  return substr($str,$pos,$len);
}


#####################################################
# Common useful user-level subroutines 

sub NewRBrother {
## Adds new RBrother to current node and shifts
## ords of the other nodes appropriately
  return unless ($this and Parent($this));

  my $nd={};
  NewNode($nd); # blessing NewNode
  Set($nd,AOrd(\%attribs),Ord($this,\%attribs)+1);
  my $node=$root;
  while ($node) {
    $node->{AOrd(\%attribs)}++ if (Ord($node,\%attribs)>Ord($this,\%attribs));
    $node=Next($node);
  }
  PasteNode($nd,Parent($this));
  $this=$nd;
}

sub NewSon {
## Adds new son to current node and shifts
## ords of the other nodes appropriately
  return unless ($this);

  my $nd={};
  NewNode($nd); # blessing NewNode
  Set($nd,AOrd(\%attribs),Ord($this,\%attribs)+1);
  my $node=$root;
  while ($node) {
    $node->{AOrd(\%attribs)}++ if (Ord($node,\%attribs)>Ord($this,\%attribs));
    $node=Next($node);
  }
  PasteNode($nd,$this);
  $this=$nd;
}

sub DeleteThisNode {
## Deletes current node and shifts
## ords of the other nodes appropriately
  return unless ($this and Parent($this));

  my $parent=Parent($this);
  my $ord=Ord($this,\%attribs);
  if (DeleteLeaf($this)) {
    my $node=$root;
    while ($node) {
      $node->{AOrd(\%attribs)}-- if (Ord($node,\%attribs)>$ord);
      $node=Next($node);
    }
    $this=$parent;
  }
}

sub CopyValues {
  undef %ValuesClipboard;
  %ValuesClipboard = map { $_ => $this->{$_} } keys(%attribs);
  delete $ValuesClipboard{AOrd(\%attribs)}; # we do not copy this
  $FileNotSaved=0;
}

sub PasteValues {
  foreach $_ (keys(%ValuesClipboard)) {
    $this->{$_}=$ValuesClipboard{$_};
  }
}
