## This is macro file for Tred                           -*-cperl-*-
## author: Petr Pajas
## Time-stamp: <2001-11-29 18:39:28 pajas>

package TredMacro;

use base qw(main);
use vars qw(@FORCE_EXPORT);
@FORCE_EXPORT = qw($libDir $grp $root $this $_NoSuchTree $Redraw
                   $forceFileSaved $FileChanged $FileNotSaved $NodeClipboard);
use vars @FORCE_EXPORT;

*FileChanged=*FileNotSaved;	# alias

# set $Redraw to one of "file|tree|win|all|tie"; file is default
# tie means redraw all if windows are tied. Otherwise redraw only
# current window

#  $_NoSuchTree=0;
#  $grp=undef
#  $root=undef;
#  $NodeClipboard=undef;
#  $forceFileSaved=0;
#  $FileNotSaved=0;
import Fslib;
import Fslib qw(&Ord &Value &Hide &SentOrd &AOrd &AValue &AHide &ASentOrd &Index);
import main;

sub import {
  # If specified without parameter, exports everything but
  # names already defined in caller package
  # If parameters are given, exports only names specified by the parameters
  # and few variables that every TredMacro *must* share.

  my $pkg=shift;
  my $caller=caller;
  my %stash=%{"${pkg}::"};
  my ($type,$val);
  my @exports;

  @exports = $#_>=0 ? @_ : keys %stash;
  push @exports,@FORCE_EXPORT;
  foreach my $k (@exports) {
    unless ($k =~ s/^(\W)//) {
      *{"${caller}::$k"} = \&{"${pkg}::$k"} unless defined (&{"${caller}::$k"});
       next;
    }
    $type = $1;
    if ($type eq '&') {
      *{"${caller}::$k"} = \&{"${pkg}::$k"};
    } elsif ($type eq '$') {
      *{"${caller}::$k"} = \${"${pkg}::$k"};
    } elsif ($type eq '@') {
      *{"${caller}::$k"} = \@{"${pkg}::$k"};
    } elsif ($type eq '%') {
      *{"${caller}::$k"} = \%{"${pkg}::$k"};
    } elsif ($type eq '*') {
      *{"${caller}::$k"} = \*{"${pkg}::$k"};
    } else {
      do { warn("Can't export symbol: $type$sym") };
    }
  }
};

###########################################################
# Default macro definitions to make
# calls to global subroutines less humble

sub Redraw {
  my $ie=$main::insideEval;
  $main::insideEval=0;
  &main::redraw_win($grp);
  $main::insideEval=$ie;
}

sub Redraw_FSFile {
  my $ie=$main::insideEval;
  $main::insideEval=0;
  &main::redraw_fsfile($grp->{framegroup},$grp->{FSFile});
  $main::insideEval=$ie;
}

sub Redraw_FSFile_Tree {
  my $ie=$main::insideEval;
  $main::insideEval=0;
  &main::redraw_fsfile($grp->{framegroup},$grp->{FSFile},$grp->{treeNo});
  $main::insideEval=$ie;
}

sub Redraw_All {
  my $ie=$main::insideEval;
  $main::insideEval=0;
  &main::redraw_all($grp->{framegroup});
  $main::insideEval=$ie;
}


sub StandardTredFont {
  return $main::font;
}

sub StandardTredValueLineFont {
  return $main::vLineFont;
}

sub SetCurrentNodeInOtherWin {
  my ($win,$node)=@_;
  TrEd::Basics::setCurrent($win,$node);
}

sub SetDisplayAttrs {
  return unless $grp->{FSFile};
  $grp->{FSFile}->changePatterns(@_);
}

sub SetBalloonPattern {
  return unless $grp->{FSFile};
  $grp->{FSFile}->changeHint(join "\n",@_);
}

sub GetDisplayAttrs {
  return unless $grp->{FSFile};
  return $grp->{FSFile}->patterns();
}

sub GetBalloonPattern {
  return unless $grp->{FSFile};
  return $grp->{FSFile}->hint();
}

sub SwitchContext {
  main::switchContext($grp,shift);
}

sub CurrentContext {
  return $grp->{macroContext};
}

sub GotoTree {
  my $to=shift()-1;
  $_NoSuchTree=($to != main::max(0,min($to,$#trees)));
  my $result=main::gotoTree($grp,$to);
  $root=$grp->{root};
  $this=$root;
  return $result;
}

sub TieNextTree {
  my $result=main::tieNextTree($grp->{framegroup});
  $root=$grp->{root};
  $this=$root;
  $Redraw='tie';
  return $result;
}

sub TiePrevTree {
  my $result=main::tiePrevTree($grp->{framegroup});
  $root=$grp->{root};
  $this=$root;
  $Redraw='tie';
  return $result;
}


sub NextTree {
  my $result=main::nextTree($grp);
  $root=$grp->{root};
  $this=$root;
  $_NoSuchTree=!$result; # for compatibility with Graph2Tred
  return $result;
}

sub PrevTree { 
  my $result=main::prevTree($grp);
  $root=$grp->{root};
  $this=$root;
  $_NoSuchTree=!$result; # for compatibility with Graph2Tred
  return $result;
}

sub GetOrd { return shift->{$grp->{FSFile}->FS->order}; }
sub PasteNode { my $node=shift; Fslib::Paste($node,shift,$grp->{FSFile}->FS->defs); return $node; }
sub CutNode {
  my $node=shift;
  my $parent=Fslib::Parent($node);
  $result=Fslib::Cut($node);
  $this=$parent if ($result and $this==$node);
  return $result;
}

sub NewTree {
  main::newTree($grp);
  $root=$grp->{root};
  $this=$root;
  return $root;
}

sub NewTreeAfter {
  main::newTreeAfter($grp);
  $root=$grp->{root};
  $this=$root;
  return $root;
}

sub Save {
  main::saveFile($grp);
  $forceFileSaved=1;
  $FileNotSaved=0;
}

sub SaveAndNextFile {
  Save();
  main::nextFile($grp);
  $root=$grp->{root};
}

sub SaveAndPrevFile {
  Save();
  main::prevFile($grp);
  $root=$grp->{root};
}

sub Find {
  $grp->{framegroup}->{findButton}->invoke();
  $this=$grp->{currentNode};
  $FileNotSaved=0;
}

sub FindNext {
  $grp->{framegroup}->{findNextButton}->invoke();
  $this=$grp->{currentNode};
  $FileNotSaved=0;
}

sub FindPrev {
  $grp->{framegroup}->{findPrevButton}->invoke();
  $this=$grp->{currentNode};
  $FileNotSaved=0;
}

sub ToplevelFrame {
  return $grp->toplevel();
}

###########################################################
# Macros used by Graph2Tred macro convertor


sub PlainNewSon {
## Adds new son to a given parent
  my $parent=shift;
  return unless ($parent);
  my $nd=FSNode->new();
  PasteNode($nd,$parent);
  return $this=$nd;
}

sub PlainDeleteNode {
## Deletes given node
  my $node=shift;
  return undef unless ($node and Parent($node));

  $this=Parent($this) if ($node == $this);
  return DeleteLeaf($node);
}

sub PrintToFile {
  my $file=shift;
  return unless( defined($file) and $file ne '' );
  my @a=@_;

  if (open(PTF,">>$file")) {
    print PTF (join("",(map {
      s/\\\|/|/g;
      s/\\n/\n/g;
      $_} @a)));
    close(PTF);
} else { print STDERR "Could not open file $file\n"; }
}

sub ValNo {
## return n'th field of given string (separated by |); 
  my $n=shift;
  my @val=ListSplit(shift);
  return $val[$n];
}

sub AtrNo {
  return $grp->{FSFile}->FS->atno(shift);
}

sub Union {
# make (pairwise disjoint, i.e. set-like) union
# of two lists ( strings with |-delimited elements )
  my @c=();
  my $s;
  my $t;
  element: foreach $s (ListSplit(shift),ListSplit(shift)) {
    for ($t=0;$t<=$#c;$t++) {
      next element if ($c[$t] eq $s);
    }
    push @c,$s;
  }
  return join('|',@c);
}

sub Interjection {
# make interjection of two lists
# ( strings with |-delimited elements )
  my @a=ListSplit(shift);
  my @c=();
  my $s;
  my $t;
  element: foreach $s (ListSplit(Union(shift,""))) {
    for ($t=0;$t<=$#a;$t++) {
      if ($a[$t] eq $s) {
	push(@c,$s);
	next element;
      }
    }
  }
  return join '|',@c;
}

sub ListSplit {
# split |-delimited string to a list
  my $s=shift;
  my $j=0,$i=0;
  my @a=();
  while (($j=index($s,'|',$j))>=0) {
    $j++,next if ($j>0 and substr($s,$j-1,1) eq "\\");
    push @a, substr($s,$i,$j-$i);
    $i=++$j; $j=$i;
  }
  push @a, substr($s,$i,length($s)-$i) if ($i<length($s));
  return @a;
}

sub ListJoin {
# split |-delimited string to a list
 return join '|', @_;
}

sub ListEq {
# test if two given lists ( strings with |-delimited elements )
# contain the same elements
  my ($a,$b)=(shift,shift);
  $a=Union($a,""); # make them uniqe
  $b=Union($b,""); # make them uniqe
  my @a=ListSplit($a);
  my @b=ListSplit($b);

  return 0 unless ($#a == $#b);

  my @c=ListSplit(Union($a,$b));

  return ($#a == $#c);
}

sub ListAssign {
# args: list, n, value
# assign (string) value to the n'th position in a list
# represented as |-delimited string

  my @a=ListSplit(shift);
  my ($n,$value)=(shift,shift);

  @a[$n]=ValNo(0,$value);
  return join '|',@a;
}

sub SubStr {
  my ($str, $pos, $len)=(shift, shift, shift);

  return "" if ($pos > length($str));
  return substr($str,$pos,$len);
}


#####################################################
# Common useful user-level subroutines 

sub NewRBrother {
## Adds new RBrother to current node and shifts
## ords of the other nodes appropriately
  return unless ($this and Parent($this));
  my $nd=FSNode->new();
  my $ord=$grp->{FSFile}->FS->order;
  $nd->{$ord}=$this->{$ord}+1;
  my $node=$root;
  while ($node) {
    $node->{$ord}++ if ($node ne $nd and $node->{$ord}>$this->{$ord});
    $node=Next($node);
  }
  PasteNode($nd,Parent($this));
  return $this=$nd;
}

sub NewLBrother {
## Adds new RLrother to current node and shifts
## ords of the other nodes appropriately
  return unless ($this and Parent($this));
  my $nd=FSNode->new();
  my $ord=$grp->{FSFile}->FS->order;
  $nd->{$ord}=$this->{$ord};
  my $node=$root;
  while ($node) {
    $node->{$ord}++ if ($node ne $nd and $node->{$ord}>=$this->{$ord});
    $node=Next($node);
  }
  PasteNode($nd,Parent($this));
  return $this=$nd;
}

sub NewSon {
## Adds new son to current node and shifts
## ords of the other nodes appropriately
  return unless ($this);
  my $nd=FSNode->new();
  my $ord=$grp->{FSFile}->FS->order;
  $nd->{$ord}=$this->{$ord}+1;

  my $node=$root;
  while ($node) {
    $node->{$ord}++ if ($node->{$ord}>$this->{$ord});
    $node=Next($node);
  }
  PasteNode($nd,$this);
  return $this=$nd;
}

sub DeleteThisNode {
## Deletes current node and shifts
## ords of the other nodes appropriately
  return unless ($this and Parent($this));
  my $parent=Parent($this);
  my $ord=$grp->{FSFile}->FS->order;
  my $order=$this->{$ord};

  if (DeleteLeaf($this)) {
    my $node=$root;
    while ($node) {
      $node->{$ord}-- if ($node->{$ord}>$order);
      $node=Next($node);
    }
    $this=$parent;
  }
}

sub CopyValues {
  undef %ValuesClipboard;
  %ValuesClipboard = map { $_ => $this->{$_} } $grp->{FSFile}->FS->attributes;
  delete $ValuesClipboard{$grp->{FSFile}->FS->order}; # we do not copy this
  $FileNotSaved=0;
}

sub PasteValues {
  foreach $_ (keys(%ValuesClipboard)) {
    $this->{$_}=$ValuesClipboard{$_};
  }
}

sub NextNode {
  my ($node,$top)=@_;
  return $node ? main::HNext($grp,$node,$top) : undef;
}

sub PrevNode {
  my ($node,$top)=@_;
  return $node ? main::HPrev($grp,$node,$top) : undef;
}

sub NextVisibleNode {
  my ($node,$top)=@_;
  $node=Next($node,$top);
  my $fs=$grp->{FSFile}->FS;
  while ($node) {
    return $node unless ($fs->isHidden($node));
    $node=Next($node,$top);
  }
  return 0;
}

sub PrevVisibleNode {
  my ($node,$top)=@_;
  $node=Prev($node,$top);
  my $fs=$grp->{FSFile}->FS;
  while ($node) {
    return $node unless ($fs->isHidden($node));
    $node=Prev($node,$top);
  }
  return 0;
}

sub IsHidden {
  my ($node)=@_;
  return $grp->{FSFile}->FS->isHidden($node);
}

## Node shifting macros

# Get all nodes
sub GetNodes {
  my $top = defined($_[0]) ? $_[0] : $root;
  my $node=$top;
  my @n;
  while ($node) {
    push @n,$node;
    $node=$node->following($top);
  }
  return @n;
}

sub GetVisibleNodes {
  my $top = defined($_[0]) ? $_[0] : $root;
  my $node=$top;
  my @n;
  while ($node) {
    push @n,$node;
    $node=NextVisibleNode($node,$top);
  }
  return @n;
}

sub NormalizeOrds {
  my ($nodesref)=@_;

  my $ord=$grp->{FSFile}->FS->order;
  for (my $i=0;$i<=$#$nodesref;$i++) {
    $nodesref->[$i]->{$ord}=$i;
  }
  for (my $i=0;$i<=$#$nodesref;$i++) {
    RepasteNode($nodesref->[$i]);
  }
}

sub SortByOrd {
  my ($nodesref)=@_;
  my $ord=$grp->{FSFile}->FS->order;
  @$nodesref=sort { $a->{$ord} <=> $b->{$ord} } @$nodesref;
}

sub RepasteNode {
  my ($node)=@_;
  my $parent=Parent($node);
  return unless $parent;
  Fslib::Paste(Fslib::Cut($node),$parent,$grp->{FSFile}->FS->defs);
}

sub ShiftNodeRightSkipHidden {
  my ($node)=@_;
  my $ord=$grp->{FSFile}->FS->order;
  return unless $node;
  my @all=GetNodes();
  SortByOrd(\@all);

  # This is sideeffect, but
  # whe want to do this anyway
  NormalizeOrds(\@all);
  #
  #
  print "$n\n";
  my $n=$node->{$ord};
  return $n if ($n == $#all);

  my @vis=GetVisibleNodes();
  SortByOrd(\@vis);
  my $m=Index(\@vis,$node);
  return undef unless (defined($m) and $m<$#vis);
  my $x=min(Index(\@all,$vis[$m+1]),$#all);
  for (my $i=$n+1;$i<=$x;$i++) { $all[$i]->{$ord}--; }
  $node->{$ord}=$x;
  my $parent=Parent($node);
  Fslib::Paste(Fslib::Cut($node),$parent,$grp->{FSFile}->FS->defs);
}

sub ShiftNodeLeftSkipHidden {
  my ($node,$min)=@_;          # min sets the minimum left...
  my $ord=$grp->{FSFile}->FS->order;     # ... boundary for Ord
  return unless $node;
  my @all=GetNodes();
  SortByOrd(\@all);

  # This is sideeffect, but
  # whe want to do this anyway
  NormalizeOrds(\@all);
  #
  #
  print "$n\n";
  my $n=$node->{$ord};
  return $n if ($n == 0);

  my @vis=GetVisibleNodes();
  SortByOrd(\@vis);
  my $m=Index(\@vis,$node);
  return undef unless (defined($m) and !defined($min) || $m>$min);
  my $x=max(Index(\@all,$vis[$m-1]),0);
  for (my $i=$n-1;$i>=$x;$i--) { $all[$i]->{$ord}++; }
  $node->{$ord}=$x;
  RepasteNode($node);
}

sub ShiftNodeRight {
  my ($node)=@_;
  my $ord=$grp->{FSFile}->FS->order;
  return unless $node;
  my @all=GetNodes();
  SortByOrd(\@all);

  # This is sideeffect, but
  # whe want to do this anyway
  NormalizeOrds(\@all);
  #
  #

  my $n=$node->{$ord};
  return $n if ($n == $#all);

  $all[$n+1]->{$ord}=$n;
  $node->{$ord}=$n+1;
  RepasteNode($node);
}

sub ShiftNodeLeft {
  my ($node)=@_;
  my $ord=$grp->{FSFile}->FS->order;
  return unless $node;
  my @all=GetNodes();
  SortByOrd(\@all);

  # This is sideeffect, but
  # whe want to do this anyway
  NormalizeOrds(\@all);
  #
  #

  my $n=$node->{$ord};
  return $n if ($n == 0);

  $all[$n-1]->{$ord}=$n;
  $node->{$ord}=$n-1;
  RepasteNode($node);
}

sub HiddenVisible {
  return (ref($grp->{treeView}) and $grp->{treeView}->get_showHidden());
}
