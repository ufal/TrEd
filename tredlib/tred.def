## This is macro file for Tred                           -*-cperl-*-
## author: Petr Pajas
## $Id$

package TredMacro;
use Exporter;
use Fslib;
use TrEd::MinMax qw(first max maxstr min minstr reduce sum);
use base qw(main Exporter);
use Carp;

use vars qw(@FORCE_EXPORT);
BEGIN {
@FORCE_EXPORT = qw($libDir $grp $root $this $_NoSuchTree $Redraw $stderr $stdout
                   $forceFileSaved $FileChanged $FileNotSaved $NodeClipboard);
}
use vars (@FORCE_EXPORT);

*FileChanged=*FileNotSaved;	# alias

import Fslib;
import Fslib qw(&Index &FindInResources &ResolvePath);
import main;

=pod

=head1 TredMacro

TredMacro (F<tred.def>) - implements the public API for TrEd/bTred macros

=head2 Global variables

=over 4

=item C<$FileChanged> (alias C<$FileNotSaved> - still valid but obsolete)

If this variable is set to 1, TrEd/bTrEd considers the current file to
be modified and in case of bTrEd makes the program to save it before
it is closed (in case of TrEd, user is prompted before the file is
closed). If the macro does not change this variable, bTrEd does not
change the file status, while TrEd still assumes that the file B<was>
modified. In other words, set this variable to 1 in bTrEd if you want
the file to be saved at last, and set this variable to 0 in TrEd if
you are sure you did not make any change to the file that would be
worth saving it. As there is a danger that calling one macro from
another may result in a mess in the value of C<$FileChanged> it is
adviced to use the default macro C<ChangingFile()> which tries to set
the file status only if really intended (see below).

=item C<$Redraw>

This variable makes sense only in TrEd.  You may set it to one of
C<file>, C<tree>, C<win>, C<all>, C<tie> to alter the mechanism of redrawing the
screen. The default value is C<file> (redraw all windows displaying
current file), while C<tree> means redraw all windows displaying
current tree, C<win> means redraw only current window and C<tie> means
redraw all if windows are tied or (if not) redraw only current window.
To disable redrawing set this variable to C<none>.

=item C<$forceFileSaved>

In TrEd, you may wish to set this variable to 0 if you wish to change
the status of the file to C<saved> (e.g. after saving the file from
your macro).

=item C<$root>

Root of the current tree. If possible, avoid changing this variable in
your code, so that other macros you call may use it too.

=item C<$this>

Current node (i.e. the active node in TrEd and the node in turn if
C<-N> or C<-H> flag was used in bTrEd). Assigning a different node
from the current tree to this variable results in changing the active
node in TrEd.

=item C<$libDir>

This variable contains a path to TrEd library directory.

=item C<$grp>

This variable is a hash reference which stores the fundamental piece
of information about the current file, context etc. B<DO
NOT CHANGE IT>. You may, however, use 
this variable to access that information:

=over 5

=item C<$grp-E<gt>{FSFile}>

This field stores the FSFile object of the current file.  See Fslib
or manual to TrEd (section Accessing other trees) for more info.

=item C<$grp-E<gt>{treeNo}>

This field contains index of the current tree.

=item C<$grp-E<gt>{macroContext}>

This field contains the name of current macro context. To change
current context use the pre-defined macro SwitchContext

=back

=back

=cut


## =head2 FUNCTION REFERENCE

###########################################################

=head2 Navigation

Methods of FSNode objects should be used for basic navigation within
trees. Here are described means to navigate from one tree to another
and a few extra macros for specific navigation in trees.

=over 4

=item C<GotoTree(n)>

Display the n'th tree in the current file.

=cut

sub GotoTree {
#  $FileNotSaved=0 if ($FileNotSaved eq '?');
  my $to=shift()-1;
  my $result=main::gotoTree($grp,$to);
  $_NoSuchTree= ($to != $result);
  $root=$grp->{root};
  $this=$root;
  return $result;
}

=item C<TieGotoTree(n)>

Go to n'th tree in all tied windows.

=cut

sub TieGotoTree {
#  $FileNotSaved=0 if ($FileNotSaved eq '?');;
  my $to=shift()-1;
  my $result=main::tieGotoTree($grp->{framegroup},$to);
  $root=$grp->{root};
  $this=$root;
  $Redraw='tie';
  return $result;
}


=item C<TieNextTree()>

Display the next tree in all tied windows.

=cut

sub TieNextTree {
#  $FileNotSaved=0 if ($FileNotSaved eq '?');;
  my $result=main::tieNextTree($grp->{framegroup});
  $root=$grp->{root};
  $this=$root;
  $Redraw='tie';
  return $result;
}

=item C<TiePrevTree()>

Display the previous tree in all tied windows.

=cut

sub TiePrevTree {
#  $FileNotSaved=0 if ($FileNotSaved eq '?');;
  my $result=main::tiePrevTree($grp->{framegroup});
  $root=$grp->{root};
  $this=$root;
  $Redraw='tie';
  return $result;
}

=item C<NextTree()>

Display the next tree in the current file.

=cut

sub NextTree {
#  $FileNotSaved=0 if ($FileNotSaved eq '?');;
  my $result=main::nextTree($grp);
  $root=$grp->{root};
  $this=$root;
  $_NoSuchTree=!$result; # for compatibility with Graph2Tred
  return $result;
}

=item C<PrevTree()>

Display the previous tree in the current file.

=cut

sub PrevTree { 
#  $FileNotSaved=0 if ($FileNotSaved eq '?');;
  my $result=main::prevTree($grp);
  $root=$grp->{root};
  $this=$root;
  $_NoSuchTree=!$result; # for compatibility with Graph2Tred
  return $result;
}


=item C<GetTrees()>

Return a list of trees in current FSFile. Equivallent to
C<$grp-E<gt>{FSFile}-E<gt>trees>.

=cut

sub GetTrees {
  return $grp->{FSFile}->trees;
}

=item C<NextNode(node,top?)>

Return the first displayed node following the given node in the
subtree of top. This function behaves in the same manner as the
node->following(top) method, except it works only on the nodes which
are actually visible according to the state of the View->Show Hidden
Nodes menu item.

=cut

sub NextNode {
  my ($node,$top)=@_;
  return $node ? main::NextDisplayed($grp,$node,$top) : undef;
}

=item C<PrevNode(node,top?)>

Return the first displayed node preceding the given node in the
subtree of top. This function behaves in the same manner as the
node->previous(top) method, except it works only on the nodes which
are actually visible according to the state of the View->Show Hidden
Nodes menu item.

=cut

sub PrevNode {
  my ($node,$top)=@_;
  return $node ? main::PrevDisplayed($grp,$node,$top) : undef;
}

=item C<NextVisibleNode(node,top?)>

Return the first visible node following the given node in the subtree
of top. This function behaves in the same manner as the
C<$node-E<gt>following($top)> method, except that nodes of hidden subtrees
are skipped.

=cut

sub NextVisibleNode {
  my ($node,$top)=@_;
  $node=$node->following($top);
  my $fs=$grp->{FSFile}->FS;
  while ($node) {
    return $node unless ($fs->isHidden($node));
    $node=$node->following($top);
  }
  return 0;
}

=item C<PrevVisibleNode(node,top?)>

Return the first visible node preceding the given node in the subtree
of top. This function behaves in the same manner as the
C<$node-E<gt>previous($top)> method, except that nodes of hidden subtrees
are skipped.

=cut

sub PrevVisibleNode {
  my ($node,$top)=@_;
  $node=$node->previous($top);
  my $fs=$grp->{FSFile}->FS;
  while ($node) {
    return $node unless ($fs->isHidden($node));
    $node=$node->previous($top);
  }
  return 0;
}

=item C<IsHidden(node)>

Return true if the given node is member of a hidden subtree. This
macro is only an abbreviation for
C<$grp-E<gt>{FSFile}-E<gt>FS-E<gt>isHidden(node)>

=cut

sub IsHidden {
  my ($node)=@_;
  return $grp->{FSFile}->FS->isHidden($node);
}

=item C<Hide(node)>

Hide the given node.

=cut

sub Hide {
  my ($node)=@_;
  my $hide=$grp->{FSFile}->FS->hide();
  if ($node and $hide ne "") {
    $node->{$hide}='hide';
    return 1;
  }
  return 0;
}

=item C<GetNodes(top?)>

Get a list of all nodes in the current tree of (if top is given) in
the subtree of top (the root of the tree is icluded as well). The list
returned is ordered in the natural structure ordering.
(This function automatically returns array reference in scalar context.)

=cut

sub GetNodes {
  my $top = defined($_[0]) ? $_[0] : $root;
  my $node=$top;
  my @n;
  while ($node) {
    push @n,$node;
    $node=$node->following($top);
  }
  return wantarray ? @n : \@n;
}

=item C<GetVisibleNodes(top?)>

Return the list of all visible nodes in the subtree of the given top
node (or the whole current tree if no top is given). The list returned
is ordered in the natural structure ordering and all members of hidden
subtrees are skipped.

=cut

sub GetVisibleNodes {
  my $top = defined($_[0]) ? $_[0] : $root;
  my $node=$top;
  my @n;
  while ($node) {
    push @n,$node;
    $node=$node->following_visible($top);
  }
  return @n;
}

=item C<PrevNodeLinear(node,attribute,top?)>

Returns nearest node in the tree preceding the given node in linear
ordering provided by the given attribute. If top node is present, only
a subtree of top is examined.

=cut

sub PrevNodeLinear {
  my ($node, $attr, $top) = @_;

  return undef unless $node;

  my $v=$node->{$attr};
  my $best;
  my $best_v;

  my $nv;
  $node=$top || $root; # reusing variable $node
  while ($node) {
    $nv=$node->{$attr};
    if ($nv < $v and
	(!$best or $nv > $best_v)) {
      $best_v=$nv;
      $best=$node;
    }
    $node=$node->following($top);
  }
  return $best;
}

=item C<NextNodeLinear(node,attribute,top?)>

Returns nearest node in the tree following the given node in linear
ordering provided by the given attribute. If top node is present, only
a subtree of top is examined.

=cut

sub NextNodeLinear {
  my ($node, $attr, $top) = @_;

  return undef unless $node;

  my $v=$node->{$attr};
  my $best;
  my $best_v;

  my $nv;
  $node=$top || $root; # reusing the variable
  while ($node) {
    $nv=$node->{$attr};
    if ($nv > $v and
	(!$best or $nv < $best_v)) {
      $best_v=$nv;
      $best=$node;
    }
    $node=$node->following($top);
  }
  return $best;
}

=item C<CurrentTreeNumber()>

Return current tree number.

=cut

sub CurrentTreeNumber {
  return $grp->{treeNo};
}

=item C<GetNodeIndex()>

Return given node's position in the deep-first tree ordering.

=cut

sub GetNodeIndex {
  my $node = ref($_[0]) ? $_[0] : $this;
  my $i=-1;
  while ($node) {
    $node=$node->previous();
    $i++;
  }
  return $i;
}

=item C<LocateNode(node)>

Return current filename, index of a tree (starting from 1) in the file
to which the node belongs (0 if not found) and node's position in the tree
in the deep-first tree ordering.

=cut

sub LocateNode {
  my $node = ref($_[0]) ? $_[0] : $this;
  if ($node eq $root) {
    return (FileName(),CurrentTreeNumber()+1,GetNodeIndex($node));
  } else {
    my $tree = $node->root;
    my $i = 1;
    foreach my $t (GetTrees()) {
      if ($t == $tree) {
	return (FileName(),$i,GetNodeIndex($node));
	return FileName().'@'.$i.'##1.'.GetNodeIndex($node);
      }
      $i++;
    }
    return (FileName(),0,GetNodeIndex($node));
  }
}

=item C<ThisAddress(node?)>

Return current node's address string in a form of filename#tree_no.index
(tree_no starts from 1 to reflect TrEd's UI convention).

=cut


sub ThisAddress {
  my ($f,$i,$n)=&LocateNode;
  return $f.'##'.$i.'.'.$n;
}

=item C<ThisAddressNTRED(node?)>

Return current node's address string in a form of
ntred://filename@tree_no#1.index (tree_no starts from 1 to reflect
TrEd's UI convention). This address may be opened in TrEd to examine
the tree in memory of a remote btred server.

=cut

sub ThisAddressNTRED {
  my ($f,$i,$n)=&LocateNode;
  return 'ntred://'.$f.'@'.$i.'##1.'.$n;
}

=item C<FPosition(node?)>

Prints the result of C<ThisAddress> on stdout.

=cut

sub FPosition { print ThisAddress(@_),"\n"; }


=item C<NPosition(node?)>

Prints the result of C<ThisAddressNTRED> on stdout.

=cut

sub NPosition { print ThisAddressNTRED(@_),"\n"; }

=back

=cut

###########################################################

=head2 Tree editing API

=over 4

=item C<CutPaste(node,new-parent)>

Cut given node and paste it to a new parent. This macro is safer than
PasteNode since it checks that new-parent isn't a descendant of node
or node itself. This macro dies on error before any change is made.

=cut

sub CutPaste {
  my($cutted,$target)=@_;
  my $p = $target;
  while ($p) {
    if( $p == $cutted ) {
      die("Can't paste node to its descendant or self at ".ThisAddress($cutted));
    }
    $p=$p->parent;
  }
  PasteNode(Cut($cutted),$target);
}

=item C<PasteNode(node,new-parent)>

Paste the subtree of the node under the new-parent.  The root of the
subtree is placed among other children of new-parent with respect to
the numbering attribute.

=cut

sub PasteNode {
  my ($node,$p)=@_; 
  Fslib::Paste($node,$p,$grp->{FSFile}->FS);
  return $node;
}


=item C<CloneSubtree(node)>

Return an identical copy (except that only declared attributes are
preserved) of the given subtree.

=cut

sub CloneSubtree {
  my ($node)=@_;
  return $grp->{FSFile}->FS->clone_subtree($node);
}

=item C<CopyNode(node)>

Return an identical copy (except that only declared attributes are
preserved) of the given node.

=cut

sub CopyNode {
  my ($node)=@_;
  my $nd=FSNode->new();
  foreach (Attributes()) {
    $nd->{$_}=$node->{$_};
  }
  return $nd;
}

=item C<CutNode(node)>

Cut the node's subtree off the tree and return it. By cuttin a subtree
we mean disconnecting it from the rest of the tree. Use PasteNode to
attach it to some node again.

=cut

sub CutNode {
  my $node=shift;
  my $parent=$node->parent;
  $result=Fslib::Cut($node);
  $this=$parent if ($result and $this==$node);
  return $result;
}

=item C<NewTree()>

Create a new tree before the current tree. The new tree consists of
exactly one node. This node is activated and a reference to its FSNode
object is returned.

=cut

sub NewTree {
  main::newTree($grp);
  $root=$grp->{root};
  $this=$root;
  return $root;
}

=item C<NewTreeAfter()>

Create a new tree after the current tree. The new tree consists of
exactly one node. This node is activated and a reference to its FSNode
object is returned.

=cut

sub NewTreeAfter {
  main::newTreeAfter($grp);
  $root=$grp->{root};
  $this=$root;
  return $root;
}

=item C<NewRBrother(node)>

Create a new brother of the given node and recalculate the special FS
numbering attribute values in the whole tree so that the new node is
the first right sibling of the given node.

If no node is given, this function operates on C<$this> and B<resets>
C<$this> to the newly created node. If some node is given the value
of C<$this> is preserved.

=cut

sub NewRBrother {
## Adds new RBrother to current node and shifts
## ords of the other nodes appropriately
  my $ref=ref($_[0]) ? $_[0] : $this;

  return unless ($ref and $ref->parent);
  my $nd=FSNode->new();
  my $ord=$grp->{FSFile}->FS->order;
  $nd->{$ord}=$ref->{$ord}+1;
  my $node=$root;
  while ($node) {
    $node->{$ord}++ if ($node ne $nd and $node->{$ord}>$ref->{$ord});
    $node=$node->following;
  }
  PasteNode($nd,$ref->parent);
  $this=$nd unless ref($_[0]);
  return $nd;
}

=item C<NewLBrother(node)>

Create a new brother of the given node and recalculate the special FS
numbering attribute values in the whole tree so that the new node is
the first left sibling of the given node.

If no node is given, this function operates on C<$this> and B<resets>
C<$this> to the newly created node. If some node is given the value
of C<$this> is preserved.

=cut

sub NewLBrother {
## Adds new RLrother to current node and shifts
## ords of the other nodes appropriately
  my $ref=ref($_[0]) ? $_[0] : $this;
  return unless ($ref and $ref->parent);
  my $nd=FSNode->new();
  my $ord=$grp->{FSFile}->FS->order;
  $nd->{$ord}=$ref->{$ord};
  my $node=$root;
  while ($node) {
    $node->{$ord}++ if ($node ne $nd and $node->{$ord}>=$ref->{$ord});
    $node=$node->following;
  }
  PasteNode($nd,$ref->parent);
  $this=$nd unless ref($_[0]);
  return $nd;
}

=item C<NewSon(parent)>

Create a new child of the given parent node and recalculate the
special FS numbering attribute values in the whole tree so that the
new node is the first node left to the given parent. 

If no parent node is given, this function operates on C<$this> and
B<resets> C<$this> to the newly created node. If a parent node is
given the value of C<$this> is preserved.

=cut

sub NewSon {
## Adds new son to current node and shifts
## ords of the other nodes appropriately
  my $ref=ref($_[0]) ? $_[0] : $this;
  return unless ($ref);
  my $nd=FSNode->new();
  my $ord=$grp->{FSFile}->FS->order;
  $nd->{$ord}=$ref->{$ord}+1;

  my $node=$root;
  while ($node) {
    $node->{$ord}++ if ($node->{$ord}>$ref->{$ord});
    $node=$node->following;
  }
  PasteNode($nd,$ref);
  $this=$nd unless ref($_[0]);
  return $nd;
}

=item C<NewParent(node)>

Create a node between given node and its parent and recalculate the
special FS numbering attribute values in the whole tree so that the
new node is the first node left to the given node. 

If no node is given, this function operates on C<$this> and
B<resets> C<$this> to the newly created node. If a parent node is
given the value of C<$this> is preserved.

=cut

sub NewParent {
  my $ref=ref($_[0]) ? $_[0] : $this;
  return unless ($ref);
  my $nd=FSNode->new();
  my $ord=$grp->{FSFile}->FS->order;
  $nd->{$ord}=$ref->{$ord};
  my $node=$root;
  while ($node) {
    $node->{$ord}++ if ($node->{$ord}>=$ref->{$ord});
    $node=$node->following;
  }
  if ($ref->parent) {
    PasteNode($nd,$ref->parent);
    CutNode($ref);
    PasteNode($ref,$nd);
  } else { # root of the tree
    my $trees=$grp->{FSFile}->treeList();
    my $n;
    for ($n=0;$n<=$#$trees;$n++) {
      last if ($trees->[$n] == $ref);
    }
    if ($n>$#$trees) {
      die "tree not found in current FSFile";
    } else {
      $grp->{FSFile}->set_tree($nd,$n);
    }
    PasteNode($ref,$nd);
  }
  $this=$nd unless ref($_[0]);
  return $nd;
}

=item C<DeleteThisNode()>

Delete the current (C<$this>) node and recalculate the special FS
numbering attribute values in the whole tree so that there is no gap
in the numbering. If the current node is not a leaf or if it is the
root of the current tree, this macro does nothing.

=cut

sub DeleteThisNode {
  return unless $this and $this->parent;
  my $p = $this->parent;
  if (DeleteLeafNode($this)) {
    $this=$p;
  }
}

=item C<DeleteLeafNode(node)>

Delete a leaf node and recalculate the special FS numbering attribute
values in the whole tree so that there is no gap in the numbering. If
a given node is not a leaf, this macro does nothing.

=cut

sub DeleteLeafNode {
## Deletes a given node and shifts
## ords of the other nodes appropriately
  shift unless ref($_[0]);
  my $n = $_[0] || $this;
  return unless ($n);
  my $ord=$grp->{FSFile}->FS->order;
  my $order=$n->{$ord};

  if (DeleteLeaf($n)) {
    my $node=$root;
    while ($node) {
      $node->{$ord}-- if ($node->{$ord}>$order);
      $node=$node->following;
    }
    return 1;
  } else {
    return 0;
  }
}

=item C<DeleteSubtree(node)>

Deletes a whole node's subtree and recalculate the special FS
numbering attribute values in the whole tree so that there is no gap
in the numbering.

=cut

sub DeleteSubtree {
  shift unless ref($_[0]);
  my $n = $_[0] || $this;
  my $top = $n->root;
  if (PlainDeleteSubtree($n)) {
    my $ord=$grp->{FSFile}->FS->order;
    if ($ord ne "") {
      my $i=0;
      for my $node (sort { $a->{$ord} <=> $b->{$ord} } $top,$top->descendants) {
	$node->{$ord} = $i++;
      }
    }
  }
}


=item C<CopyValues()>

Copy the values of all the attributes except the special FS numbering
attribute of the current node to a global hash variable named
%ValuesClipboard.

=cut

my %ValuesClipboard;
sub CopyValues {
  undef %ValuesClipboard;
  %ValuesClipboard = map { $_ => $this->{$_} } $grp->{FSFile}->FS->attributes;
  delete $ValuesClipboard{$grp->{FSFile}->FS->order}; # we do not copy this
#  $FileNotSaved=0 if ($FileNotSaved eq '?');;
}

=item C<PasteValues()>

Replace the values of the current node's attributes by those stored in
the global hash variable named %ValuesClipboard.

=cut

sub PasteValues {
  foreach $_ (keys(%ValuesClipboard)) {
    $this->{$_}=$ValuesClipboard{$_};
  }
}

=item C<PlainNewSon(parent)>

Add a new child node to the given parent and make it the current
node (by setting C<$this> to point to it).

=cut

sub PlainNewSon {
## Adds new son to a given parent
  my $parent=shift;
  return unless ($parent);
  my $nd=FSNode->new();
  PasteNode($nd,$parent);
  return $this=$nd;
}

=item C<PlainDeleteNode()>

Delete the given node. The node must be a leaf of the tree (may not
have any children) and must have a parent (may not be the root of the
tree).

=cut

sub PlainDeleteNode {
## Deletes given node
  my $node=shift;
  return undef unless ($node and $node->parent);

  $this=$this->parent if ($node == $this);
  return DeleteLeaf($node);
}

=item C<PlainDeleteSubtree(node)>

Cut a the given node's subtree and destroy all its nodes.
This macro doesn't recalculate ordering attributes.

=cut

sub PlainDeleteSubtree {
  shift unless ref($_[0]);
  my $n = $_[0] || $this;
  return 0 unless ($n);
  $n->destroy();
  return 1;
}

=item C<NormalizeOrds(listref)>

Adjusts the special FS numbering attribute of every node of the list
referenced by the listref argument so that the value for the attribute
corresponds to the order of the node in the list.

=cut

sub NormalizeOrds {
  my ($nodesref)=@_;

  my $ord=$grp->{FSFile}->FS->order;
  for (my $i=0;$i<=$#$nodesref;$i++) {
    $nodesref->[$i]->{$ord}=$i;
  }
  for (my $i=0;$i<=$#$nodesref;$i++) {
    RepasteNode($nodesref->[$i]);
  }
}

=item C<SortByOrd(listref)>

Sort the list of nodes referenced by the listref argumnt according to
the values of the special FS numbering attribute.

=cut

sub SortByOrd {
  my ($nodesref)=@_;
  my $ord=$grp->{FSFile}->FS->order;
  local ($a,$b);
  @$nodesref=sort { $a->{$ord} <=> $b->{$ord} } @$nodesref;
  return $nodesref;
}

=item C<RepasteNode(node)>

Cut the given node and paste it immediately on the same parent so that
its structural position between its parent children is brought to
correspondence with the values of the special FS numbering attribute.

=cut

sub RepasteNode {
  my ($node)=@_;
  my $parent=$node->parent;
  return unless $parent;
  CutPaste($node,$parent);
}

=item C<ShiftNodeRightSkipHidden(node)>

Shift the current node in the tree to the right leaping over all
hidden subtress by modifying the tree structure and value of the
special FS numbering attribute appropriately.

=cut

sub ShiftNodeRightSkipHidden {
  my ($node)=@_;
  my $ord=$grp->{FSFile}->FS->order;
  return unless $node;
  my @all=GetNodes();
  SortByOrd(\@all);

  # This is sideeffect, but
  # whe want to do this anyway
  NormalizeOrds(\@all);
  #
  #
  my $n=$node->{$ord};
  return $n if ($n == $#all);

  my @vis=GetVisibleNodes();
  SortByOrd(\@vis);
  my $m=Index(\@vis,$node);
  return undef unless (defined($m) and $m<$#vis);
  my $x=min(Index(\@all,$vis[$m+1]),$#all);
  for (my $i=$n+1;$i<=$x;$i++) { $all[$i]->{$ord}--; }
  $node->{$ord}=$x;
  RepasteNode($node);
}

=item C<ShiftNodeLeftSkipHidden(node,min?)>

Shift the current node in the tree to the left leaping over all hidden
subtress by modifying the tree structure and value of the special FS
numbering attribute appropriately. The optional argument min may be
used to specify the minimum left boundary for the value of the
ordering attribute of node.

=cut

sub ShiftNodeLeftSkipHidden {
  my ($node,$min)=@_;          # min sets the minimum left...
  my $ord=$grp->{FSFile}->FS->order;     # ... boundary for Ord
  return unless $node;
  my @all=GetNodes();
  SortByOrd(\@all);

  # This is sideeffect, but
  # whe want to do this anyway
  NormalizeOrds(\@all);
  #
  #
  my $n=$node->{$ord};
  return $n if ($n == 0);

  my @vis=GetVisibleNodes();
  SortByOrd(\@vis);
  my $m=Index(\@vis,$node);
  return undef unless (defined($m) and !defined($min) || $m>$min);
  my $x=max(Index(\@all,$vis[$m-1]),0);
  for (my $i=$n-1;$i>=$x;$i--) { $all[$i]->{$ord}++; }
  $node->{$ord}=$x;
  RepasteNode($node);
}

=item C<ShiftNodeRight(node)>

Shift the current node in the tree to the right by modifying the tree
structure and value of the special FS numbering attribute
appropriately.

=cut

sub ShiftNodeRight {
  my ($node)=@_;
  my $ord=$grp->{FSFile}->FS->order;
  return unless $node;
  my @all=GetNodes();
  SortByOrd(\@all);

  # This is sideeffect, but
  # whe want to do this anyway
  NormalizeOrds(\@all);
  #
  #

  my $n=$node->{$ord};
  return $n if ($n == $#all);

  $all[$n+1]->{$ord}=$n;
  $node->{$ord}=$n+1;
  RepasteNode($node);
}

=item C<ShiftNodeLeft(node)>

Shift the current node in the tree to the right by modifying the tree
structure and value of the special FS numbering attribute
appropriately.

=cut

sub ShiftNodeLeft {
  my ($node)=@_;
  my $ord=$grp->{FSFile}->FS->order;
  return unless $node;
  my @all=GetNodes();
  SortByOrd(\@all);

  # This is sideeffect, but
  # whe want to do this anyway
  NormalizeOrds(\@all);
  #
  #

  my $n=$node->{$ord};
  return $n if ($n == 0);

  $all[$n-1]->{$ord}=$n;
  $node->{$ord}=$n-1;
  RepasteNode($node);
}

=back

=cut

###########################################################

=head2 Helper macros for attributes with list or alternatives of values

=over 4

=cut

=item C<IsList(value)>

Check that a given value is a list, i.e. Fslib::List object.

=cut

sub IsList {
  return 1 if ref($_[0]) eq 'Fslib::List';
}

=item C<IsAlt(value)>

Check that a given value is an alternative, i.e. Fslib::Alt object.

=cut

sub IsAlt {
  return 1 if ref($_[0]) eq 'Fslib::Alt';
}

=item C<List(value,value,...)>

Return a new list (Fslib::List object) populated with given values.

=cut

sub List {
  Fslib::List->new(@_);
}

=item C<Alt(value,value,...)>

Return a new alternative (Fslib::Alt object) populated with given values.

=cut

sub Alt {
  Fslib::Alt->new(@_);
}

=item C<AltV(value)>

If the value is an alternative (i.e. a Fslib::Alt object), return
all its values. Otherwise return value.

=cut

sub AltV {
  ref($_[0]) eq 'Fslib::Alt' ? @{$_[0]} : $_[0]
}

=item C<ListV(value)>

If the value is a list (i.e. a Fslib::List object), return
all its values. Otherwise return empty (Perl) list.

=cut

sub ListV {
  ref($_[0]) eq 'Fslib::List' ? @{$_[0]} : ()
}

=item C<AddToAlt(node,attr,value,value...)>

Add given values as alternatives to the current value of
C<$node-E<gt>{$attr}>.  If only one value is given and C<$node-E<gt>{$attr}> is
empty or same as value, the given value is simply assigned to it. If
C<$node-E<gt>{$attr}> is a C<Fslib::Alt> object, the new values are simply added
to it. Otherwise, if C<$node-E<gt>{$attr}> is a simple value, C<$node-E<gt>{$attr}>
is set to a new C<Fslib::Alt> object containing the original value as
well as the given values.

=cut

sub AddToAlt {
  my ($node,$attr)=(shift,shift);
  if ($node->{$attr} eq "") {
    if (@_>1) {
      $node->{$attr}=Fslib::Alt->new(uniq(@_));
    } else {
      $node->{$attr}=$_[0];
    }
  } elsif (IsAlt($node->{$attr})) {
    @{$node->{$attr}} = uniq(@{$node->{$attr}},@_);
  } else {
    @{$node->{$attr}} = Fslib::Alt->new($node->{$attr},@_);
  }
}

=item C<AddToList(node,attr,value,value,...)>

Add values to a given attribute. If C<$node-E<gt>{$attr}> is not defined or
empty, a new C<Fslib::List> containing given values is created. If
C<$node-E<gt>{$attr}> is a C<Fslib::List> object, given values are simply added
to it. Error is issued if C<$node-E<gt>{$attr}> is defined, non-empty, yet not
a C<Fslib::List> object.

=cut

sub AddToList {
  my ($node,$attr)=(shift,shift);
  my $val = $node->attr($attr);
  if (IsList($val)) {
    push @$val,@_;
  } elsif ($val eq "") {
    $val = Fslib::List->new(@_);
    $node->set_attr($attr,$val,1);
  } else {
    die "AddToList: Attribute '$attr' contains a non-empty non-list value. Refusing to add '$val'!\n"
  }
}


=back

=head2 General-purpose list functions

=over 4

=cut

sub uniq { my %a; grep { !($a{$_}++) } @_ }

=item C<Index(array-ref,item)>

A helper function which returns the first occurence of the item in the
array.

=cut

# imported from Fslib

=item C<ListIntersect(array-ref,array-ref,...)>

Compute intersection of given lists. In scalar context returns an
array-ref, in list context returns a list. All duplicities are
removed.

=cut

sub ListIntersect {
  my %counts;
  my $first = shift;
  $counts{$_}++ for (map { @$_ } @_);
  my $count  = scalar(@_);
  my @res = uniq grep { $counts{$_}==$count } @{$first};
  return wantarray ? @res : List(@res);
}

=item C<ListSubtract(array-ref, array-ref)>

Return elements occuring in the first list but not in the second list.
In scalar context returns a Fslib::List object (array-ref), in list
context returns a list. All duplicities are removed.

=cut

sub ListSubtract($$) {
  my %a; @a{ @{$_[1]} }=();
  my @res = grep { !exists($a{$_}) ? $a{$_}=1 : 0 } @{$_[0]};
  return wantarray ? @res : List(@res);
}


=item C<ListUnion(array-ref, array-ref, ...)>

Return union of given lists. In scalar context returns an array-ref,
in list context returns a Fslib::List object (array-ref). All
duplicities are removed.

=cut

sub ListUnion {
  my @res = uniq map @$_,@_;
  return wantarray ? @res : List(@res);
}


=item C<ListRegroupElements(array-ref, array-ref, ...)>

This is rotate-matrix like operation. The input is a list of
rows (array-refs each representing a row in a matrix); the output
is a list of columns in the matrix (a list of array-refs, each
representing a column in the matrix).

=cut

sub ListRegroupElements {
  my @r;
  for (my $row=0; $row<@_;$row++) {
    for (my $col=0; $col<@{$_[$row]}; $col++) {
      $r[$col][$row] = $_[$row][$col];
    }
  }
  return wantarray ? @r : List(@r);
}

=back

=cut

=head2 GUI-related macros

=over 4

=item C<GUI()>

Return 1 if running from TrEd, i.e., GUI is available.

=cut


sub GUI {
  return (ref($grp) eq 'TrEd::Window');
}

#ifdef TRED

=item C<Redraw()>

Force TrEd to immediately redraw the current window. Hence TrEd
redraws the tree right after an interactively invoked macro finishes,
explicit calls to Redraw macro are needed rather rearly (for example
from a hook).

=cut

sub Redraw {
  confess "Can't call Redraw without a GUI\n" unless GUI();
  my $ie=$main::insideEval;
  $main::insideEval=0;
  &main::setCurrent($grp,$this) if ($this);
  &main::get_nodes_win($grp);
  &main::redraw_win($grp);
  $main::insideEval=$ie;
}

=item C<Redraw_FSFile()>

Force TrEd to immediately redraw all windows displaying current
file.

=cut

sub Redraw_FSFile {
  confess "Can't call Redraw without a GUI\n" unless GUI();
  my $ie=$main::insideEval;
  $main::insideEval=0;
  &main::setCurrent($grp,$this) if ($this);
  &main::get_nodes_fsfile($grp->{framegroup},$grp->{FSFile});
  &main::redraw_fsfile($grp->{framegroup},$grp->{FSFile});
  $main::insideEval=$ie;
}

=item C<Redraw_FSFile_Tree()>

Force TrEd to immediately redraw all windows displaying current
tree.

=cut

sub Redraw_FSFile_Tree {
  confess "Can't call Redraw without a GUI\n" unless GUI();
  my $ie=$main::insideEval;
  $main::insideEval=0;
  &main::setCurrent($grp,$this) if ($this);
  &main::get_nodes_fsfile_tree($grp->{framegroup},$grp->{FSFile},$grp->{treeNo});
  &main::redraw_fsfile_tree($grp->{framegroup},$grp->{FSFile},$grp->{treeNo});
  $main::insideEval=$ie;
}

=item C<Redraw_All()>

Force TrEd to immediately redraw all windows.

=cut

sub Redraw_All {
  confess "Can't call Redraw without a GUI\n" unless GUI();
  my $ie=$main::insideEval;
  $main::insideEval=0;
  &main::setCurrent($grp,$this) if ($this);
  &main::get_nodes_all($grp->{framegroup});
  &main::redraw_all($grp->{framegroup});
  $main::insideEval=$ie;
}

=item C<RedrawStatusLine()>

Force TrEd to immediately redraw status line.

=cut

sub RedrawStatusLine {
  confess "Can't call Redraw without a GUI\n" unless GUI();
  local $main::insideEval=0;
  &main::setCurrent($grp,$this) if ($this);
  &main::updateStatusLine($grp);
}


=item C<EditAttribute(node,attribute)>

Open edit attribute GUI.

=cut

sub EditAttribute {
  confess "Can't call EditAttribute without a GUI\n" unless GUI();
  main::doEditAttr($grp,@_);
}

#endif TRED

=item C<Find()>

Open the Find Node by Attributes GUI dialog.

=cut

sub Find {
  confess "Can't call Find without a GUI\n" unless GUI();
  $grp->{framegroup}->{findButton}->invoke();
  $this=$grp->{currentNode};
#  $FileNotSaved=0 if ($FileNotSaved eq '?');;
}

=item C<FindNext()>

Searches for the first node matching the criteria of the previous use
of the Find... menu command or FindNode macro usage.

=cut

sub FindNext {
  confess "Can't call FindNext without a GUI\n" unless GUI();
  $grp->{framegroup}->{findNextButton}->invoke();
  $this=$grp->{currentNode};
#  $FileNotSaved=0 if ($FileNotSaved eq '?');;
}

=item C<FindPrev()>

Searches for the previous node matching the criteria of the previous
use of the Find... menu command or FindNode macro usage.

=cut

sub FindPrev {
  confess "Can't call FindPrev without a GUI\n" unless GUI();
  $grp->{framegroup}->{findPrevButton}->invoke();
  $this=$grp->{currentNode};
#  $FileNotSaved=0 if ($FileNotSaved eq '?');;
}

=item C<ToplevelFrame()>

Returns the Tk::Toplevel object containing the current window.

=cut

sub ToplevelFrame {
  return $grp->toplevel();
}

=item C<PrintDialog(...)>

See the description in the L<Printing trees> section.

=cut


=item C<ErrorMessage(message)>

In TrEd, show a dialog box containing the given error-message.
In BTrEd print the error message on standard output.

=cut

sub ErrorMessage {
  TrEd::Basics::errorMessage($grp,join("",@_));
}

=item C<StandardTredFont()>

Return a string or Tk::Font object representation of the font used in
TrEd to label tree-nodes.

=cut

sub StandardTredFont {
  return $main::font;
}

=item C<StandardTredValueLineFont()>

Return a string or Tk::Font object representation of the font used in
TrEd to display the "sentence" above the tree.

=cut

sub StandardTredValueLineFont {
  return $main::vLineFont;
}

=item C<SetCurrentNodeInOtherWin(win,node)>

Set active node for a given window.

=cut

sub SetCurrentNodeInOtherWin {
  my ($win,$node)=@_;
  TrEd::Basics::setCurrent($win,$node);
}

=item C<CenterOtherWinTo(win,node)>

Center given window to a given node.

=cut

sub CenterOtherWinTo {
  my ($win,$node)=@_;
  main::centerTo($win,$node);
}


=item C<HiddenVisible()>

Return true if TrEd presently displays hidden nodes.

=cut

sub HiddenVisible {
  return (ref($grp->{treeView}) and $grp->{treeView}->get_showHidden());
}

=back

=cut

###########################################################

=head2 Stylesheet API

=over 4

=item C<STYLESHEET_FROM_FILE()>

This function returns a symbolic name for a virtual stylesheet that is
constructed from the patterns and hint specified in the currently
displayed file.

=cut

sub STYLESHEET_FROM_FILE { &main::STYLESHEET_FROM_FILE }

=item C<SetStylesheetPatterns(patterns,stylesheet,create)>

Set TrEd's display patterns for a given stylesheet. If stylesheet is
undefined, then the stylesheet currently selected for the active view
is used. The patterns argument should either be a string or an array
reference.  If it is a string, then it should provide all the
patterns, each pattern starting on a new line (but possibly spanning
across several lines) which starts with a pattern prefix of the form
"something:", where "something" is hint for the hint pattern, or
"node" for the node pattern, etc.

Patterns can also be provided as an array reference containing two
elements: the first one being a hint text and the second one an array
reference whose each element is the text of an individual pattern.

The create flag can be set to 1 in order to create a new stylesheet in
case that no stylesheet with the given exists.

This function returns 1 if success, 0 if failed (i.e. when create is
not set and a given stylesheet is not found).

=cut

sub SetStylesheetPatterns {
  my ($patterns,$stylesheet,$create) = @_;
  main::setStylesheetPatterns($grp,$patterns,$stylesheet,$create);
}

=item C<DeleteStylesheet(stylesheet)>

Delete given stylesheet. All windows using that stylesheet are
switched to the pattern and hint specified in the respective files
they display.

=cut

sub DeleteStylesheet {
  my ($stylesheet) = @_;
  main::deleteStylesheet($grp->{framegroup},$stylesheet) unless GUI();
}

=item C<SaveStylesheets()>

Save all TrEd's stylesheets (to ~/.tred-stylesheets).

=cut

sub SaveStylesheets {
  my ($patterns,$stylesheet) = @_;
  main::saveStyleSheets($grp->{framegroup}) unless GUI();
}

=item C<ReloadStyleseets(filename?)>

Reload stylesheets from a given file. If no filename is specified, the
default path "~/.tred-stylesheets" is used.

=cut

sub ReloadStylesheets {
  my ($filename) = @_;
   main::readStyleSheets($grp->{framegroup},$filename) unless GUI();
}

=item C<GetStylesheetPatterns(stylesheet)>

For a given stylesheet, return it's patterns. In a scalar context,
returns a string consisting of all patterns, including the hint.  In
the array context returns two scalars: the first one containing the
text of the hint pattern and the other a reference to a list
containing the stylesheet patterns. Returns empty list if fail.

=cut

sub GetStylesheetPatterns {
  my ($stylesheet)=@_;
  return main::getStylesheetPatterns($grp,$stylesheet);
}

=item C<GetPatternsByPrefix(prefix,stylesheet?)>

Return all patterns of a given stylesheet starting with a given prefix.
If no stylesheet name is given, a current stylesheet is used.

=cut

sub GetPatternsByPrefix {
  my ($prefix,$stylesheet)=@_;
  my ($hint,$patterns) = main::getStylesheetPatterns($grp,$stylesheet);
  if ($prefix eq 'hint') {
    return $hint;
  } else {
    return map { /^\Q$prefix\E:\s*((?:.|\n)*?)\s*$/ ? $1 : () } @$patterns;
  }
}

=item C<StylesheetExists(stylesheet)>

Returns true if stylesheet with a given name exists.

=cut

sub StylesheetExists {
  if (GUI()) {
    return 1 if exists ($grp->{framegroup}{stylesheets})
      and exists ($grp->{framegroup}{stylesheets}{$_[0]})
  }
}

=item C<Stylesheets()>

Returns a list of TrEd's stylesheet names.

=cut

sub Stylesheets {
  if (GUI()) {
    return (keys(%{$grp->{framegroup}{stylesheets}}));
  }
}

=item C<SetCurrentStylesheet()>

Set stylesheet for the active window.

=cut

sub SetCurrentStylesheet {
  if (GUI()) {
    if (StylesheetExists($_[0]) or $_[0] eq STYLESHEET_FROM_FILE()) {
      $grp->{framegroup}{selectedStylesheet} = $_[0];
      return main::switchStylesheet($grp->{framegroup},$_[0]);
    }
  }
  return -1;
}

=item C<GetCurrentStylesheet()>

Returns name of the stylesheet currently selected for the active
window.

=cut

sub GetCurrentStylesheet {
  if (GUI()) {
    return $grp->{stylesheet};
  }
}

=item C<GetSpecialPattern(prefix)> - OBSOLETE!!

This macro is obsoleted by GetPatternsByPrefix.

=cut

sub GetSpecialPattern {
  my ($patname)=@_;
  return unless $grp->{FSFile};
  warn "GetSpecialPattern is obsolete: use GetPatternsByPrefix('$patname',STYLESHEET_FROM_FILE()) instead\n";
  my ($pat) = GetPatternsByPrefix($patname,STYLESHEET_FROM_FILE());
  return $pat;
}

=item C<SetDisplayAttrs(pattern,...)> - OBSOLETE!!

Setup given patterns as a stylesheet of
the currently displayed FSFile. This doesn't include
a hint pattern.

=cut

sub SetDisplayAttrs {
  return unless $grp->{FSFile};
  warn "SetDisplayAttrs is obsolete: use SetStylesheetPatterns([...],STYLESHEET_FROM_FILE()) instead\n";
  $grp->{FSFile}->changePatterns(@_);
}

=item C<SetBalloonPattern(string,...)> - OBSOLETE!!

Use given strings as a C<hint:> pattern for
the currently displayed FSFile.

=cut

sub SetBalloonPattern {
  return unless $grp->{FSFile};
  $grp->{FSFile}->changeHint(join "\n",@_);
  warn "SetBalloonPattern is obsolete: use SetStylesheetPatterns([...],STYLESHEET_FROM_FILE()) instead\n";
}

=item C<GetDisplayAttrs()> - OBSOLETE!!

Get patterns of the currently displayed FSFile's stylesheet, except
for a C<hint:> pattern.

=cut

sub GetDisplayAttrs {
  return unless $grp->{FSFile};
  warn "GetDisplayAttrs is obsolete: use GetStylesheetPatterns(STYLESHEET_FROM_FILE()) instead\n";
  return $grp->{FSFile}->patterns();
}

=item C<GetBalloonPattern()> - OBSOLETE!!

Get a C<hint:> pattern of the currently displayed
FSFile's stylesheet.

=cut

sub GetBalloonPattern {
  return unless $grp->{FSFile};
  warn "GetBalloonPattern is obsolete: use (\$hint)=GetPatternsByPrefix('hint',STYLESHEET_FROM_FILE()) instead\n";
  return $grp->{FSFile}->hint();
}


=item C<CustomColor(name,new-value?)>

Get or set user defined custom color.

=cut


sub CustomColor {
  my ($color,$value)=@_;
#ifdef TRED
  if (defined($value)) {
    $TrEd::Config::treeViewOpts->{customColors}->{$color}=$value;
  } else {
    $value = $TrEd::Config::treeViewOpts->{customColors}->{$color};
    return $value;
  }
#endif TRED
}

=item C<UserConf(name,new-value?)>

Get or set value of a user defined configuration option.

=cut

sub UserConf {
  my ($name,$value)=@_;
  if (@_>=1) {
    $TrEd::Config::userConf->{$name}=$value;
  } else {
    $TrEd::Config::userConf->{$name};
  }
}


=item C<AddStyle(styles,object,key =E<gt> value,...)>

Auxiliary funcion: add styles for an object to a given
style-hash (can be used e.g. from node_style_hook).

=cut

sub AddStyle {
  my $styles=shift;
  my $style=shift;
  if (exists($styles->{$style})) {
    push @{$styles->{$style}},@_
  } else {
    $styles->{$style}=[@_];
  }
}

=back

=cut

###########################################################

=head2 Context API

=over 4

=item C<SwitchContext()>

Switch to given macro context.

=cut

sub SwitchContext {
  main::switchContext($grp,shift);
}

=item C<SwitchContextForWindow()>

Switch given window to given macro context.

=cut

sub SwitchContextForWindow {
  main::switchContext(@_);
}

=item C<CurrentContext()>

Return the name of the current macro context.

=cut

sub CurrentContext {
  return $grp->{macroContext};
}

=back

=cut


###########################################################

=head2 FSFormat API

Here are described for working with FSFormat objects. Beside these
macros, FSFormat object methods can be used.

=over 4

=item C<FS()>

Return FSFormat object associated with the current FSFile.

=cut

sub FS {
  return $grp->{FSFile}->FS;
}

=item C<GetOrd(node)>

Return value of the special numbering FS attribute. This macro
actually returns the same value as
C<$node-E<gt>{$grp-E<gt>{FSFile}-E<gt>FS-E<gt>order()}>

=cut

sub GetOrd { return $_[0]->{$grp->{FSFile}->FS->order}; }


=item C<Attributes()>

Return a list of names of all attributes declared in the header of the
current FS file.

=cut

sub Attributes {
  if (ref($grp->{FSFile}->metaData('schema'))) {
    return $grp->{FSFile}->metaData('schema')->attributes()
  } else {
    return $grp->{FSFile}->FS->attributes;
  }
}

=item C<SubstituteFSHeader(declarations)>

Substitute a new FS header for current document. A list of valid FS
declarations must be passed to this function.

=cut

sub SubstituteFSHeader {
  $grp->{FSFile}->changeFS(FS()->create(@_));
}


=item C<AppendFSHeader(declarations)>

Merge given FS header declarations with the present header
of the current document.

=cut

sub AppendFSHeader {
  my $new=FS()->create(@_);
  my $newdefs=$new->defs();
  my $fs=$grp->{FSFile}->FS;
  my $defs=$grp->{FSFile}->FS->defs();
  my $list=$grp->{FSFile}->FS->list();
  foreach ($new->attributes()) {
    push @$list, $_ unless ($fs->exists($_));
    $defs->{$_}=$newdefs->{$_};
  }
  @{$fs->unparsed}=$fs->toArray() if $fs->unparsed;
}

=item C<UndeclareAttributes(attribute,...)>

Remove declarations of given attributes from the FS header

=cut

sub UndeclareAttributes {
  my $fs=$grp->{FSFile}->FS;
  my $defs=$grp->{FSFile}->FS->defs();
  my $list=$grp->{FSFile}->FS->list();
  delete @{$defs}{@_};

  @$list=grep { exists($defs->{$_}) } @$list;
  @{$fs->unparsed}=grep { !/^\@\S+\s+([^\s|]+)/ || exists($defs->{$1})  }
    @{$fs->unparsed} if $fs->unparsed;

}

=back

=cut

###########################################################

=head2 FSFile I/O API

See also FSFile object methods defined in L<Fslib>.

=over 4

=item C<ChangingFile(0|1)>

If no argument given the default is 1. If C<$FileChanged> is already
set to 1 already 1, does nothing. If C<$FileChanged> has not yet been
assigned or is zero, sets it to the given value. Returns the resulting
value. C<ChangingFile(1)> also resets C<$forceFileSaved> to 0.

=cut

sub ChangingFile {
  my ($val)=@_;
  $val=1 if !defined($val);
  if ($FileChanged eq '?') {
    $FileChanged=$val;
  } elsif ($FileChanged==0) {
    $FileChanged=$val;
  }
  $forceFileSaved=0 if ($val);
  return $FileChanged;
}

=item C<Open(filename)>

Open a given FSFile in TrEd.

=cut

sub Open {
  if (exists($grp->{framegroup})) {
    main::openFile($grp->{framegroup},$_[0]);
  } else {
    main::openFile($grp,$_[0]);
  }
}

=item C<Save()>

Save the current FSFile.

=cut

sub Save {
  main::saveFile($grp);
  $forceFileSaved=!GetFileSaveStatus();
  $FileNotSaved=0;
}

=item C<GetFileSaveStatus()>

Return 1 if some file modification was noticed by TrEd untill last save
or reload, 0 otherwise.

=cut

sub GetFileSaveStatus {
  return $grp->{FSFile} ? $grp->{FSFile}->notSaved : 0;
}

=item C<SetFileSaveStatus()>

Use SetFileSaveStatus(1) to declare that some modification was made to
the file. Use SetFileSaveStatus(0) after the file was saved from a
macro (and TrEd/bTrEd would not notice that).

=cut

sub SetFileSaveStatus {
  $grp->{FSFile}->notSaved($_[0]) if $grp->{FSFile};
}


=item C<DefaultInputEncoding()>

Return's TrEd's/bTrEd's default IO encoding.

=cut

sub DefaultInputEncoding {
  return $TrEd::Convert::inputenc;
}


=item C<SetDefaultInputEncoding(encoding)>

Set TrEd's/bTrEd's default IO encoding.

=cut

sub SetDefaultInputEncoding {
  $TrEd::Convert::inputenc = $_[0];
}




=item C<DumpFS(treelist,fsfile,fh)>

Dump given trees from the given FSFile in FS format to the given
filehandle. If C<$treelist> is undefined, all trees from the FSFile are
dumped. If C<$fsfile> is undefined, current file is used. If C<$fh> is
undefined, C<STDOUT> is used.

=cut

sub DumpFS {
  my ($treelist, $fsfile, $fh)=@_;

  $fsfile ||= $grp->{FSFile};
  $fh ||= \*STDOUT;
  $treelist ||= $fsfile->treeList;

  return 0 unless ref($fsfile);

  $fsfile->FS->writeTo($fh);
  FSBackend::PrintFSFile($fh,$fsfile->FS,$treelist);
  $fh->print($fsfile->tail);
  return 1;
}

=item C<FileName()>

Return current file's name.

=cut

sub FileName {
  return $grp->{FSFile}->filename if $grp->{FSFile};
}

=item C<FileMetaData(key,value?)>

Get or set meta data associated with the current FSFile.  Key is the
meta data key. If value is omitted, current value associated with the
key is returned. Otherwise, the given value is associated with the
key, overwritting any previous value.

=cut

sub FileMetaData {
  my ($name,$value)=@_;
  if (@_<=1) {
    $grp->{FSFile}->metaData($name);
  } else {
    $grp->{FSFile}->changeMetaData($name,$value);
  }
}

=item C<FileUserData(key,value?)>

Get or set user data associated with the current FSFile.  Key is the
user data key. If value is omitted, current value associated with the
key is returned. Otherwise, the given value is associated with the
key, overwritting any previous value.

=cut

sub FileUserData {
  my ($name,$value)=@_;
  if (@_<=1) {
    $grp->{FSFile}->userData()->{$name};
  } else {
    $grp->{FSFile}->userData()->{$name}=$value;
  }
}

=item C<FileAppData(key,value?)>

Get or set application specific data associated with the current
FSFile.  Key is the appData key. If value is omitted, current value
associated with the key is returned. Otherwise, the given value is
associated with the key, overwritting any previous value.

=cut

sub FileAppData {
  my ($name,$value)=@_;
  if (@_<=1) {
    $grp->{FSFile}->appData($name);
  } else {
    $grp->{FSFile}->changeAppData($name,$value);
  }
}

=item C<GotoFileNo(n)>

Goto n'th file in the current filelist.

=cut

sub GotoFileNo {
  my $result;
  if ($FileNotSaved ne '?' and $FileNotSaved) {
    SetFileSaveStatus(1);
  }
  if (exists($grp->{framegroup})) {
    $result=main::gotoFile($grp->{framegroup},$_[0]);
  } else {
    $result=main::gotoFile($grp,$_[0]);
  }
  $root=$grp->{root};
  $this=$grp->{currentNode};
  return $result;
}

=item C<LastFileNo()>

Return the index of the last file in the current filelist.

=cut

sub LastFileNo {
  main::lastFileNo($grp);
}

=item C<CurrentFileNo()>

Return the index of the current file in the current filelist.

=cut

sub CurrentFileNo {
  main::currentFileNo($grp);
}

=item C<SaveAndNextFile()>

Save the current file and open the next file in the current file-list.

=cut

sub SaveAndNextFile {
  Save() if GetFileSaveStatus() || $FileNotSaved;
  NextFile();
}

=item C<NextFile()>

Goto next file in the file-list.

=cut

sub NextFile {
  my $result;
  my $GRP=exists($grp->{framegroup}) ? $grp->{framegroup} : $grp;
  if ($FileNotSaved ne '?' and $FileNotSaved) {
    SetFileSaveStatus(1);
  }
  if ($result=main::nextFile($GRP)) {
    $root=$grp->{root};
    $this=$grp->{currentNode} || $root;
    $FileNotSaved=GetFileSaveStatus();
  } else {
    $FileNotSaved=0 if $FileNotSaved eq '?';
  }
  return $result;
}

=item C<SaveAndPrevFile()>

Save the current file and open the previous file in the current
file-list.

=cut

sub SaveAndPrevFile {
  Save() if GetFileSaveStatus() || $FileNotSaved;
  PrevFile();
}

=item C<PrevFile()>

Goto previous file in the file-list.

=cut

sub PrevFile {
  my $result;
  my $GRP=exists($grp->{framegroup}) ? $grp->{framegroup} : $grp;
  if ($FileNotSaved ne '?' and $FileNotSaved) {
    SetFileSaveStatus(1);
  }
  if ($result=main::prevFile($GRP)) {
    $root=$grp->{root};
    $this=$grp->{currentNode} || $root;
    $FileNotSaved=GetFileSaveStatus();
  } else {
    $FileNotSaved=0 if $FileNotSaved eq '?';
  }
  return $result;
}

=back

=head2 General I/O macros

=over 4

=item C<ResourcePath()>

Return a list of directories in a current resource path.

=cut

sub ResourcePath {
  my $split = ($^O eq "MSWin32") ? ',' : ':';
  return split /\Q${Fslib::resourcePathSplit}\E/, $Fslib::resourcePath;
}

=item C<AddToResourcePath(dirs)>

Add given directories to the current resource path.

=cut

sub AddToResourcePath {
  $Fslib::resourcePath.=$Fslib::resourcePathSplit.join $Fslib::resourcePathSplit,@_;
}

=item C<RemoveFromResourcePath(dirs)>

Remove given directories from the current resource path (directory
names must exactly match those listed in the resource path).

=cut

sub RemoveFromResourcePath {
  my %x;@x{@_}=();
  SetResourcePath(grep { !exists($x{$_}) } ResourcePath);
}

=item C<SetResourcePath(dirs)>

Set given list of directories as a current resource path (discarding
the existing values of ResourcePath).

=cut

sub SetResourcePath {
  $Fslib::resourcePath=join $Fslib::resourcePathSplit,@_;
}


=item C<FindInResources(filename)>

If a given filename is a relative path of a file found in TrEd's
resource directory, return an absolute path for the
resource. Otherwise return filename.

=cut

=item C<ResolvePath(ref-filename,filename,use_resources?)>

If a given filename is a relative path, try to find the file in the
same directory as ref-filename. In case of success, return a path
based on the directory part of ref-filename and filename.  If the file
can't be located in this way and use_resources is true, return the
value of C<FindInResources(filename)>.

=cut

=item C<writeln(string?,...)>

Print the arguments to standard output appending a new-line if missing.

=cut

sub writeln { $::stdout->print(@_, $_[$#_]=~/\n$/ ? () : "\n") }


=item C<stdout(string?,...)>

If called without arguments return current standard output filehandle.
Otherwise call print the arguments to standard output.

=cut

sub stdout { @_ ? $::stdout && $::stdout->print(@_) : $::stdout }

=item C<stderr(string?,...)>

If called without arguments return current standard error output
filehandle.  Otherwise call print the arguments to standard output.

=cut

sub stderr { @_ ? $::stderr && $::stderr->print(@_) : $::stderr}

=item C<tmpFileName()>

Returns a temporary filename..

=cut

sub tmpFileName {
  require POSIX;
  return POSIX::tmpnam();
}

=back

=cut

#######################################################

=head2 Printing trees

=over 4

=item C<PrintDialog(-option =E<gt> value,...)>

Display TrEd's standard print dialog. Possible options are:

-command -psFile -toFile -format -imageMagickResolution
-fileExtension -useType1Font -sentenceInfo -noRotate -colors

=cut

sub PrintDialog {
  my (%opts)=@_;
  if (GUI()) {
    local $main::insideEval = 0;
    local $grp->{currentNode} = $this;
    local $grp->{root} = $root;

    foreach (qw(-command -psFile -toFile -format -noRotate -sentenceInfo
                -imageMagickResolution -fileExtension -colors)) {
      if (exists($opts{$_})) {
	my $o=$_; $o=~s/^-//;
	$grp->{framegroup}->{"print".lcfirst($o)} = $opts{$_}
      }
      main::printDialog($grp->{framegroup});
    }
  } else {
    die "Cannot call PrintDialog from non-GUI version TrEd\n";
  }
  return 1;
}

=item C<Print(-option =E<gt> value,...)>

Print trees given from current file according to given printing options:

C<-range>, C<-command>, C<-toFile>, C<-filename>, C<-format>,
C<-noRotate>, C<-sentenceInfo> C<-imageMagickResolution>, C<-colors>,
C<-hidden>, C<-psFontFile>, C<-psFontAFMFile>, C<-ttFont>,
C<-fontSize>, C<-fmtWidth>, C<-hMargin>, C<-fmtHeight>, C<-vMargin>,
C<-maximize>, C<-psMedia>

=cut

sub Print {
  my (%opts)=@_;

  if (GUI()) {
    my $group=$grp->{framegroup};
    local $main::insideEval = 0;
    local $grp->{currentNode} = $this;
    local $grp->{root} = $root;

    my $canvas=ToplevelFrame()->Canvas();
    $opts{-range}=CurrentTreeNumber()+1 if ($opts{-range} eq "");

    foreach (qw(-command -toFile -format -noRotate -sentenceInfo
                -imageMagickResolution -colors)) {
      unless (exists($opts{$_})) {
	my $o=$_; $o=~s/^-//;
	$opts{$_} = $group->{"print".lcfirst($o)};
      }
    }
    unless ($opts{-format} ne 'PDF' or $opts{-ttFont} or $group->{ttfonts}) {
      main::initTTFonts($group);
    }

    $TrEd::TreeView::on_get_root_style = [\&main::onGetRootStyle,$grp];
    $TrEd::TreeView::on_get_node_style = [\&main::onGetNodeStyle,$grp];

    my $stylesheet = $grp->{stylesheet};
    my $ss = undef;
    if ($stylesheet ne STYLESHEET_FROM_FILE()) {
      $ss=$group->{stylesheets}->{$stylesheet};
    }

    $opts{-imageMagickResolution} ||= 80;

    TrEd::Print::print_trees
	($grp->{FSFile},
	 ToplevelFrame(),
	 $canvas,
	 $opts{-range},
	 ($opts{-toFile} and $opts{-format} !~ /ImageMagick/i) ? 1 : 0,
	 $opts{-format} =~ /ImageMagick|EPS/i ? 1 : 0,
	 ($opts{-toFile} and $opts{-format} eq 'PDF') ? 1 : 0,
	 $opts{-filename},
	 $opts{-sentenceInfo},
	 (($opts{-format} =~ /ImageMagick/i) ?
	    "$main::imageMagickConvert -density $opts{-imageMagickResolution} - $opts{-filename}" : 
	      $opts{-command}),
	 $opts{-colors},
	 $opts{-noRotate},
	 $opts{-hidden},
	 {
	  'PS' => exists($opts{-psFontFile}) ? $opts{-psFontFile} :
	  $main::psFontFile,
	  'AFM' => exists($opts{-psFontAFMFile}) ? $opts{-psFontAFMFile} :
	  $main::psFontAFMFile,
	  'TTF' => exists($opts{-ttFont}) ? $opts{-ttFont} :
	  $group->{ttfonts}->{$main::ttFont},
	  'Size' => exists($opts{-fontSize}) ? $opts{-fontSize} :
	  $main::psFontSize,
	 },
	 exists($opts{-fmtWidth}) ? $opts{-fmtWidth} : $main::prtFmtWidth,
	 exists($opts{-hMargin}) ? $opts{-hMargin} : $main::prtHMargin,
	 exists($opts{-fmtHeight}) ? $opts{-fmtHeight} : $main::prtFmtHeight,
	 exists($opts{-vMargin}) ? $opts{-vMargin} : $main::prtVMargin,
	 exists($opts{-maximize}) ? $opts{-maximize} : $main::maximizePrintSize,
	 exists($opts{-psMedia}) ? $opts{-psMedia} : $main::psMedia,
	 $main::treeViewOpts,
	 $ss
	);

    $TrEd::TreeView::on_get_root_style = undef;
    $TrEd::TreeView::on_get_node_style = undef;


    $canvas->destroy();
  } else {
    die "Cannot call PrintDialog from non-GUI version TrEd\n";
  }
}

=back

=cut

###########################################################
# Macros for backward compatibility with Graph

=head2 Compatibility macros used by the Graph2Tred macro convertor

=over 4

=item C<PrintToFile(filename,string,...)>

Print given strings to the end of the given file.

=cut

sub PrintToFile {
  my $file=shift;
  return unless( defined($file) and $file ne '' );
  my @a=@_;

  if (open(my $PTF,">>$file")) {
    print $PTF (join("",(map {
      s/\\\|/|/g;
      s/\\n/\n/g;
      $_} @a)));
    close($PTF);
  } else { print STDERR "Could not open file $file\n"; }
}

=item C<ValNo(n,string)>

Return the n'th field of the given string where individual fields are
separated by "|".

=cut

sub ValNo {
  my $n=shift;
  my @val=ListSplit(shift);
  return $val[$n];
}

=item C<AtrNo(n)>

Retrun name of the n'th attribute defined in the FS file. This macro
only abbreviates the following expression:
C<$grp-E<gt>{FSFile}-E<gt>FS-E<gt>atno(n)>

=cut

sub AtrNo {
  return $grp->{FSFile}->FS->atno(shift);
}

=item C<Union(string_a,string_b)>

Return a string consisting of |-separated fields which form a pairwise
disjoint set of the |-separated fields of the given strings string_a
and string_b.

=cut

sub Union {
  my @c=();
  my $s;
  my $t;
  element: foreach $s (ListSplit(shift),ListSplit(shift)) {
    for ($t=0;$t<=$#c;$t++) {
      next element if ($c[$t] eq $s);
    }
    push @c,$s;
  }
  return join('|',@c);
}

=item C<Interjection(string_a,string_b)>

Return a string consisting of |-separated fields which form the
interjection of the sets of |-separated fields of the given strings
string_a and string_b.

=cut

sub Interjection {
  return $_[0] unless $_[1] ne "";
  my @a=ListSplit($_[1]);
  my @c=();
  my $s;
  my $t;
  element: foreach $s (ListSplit(Union($_[0],""))) {
    for ($t=0;$t<=$#a;$t++) {
      if ($a[$t] eq $s) {
	push(@c,$s);
	next element;
      }
    }
  }
  return join '|',@c;
}

=item C<ListSplit(string)>

Split the given string of |-separated fields and return a list of the
individual fields.

=cut

sub ListSplit {

  my $s=shift;
  my $j=0;
  my $i=0;
  my @a=();
  while (($j=index($s,'|',$j))>=0) {
    $j++,next if ($j>0 and substr($s,$j-1,1) eq "\\");
    push @a, substr($s,$i,$j-$i);
    $i=++$j; $j=$i;
  }
  push @a, substr($s,$i,length($s)-$i) if ($i<length($s));
  return @a;
}

=item C<ListJoin(list)>

Form a string of |-separated fields from the given list of fields.

=cut

sub ListJoin {
 return join '|', map { s/|/\|/ }  @_;
}

=item C<ListEq(string1, string2)>

Compare the sets of |-separated fields of the two given
strings. Return true if the sets contain the same elements; return
false otherwise.

=cut

sub ListEq {
  my ($a,$b)=(shift,shift);
  $a=Union($a,""); # make them uniqe
  $b=Union($b,""); # make them uniqe
  my @a=ListSplit($a);
  my @b=ListSplit($b);

  return 0 unless ($#a == $#b);

  my @c=ListSplit(Union($a,$b));

  return ($#a == $#c);
}

=item C<ListAssign(string,n,value)>

Return the given string of |-separated fields, except that the n'th
field in the string is replaced by the given value.

=cut

sub ListAssign {
  my @a=ListSplit(shift);
  my ($n,$value)=(shift,shift);

  $a[$n]=ValNo(0,$value);
  return join '|',@a;
}

=item C<SubStr(string,position,length)>

Simple substr wrapper which returns an empty string if the position is
beyond the end of the string.

=cut

sub SubStr {
  my ($str, $pos, $len)=(shift, shift, shift);

  return "" if ($pos > length($str));
  return substr($str,$pos,$len);
}

=back

=cut

##########################################

=head2 Implementation of TredMacro::import

=over 4

=item C<import(names?)>

If specified without parameter, exports every symbol to the caller
package (except for symbols already (re)defined in the caller
packages). If parameters are given, exports only names specified by
the parameters and the following few variables that every package
derived from TredMacro (e.g. a context)  B<must> share: C<$libDir>,
C<$grp>, C<$root>, C<$this> C<$_NoSuchTree> C<$Redraw>,
C<$forceFileSaved>, C<$FileChanged>, C<$FileNotSaved>,
C<$NodeClipboard>.

=cut

sub import {
  # If specified without parameter, exports everything but
  # names already defined in caller package
  # If parameters are given, exports only names specified by the parameters
  # and few variables that every TredMacro *must* share.

  my $pkg=shift;
  my $caller=caller;
  my %stash=%{"${pkg}::"};
  my ($type,$val);
  my @exports;

  @exports = $#_>=0 ? @_ : keys %stash;
  push @exports,@FORCE_EXPORT;
  foreach my $k (@exports) {
    unless ($k =~ s/^(\W)//) {
      *{"${caller}::$k"} = \&{"${pkg}::$k"} unless defined (&{"${caller}::$k"});
       next;
    }
    $type = $1;
    if ($type eq '&') {
      *{"${caller}::$k"} = \&{"${pkg}::$k"};
    } elsif ($type eq '$') {
      *{"${caller}::$k"} = \${"${pkg}::$k"};
    } elsif ($type eq '@') {
      *{"${caller}::$k"} = \@{"${pkg}::$k"};
    } elsif ($type eq '%') {
      *{"${caller}::$k"} = \%{"${pkg}::$k"};
    } elsif ($type eq '*') {
      *{"${caller}::$k"} = \*{"${pkg}::$k"};
    } else {
#      do { warn("Can't export symbol: $type $pkg $k") };
    }
  }
};


=back

=cut

############################################

=head2 XPath extension (slow)

=over 4

=item C<SetupXPath(function-mapping...)>

C<SetupXPath(
            id         =E<gt> \&find_node_by_id,
            pos        =E<gt> \&node_position,
            attributes =E<gt> \&node_attributes_hashref,
            name       =E<gt> \&node_name,
            value      =E<gt> \&node_value,
            children   =E<gt> \&node_children,
            parent     =E<gt> \&node_parent,
            lbrother   =E<gt> \&node_left_sibling,
            rbrother   =E<gt> \&node_right_sibling,
           )>

This macro requires C<XML::XPath> module to be installed.  It adjusts
FSNode API to match XPath model based on a given function mapping.  By
defalut, 'id' is defined to return nothing, 'pos' returns nodes
sentence-ordering position (or tree-ordering position if sentord
attribute isn't defined), 'attributes' returs a hashref of node's
attributes (actually a FSNode itself), 'name' returns "node", 'value'
returns node's value of the special FS value attribute, and
'children', 'parent', 'lbrother', and 'rbrother' all default to the
respective FSNode methods.

Usage example:

C<SetupXPath(id    =E<gt> sub { $hashed_ids{ $_[0] } },
           name  =E<gt> sub { $_[0]-E<gt>{functor} }
           value =E<gt> sub { $_[0]-E<gt>{t_lemma} });>

C<foreach ($node-E<gt>findnodes(q{//ACT/PAT[starts-with(@tag,"N") or .="ano"]})) {
    # process matching nodes
}>

=cut

sub SetupXPath {
  my %handlers = @_;

  unless (exists $handlers{pos}) {
    my $attr=FS()->sentord() || FS()->order();
    $handlers{pos} = sub { $_[0]->{$attr} } ;
  }
  unless (exists $handlers{value}) {
    my $val=FS()->value();
    $handlers{value} = sub { $_[0]->{$val} } ;
  }

  *FSNode::getElementById = $handlers{id} if $handlers{id};
  *FSNode::get_global_pos = $handlers{pos} if $handlers{pos};
  *FSNode::getAttributes = $handlers{attributes} if $handlers{attributes};
  *FSNode::getName = $handlers{name} if $handlers{name};
  *FSNode::getLocalName = $handlers{name} if $handlers{name};
  *FSNode::getValue = $handlers{value} if $handlers{value};
  *FSNode::string_value = $handlers{value} if $handlers{value};

  *FSNode::getParentNode = $handlers{parent} if $handlers{parent};
  *FSNode::getChildNodes = $handlers{children} if $handlers{children};
  *FSNode::getPreviousSibling = $handlers{lbrother} if $handlers{lbrother};
  *FSNode::getNextSibling = $handlers{rbrother} if $handlers{rbrother};
}


sub noop { 1 }


=back

=cut
