## This is macro file for Tred                           -*-cperl-*-
## author: Petr Pajas
## Time-stamp: <2003-08-15 14:12:35 pajas>
package TredMacro;
use Exporter;
use Fslib;
use base qw(main Exporter);

use vars qw(@FORCE_EXPORT);
@FORCE_EXPORT = qw($libDir $grp $root $this $_NoSuchTree $Redraw $stderr $stdout
                   $forceFileSaved $FileChanged $FileNotSaved $NodeClipboard);
use vars @FORCE_EXPORT;

*FileChanged=*FileNotSaved;	# alias

=pod

=head1 TredMacro

tred.def - This package implements default macros for TrEd/bTred

=head2 GLOBAL VARIABLES

=over 4

=item $FileChanged (alias $FileNotSaved - still valid but obsolete)

If this variable is set to 1, TrEd/bTrEd considers the current file to
be modified and in case of bTrEd makes the program to save it before
it is closed (in case of TrEd, user is prompted before the file is
closed). If the macro does not change this variable, bTrEd does not
change the file status, while TrEd still assumes that the file B<was>
modified. In other words, set this variable to 1 in bTrEd if you want
the file to be saved at last, and set this variable to 0 in TrEd if
you are sure you did not make any change to the file that would be
worth saving it. As there is a danger that calling one macro from
another may result in a mess in the value of C<$FileChanged> it is
adviced to use the default macro C<ChangingFile()> which tries to set
the file status only if really intended (see below).

=item $Redraw

This variable makes sense only in TrEd.  You may set it to one of
C<file, tree, win, all, tie> to alter the mechanism of redrawing the
screen. The default value is C<file> (redraw all windows displaying
current file), while C<tree> means redraw all windows displaying
current tree, C<win> means redraw only current window and C<tie> means
redraw all if windows are tied or (if not) redraw only current window.
To disable redrawing set this variable to C<none>.

=item $forceFileSaved

In TrEd, you may wish to set this variable to 0 if you wish to change
the status of the file to C<saved> (e.g. after saving the file from
your macro).

=item $root

Root of the current tree. If possible, avoid changing this variable in
your code, so that other macros you call may use it too.

=item $this

Current node (i.e. the active node in TrEd and the node in turn if
C<-N> or C<-H> flag was used in bTrEd). Assigning a different node
from the current tree to this variable results in changing the active
node in TrEd.

=item $libDir

This variable contains path to TrEd's library directory.

=item $grp

This variable is a hash reference which stores the fundamental piece
of information about current file, current context etc. B<DO NOT
CHANGE IT>. You may (and in some situations must), however, use this
variable to access that information.

=over 5

=item $grp->{FSFile}

This field stores the FSFile object of the current file.  See Fslib
or manual to TrEd (section Accessing other trees) for more info.

=item $grp->{treeNo}

This field contains index of the current tree.

=item $grp->{macroContext}

This field contains the name of current macro context. To change
current context use the pre-defined macro SwitchContext.

=back

=back

=cut

import Fslib;
import Fslib qw(&Index);
import main;

=head2 FUNCTION REFERENCE

=head3 Auxiliary functions

=over 4

=item Index (array-ref, item)

This is an auxiliary function imported from Fslib which returns the
first occurence of the item in the array.

=cut

=item import (names?)

If specified without parameter, exports every symbol to the caller
package (except for symbols already (re)defined in the caller
packages). If parameters are given, exports only names specified by
the parameters and the following few variables that every TredMacro
B<must> share: C<$libDir $grp $root $this $_NoSuchTree $Redraw
$forceFileSaved $FileChanged $FileNotSaved $NodeClipboard>.

=cut

sub import {
  # If specified without parameter, exports everything but
  # names already defined in caller package
  # If parameters are given, exports only names specified by the parameters
  # and few variables that every TredMacro *must* share.

  my $pkg=shift;
  my $caller=caller;
  my %stash=%{"${pkg}::"};
  my ($type,$val);
  my @exports;

  @exports = $#_>=0 ? @_ : keys %stash;
  push @exports,@FORCE_EXPORT;
  foreach my $k (@exports) {
    unless ($k =~ s/^(\W)//) {
      *{"${caller}::$k"} = \&{"${pkg}::$k"} unless defined (&{"${caller}::$k"});
       next;
    }
    $type = $1;
    if ($type eq '&') {
      *{"${caller}::$k"} = \&{"${pkg}::$k"};
    } elsif ($type eq '$') {
      *{"${caller}::$k"} = \${"${pkg}::$k"};
    } elsif ($type eq '@') {
      *{"${caller}::$k"} = \@{"${pkg}::$k"};
    } elsif ($type eq '%') {
      *{"${caller}::$k"} = \%{"${pkg}::$k"};
    } elsif ($type eq '*') {
      *{"${caller}::$k"} = \*{"${pkg}::$k"};
    } else {
#      do { warn("Can't export symbol: $type $pkg $k") };
    }
  }
};

=back

=cut

###########################################################
# Default macro definitions to make
# calls to global subroutines less humble

=head3 Basic TrEd-related macros

=over 4

=item Redraw

Force TrEd to immediately redraw the current window. Hence TrEd
redraws the tree right after an interactively invoked macro finishes,
explicit calls to Redraw macro are needed rather rearly (for example
from a hook).

=cut
sub Redraw {
  my $ie=$main::insideEval;
  $main::insideEval=0;
  &main::get_nodes_win($grp);
  print STDERR "WIN: $grp\n";
  &main::redraw_win($grp);
  $main::insideEval=$ie;
}

=item Redraw_FSFile

Force TrEd to immediately redraw all windows displaying current
file.

=cut
sub Redraw_FSFile {
  my $ie=$main::insideEval;
  $main::insideEval=0;
  &main::get_nodes_fsfile($grp->{framegroup},$grp->{FSFile});
  &main::redraw_fsfile($grp->{framegroup},$grp->{FSFile});
  $main::insideEval=$ie;
}

=item Redraw_FSFile_Tree

Force TrEd to immediately redraw all windows displaying current
tree.

=cut
sub Redraw_FSFile_Tree {
  my $ie=$main::insideEval;
  $main::insideEval=0;
  &main::get_nodes_fsfile_tree($grp->{framegroup},$grp->{FSFile},$grp->{treeNo});
  &main::redraw_fsfile_tree($grp->{framegroup},$grp->{FSFile},$grp->{treeNo});
  $main::insideEval=$ie;
}

=item Redraw_All

Force TrEd to immediately redraw all windows.

=cut
sub Redraw_All {
  my $ie=$main::insideEval;
  $main::insideEval=0;
  &main::get_nodes_all($grp->{framegroup});
  &main::redraw_all($grp->{framegroup});
  $main::insideEval=$ie;
}

=item RedrawStatusLine

Force TrEd to immediately redraw status line.

=cut
sub RedrawStatusLine {
  local $main::insideEval=0;
  &main::updateStatusLine($grp);
}

=item StandardTredFont

Return a string or Tk::Font object representation of the font used in
TrEd to label tree-nodes.

=cut
sub StandardTredFont {
  return $main::font;
}

=item StandardTredValueLineFont

Return a string or Tk::Font object representation of the font used in
TrEd to display the "sentence" above the tree.

=cut
sub StandardTredValueLineFont {
  return $main::vLineFont;
}

=item SetCurrentNodeInOtherWin (win, node)

Set active node for a given window.

=cut
sub SetCurrentNodeInOtherWin {
  my ($win,$node)=@_;
  TrEd::Basics::setCurrent($win,$node);
}

=item CenterOtherWinTo (win, node)

Center given window to a given node.

=cut
sub CenterOtherWinTo {
  my ($win,$node)=@_;
  main::centerTo($win,$node);
}

=item SetDisplayAttrs

Use the given list of TrEd's patterns for displaying attributes.

=cut
sub SetDisplayAttrs {
  return unless $grp->{FSFile};
  $grp->{FSFile}->changePatterns(@_);
}

=item SetBalloonPattern

Use the given pattern as a new hint pattern

=cut
sub SetBalloonPattern {
  return unless $grp->{FSFile};
  $grp->{FSFile}->changeHint(join "\n",@_);
}

=item GetDisplayAttrs

Get the current list of patterns used by TrEd to display attributes.

=cut
sub GetDisplayAttrs {
  return unless $grp->{FSFile};
  return $grp->{FSFile}->patterns();
}

=item GetBalloonPattern

Get TrEd's current hint pattern.

=cut
sub GetBalloonPattern {
  return unless $grp->{FSFile};
  return $grp->{FSFile}->hint();
}

=item SwitchContext

Switch to given macro context.

=cut
sub SwitchContext {
  main::switchContext($grp,shift);
}

=item SwitchContextForWindow

Switch given window to given macro context.

=cut
sub SwitchContextForWindow {
  main::switchContext(@_);
}

=item CurrentContext

Return the name of the current macro context.

=cut
sub CurrentContext {
  return $grp->{macroContext};
}

=item GotoTree (n)

Display the n'th tree in the current file.

=cut
sub GotoTree {
  $FileNotSaved=0 if ($FileNotSaved eq '?');
  my $to=shift()-1;
  $_NoSuchTree=($to != main::max(0,min($to,$#trees)));
  my $result=main::gotoTree($grp,$to);
  $root=$grp->{root};
  $this=$root;
  return $result;
}

=item TieGotoTree (n)

Go to n'th tree in all tied windows.

=cut
sub TieGotoTree {
  $FileNotSaved=0 if ($FileNotSaved eq '?');;
  my $to=shift()-1;
  my $result=main::tieGotoTree($grp->{framegroup},$to);
  $root=$grp->{root};
  $this=$root;
  $Redraw='tie';
  return $result;
}


=item TieNextTree

Display the next tree in all tied windows.

=cut
sub TieNextTree {
  $FileNotSaved=0 if ($FileNotSaved eq '?');;
  my $result=main::tieNextTree($grp->{framegroup});
  $root=$grp->{root};
  $this=$root;
  $Redraw='tie';
  return $result;
}

=item TiePrevTree

Display the previous tree in all tied windows.

=cut
sub TiePrevTree {
  $FileNotSaved=0 if ($FileNotSaved eq '?');;
  my $result=main::tiePrevTree($grp->{framegroup});
  $root=$grp->{root};
  $this=$root;
  $Redraw='tie';
  return $result;
}

=item NextTree

Display the next tree in the current file.

=cut
sub NextTree {
  $FileNotSaved=0 if ($FileNotSaved eq '?');;
  my $result=main::nextTree($grp);
  $root=$grp->{root};
  $this=$root;
  $_NoSuchTree=!$result; # for compatibility with Graph2Tred
  return $result;
}

=item PrevTree

Display the previous tree in the current file.

=cut
sub PrevTree { 
  $FileNotSaved=0 if ($FileNotSaved eq '?');;
  my $result=main::prevTree($grp);
  $root=$grp->{root};
  $this=$root;
  $_NoSuchTree=!$result; # for compatibility with Graph2Tred
  return $result;
}

=item GetOrd (node)

Return value of the special numbering FS attribute. This macro
actually returns the same value as
C<$node->{$grp->{FSFile}->FS->order()}>

=cut
sub GetOrd { return $_[0]->{$grp->{FSFile}->FS->order}; }

=item PasteNode (node, new-parent)

Paste the subtree of the node under the new-parent.  The root of the
subtree is placed among other children of new-parent with respect to
the numbering attribute.

=cut
sub PasteNode {
  my ($node,$p)=@_; 
  Fslib::Paste($node,$p,$grp->{FSFile}->FS->defs); 
  return $node;
}

=item CloneSubtree (node)

Return an identical copy (except that only declared attributes are
preserved) of the given subtree.

=cut
sub CloneSubtree {
  my ($node)=@_;
  return $grp->{FSFile}->FS->clone_subtree($node);
}

=item CopyNode (node)

Return an identical copy (except that only declared attributes are
preserved) of the given node.

=cut
sub CopyNode {
  my ($node)=@_;
  my $nd=FSNode->new();
  foreach (Attributes()) {
    $nd->{$_}=$node->{$_};
  }
  return $nd;
}

=item CutNode (node)

Cut the node's subtree off the tree and return it. By cuttin a subtree
we mean disconnecting it from the rest of the tree. Use PasteNode to
attach it to some node again.

=cut
sub CutNode {
  my $node=shift;
  my $parent=Fslib::Parent($node);
  $result=Fslib::Cut($node);
  $this=$parent if ($result and $this==$node);
  return $result;
}

=item NewTree

Create a new tree before the current tree. The new tree consists of
exactly one node. This node is activated and a reference to its FSNode
object is returned.

=cut
sub NewTree {
  main::newTree($grp);
  $root=$grp->{root};
  $this=$root;
  return $root;
}

=item NewTreeAfter

Create a new tree after the current tree. The new tree consists of
exactly one node. This node is activated and a reference to its FSNode
object is returned.

=cut
sub NewTreeAfter {
  main::newTreeAfter($grp);
  $root=$grp->{root};
  $this=$root;
  return $root;
}


=item Open ($filename)

Open given file.

=cut
sub Open {
  if (exists($grp->{framegroup})) {
    main::openFile($grp->{framegroup},$_[0]);
  } else {
    main::openFile($grp,$_[0]);
  }
}

=item Save

Save the current file.

=cut
sub Save {
  main::saveFile($grp);
  $forceFileSaved=1;
  $FileNotSaved=0 if ($FileNotSaved eq '?');;
}

=item GotoFileNo ($n)

Goto n'th file in the current filelist.

=cut

sub GotoFileNo {
  my $result;
  if (exists($grp->{framegroup})) {
    $result=main::gotoFile($grp->{framegroup},$_[0]);
  } else {
    $result=main::gotoFile($grp,$_[0]);
  }
  $root=$grp->{root};
  $this=$grp->{currentNode};
  return $result;
}

=item LastFileNo

Return the index of the last file in the current filelist.

=cut

sub LastFileNo {
  main::lastFileNo($grp);
}

=item CurrentFileNo

Return the index of the current file in the current filelist.

=cut

sub CurrentFileNo {
  main::currentFileNo($grp);
}

=item SaveAndNextFile

Save the current file and open the next file in the current file-list.

=cut
sub SaveAndNextFile {
  Save();
  my $result = main::nextFile($grp);
  $root=$grp->{root};
  return $result;
}

=item NextFile

Goto next file in the file-list.

=cut
sub NextFile {
  my $result = main::nextFile($grp);
  $root=$grp->{root};
  return $result;
}


=item SaveAndPrevFile

Save the current file and open the previous file in the current
file-list.

=cut
sub SaveAndPrevFile {
  Save();
  my $result = main::prevFile($grp);
  $root=$grp->{root};
  return $result;
}

=item PrevFile

Goto previous file in the file-list.

=cut
sub PrevFile {
  my $result = main::prevFile($grp);
  $root=$grp->{root};
  return $result;
}


=item EditAttribute (node, attribute)

Open edit attribute GUI.

=cut

sub EditAttribute {
  main::doEditAttr($grp,@_);
}

=item Find

Open the Find Node by Attributes GUI dialog.

=cut
sub Find {
  $grp->{framegroup}->{findButton}->invoke();
  $this=$grp->{currentNode};
  $FileNotSaved=0 if ($FileNotSaved eq '?');;
}

=item FindNext

Searches for the first node matching the criteria of the previous use
of the Find... menu command or FindNode macro usage.

=cut
sub FindNext {
  $grp->{framegroup}->{findNextButton}->invoke();
  $this=$grp->{currentNode};
  $FileNotSaved=0 if ($FileNotSaved eq '?');;
}

=item FindPrev

Searches for the previous node matching the criteria of the previous
use of the Find... menu command or FindNode macro usage.

=cut
sub FindPrev {
  $grp->{framegroup}->{findPrevButton}->invoke();
  $this=$grp->{currentNode};
  $FileNotSaved=0 if ($FileNotSaved eq '?');;
}

=item ToplevelFrame

Returns the Tk::Toplevel object containing the current window.

=cut
sub ToplevelFrame {
  return $grp->toplevel();
}



#####################################################
# Common useful user-level subroutines

=item ErrorMessage (message)

In TrEd, show a dialog box containing the given error-message.
In BTrEd print the error message on standard output.

=cut
sub ErrorMessage {
  TrEd::Basics::errorMessage($grp,join("",@_));
}

=item NewRBrother (node)

Create a new brother of the given node and recalculate the special FS
numbering attribute values in the whole tree so that the new node is
the first right sibling of the given node.

If no node is given, this function operates on C<$this> and B<resets>
C<$this> to the newly created node. If some node is given the value
of C<$this> is preserved.

=cut
sub NewRBrother {
## Adds new RBrother to current node and shifts
## ords of the other nodes appropriately
  my $ref=ref($_[0]) ? $_[0] : $this;

  return unless ($ref and Parent($ref));
  my $nd=FSNode->new();
  my $ord=$grp->{FSFile}->FS->order;
  $nd->{$ord}=$ref->{$ord}+1;
  my $node=$root;
  while ($node) {
    $node->{$ord}++ if ($node ne $nd and $node->{$ord}>$ref->{$ord});
    $node=Next($node);
  }
  PasteNode($nd,Parent($ref));
  $this=$nd unless ref($_[0]);
  return $nd;
}

=item NewLBrother (node)

Create a new brother of the given node and recalculate the special FS
numbering attribute values in the whole tree so that the new node is
the first left sibling of the given node.

If no node is given, this function operates on C<$this> and B<resets>
C<$this> to the newly created node. If some node is given the value
of C<$this> is preserved.

=cut
sub NewLBrother {
## Adds new RLrother to current node and shifts
## ords of the other nodes appropriately
  my $ref=ref($_[0]) ? $_[0] : $this;
  return unless ($ref and Parent($ref));
  my $nd=FSNode->new();
  my $ord=$grp->{FSFile}->FS->order;
  $nd->{$ord}=$ref->{$ord};
  my $node=$root;
  while ($node) {
    $node->{$ord}++ if ($node ne $nd and $node->{$ord}>=$ref->{$ord});
    $node=Next($node);
  }
  PasteNode($nd,Parent($ref));
  $this=$nd unless ref($_[0]);
  return $nd;
}

=item NewSon (parent)

Create a new child of the given parent node and recalculate the
special FS numbering attribute values in the whole tree so that the
new node is the first node left to the given parent. 

If no parent node is given, this function operates on C<$this> and
B<resets> C<$this> to the newly created node. If a parent node is
given the value of C<$this> is preserved.

=cut
sub NewSon {
## Adds new son to current node and shifts
## ords of the other nodes appropriately
  my $ref=ref($_[0]) ? $_[0] : $this;
  return unless ($ref);
  my $nd=FSNode->new();
  my $ord=$grp->{FSFile}->FS->order;
  $nd->{$ord}=$ref->{$ord}+1;

  my $node=$root;
  while ($node) {
    $node->{$ord}++ if ($node->{$ord}>$ref->{$ord});
    $node=Next($node);
  }
  PasteNode($nd,$ref);
  $this=$nd unless ref($_[0]);
  return $nd;
}

=item NewParent (node)

Create a node between given node and its parent and recalculate the
special FS numbering attribute values in the whole tree so that the
new node is the first node left to the given node. 

If no node is given, this function operates on C<$this> and
B<resets> C<$this> to the newly created node. If a parent node is
given the value of C<$this> is preserved.

=cut
sub NewParent {
  my $ref=ref($_[0]) ? $_[0] : $this;
  return unless ($ref);
  my $nd=FSNode->new();
  my $ord=$grp->{FSFile}->FS->order;
  $nd->{$ord}=$ref->{$ord};
  my $node=$root;
  while ($node) {
    $node->{$ord}++ if ($node->{$ord}>=$ref->{$ord});
    $node=Next($node);
  }
  if ($ref->parent) {
    PasteNode($nd,$ref->parent);
    CutNode($ref);
    PasteNode($ref,$nd);
  } else { # root of the tree
    $trees=$grp->{FSFile}->treeList();
    my $n;
    for ($n=0;$n<=$#$trees;$n++) {
      last if ($trees->[$n] == $ref);
    }
    if ($n>$#$trees) {
      die "tree not found in current FSFile";
    } else {
      $grp->{FSFile}->set_tree($nd,$n);
    }
    PasteNode($ref,$nd);
  }
  $this=$nd unless ref($_[0]);
  return $nd;
}


=item DeleteThisNode

Delete the current (C<$this>) node and recalculate the special FS
numbering attribute values in the whole tree so that there is no gap
in the numbering. If the current node is not a leaf or if it is the
root of the current tree, this macro does nothing.

=cut
sub DeleteThisNode {
## Deletes current node and shifts
## ords of the other nodes appropriately
  return unless ($this and Parent($this));
  my $parent=Parent($this);
  my $ord=$grp->{FSFile}->FS->order;
  my $order=$this->{$ord};

  if (DeleteLeaf($this)) {
    my $node=$root;
    while ($node) {
      $node->{$ord}-- if ($node->{$ord}>$order);
      $node=Next($node);
    }
    $this=$parent;
  }
}

=item CopyValues

Copy the values of all the attributes except the special FS numbering
attribute of the current node to a global hash variable named
%ValuesClipboard.

=cut
sub CopyValues {
  undef %ValuesClipboard;
  %ValuesClipboard = map { $_ => $this->{$_} } $grp->{FSFile}->FS->attributes;
  delete $ValuesClipboard{$grp->{FSFile}->FS->order}; # we do not copy this
  $FileNotSaved=0 if ($FileNotSaved eq '?');;
}

=item PasteValues

Replace the values of the current node's attributes by those stored in
the global hash variable named %ValuesClipboard.

=cut
sub PasteValues {
  foreach $_ (keys(%ValuesClipboard)) {
    $this->{$_}=$ValuesClipboard{$_};
  }
}

=item NextNode (node, top?)

Return the first displayed node following the given node in the
subtree of top. This function behaves in the same manner as the
node->following(top) method, except it works only on the nodes which
are actually visible according to the state of the View->Show Hidden
Nodes menu item.

=cut
sub NextNode {
  my ($node,$top)=@_;
  return $node ? main::HNext($grp,$node,$top) : undef;
}

=item PrevNode (node,top?)

Return the first displayed node preceding the given node in the
subtree of top. This function behaves in the same manner as the
node->previous(top) method, except it works only on the nodes which
are actually visible according to the state of the View->Show Hidden
Nodes menu item.

=cut
sub PrevNode {
  my ($node,$top)=@_;
  return $node ? main::HPrev($grp,$node,$top) : undef;
}

=item NextVisibleNode (node,top?)

Return the first visible node following the given node in the subtree
of top. This function behaves in the same manner as the
C<$node->following($top)> method, except that nodes of hidden subtrees
are skipped.

=cut
sub NextVisibleNode {
  my ($node,$top)=@_;
  $node=Next($node,$top);
  my $fs=$grp->{FSFile}->FS;
  while ($node) {
    return $node unless ($fs->isHidden($node));
    $node=Next($node,$top);
  }
  return 0;
}

=item PrevVisibleNode (node,top?)

Return the first visible node preceding the given node in the subtree
of top. This function behaves in the same manner as the
C<$node->previous($top)> method, except that nodes of hidden subtrees
are skipped.

=cut
sub PrevVisibleNode {
  my ($node,$top)=@_;
  $node=Prev($node,$top);
  my $fs=$grp->{FSFile}->FS;
  while ($node) {
    return $node unless ($fs->isHidden($node));
    $node=Prev($node,$top);
  }
  return 0;
}

=item IsHidden (node)

Return true if the given node is member of a hidden subtree. This
macro is only an abbreviation for
C<$grp->{FSFile}->FS->isHidden(node)>

=cut
sub IsHidden {
  my ($node)=@_;
  return $grp->{FSFile}->FS->isHidden($node);
}

=item Hide (node)

Hide the given node.

=cut
sub Hide {
  my ($node)=@_;
  my $hide=$grp->{FSFile}->FS->hide();
  if ($node and $hide ne "") {
    $node->{$hide}='hide';
    return 1;
  }
  return 0;
}

=back

=cut

###########################################################
# Macros for backward compatibility with Graph

=head3 Macros used by Graph2Tred macro convertor

=over 4

=item PlainNewSon (parent)

Add a new child node to the given parent and make it the current
node (by setting C<$this> to point to it).

=cut
sub PlainNewSon {
## Adds new son to a given parent
  my $parent=shift;
  return unless ($parent);
  my $nd=FSNode->new();
  PasteNode($nd,$parent);
  return $this=$nd;
}

=item PlainDeleteNode

Delete the given node. The node must be a leaf of the tree (may not
have any children) and must have a parent (may not be the root of the
tree).

=cut
sub PlainDeleteNode {
## Deletes given node
  my $node=shift;
  return undef unless ($node and Parent($node));

  $this=Parent($this) if ($node == $this);
  return DeleteLeaf($node);
}


=item Attributes

Return a list of names of all attributes declared in the header of the
current FS file.

=cut
sub Attributes {
  return $grp->{FSFile}->FS->attributes;
}

=item PrintToFile (filename, string, ...)

Print given strings to the end of the given file.

=cut
sub PrintToFile {
  my $file=shift;
  return unless( defined($file) and $file ne '' );
  my @a=@_;

  if (open(PTF,">>$file")) {
    print PTF (join("",(map {
      s/\\\|/|/g;
      s/\\n/\n/g;
      $_} @a)));
    close(PTF);
  } else { print STDERR "Could not open file $file\n"; }
}

=item ValNo (n,string)

Return the n'th field of the given string where individual fields are
separated by "|".

=cut
sub ValNo {
  my $n=shift;
  my @val=ListSplit(shift);
  return $val[$n];
}

=item AtrNo (n)

Retrun name of the n'th attribute defined in the FS file. This macro
only abbreviates the following expression:
C<$grp->{FSFile}->FS->atno(n)>

=cut
sub AtrNo {
  return $grp->{FSFile}->FS->atno(shift);
}

=item Union(string_a,string_b)

Return a string consisting of |-separated fields which form a pairwise
disjoint set of the |-separated fields of the given strings string_a
and string_b.

=cut
sub Union {
  my @c=();
  my $s;
  my $t;
  element: foreach $s (ListSplit(shift),ListSplit(shift)) {
    for ($t=0;$t<=$#c;$t++) {
      next element if ($c[$t] eq $s);
    }
    push @c,$s;
  }
  return join('|',@c);
}

=item Interjection (string_a,string_b)

Return a string consisting of |-separated fields which form the
interjection of the sets of |-separated fields of the given strings
string_a and string_b.

=cut
sub Interjection {
  return $_[0] unless $_[1] ne "";
  my @a=ListSplit($_[1]);
  my @c=();
  my $s;
  my $t;
  element: foreach $s (ListSplit(Union($_[0],""))) {
    for ($t=0;$t<=$#a;$t++) {
      if ($a[$t] eq $s) {
	push(@c,$s);
	next element;
      }
    }
  }
  return join '|',@c;
}

=item ListSplit (string)

Split the given string of |-separated fields and return a list of the
individual fields.

=cut
sub ListSplit {

  my $s=shift;
  my $j=0,$i=0;
  my @a=();
  while (($j=index($s,'|',$j))>=0) {
    $j++,next if ($j>0 and substr($s,$j-1,1) eq "\\");
    push @a, substr($s,$i,$j-$i);
    $i=++$j; $j=$i;
  }
  push @a, substr($s,$i,length($s)-$i) if ($i<length($s));
  return @a;
}

=item ListJoin (list)

Form a string of |-separated fields from the given list of fields.

=cut
sub ListJoin {
 return join '|', map { s/|/\|/ }  @_;
}

=item ListEq (string1, string2)

Compare the sets of |-separated fields of the two given
strings. Return true if the sets contain the same elements; return
false otherwise.

=cut
sub ListEq {
  my ($a,$b)=(shift,shift);
  $a=Union($a,""); # make them uniqe
  $b=Union($b,""); # make them uniqe
  my @a=ListSplit($a);
  my @b=ListSplit($b);

  return 0 unless ($#a == $#b);

  my @c=ListSplit(Union($a,$b));

  return ($#a == $#c);
}

=item ListAssign (string,n,value)

Return the given string of |-separated fields, except that the n'th
field in the string is replaced by the given value.

=cut
sub ListAssign {
  my @a=ListSplit(shift);
  my ($n,$value)=(shift,shift);

  $a[$n]=ValNo(0,$value);
  return join '|',@a;
}

=item SubStr (string, position, length)

Simple substr wrapper which returns empty string if the position is
beyond the end of the string.

=cut
sub SubStr {
  my ($str, $pos, $len)=(shift, shift, shift);

  return "" if ($pos > length($str));
  return substr($str,$pos,$len);
}

=back

=head3 Node shifting macros

=over 4

=item GetNodes (top?)

Get a list of all nodes in the current tree of (if top is given) in
the subtree of top (the root of the tree is icluded as well). The list
returned is ordered in the natural structure ordering.
(This function automatically returns array reference in scalar context.)

=cut
sub GetNodes {
  my $top = defined($_[0]) ? $_[0] : $root;
  my $node=$top;
  my @n;
  while ($node) {
    push @n,$node;
    $node=$node->following($top);
  }
  return wantarray ? @n : \@n;
}

=item GetVisibleNodes (top?)

Return the list of all visible nodes in the subtree of the given top
node (or the whole current tree if no top is given). The list returned
is ordered in the natural structure ordering and all members of hidden
subtrees are skipped.

=cut
sub GetVisibleNodes {
  my $top = defined($_[0]) ? $_[0] : $root;
  my $node=$top;
  my @n;
  while ($node) {
    push @n,$node;
    $node=NextVisibleNode($node,$top);
  }
  return @n;
}

=item NormalizeOrds (listref)

Adjusts the special FS numbering attribute of every node of the list
referenced by the listref argument so that the value for the attribute
corresponds to the order of the node in the list.

=cut
sub NormalizeOrds {
  my ($nodesref)=@_;

  my $ord=$grp->{FSFile}->FS->order;
  for (my $i=0;$i<=$#$nodesref;$i++) {
    $nodesref->[$i]->{$ord}=$i;
  }
  for (my $i=0;$i<=$#$nodesref;$i++) {
    RepasteNode($nodesref->[$i]);
  }
}

=item SortByOrd (listref)

Sort the list of nodes referenced by the listref argumnt according to
the values of the special FS numbering attribute.

=cut
sub SortByOrd {
  my ($nodesref)=@_;
  my $ord=$grp->{FSFile}->FS->order;
  @$nodesref=sort { $a->{$ord} <=> $b->{$ord} } @$nodesref;
  return $nodesref;
}

=item RepasteNode (node)

Cut the given node and paste it immediately on the same parent so that
its structural position between its parent children is brought to
correspondence with the values of the special FS numbering attribute.

=cut
sub RepasteNode {
  my ($node)=@_;
  my $parent=Parent($node);
  return unless $parent;
  Fslib::Paste(Fslib::Cut($node),$parent,$grp->{FSFile}->FS->defs);
}

=item ShiftNodeRightSkipHidden (node)

Shift the current node in the tree to the right leaping over all
hidden subtress by modifying the tree structure and value of the
special FS numbering attribute appropriately.

=cut
sub ShiftNodeRightSkipHidden {
  my ($node)=@_;
  my $ord=$grp->{FSFile}->FS->order;
  return unless $node;
  my @all=GetNodes();
  SortByOrd(\@all);

  # This is sideeffect, but
  # whe want to do this anyway
  NormalizeOrds(\@all);
  #
  #
  print "$n\n";
  my $n=$node->{$ord};
  return $n if ($n == $#all);

  my @vis=GetVisibleNodes();
  SortByOrd(\@vis);
  my $m=Index(\@vis,$node);
  return undef unless (defined($m) and $m<$#vis);
  my $x=min(Index(\@all,$vis[$m+1]),$#all);
  for (my $i=$n+1;$i<=$x;$i++) { $all[$i]->{$ord}--; }
  $node->{$ord}=$x;
  my $parent=Parent($node);
  Fslib::Paste(Fslib::Cut($node),$parent,$grp->{FSFile}->FS->defs);
}

=item ShiftNodeLeftSkipHidden (node,min?)

Shift the current node in the tree to the left leaping over all hidden
subtress by modifying the tree structure and value of the special FS
numbering attribute appropriately. The optional argument min may be
used to specify the minimum left boundary for the value of the
ordering attribute of node.

=cut
sub ShiftNodeLeftSkipHidden {
  my ($node,$min)=@_;          # min sets the minimum left...
  my $ord=$grp->{FSFile}->FS->order;     # ... boundary for Ord
  return unless $node;
  my @all=GetNodes();
  SortByOrd(\@all);

  # This is sideeffect, but
  # whe want to do this anyway
  NormalizeOrds(\@all);
  #
  #
  print "$n\n";
  my $n=$node->{$ord};
  return $n if ($n == 0);

  my @vis=GetVisibleNodes();
  SortByOrd(\@vis);
  my $m=Index(\@vis,$node);
  return undef unless (defined($m) and !defined($min) || $m>$min);
  my $x=max(Index(\@all,$vis[$m-1]),0);
  for (my $i=$n-1;$i>=$x;$i--) { $all[$i]->{$ord}++; }
  $node->{$ord}=$x;
  RepasteNode($node);
}

=item ShiftNodeRight (node)

Shift the current node in the tree to the right by modifying the tree
structure and value of the special FS numbering attribute
appropriately.

=cut
sub ShiftNodeRight {
  my ($node)=@_;
  my $ord=$grp->{FSFile}->FS->order;
  return unless $node;
  my @all=GetNodes();
  SortByOrd(\@all);

  # This is sideeffect, but
  # whe want to do this anyway
  NormalizeOrds(\@all);
  #
  #

  my $n=$node->{$ord};
  return $n if ($n == $#all);

  $all[$n+1]->{$ord}=$n;
  $node->{$ord}=$n+1;
  RepasteNode($node);
}

=item ShiftNodeLeft (node)

Shift the current node in the tree to the right by modifying the tree
structure and value of the special FS numbering attribute
appropriately.

=cut
sub ShiftNodeLeft {
  my ($node)=@_;
  my $ord=$grp->{FSFile}->FS->order;
  return unless $node;
  my @all=GetNodes();
  SortByOrd(\@all);

  # This is sideeffect, but
  # whe want to do this anyway
  NormalizeOrds(\@all);
  #
  #

  my $n=$node->{$ord};
  return $n if ($n == 0);

  $all[$n-1]->{$ord}=$n;
  $node->{$ord}=$n-1;
  RepasteNode($node);
}

=back

=head3 Miscelaneous macros

=over 4

=cut

=item HiddenVisible

Return true if TrEd presently displays hidden nodes.

=cut
sub HiddenVisible {
  return (ref($grp->{treeView}) and $grp->{treeView}->get_showHidden());
}


=item PrevNodeLinear(node,attribute,top?)

Returns nearest node in the tree preceding the given node in linear
ordering provided by the given attribute. If top node is present, only
a subtree of top is examined.

=cut

sub PrevNodeLinear {
  my ($node, $attr, $top) = @_;

  return undef unless $node;

  my $v=$node->{$attr};
  my $best;
  my $best_v;

  my $nv;
  $node=$top || $root; # reusing variable $node
  while ($node) {
    $nv=$node->{$attr};
    if ($nv < $v and
	(!$best or $nv > $best_v)) {
      $best_v=$nv;
      $best=$node;
    }
    $node=$node->following($top);
  }
  return $best;
}

=item NextNodeLinear(node,attribute,top?)

Returns nearest node in the tree following the given node in linear
ordering provided by the given attribute. If top node is present, only
a subtree of top is examined.

=cut

sub NextNodeLinear {
  my ($node, $attr, $top) = @_;

  return undef unless $node;

  my $v=$node->{$attr};
  my $best;
  my $best_v;

  my $nv;
  $node=$top || $root; # reusing the variable
  while ($node) {
    $nv=$node->{$attr};
    if ($nv > $v and
	(!$best or $nv < $best_v)) {
      $best_v=$nv;
      $best=$node;
    }
    $node=$node->following($top);
  }
  return $best;
}


=item GetTrees

Return a list of trees in current FSFile. Equivallent to
$grp->{FSFile}->trees.

=cut

sub GetTrees {
  return $grp->{FSFile}->trees;
}

=item FS

Return FSFormat object associated with the current FSFile.

=cut

sub FS {
  return $grp->{FSFile}->FS;
}

=item FileName

Return current file's name.

=cut

sub FileName {
  return $grp->{FSFile}->filename if $grp->{FSFile};
}

=item CurrentTreeNumber

Return current tree number.

=cut

sub CurrentTreeNumber {
  return $grp->{treeNo};
}

=item GetNodeIndex

Return given node's position in the deep-first tree ordering.

=cut

sub GetNodeIndex {
  my $node = ref($_[0]) ? $_[0] : $this;
  my $i=-1;
  while ($node) {
    $node=$node->previous();
    $i++;
  }
  return $i;
}

=item ThisAddress

Return current node's address string in a form of filename#tree_no.index
(tree_no starts from 1 to reflect TrEd's UI convention).

=cut

sub ThisAddress {
  my $node = ref($_[0]) ? $_[0] : $this;
  return FileName().'##'.(CurrentTreeNumber()+1).'.'.GetNodeIndex($node);
}

=item ThisAddressNTRED

Return current node's address string in a form of
ntred://filename@tree_no#1.index (tree_no starts from 1 to reflect
TrEd's UI convention). This address may be opened in TrEd to examine
the tree in memory of a remote btred server.

=cut

sub ThisAddressNTRED {
  my $node = ref($_[0]) ? $_[0] : $this;
  return "ntred://".FileName().'@'.(CurrentTreeNumber()+1).'##1.'.GetNodeIndex($node);
}

=item GetFileSaveStatus

Return 1 if some file modification was noticed by TrEd untill last save
or reload, 0 otherwise.

=cut

sub GetFileSaveStatus {
  return $grp->{FSFile}->notSaved;
}

=item SetFileSaveStatus

Use SetFileSaveStatus(1) to declare that some modification was made to
the file. Use SetFileSaveStatus(0) after the file was saved from a
macro (and TrEd/bTrEd would not notice that).

=cut

sub SetFileSaveStatus {
  $grp->{FSFile}->notSaved($_[0]);
}


=item GetSpecialPattern (prefix)

Return value of the first pattern prefixed with given prefix.
Note, that only some prefixes (such as node, edge, style, or rootstyle)
are used by TrEd. All other patterns are ignored, so feel free to
use them for other purposes.

=cut

sub GetSpecialPattern {
  my ($patname)=@_;
  my $pat;
  foreach ($grp->{FSFile}->patterns()) {
    if (/^$patname:\s*(\S+)\s*$/) {
      $pat=$1,last;
    }
  }
  return $pat;
}

=item GUI

Return 1 if running from TrEd, i.e., GUI is available.

=cut


sub GUI {
  return (ref($grp) eq 'TrEd::Window');
}


=item SubstituteFSHeader(declarations)

Substitute a new FS header for current document. A list of valid FS
declarations must be passed to this function.

=cut

sub SubstituteFSHeader {
  $grp->{FSFile}->changeFS(FS()->create(@_));
}


=item AppendFSHeader(declarations)

Merge given FS header declarations with the present header
of the current document.

=cut
sub AppendFSHeader {
  my $new=FS()->create(@_);
  my $newdefs=$new->defs();
  my $fs=$grp->{FSFile}->FS;
  my $defs=$grp->{FSFile}->FS->defs();
  my $list=$grp->{FSFile}->FS->list();
  foreach ($new->attributes()) {
    push @$list, $_ unless ($fs->exists($_));
    $defs->{$_}=$newdefs->{$_};
  }
  @{$fs->unparsed}=$fs->toArray() if $fs->unparsed;
}

=item UndeclareAttributes(@attributes)

Remove declarations of given attributes from the FS header

=cut

sub UndeclareAttributes {
  my $fs=$grp->{FSFile}->FS;
  my $defs=$grp->{FSFile}->FS->defs();
  my $list=$grp->{FSFile}->FS->list();
  delete @{$defs}{@_};

  @$list=grep { exists($defs->{$_}) } @$list;
  @{$fs->unparsed}=grep { !/^\@\S+\s+([^\s|]+)/ || exists($defs->{$1})  }
    @{$fs->unparsed} if $fs->unparsed;

}


=item AddStyle($styles,$object,%styles)

Auxiliary funcion: add styles for an object to given style-sheet (can
be used e.g. from node_style_hook).

=cut
sub AddStyle {
  my $styles=shift;
  my $style=shift;
  if (exists($styles->{$style})) {
    push @{$styles->{$style}},@_
  } else {
    $styles->{$style}=[@_];
  }
}

=item DefaultInputEncoding()

Return's TrEd's/bTrEd's default IO encoding.

=cut
sub DefaultInputEncoding {
  return $TrEd::Convert::inputenc;
}


=item SetDefaultInputEncoding($encoding)

Set TrEd's/bTrEd's default IO encoding.

=cut
sub SetDefaultInputEncoding {
  $TrEd::Convert::inputenc = $_[0];
}

=item stdout

If called without arguments return current standard output filehandle.
Otherwise call print the arguments to standard output.

=cut
sub stdout { @_ ? $::stdout && $::stdout->print(@_) : $::stdout }

=item stderr

If called without arguments return current standard error output
filehandle.  Otherwise call print the arguments to standard output.

=cut
sub stderr { @_ ? $::stderr && $::stderr->print(@_) : $::stderr}

=item tmpFileName

Returns a temporary filename..

=cut
sub tmpFileName {
  require POSIX;
  return POSIX::tmpnam();
}

=item DumpFS ($treelist, $fsfile, $fh)

Dump given trees from the given FSFile in FS format to the given
filehandle. If $treelist is undefined, all trees from the FSFile are
dumped. If $fsfile is undefined, current file is used. If $fh is
undefined, STDOUT is used.

=cut

sub DumpFS {
  my ($treelist, $fsfile, $fh)=@_;

  $fsfile ||= $grp->{FSFile};
  $fh ||= \*STDOUT;
  $treelist ||= $fsfile->treeList;

  return 0 unless ref($fsfile);

  $fsfile->FS->writeTo($fh);
  Fslib::PrintFS($fh,undef,
		 $fsfile->treeList,
		 $fsfile->FS->list,
		 $fsfile->FS->defs);
  $fh->print($fsfile->tail);
  return 1;
}

=item ChangingFile (0|1)

If no argument given the default is 1. If C<$FileChanged> is already
set to 1 already 1, does nothing. If C<$FileChanged> has not yet been
assigned or is zero, sets it to the given value. Returns the resulting
value. ChangingFile(1) also resets $forceFileSaved to 0.

=cut

sub ChangingFile {
  my ($val)=@_;
  $val=1 if !defined($val);
  if ($FileChanged eq '?') {
    $FileChanged=$val;
  } elsif ($FileChanged==0) {
    $FileChanged=$val;
  }
  $forceFileSaved=0 if ($val);
  return $FileChanged;
}

=back



=cut


