## This is macro file for Tred                                 -*-cperl-*-
## author: Petr Pajas
## created: Wed Mar 15 14:50:16 CET 2000

#ifndef __TRED_MAC__
#define __TRED_MAC__

## add few custom bindings to predefined subroutines

#bind Save to F2 menu Save File
#bind SaveAndPrevFile to F11 menu Save and Go to Next File
#bind SaveAndNextFile to F12 menu Save and Go to Next File
#bind PrevFile to Shift+F11 menu Go to Next File
#bind NextFile to Shift+F12 menu Go to Next File

#bind Find_nochange to F3 menu Find
sub Find_nochange { Find(@_); ChangingFile(0) }

#bind FindNext_nochange to F4 menu Find Next
sub FindNext_nochange { FindNext(@_); ChangingFile(0); }
#bind NewRBrother to F7 menu New Node (r-brother)
#bind NewSon to Shift+F7 menu New Node (son)
#bind DeleteThisNode to F8 menu Delete Node
#bind CopyValues_nochange to F5 menu Copy Values
sub CopyValues_nochange { CopyValues(@_); ChangingFile(0); }
#bind PasteValues to F6 menu Paste Values
#bind PrevTree_nochange to comma
sub PrevTree_nochange { PrevTree(@_); ChangingFile(0); }
#bind NextTree_nochange to period
sub NextTree_nochange { NextTree(@_); ChangingFile(0); }
#bind TiePrevTree_nochange to Ctrl+comma
sub TiePrevTree_nochange { TiePrevTree(@_); ChangingFile(0); }
#bind TieNextTree_nochange to Ctrl+period
sub TieNextTree_nochange { TieNextTree(@_); ChangingFile(0); }
#bind TiePrevTree_nochange to Ctrl+Prior
sub TiePrevTree_nochange { TiePrevTree(@_); ChangingFile(0); }
#bind TieNextTree_nochange to Ctrl+Next
sub TieNextTree_nochange { TieNextTree(@_); ChangingFile(0); }

#bind CutToClipboard to Ctrl+Insert menu Cut Subtree
sub CutToClipboard {
  return unless ($this and $this->parent);
  $nodeClipboard=$this;
  $this=$this->rbrother ? $this->rbrother : $this->parent;
  CutNode($nodeClipboard);
}

#bind PasteFromClipboard to Shift+Insert menu Paste Subtree
sub PasteFromClipboard {
  return unless ($this and $nodeClipboard);
  PasteNode($nodeClipboard,$this);
  $this=$nodeClipboard;
  $nodeClipboard=undef;
}

sub QueryString {
  ## display a dialog box with an edit line and Ok/Cancel buttons
  ## parameters: window title, entry label, default value

  main::QueryString($grp->{framegroup},@_);
}

sub editQuery {
  ## draws a dialog box with one Text widget and Ok/Cancel buttons
  ## expects dialog title and default text
  ## returns text of the Text widget
  my $d;
  my $ed;

  my ($title,$var,$hintText)=@_;

  $d=ToplevelFrame()->DialogBox(-title => $title,
			   -buttons => ["OK","Cancel"]);
  main::addBindTags($d,'dialog');
  $d->bind('all','<Tab>',sub { shift->focusNext; });
  $d->bind('all','<Shift-Tab>',sub { shift->focusPrev; });
  if ($hintText) {
    my $t=$d->add(qw/Label -wraplength 6i -justify left -text/,$hintText);
    $t->pack(qw/-padx 0 -pady 10 -expand yes -fill both/);
  }
  $ed=$d->Scrolled(qw/Text -height 8 -relief sunken -scrollbars sw -borderwidth 2/,-font => $main::font);
  $ed->insert('0.0',$var);
  $ed->pack(qw/-padx 0 -pady 10 -expand yes -fill both/);
  $d->bind(ref($ed->Subwidget('scrolled')),'<Control-Return>' => sub {1;});
  $d->bind('<Return>' => sub {Tk->break;});
  $d->bind('<Control-Return>' => sub { shift->toplevel->{default_button}->Invoke; Tk->break;});
  $d->bind($d,'<Escape>', [sub { shift; shift->{selected_button}= 'Cancel'; },$d] );
  $d->bind(ref($ed->Subwidget('scrolled')),'<Escape>', [sub { shift; my $w=shift; $w->{selected_button}= 'Cancel'; },$d] );
  $ed->focus;
  if (main::ShowDialog($d) =~ /OK/) {
    $var=$ed->get('0.0','end');
    chomp($var);
    $d->destroy();
    return $var;
  } else {
    $d->destroy();
    return undef;
  }
}

sub ListQuery {
  my ($title,$select_mode,$vals,$selected)=@_;
  my $top=ToplevelFrame();
  main::listQuery($top,$title,$select_mode,$vals,$selected);
}

sub questionQuery {
  my ($title, $message,@buttons) = @_;

  my $d = ToplevelFrame()->DialogBox(-title => $title,
				     -buttons => [@buttons]);
  $d->add('Label', -text => $message, -font => StandardTredFont(), -wraplength => 200)->pack;
  $d->bind('<Return>', sub { my $w=shift; my $f=$w->focusCurrent;
			     $f->Invoke if ($f and $f->isa('Tk::Button')) } );
  $d->bind($d,'<Escape>', [sub { shift; shift->toplevel->{selected_button}= 'Cancel' },$d] );
#    if grep { $_ eq 'Cancel' } @buttons;
  $d->bind('all','<Tab>',[sub { shift->focusNext; }]);
  return $d->Show;
}


#bind PerlSearch to Alt+H menu Perl-Search
sub PerlSearch {
  my $label= "Any inserted perl code will be evaluated for each node from current ".
  "as long as it ends with zero or undefined value; the first node for which ".
  "the code succeedes (returns defined non-zero value) will be selected.\n\n".
  "Use \`\$this\' to refer to the current node, \`\$root\' to the root of the tree.\n".
  "If \`\$n\' refers to some node, \`\$n->{attr}\' is its value of the attribute \`attr\'.\n".
  "The governor of a node \$n is \`\$n->parent\', nearest ".
  "left brother of \'\$n\' in the tree structure is \'\$n->lbrother\'".
  "the right brother of \$n is \`\$n->rbrother\'. The first son of \'$n\' ".
  "is referred to as \`\$->firstson\'. If no such node exists, all these functions ".
  "return zero (\`0\') or possibly \`undef\'.".
  "NOTE: \$n->lbrother and \$n->rbrother are not necesserilly displayed on left of \$n\n\n".
  "Press Ctrl+Enter to start search\n\n"
    ;

  my $script = editQuery("Search: insert perl expression:",$TrEd::MacroStorage::macPerlSearchScript,$label);
  unless ($script) {
    $FileNotSaved=0;
    return;
  }
  $TrEd::MacroStorage::macPerlSearchScript=$script;
  while ($this=$this->following or NextTree()) {
    last if eval($script);
    if ($@) {
      ErrorMessage($@);
      last;
    }
  };
}

#bind PerlEval to Alt+e menu Perl-Eval
sub PerlEval {
  my $label= <<EOF;
Insert perl code to evaluate.

Use:
\$this\t\t- to refer to the current node
\$root\t\t- to the root of the tree
\$n->{attr}\t- to refer to the attribute `attr' of node \$n
\$n->parent\t- to refer to \$n's parent
\$n->lbrother\t- to refer to \$n's nearest left sibling
\$n->rbrother\t- to refer to \$n's nearest right sibling
\$n->firstson\t- to refer to \$n's leftmost child node
\$n->children\t- to obtain a list of all \$n's child nodes
\$n->descendants\t- to obtain a list of all nodes in \$n's subtree

When finished, press Ctrl+Enter to execute your script.
EOF

  my $script = editQuery("Insert perl expression:",$TrEd::MacroStorage::macPerlEvalScript,$label);
  unless ($script) {
    $FileNotSaved=0;
    return;
  }
  $TrEd::MacroStorage::macPerlEvalScript=$script;
  eval("package ".CurrentContext().";\n#line 1\n".$script);
  die $@ if $@;
}


#bind GotoTreeAsk to Alt+g menu Go to...
sub GotoTreeAsk {
  my $to=main::QueryString($grp->{framegroup},"Give a Tree Number","Number");

  $FileNotSaved=0;
  if ($to=~/#/) {
    for (my $i=$grp->{treeNo}+1; $i<=$grp->{FSFile}->lastTreeNo; $i++) {
      GotoTree($i+1), return if ($grp->{FSFile}->treeList->[$i]->{form} =~ $to);
    }
    for (my $i=0; $i<$grp->{treeNo}; $i++) {
      GotoTree($i+1), return if ($grp->{FSFile}->treeList->[$i]->{form} =~ $to);
    }
  } else {
    GotoTree($to) if defined $to;
  }
  ChangingFile(0);
}

#bind GotoFileAsk to Alt+G menu Go to file...
sub GotoFileAsk {
  my $to=main::QueryString($grp->{framegroup},"Give a File Number","Number");
  return unless $to=~/^\s*\d+\s*$/;
  if (GotoFileNo($to-1)) {
    $FileNotSaved = GetFileSaveStatus();
  } else {
    ChangingFile(0);
  }
}


#bind TieGotoTreeAsk to Ctrl+Alt+g menu Go to... (tied)
sub TieGotoTreeAsk {
  my $to=main::QueryString($grp->{framegroup},"Give a Tree Number","Number");

  if ($to=~/#/) {
    for (my $i=$grp->{treeNo}+1; $i<=$grp->{FSFile}->lastTreeNo; $i++) {
      TieGotoTree($i+1), return if ($grp->{FSFile}->treeList->[$i]->{form} =~ $to);
    }
    for (my $i=0; $i<$grp->{treeNo}; $i++) {
      TieGotoTree($i+1), return if ($grp->{FSFile}->treeList->[$i]->{form} =~ $to);
    }
  } else {
    TieGotoTree($to) if defined $to;
  }
  ChangingFile(0);
}

#bind PerlSearchNext to Ctrl+Alt+H menu Perl-Search Next
sub PerlSearchNext {
  if ($TrEd::MacroStorage::macPerlSearchScript) {
    while ($this=$this->following or NextTree()) {
      last if eval($TrEd::MacroStorage::macPerlSearchScript);
    }
  } else {
    PerlSearch();
  }
}

#bind TieLastTree to Ctrl+End menu Go to last tree (tied)
sub TieLastTree {
  ChangingFile(0);
  TieGotoTree($grp->{FSFile}->lastTreeNo+1);
}

#bind TieFirstTree to Ctrl+Home menu Go to first tree (tied)
sub TieFirstTree {
  ChangingFile(0);
  TieGotoTree(1);
}


#bind LastTree to End menu Go to last tree
#bind LastTree to greater
sub LastTree {
  ChangingFile(0);
  GotoTree($grp->{FSFile}->lastTreeNo+1);
}

#bind FirstTree to Home menu Go to first tree
#bind FirstTree to less
sub FirstTree {
  ChangingFile(0);
  GotoTree(1);
}

#bind GotoNextNodeLin to Ctrl+greater
sub GotoNextNodeLin {
  ChangingFile(0);
  my $sentord=$grp->{FSFile}->FS->sentord;
  my $next=NextNodeLinear($this,$sentord);
  unless (HiddenVisible()) {
    while ($next and IsHidden($next)) {
      $next=NextNodeLinear($next,$sentord);
    }
  }
  $this=$next if $next;
}

#bind GotoPrevNodeLin to Ctrl+less
sub GotoPrevNodeLin {
  ChangingFile(0);
  my $sentord=$grp->{FSFile}->FS->sentord;
  my $next=PrevNodeLinear($this,$sentord);
  unless (HiddenVisible()) {
    while ($next and IsHidden($next)) {
      $next=PrevNodeLinear($next,$sentord);
    }
  }
  $this=$next if $next;
}

@global_exit_hooks=();

# the hook may be either a sub name, CODE ref or ARRAY ref, where
# the first element of the array is the name/CODE-ref to execute
# and the rest are arguments to be passed to it
sub register_exit_hook ($) {
  my ($hook)=@_;
  push @global_exit_hooks,$hook;
}

sub unregister_exit_hook ($) {
  my ($hook)=@_;
  @global_exit_hooks=grep { $_ ne $hook } @global_exit_hooks;
}

sub exit_hook {
  foreach my $sub (@global_exit_hooks) {
    if (ref($sub) eq 'ARRAY') {
      my $realsub=shift @$sub;
      eval{ &{$realsub}(@$sub); };
    } else {
      eval{ &$sub(); };
    }
    stderr($@) if $@;
  }
}

#ifinclude <contrib/contrib.mac>

package TredMacro;
#binding-context TredMacro

#endif __TRED_MAC__
