.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
''' Revision 1.1  2000/04/26 08:15:03  pajas
''' Initial revision
'''
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH Fslib 3 "perl 5.004, patch 04" "25/Apr/100" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
Fslib.pm \- Simple API for treebank files in .fs format 
.SH "SYNOPSIS"
.PP
.Vb 3
\&  use Fslib;
\&  use locale;
\&  use POSIX qw(locale_h);
.Ve
.Vb 2
\&  setlocale(LC_ALL,"cs_CZ");
\&  setlocale(LANG,"czech");
.Ve
.Vb 3
\&  %attribs = ();
\&  @atord = ();
\&  @trees = ();
.Ve
.Vb 2
\&  # read the header
\&  %attribs=ReadAttribs(\e*STDIN,\e@atord,2,\e@header);
.Ve
.Vb 7
\&  # read the raw tree
\&  while ($_=ReadTree(\e*F)) {
\&    if (/^\e[/) {
\&      $root=GetTree($_,\e@atord,\e%attribs);  # parse the tree
\&      push(@trees, $root) if $root;         # store the structure
\&    } else { push(@rest, $_); }             # keep the rest of the file
\&  }
.Ve
.Vb 2
\&  # do some changes 
\&  ...
.Ve
.Vb 8
\&  # save the tree
\&  print @header;      # print header
\&  PrintFS(\e*STDOUT,
\&          \e@header,
\&          \e@trees,
\&          \e@atord,
\&          \e%attribs); # print the trees
\&  print @rest;        # print the rest of the file
.Ve
.Vb 3
\&  # destroy trees and free memory
\&  foreach (@trees) { DeleteTree($_); }
\&  undef @header;
.Ve
.SH "DESCRIPTION"
This package has the ambition to be a simple and usable perl API for manipulating the
treebank files in the .fs format (which was designed by Michal Kren
and is the only format supported by his Windows application GRAPH.EXE
used to interractively edit treebank analytical or tectogramatical
trees). See also Dan Zeman's review of this format in czech at
.PP
http://ufal.mff.cuni.cz/local/doc/trees/format_fs.html
.PP
The Fslib package defines functions for parsing .fs files, extracting
headers, reading trees and representing them in memory using simple
hash structures, manipulate the values of node attributes (either
\*(L"directly\*(R" or via \fBGet\fR and \fBSet\fR functions) and even modify the structure
of the trees (via \fBCut\fR, \fBPaste\fR and \fBDeleteTree\fR functions or \*(L"directly").
.SH "USAGE"
There are many ways to benefit from this package, I note here the most
typical one. 
Assume, you want to read the .fs file from the STDIN (or whatever),
then make some changes either to the structure of the trees or to the
values of the attributes (or both) and write it again. (Maybe you
only want to examine the structure, find something of your interest
and write some output about it -- it's up to you). For this purpose
you may use the code similar to the one mentioned in SYNOPSIS of this
document. Let's see how to manage the appropriate tasks (also watch the
example in SYNOPSIS while reading):
.Sh "\s-1PARSING\s0 \s-1FS\s0 \s-1FILES\s0"
First you should read the header of the .fs file using
\fBReadAttribs()\fR function, passing it as parameters the reference to
the input file descriptor (like \e*\s-1STDIN\s0), reference to an array, that
will contain the list of attribute names positionaly ordered and
storing its return value to a hash. The returned hash will then have the
attribute names as keys and their type character definitions as
values. (see ReadAttribs description for detail).
.PP
Note, that no Read... function from this package performs any seeking,
only reads the file on. So, it's expected, that you are at the
beggining of the file when you call ReadAttribs, and that you have
read the header before you parse the trees.
.PP
Anyway, having the attribute definitions read you probbably want to
continue and parse the trees. This is done in two steps. First you
call the \fBReadTree()\fR function (passing it only a reference to the
input file descriptor) to obtain (on return) a scalar (string),
containing a linear representation of the next tree on input in the
\&.fs format (except for line-breaks). You should store it. Now you
should test, that it was really a tree that was read and not something
else, which may be some environmetal or macro definition for \s-1GRAPH\s0.\s-1EXE\s0
which is allowed by .fs format. This may be done simply by matching
the result of \fBReadTree()\fR with the pattern /^\e[/ because trees and
only trees begin with the square bracket `[\*(R'. If it is so, you may
continue by parsing the tree with \fBGetTree()\fR. This function parses
the linear .fs representation of the tree and re-represents it as a
structure of references to perl hashes (this I call a tree node
structure \- \s-1TNS\s0). For more about \s-1TNS\s0's see chapter called \s-1MODIFYING\s0
\s-1AND\s0 \s-1EXAMINING\s0 \s-1TREES\s0 and the \s-1REFERENCE\s0 item Tree Node Structure. On
return of \fBGetTree()\fR you get a reference to the tree's \s-1TNS\s0. You may
store it (by pushing it to an array, i.e.) and continue by reading
next tree, or do any other job on it.
.PP
When you are finished with reading the trees and also had made all the
changes you wanted, you may want to write the trees back. This is done
using the \fBPrintFS()\fR function (see its description bellow). To
create a corect .fs file, you probably should write back the header
before writing the trees, and also write that messy environmetal stuff
after the trees are written.
.Sh "\s-1MODIFYING\s0 \s-1OR\s0 \s-1EXAMINING\s0 \s-1TREES\s0"
\s-1TNS\s0 represents both a node and the whole subtree having root in this
node. So whole trees are represented by their roots. \s-1TNS\s0 is actualy
just a reference to a hash. The keys of the hashes may be either some
of attribute names or some `special\*(R' keys, serving to hold the tree
structure. Suppose \f(CW$node\fR is a \s-1TNS\s0 and `lemma\*(R' is an attribute defined
in the appropriate .fs file. Than $$node{"lemma"} is value of the
attribute for the node represented by \s-1TNS\s0 \f(CW$node\fR. You may obtain this
value also as \fBGet\fR($node,"lemma"). From the \f(CW$node\fR \s-1TNS\s0 you may
obtain also the node's parent, sons and brothers (both left and
right). This may be done in several equivalent ways. \s-1TNS\s0's of a nodes
relatives are stored under values of those `special\*(R' keys mentioned
above. These keys are chosen in such a way that they should not colide
with attribute names and are stored in the following scalar variables:
.Ip "\(bu" 4
$parent
.Ip "\(bu" 4
$firstson
.Ip "\(bu" 4
$lbrother
.Ip "\(bu" 4
$rbrother
.PP
(You may change these variables if you want, but note, that modifying
them once the trees are read may lead to problems:\-)
.PP
So, to obtain \f(CW$node\fR's parent's \s-1TNS\s0 you may use either
$$node{$parent} or \fBGet\fR($node,$parent) or even special
function \fBParent\fR($node). The same holds for the first son, left and right
brothers while you may also prefere to use the \fBFirstSon()\fR, \fBLBrother()\fR and
\fBRBrother()\fR functions respectively. If the node's relative (say
first son) does not exist, the value obtained in either of the mentioned
ways \fIis\fR still \fIdefined but zero\fR.
.PP
To create a new node, you usually create a new hash and call
\fBNewNode()\fR passing it a reference to the new hash as a parameter.
.PP
To modify a node's value for a certain attribute (say \*(L'lemma'), you
symply type \f(CW$$node{"lemma"}="bar"\fR (supposed you want the value to
become \*(L'bar') or use the \fBSet()\fR function like
\fBSet\fR\f(CW($node,"bar");\fR.
.PP
To modify the tree's structure, you may use \fBCut\fR and \fBPaste\fR
function as described bellow or to delete a whole subtree you may use
the \fBDeleteTree\fR function. This also frees memory used by the \s-1TNS\s0.
If you want to delete a subtree of \f(CW$node\fR, but still keep its root, you may use
a construct like:
.PP
.Vb 1
\&  DeleteTree(FirstSon($node)) while(FirstSon($node));
.Ve
Note, that Cut function also deletes a subree from the tree but
keeps the \s-1TNS\s0 in memory and returns a reference to it.
.SH "REFERENCE"
.Ip "ReadAttribs (\s-1FILE\s0,$aref[,$\s-1DO_PRINT\s0[,\s-1OUTFILE\s0]])" 4
.Sp
.Vb 1
\& Params:
.Ve
.Vb 8
\&   FILE      - file handle reference, like \e*STDIN
\&   $aref     - reference to array
\&   $DO_PRINT - if 1, read input is also copied to
\&               $OUTFILE (which must be a filehandle reference, like
\&               \e*STDOUT).
\&               if 0, read input is also stored to the @$OUTFILE
\&               array (in this case $OUTFILE is a reference to an array).
\&   $OUTFILE - output file handle or array reference , \e*STDIN if ommited
.Ve
.Vb 6
\& Returns:
\&   A hash, having fs-attribute names as keys
\&   and strings containing characters identifying 
\&   types as corresponding values   
\&   The characters may be some of following
\&   (as given by the .fs format):
.Ve
.Vb 6
\&       K        Key attribute
\&       P        Positional attribute
\&       O        Obligatory attribute
\&       L        List attribute
\&       N        Numerical attribute
\&       V        Value atribute (for displaying in GRAPH.EXE)
.Ve
.Vb 5
\&   The $aref should be on input a reference to
\&   an empty array. On return the array contains
\&   the key values of the returned hash (the attributes)
\&   orderd as thay are defined in FS file, i.e. in
\&   their positional order.
.Ve
.Ip "ReadTree (\s-1FILE\s0)" 4
.Sp
.Vb 1
\& Params: 
.Ve
.Vb 1
\&   FILE - file handle, like STDIN
.Ve
.Vb 1
\& Returns:
.Ve
.Vb 2
\&   A string containing the next tree read form FILE
\&   in its source form (only with concatenated lines).
.Ve
.Ip "GetTree ($tree,$aref,$href)" 4
.Sp
.Vb 1
\& Params: 
.Ve
.Vb 5
\&   $tree - the source form of a tree with concatenated lines
\&   $aref - a reference to an array of attributes in their 
\&           positional order (see ReadAttributes)
\&   $href - a reference to a hash, containing attributes as keys
\&           and corresponding type strigs as values
.Ve
.Vb 1
\& Returns:
.Ve
.Vb 2
\&   A reference to a tree hash-structure described below.
\&   
.Ve
.Ip "PrintNode ($node,$aref,$href)" 4
.Sp
.Vb 1
\& Params: 
.Ve
.Vb 6
\&   $node - a reference to a tree hash-structure
\&   $aref - a reference to an array of attributes in their 
\&           positional order (see ReadAttributes)
\&   $href - a reference to a hash, containing attributes as keys
\&           and corresponding type strigs as values
\&  Returns:
.Ve
.Vb 1
\&   Unknown.
.Ve
.Vb 1
\& Descrption:
.Ve
.Vb 2
\&   Prints the node structure referenced by $node 
\&   to STDOUT in a source format
.Ve
.Ip "PrintTree ($node,$aref,$href)" 4
.Sp
.Vb 1
\& Params: 
.Ve
.Vb 7
\&   $node - a reference to a tree hash-structure
\&   $aref - a reference to an array of attributes in their 
\&           positional order (see ReadAttributes)
\&   $href - a reference to a hash, containing attributes as keys
\&           and corresponding type strigs as values
\& 
\& Returns:
.Ve
.Vb 1
\&   Unknown.
.Ve
.Vb 1
\& Descrption:
.Ve
.Vb 2
\&   Prints the tree having its root-node referenced by $node 
\&   to STDOUT in a source format
.Ve
.Ip "Parent($node), FirstSon($node), LBrother($node), RBrother($node)" 4
.Sp
.Vb 1
\& Params: 
.Ve
.Vb 1
\&   $node - a reference to a tree hash-structure
.Ve
.Vb 1
\& Returns:
.Ve
.Vb 2
\&   Parent, first son, left brother or right brother resp. of
\&   the node referenced by $node
.Ve
.Ip "Next($node,[$top]), Prev($node,[$top])" 4
.Sp
.Vb 1
\& Params: 
.Ve
.Vb 3
\&   $node - a reference to a tree hash-structure
\&   $top  - a reference to a tree hash-structure, containing
\&           the node referenced by $node
.Ve
.Vb 1
\& Return:
.Ve
.Vb 4
\&   Reference to the next or previous node of $node on 
\&   the backtracking way along the tree having its root in $top.
\&   The $top parameter is NOT obligatory and may be omitted.
\&   Return zero, if $top of root of the tree reached.
.Ve
.Ip "Cut($node)" 4
.Sp
.Vb 1
\& Params: 
.Ve
.Vb 1
\&   $node - a reference to a node
.Ve
.Vb 1
\&  Description:
.Ve
.Vb 3
\&   Cuts (disconnets) $node from its parent and brothers
\& 
\&  Returns:
.Ve
.Vb 1
\&   $node
.Ve
.Ip "Paste($node,$newparent,$href)" 4
.Sp
.Vb 1
\& Params: 
.Ve
.Vb 5
\&   $node      - a reference to a (cutted or new) node
\&   $newparent - a reference to the new parent node
\&   $href      - a reference to a hash, containing attributes as keys
\&                and corresponding type strigs as values
\& Description:
.Ve
.Vb 6
\&   connetcs $node to $newparent and links it
\&   with its new brothers, placing it to position
\&   corresponding to its numerical-argument value
\&   obtained via call to an Ord function.  
\&                
\& Returns $node
.Ve
.Ip "Special($node,$href,$defchar)" 4
.Sp
.Vb 1
\& Exported with EXPORT_OK
.Ve
.Vb 1
\& Params: 
.Ve
.Vb 4
\&   $node    - a reference to a tree hash-structure
\&   $href    - a reference to a hash, containing attributes as keys
\&              and corresponding type strigs as values
\&   $defchar - a type string pattern
.Ve
.Vb 1
\& Returns:
.Ve
.Vb 2
\&   Value of the first $node attribute of type matching $defchar pattern
\&   
.Ve
.Ip "Ord($node,$href)" 4
.Sp
.Vb 1
\& Exported with EXPORT_OK
.Ve
.Vb 1
\& Params: 
.Ve
.Vb 3
\&   $node - a reference to a tree hash-structure
\&   $href - a reference to a hash, containing attributes as keys
\&           and corresponding type strigs as values
.Ve
.Vb 1
\& Returns:
.Ve
.Vb 2
\&   $node's ord (value of attribute declared by type character N)
\&   Same as Special($node,$href,'N')
.Ve
.Ip "Value($node,$href)" 4
.Sp
.Vb 1
\& Exported with EXPORT_OK
.Ve
.Vb 1
\& Params: 
.Ve
.Vb 3
\&   $node - a reference to a tree hash-structure
\&   $href - a reference to a hash, containing attributes as keys
\&           and corresponding type strigs as values
.Ve
.Vb 1
\& Returns:
.Ve
.Vb 2
\&   $node's value attribut (value of attribute declared by type character V)
\&   Same as Special($node,$href,'V')
.Ve
.Ip "SentOrd($node,$href)" 4
.Sp
.Vb 1
\& Exported with EXPORT_OK
.Ve
.Vb 1
\& Params: 
.Ve
.Vb 3
\&   $node - a reference to a tree hash-structure
\&   $href - a reference to a hash, containing attributes as keys
\&           and corresponding type strigs as values
.Ve
.Vb 1
\& Returns:
.Ve
.Vb 2
\&   $node's sentence ord (value of attribute declared by type character W)
\&   Same as Special($node,$href,'W')
.Ve
.Ip "Hide($node,$href)" 4
.Sp
.Vb 1
\& Exported with EXPORT_OK
.Ve
.Vb 1
\& Params: 
.Ve
.Vb 3
\&   $node - a reference to a tree hash-structure
\&   $href - a reference to a hash, containing attributes as keys
\&           and corresponding type strigs as values
.Ve
.Vb 1
\& Returns:
.Ve
.Vb 3
\&   "hide" if $node is hidden (actually the value of attribute declared
\&   by type character H)
\&   Same as Special($node,$href,'H')
.Ve
.Ip "IsList($attr,$href)" 4
.Sp
.Vb 1
\& Params:
.Ve
.Vb 3
\&   $attr - an atribute name
\&   $href - a reference to a hash, containing attributes as keys
\&           and corresponding type strigs as values
.Ve
.Vb 1
\& Returns:
.Ve
.Vb 3
\&   1 if attribut $attr is declared as a list (L) in hash of attribute defs
\&   (referenced in) $href
\&   0 otherwise
.Ve
.Ip "ListValues($attr,$href)" 4
.Sp
.Vb 1
\& Params:
.Ve
.Vb 3
\&   $attr - an atribute name
\&   $href - a reference to a hash, containing attributes as keys
\&           and corresponding type strigs as values
.Ve
.Vb 1
\& Returns:
.Ve
.Vb 2
\&   a list of allowed values for attribute $attr as defined in
\&   the hash of attribyte defs $href
.Ve
.Ip "Set($node,$attribute,$value)" 4
.Sp
.Vb 1
\& Params: 
.Ve
.Vb 3
\&   $node      - a reference to a node
\&   $attribute - attribute
\&   $value     - value to fill $node's $attribute with
.Ve
.Vb 1
\& Description:
.Ve
.Vb 1
\&   Does the same as $$node{$attribute}=$value
.Ve
.Ip "Get($node,$attribute)" 4
.Sp
.Vb 1
\& Params: 
.Ve
.Vb 2
\&   $node      - a reference to a node
\&   $attribute - attribute
.Ve
.Vb 1
\& Return:
.Ve
.Vb 1
\&   Returns $$node{$attribute}
.Ve
.Ip "DrawTree($node,@attrs)" 4
.Sp
.Vb 1
\& Params: 
.Ve
.Vb 2
\&   $node      - a reference to a node
\&   $attrs     - list of attributes to display
.Ve
.Vb 1
\& Description:
.Ve
.Vb 4
\&   Draws a tree on standard output using character graphics. (May be
\&   particulary useful on systems with no GUI - for real graphical
\&   representation of FS trees look for Michal Kren's GRAPH.EXE or
\&   Perl/Tk based program "tkfs" by Petr Pajas.
.Ve
.Ip "\s-1THE\s0 \s-1TREE\s0 \s-1NODE\s0\-\s-1STRUCTURE\s0 (\s-1TNS\s0)" 4
.Sp
.Vb 1
\& Description:
.Ve
.Vb 3
\& TNS is a normal hash, whose keys are names of attribute
\& and whose values are strings, values of the correspoding 
\& attributes (as they are given in the FS format source). 
.Ve
.Vb 1
\& In addtion, few other keys and values are added to each node:
.Ve
.Vb 4
\&   "Parent"    which is a reference to the parent node (or zero if N/A)
\&   $firstson  a reference to the first son's node (or zero)
\&   "RBrother"  a reference to the first right brother (or zero)
\&   $lbrother  a reference to the first left brother (or zero)
.Ve
.Vb 2
\& You may initialize a new node by calling NewNode($node),
\& where $node is a reference to some (existing and rather empty) hash.
.Ve
.SH "SEE ALSO"
http://ufal.mff.cuni.cz/local/doc/tools/fs2ps/index.html
.PP
http://ufal.mff.cuni.cz/local/doc/tools/2804/index.html
.PP
http://ufal.mff.cuni.cz/local/trees/format_fs.html

.rn }` ''
.IX Title "Fslib 3"
.IX Name "Fslib.pm - Simple API for treebank files in .fs format"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Header "USAGE"

.IX Subsection "\s-1PARSING\s0 \s-1FS\s0 \s-1FILES\s0"

.IX Subsection "\s-1MODIFYING\s0 \s-1OR\s0 \s-1EXAMINING\s0 \s-1TREES\s0"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Header "REFERENCE"

.IX Item "ReadAttribs (\s-1FILE\s0,$aref[,$\s-1DO_PRINT\s0[,\s-1OUTFILE\s0]])"

.IX Item "ReadTree (\s-1FILE\s0)"

.IX Item "GetTree ($tree,$aref,$href)"

.IX Item "PrintNode ($node,$aref,$href)"

.IX Item "PrintTree ($node,$aref,$href)"

.IX Item "Parent($node), FirstSon($node), LBrother($node), RBrother($node)"

.IX Item "Next($node,[$top]), Prev($node,[$top])"

.IX Item "Cut($node)"

.IX Item "Paste($node,$newparent,$href)"

.IX Item "Special($node,$href,$defchar)"

.IX Item "Ord($node,$href)"

.IX Item "Value($node,$href)"

.IX Item "SentOrd($node,$href)"

.IX Item "Hide($node,$href)"

.IX Item "IsList($attr,$href)"

.IX Item "ListValues($attr,$href)"

.IX Item "Set($node,$attribute,$value)"

.IX Item "Get($node,$attribute)"

.IX Item "DrawTree($node,@attrs)"

.IX Item "\s-1THE\s0 \s-1TREE\s0 \s-1NODE\s0\-\s-1STRUCTURE\s0 (\s-1TNS\s0)"

.IX Header "SEE ALSO"

