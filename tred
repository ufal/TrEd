#!/usr/bin/perl
# -*- cperl -*-
#
# $Id$
#
##############################################################################
#
# This is "TrEd" - a viewer and editor of tree graphs, such as
# dependency trees. TrEd uses PerlTk library as a GUI toolkit.
#
##############################################################################

#use strict;

if ($^V lt v5.6.0) {
  print STDERR '-' x 50,"\n";
  print STDERR "WARNING: Your version of perl is older than v5.6.0\n";
  print STDERR "THINGS MAY NOT WORK AS EXPECTED OR NOT AT ALL!\n";
  print STDERR '-' x 50,"\n\n";
}

use vars qw($version $timestamp $about $lastupdate $opt_u $opt_h $opt_c
	    $opt_t $opt_W $opt_G $opt_R $opt_X $opt_q $opt_B $opt_p
	    $opt_n $opt_D $opt_v $opt_H
            $libDir $macroFile @filelists @openfiles $treeViewOpts $opt_m
            @backends @ISA @EXPORT @open_types @save_types $opt_l $opt_s
            $insideEval %pckey_shift_translates @recentFiles $tredDebug
            $valueLine $appName %menuBindings %keyBindings
            $savedSavePixmap $normalSavePixmap $NewFileNo $stderr $stdout
	    %save_types %backend_map $debug @normal_win_opts @focused_win_opts
	    $normalUndoPixmap
	    $normalRedoPixmap
	    $normalNextPixmap
	    $normalPrevPixmap
           );

$version='$Revision$ ';
$timestamp="Time-stamp: <2001-07-27 14:45:25 pajas>";
$about=
  "Copyright (c) 2000-2003 by Petr Pajas\n".
  "This software is distributed under GPL - The General Public Licence\n".
  "Full text of the GPL can be found at http://www.gnu.org/copyleft/gpl.html";
$lastupdate=$1 if ($timestamp=~/\<([0-9-: ]+) /);

# Once we got rid of them we call getopt to read all the other options
use Tk;
use Tk::Config ();
use Tk::Wm;
use IO;

package Tk::Wm;
# overwriting the original Tk::Wm::Post:
sub Post
{
 my ($w,$X,$Y)= @_;
 $X= int($X);
 $Y= int($Y);
 $w->positionfrom('user');
# $w->geometry("+$X+$Y");
 $w->MoveToplevelWindow($X,$Y);
 $w->deiconify;
## This causes the "slowness":
# $w->raise;
}

package main;


#use Tk::Xrm;
# process the standard arguments for X resources
Tk::CmdLine::SetArguments();


use Getopt::Std;
getopts('qm:c:l:t:n:p:vhuW:GHDB:RX:s:');

if ($opt_u || $opt_h) {
  print <<EOH;
Usage:
 tred [-q] [-c <config-file>] [-m <macro-file>] [-t context]
      [-l <filelist>] [-n encoding] file1[##N|#N] [file2[##N|#N] [...]]
or
 tred -u|-h|-v    for usage/help/version

EOH
  exit unless $opt_h;
  print <<EOF;
This is `TrEd' - an interactive tool for editing tree graphs.

Each filename may be followed by suffixes of the following forms:

#N      where N is a number possibly followed by one or more
	upper-case letters. In this case, #N tells TrEd to skip to the
	first tree the root of which has `#N' as a value of attribute
	called `form' (this feature is optimized for specific
	instances of fs-format used while working on The Prague
	Dependency Treebank)

##N     where N is a number. This makes TrEd to go to the N-th tree in
	the given file after the file is opened.

-m      specifies a macro file different from the one given in your
	configuration file.

-c      specifies a config-file to be used (overrides
	~/.tredrc and all the other files TrEd would otherwise try to
	search for).

-l      specifies a file containing a list of files to open

-t      start in the given macro context (package). TredMacro is the
        default context, and it is used also when the given context
        is not found.

-s      start with the given pattern stylesheet.

-n      allows to specify the default charset for FS files (useful
        with perl >= 5.7)

-p      split window to given number of subwindows (horizontally if
        positive, vertically if negative) and open n'th file
        in n'th subwindow.


Other options:

-q              be quiet
-R              build tectogrammatic trees from CSTS files
-X <gov>,<ord>  use attribute <gov> to build tree from CSTS files
                and <ord> to order nodes
-H              Start with showing hidden nodes
-G              Do not initially resize window to its last geomtery.
-W <window_id>  Embed main window into the given window
-B <backends>   Comma separated list of additional backends to import

EOF
  exit;
}

if ($opt_v) {
  my $ver=$version;
  $ver=~s/\$//g;
  print "TrEd $ver\nPerl: $]\nPlatform: $^O\nTk: $Tk::VERSION\nLast update: $lastupdate","\n";
  exit;
}


# in Windows, if HOME not defined, use user's AppData folder instaed
if ($^O eq "MSWin32" and !exists $ENV{HOME}) {
  require Win32::Registry;
  my %shf;
  my $ShellFolders;

  my $shfolders="Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders";
  $::HKEY_CURRENT_USER->Open($shfolders,$ShellFolders) or
    die "Cannot read $shfolders $^E\n";
  $ShellFolders->GetValues(\%shf);
  $ENV{HOME}= $shf{AppData}[2];
}

# Default values of $libDir used to search for macro-file (tred.mac)
# and default-macro file (tred.def) are specified here. They may be
# overriden by value of LibDir in tred resource file (tredrc or ~/.tredrc - see above).
# It is also used to find TrEd::Config.pm module.

use FindBin;
if (exists $ENV{TREDHOME}) {
  $libDir=$ENV{TREDHOME};
} elsif (-d "$FindBin::RealBin/tredlib") {
  $libDir="$FindBin::RealBin/tredlib";
} elsif (-d "$FindBin::RealBin/../lib/tredlib") {
  $libDir="$FindBin::RealBin/../lib/tredlib";
} elsif (-d "$FindBin::RealBin/../lib/tred") {
  $libDir="$FindBin::RealBin/../lib/tred";
}
print "Trying $libDir\n" if ($libDir and !$opt_q);

$macroFile=undef;

_set_encoding(\*STDERR,'utf-8',"STDERR");
_set_encoding(\*STDOUT,'utf-8',"STDERR");

########## Config file #############
# this must be done before readconfig is first used
@filelists=();
@openfiles=();


# We *must* at least find TrEd::Config module to learn the correct libDir!!.
print "First I'm trying $libDir\n" unless $opt_q;
unshift @INC,$libDir if (-d $libDir);

do {
  my $ld=$libDir;
  require TrEd::Config;
  import TrEd::Config;
  import TrEd::Config qw(&read_config &apply_config &set_default_config_file_search_list);
  $libDir=$ld;
};

$TrEd::Config::treeViewOpts={
			     drawSentenceInfo => 0,
			     showHidden => 0,
			     customColors	 => ['darkgreen','darkblue','darkmagenta',
						     'orange','black','DodgerBlue4',
						     'red','gold','cyan','midnightblue']
			    };

if (defined $opt_c) {
  @TrEd::Config::config_file_search_list=($opt_c); # override any other possible config files
} else {
  set_default_config_file_search_list();
}
$TrEd::Config::set_user_config=\&setConfig;	# tred specific configuration

my $configFile=read_config();

$TrEd::Convert::inputenc=$opt_n if $opt_n;
$TrEd::Config::treeViewOpts->{showHidden} = 1 if $opt_H;

$macroFile="$libDir/tred.mac" unless (defined $macroFile);
if (defined $opt_m) {
  $macroFile=$opt_m;
}
####################################

unless (-d $libDir) {
  print <<'EOL';
 TrEd couldn't find a tredlib directory. You may need to point
 to its location by the TREDHOME variable or add a correct LibDir
 field to your ~/.tredrc.

EOL
    die "Error: Couldn't find lib-directory.";
}


use Cwd;

use Tk::LabFrame;
use Tk::Listbox;
use Tk::HList;
use Tk::ItemStyle;
use Tk::DialogBox;
use Tk::Tiler;
use Tk::BrowseEntry;
use Tk::Pane;
use Tk::Dialog;
use Tk::Font;

unshift @INC,$libDir unless (grep($_ eq $libDir, @INC));

require Fslib;
import Fslib;
import Fslib qw(&Ord &Value &Hide &SentOrd &AOrd &AValue &AHide &ASentOrd &Index $FSError);

$Fslib::Debug=1 if $opt_D;

# import min and max functions
require TrEd::MinMax;
import TrEd::MinMax;

# import encode and decode functions
require TrEd::Convert;
import TrEd::Convert;

if ($TrEd::Convert::support_unicode) {
  require Tk::Entry;
  require Tk::Text;
  require Tk::UCSKeyBind;
}

# import read_macros etc.
require TrEd::Macros;
import TrEd::Macros;

$TrEd::Macros::defines{TRED}=1;

# tree drawing module
require TrEd::TreeView;

# tree view windowing module
require TrEd::Window;

# tree printing module
require TrEd::Print;

# basic tree operations
require TrEd::Basics;
import TrEd::Basics;

$TrEd::Basics::on_tree_change= \&onTreeChange;
$TrEd::Basics::on_node_change= \&onNodeChange;
$TrEd::Basics::on_current_change= \&onCurrentChange;

#load back-ends
#require CSTS_SGML_SP_Backend;
@backends=('FSBackend',ImportBackends(split(/,/,$opt_B),
				      qw/NTREDBackend SSHBackend AG2FS CSTS_SGML_SP_Backend TrXMLBackend TEIXMLBackend StorableBackend/
				     ));
# CSTSBackend not used any more
#$CSTS_SGML_SP_Backend::doctype= "$libDir/csts.doctype";

require Filelist;

require Tk::MyFileSelect;
require Tk::BindMouseWheel;
require Tk::Balloon;

# different namespace only to load local rather than system files
# (rel2abs is not supported in all instalations)
use File::Spec;
if (not File::Spec->can('rel2abs')) {
  print "Using TFile::Spec\n" if $tredDebug;
  require TFile::Spec;
  require TFile::Spec::Functions;
  import TFile::Spec::Functions qw(rel2abs);
} else {
  print "Using File::Spec\n" if $tredDebug;
  require File::Spec;
  require File::Spec::Functions;
  import File::Spec::Functions qw(rel2abs);
}

$stdout=\*STDOUT;
$stderr=\*STDERR;

sub STYLESHEET_FROM_FILE { "<From File>" };
sub NEW_STYLESHEET { "<New From Current>" };
sub DELETE_STYLESHEET { "<Delete Current>" };


use Exporter;
@ISA=qw(Exporter);

@EXPORT= qw($insideEval
            $libDir $stderr $stdout
            @openfiles @filelists &min &max);

%backend_map=(
	      fs => 'FSBackend',
	      csts => 'CSTS_SGML_SP_Backend',
	      trxml => 'TrXMLBackend',
	      teixml => 'TEIXMLBackend',
	      ntred => 'NTREDBackend',
	      storable => 'SorableBackend'
	 );

@open_types=
  (["Supported",  [qw/.fs .csts .pls .pls.gz .fs.gz a.gz m.gz .csts.gz/]],
   ["FS files",           [qw/.fs .FS .Fs/]],
   ["CSTS files",           [qw/.cst .csts/]],
   ["Perl Storable files",  [qw/.pls .pls.gz/]],
   ["gzipped FS files",   [qw/.fs.gz .FS.gz .FS.GZ/]],
   ["gzipped CSTS files",   [qw/.cst.gz .csts.gz/]],
   ["All files",        '*']
  );

%save_types=(
	     fs =>
	     [["FS files",           [qw/.fs .FS .Fs/]],
	      ["gzipped FS files",   [qw/.fs.gz .FS.gz .FS.GZ/]],
	      ["All files",        '*']
	     ],
	     csts =>
	     [["CSTS files",           [qw/.cst .csts/]],
	      ["gzipped CSTS files",   [qw/.cst.gz .csts.gz/]],
	      ["All files",        '*']
	     ],
	     trxml =>
	     [["TrXML files",          [qw/.trx .trxml .xml/]],
	      ["gzipped TrXML files",   [qw/.trx.gz .trxml.gz .xml.gz/]],
	      ["All files",        '*']
	     ],
	     teixml =>
	     [["TEIXML files",          [qw/.tei .xml/]],
	      ["gzipped TEIXML files",   [qw/.tei.gz .xml.gz/]],
	      ["All files",        '*']
	     ],
	     storable =>
	     [["Perl Storable files",          [qw/.pls .pls.gz/]],
	      ["All files",        '*']
	     ]
	    );

ApplyGlobalConfig();

# it seems, that under Windoze setting LC_NUMERIC back to us does not
# work, so I recommend not to use czech locales there, unless you
# really want the decimal points to be replaced by commas in
# postscript:)
($TrEd::Config::useLocales) && do {
  use locale;
  use POSIX qw(locale_h);
  $ENV{LC_ALL}=undef;
  setlocale(LC_ALL,undef);
  setlocale(LC_NUMERIC,"C");

  if ($TrEd::Convert::support_unicode) {
    my $lc_collate=setlocale(LC_COLLATE);
    if ($lc_collate !~ /\.utf-?8/i) {
      setlocale(LC_COLLATE,$lc_collate.".UTF8");
    }
    my $lc_ctype=setlocale(LC_CTYPE);
    $lc_ctype=~s/\.utf-?8//i; # Tk doesn't support this
    setlocale(LC_CTYPE,$lc_collate);
  }
};

($TrEd::Config::useCzechLocales) && do {
  $ENV{LC_ALL}=undef;
  use locale;
  use POSIX qw(locale_h);
  setlocale(LC_ALL,undef);
  setlocale(LC_NUMERIC,"C");
  if ($TrEd::Convert::support_unicode) {
    setlocale(LC_COLLATE,"cs_CZ.UTF8");
    setlocale('LANG',"cs_CZ.UTF8");
    setlocale('LC_CTYPE',"cs_CZ");
  } else {
    setlocale(LC_COLLATE,"cs_CZ");
    setlocale('LANG',"cs_CZ");
  }
};

{
  # create Default filelists
  my @fl_files;
  foreach my $l (split /\s*,\s*/,$opt_l) {
    print STDERR "Reading -l filelist $l...\n" if $tredDebug;
    if (open(F,"<$l")) {
      my @f=<F>; chomp @f;
      push @fl_files,\@f;
      close(F);
    } else {
      print STDERR "Warning: Can't open filelist $l: $!\n";
    }
  }
  # define filelists Default, Default-2, etc.
  print STDERR "Creating filelists...\n" if $tredDebug;
  my $default= new Filelist('Default');
  $default->add(0,absolutize(@ARGV, @fl_files ? @{shift @fl_files} : ()));
  addNewFilelist(undef,$default);
  my $fl_no=-2;
  foreach (grep {@{$_}} @fl_files) {
    my $fl = new Filelist('Default'.$fl_no);
    $fl->add(0, absolutize(@{shift @fl_files}));
    addNewFilelist(undef,$fl);
    $fl_no--;
  }
  print STDERR "Done...\n" if $tredDebug;
  # create Bookmarks filelist
  unless (bookmarkFilelist()) {
    print "Bookmarks: ".$ENV{HOME}.'/.tred_bookmarks'."\n" if $tredDebug;
    my $bookmarks= new Filelist('Bookmarks',$ENV{HOME}.'/.tred_bookmarks');
    addNewFilelist(undef,$bookmarks);
  }
}

$insideEval=0;

my %searchTemplate;

%pckey_shift_translates= (exclam=> 1, at=> 2, numbersign=> 3,
			   dollar=> 4, percent=> 5, asciicircum=> 6,
			   ampersand=> 7, asterisk=> 8, parenleft=> 9,
			   parenright=> 0, plus=> 'equal',
			   underscore=> 'minus',
			   less=> 'comma', greater=> 'period', 
			   question=> 'slash',
			   colon=> 'semicolon', quotedbl=> 'apostroph',
			   braceleft=> 'bracketleft', 
			   braceright=> 'bracketright',
			   bar=> 'backslash', asciitilde=> 'grave'
			  );

$opt_R && Csts2fs::setupTR();
if ($opt_X ne "") {
  Csts2fs::setupSpec(split ',',$opt_X);
}

print STDERR "Reading macros from $macroFile...\n" unless $opt_q;
read_macros($macroFile,$libDir);		# read macros
print STDERR "done.\n" unless $opt_q;


startMain();	# display first tree

print STDERR "TrEd ended.\n" unless $opt_q;

exit;

############################
############################
############################
sub __debug {
  print STDERR @_,"\n";
}

sub absolutize {
  return map { m(^[[:alnum:]]+://|^\s*\|) ? $_ : rel2abs($_) } @_;
}

sub get_open_filename {
  my $w = shift;
  my %opts=@_;
  if ($openFilenameCommand) {
    my $c = $openFilenameCommand;
    my $types = ref($opts{-filetypes}) ?
      join " ",map { "*".$_ } map { @{$_->[1]} } @{$opts{-filetypes}} : "*";
    my $title = $opts{-title} || 'Open';
    my $initialdir = $opts{-initialdir} || '.';
    $c=~s/\%t/"$title"/g;
    $c=~s/\%m/"$types"/g;
    $c=~s/\%d/"$initialdir"/g;
    my $ret = `$c`;
    chomp $ret;
    return $ret;
  } else {
    $w->getOpenFile(%opts);
  }
}

sub get_save_filename {
  my $w = shift;
  my %opts=@_;
  if ($saveFilenameCommand) {
    my $c = $saveFilenameCommand;
    my $types = ref($opts{-filetypes}) ?
      join " ",map { "*".$_ } map { @{$_->[1]} } @{$opts{-filetypes}} : "*";
    my $title = $opts{-title} || 'Open';
    my $initialdir = $opts{-initialdir}.$TrEd::Convert::Ds || '';
    my $initialfile = $opts{-initialfile} || '';
    $c=~s/\%t/"$title"/g;
    $c=~s/\%m/"$types"/g;
    $c=~s/\%d/"$initialdir"/g;
    $c=~s/\%f/"$initialfile"/g;
    my $ret = `$c`;
    chomp $ret;
    return $ret;
  } else {
    $w->getSaveFile(%opts);
  }
}


sub saveStyleSheets {
  my ($grp)=@_;
  open my $f, '>'.$ENV{HOME}."/.tred-stylesheets" || do {
    print STDERR "can't write to stylesheet file: $ENV{HOME}/.tred-stylesheets\n" if $debug;
    return 0;
  };
  foreach my $stylesheet (keys (%{$grp->{stylesheets}})) {
    next if $stylesheet eq STYLESHEET_FROM_FILE();
    print $f "#"x 50,"\n";
    print $f "stylesheet: $stylesheet\n";
    for ($grp->{stylesheets}->{$stylesheet}) {
      print $f map { local $_=$_; tr/\n/\013/; $_."\n" } @{$_->{patterns}};
      print $f map { "hint: ".$_."\n" } split /\n/, $_->{hint};
    }
    print $f "\n\n";
  }
  close $f;
}

sub readStyleSheets {
  my ($grp)=@_;
  open my $f, $ENV{HOME}."/.tred-stylesheets" || do {
    print STDERR "no stylesheet file: $ENV{HOME}/.tred-stylesheets\n" if $debug;
    return 0;
  };
  my $stylesheet="Default";
  $grp->{stylesheets}={};
  while (<$f>) {
    chomp;
    next unless /\S/;
    next if /^#/;
    if (/^stylesheet:\s*(.*)/) {
      $stylesheet = $1;
    } elsif (/^hint:\s*(.*)/) {
      $grp->{stylesheets}->{$stylesheet}->{hint}.="\n" if
	$grp->{stylesheets}->{$stylesheet}->{hint} ne "";
      $grp->{stylesheets}->{$stylesheet}->{hint}.=$1;
    } else {
      tr/\013/\n/;
      push @{$grp->{stylesheets}->{$stylesheet}->{patterns}},$_;
    }
  }
  close $f;
}

sub bookmarkFilelist {
  foreach (@filelists) {
    return $_ if ref and $_->name eq 'Bookmarks';
  }
  return undef;
}

sub setConfig {
  my $confs=shift;

  foreach (0..9) {
    $recentFiles[$_]=$confs->{"recentfile$_"};
  }
  @recentFiles=grep {$_} @recentFiles;

  require Filelist;
  my $fl;
  foreach (grep /^filelist[0-9]+/, keys %$confs) {
    print "Reading $_\n"  if $tredDebug;
    $fl=Filelist->new(undef,$confs->{$_});
    next unless $fl;
    $fl->load();
    print STDERR "Reading filelist ".$fl->name." from ".$fl->filename."\n" if $tredDebug;
    addNewFilelist(undef,$fl);
  }

#    $CSTSBackend::csts2fs=$cstsToFs;
#    $CSTSBackend::fs2csts=$fsToCsts;

#  doEvalHook(undef,"apply_config_hook",$confs); # TrEd::Macro not imported yet :(
  print STDERR "Applying configuration.\n" if $tredDebug;
}

sub ApplyGlobalConfig {
  my ($grp)=@_;

  @normal_win_opts = qw/-relief flat -borderwidth 0 -highlightthickness 0/;
  @focused_win_opts = (qw/-relief flat/,
		       -highlightthickness  => $highlightWindowWidth,
		       -highlightbackground => $highlightWindowColor);
  return unless $grp;
  Tk::catch {
    $grp->{valueLine}->configure(-height => $valueLineHeight,
				 ($valueLineReverseLines ? () :
				  (-wrap => $valueLineWrap))
				);
  };
  update_value_line($grp);
  update_status_line($grp->{focusedWindow});
  print STDERR $@ if $@;
  foreach my $w (@{$grp->{treeWindows}}) {
    if ($w->{treeView} and $treeViewOpts->{backgroundColor}) {
      $w->{treeView}->canvas->configure(-background=> $treeViewOpts->{backgroundColor});
    }
  }
  $grp->{top}->afterCancel($grp->{autoSaveCallback});
  $grp->{autoSaveCallback}=$grp->{top}->repeat($autoSave*60000, [\&autoSaveAll,$grp]) if $autoSave>0;
}

sub lastFileNo {
  my ($win)=@_;
  return $win->{currentFilelist}->file_count()-1;
}

sub currentFileNo {
  my ($win)=@_;
  return $win->{currentFileNo};
}

sub cast_to_win {
  my ($gw)=@_;
  return UNIVERSAL::isa($gw,'TrEd::Window') ? $gw :
    (ref($gw) ? $gw->{focusedWindow} : undef);
}

sub cast_to_grp {
  my ($gw)=@_;
  return UNIVERSAL::isa($gw,'TrEd::Window') ? $gw->{framegroup} : $gw;
}

sub grp_win {
  my ($gw)=@_;
  return (cast_to_grp($gw),cast_to_win($gw));
}


# TrEd::Window ? should openFile in focusedWindow
sub gotoFile {
  my ($grp_or_win,$fn,$no_recent,$no_redraw)=@_;
  my ($grp,$win) = grp_win($grp_or_win);
  return unless $win->{currentFilelist};
  return 0 if doEvalHook($win,"goto_file_hook") eq 'stop';
  return 0 if ($fn>=$win->{currentFilelist}->file_count() or $fn<0);
  $win->{currentFileNo}=$fn;
  openFile($win,filelistFullFileName($win,$fn),
	   -norecent => $no_recent, -noredraw => $no_redraw);
  if ($grp->{Filelist} and
	$grp->{filelistCurrentFilelist} eq $win->{currentFilelist}) {
    my $path=filelistEntryPath($win->{currentFilelist},$fn);
    $grp->{Filelist}->anchorSet($path);
    $grp->{Filelist}->selectionClear();
    $grp->{Filelist}->selectionSet($path);
  }
  return 1;
}

sub filelistFullFileName {
  my ($win, $fn)=@_;
  my $grp = cast_to_grp($win);
  return undef unless $win->{currentFilelist};
  my $filename=$win->{currentFilelist}->file_at($fn);

  return $filename if $filename =~ m(^[[:alnum:]]+://) or $filename =~ m(^\s*\|);

  if ($filename!~/^\s*[\/~]/ and
      ($^O ne 'MSWin32' or $filename!~/^\s*([[:alpha:]]:)?\\/)) {
    # relative filename
    if (dirname($win->{currentFilelist}->filename()) ne "") {
      $filename=dirname($win->{currentFilelist}->filename()).$filename;
    }
  }
  return $filename;
}

sub nextOrPrevFile {
  my ($grp_or_win,$delta,$no_recent)=@_;
  my ($grp,$win) = grp_win($grp_or_win);
  return 0 if ($delta==0);
  my $op=$grp->{noOpenFileError};
  $grp->{noOpenFileError}=1;
  my $filename=filelistFullFileName($win,$win->{currentFileNo}+$delta);
  my $result=gotoFile($win,$win->{currentFileNo}+$delta,$no_recent);
  my $quiet=0;
  my $response;
  while ($result and (!$win->{FSFile} or $win->{FSFile}->lastTreeNo<0)) {
    unless ($quiet) {
      my $f="File \"$filename\" is empty, corrupted or does not exist!";
      $response=userQuery($win, $f,
			  -title => "Error",
			  -buttons => ["Try next","Skip to next correct file","Cancel"]);
      last if ($response eq "Cancel");
      $quiet=1 if ($response eq "Skip to next correct file");
    }
    $result=gotoFile($win,$win->{currentFileNo}+$delta,$no_recent);
  }
  $grp->{noOpenFileError}=$op;
  return $result;
}

sub nextFile {
  my ($grp_or_win,$no_recent)=@_;
  return nextOrPrevFile($grp_or_win,1,$no_recent);
}

sub prevFile {
  my ($grp_or_win,$no_recent)=@_;
  return nextOrPrevFile($grp_or_win,-1,$no_recent);
}

sub tieNextFile {
  my ($grp,$win) = grp_win(shift);
  if ($grp->{tieWindows}) {
    foreach my $w (@{$grp->{treeWindows}}) {
      nextFile($w) if ($w->{FSFile});
    }
  } else {
    nextFile($win) if ($win->{FSFile});
  }
}

sub tiePrevFile {
  my ($grp,$win) = grp_win(shift);
  if ($grp->{tieWindows}) {
    foreach my $w (@{$grp->{treeWindows}}) {
      prevFile($w) if ($w->{FSFile});
    }
  } else {
    prevFile($win) if ($win->{FSFile});
  }
}


sub tieGotoFile {
  my ($grp,$win) = grp_win(shift);
  if ($grp->{tieWindows}) {
    foreach my $w (@{$grp->{treeWindows}}) {
      gotoFile($w,@_) if ($w->{FSFile});
    }
  } else {
    gotoFile($win,@_) if ($win->{FSFile});
  }
}


# TrEd::Window ?
sub resumeFile {
  my ($win,$fsfile,$keep)=@_;
  $keep||=$win->{framegroup}->{keepopen};
  return unless ref($win) and ref($fsfile);
  print "Resuming file ".$fsfile->filename."\n"  if $tredDebug;

  closeFile($win,-keep_postponed => $keep);

  $win->{FSFile}=$fsfile;
  $win->{treeNo}=$fsfile->currentTreeNo;
  $win->{currentNode}=$fsfile->currentNode;
  saveFileStateUpdate($win);
}

sub fsfileDisplayingWindows {
  my ($grp,$fsfile)=@_;
  return 
    grep {
      $_->{FSFile} eq $fsfile 
    } @{$grp->{treeWindows}};
}

sub isFocused {
  my ($win)=@_;
  return $win eq $win->{framegroup}->{focusedWindow} ? 1 : 0;
}


sub closeFile {
  my ($win,%opts)=@_;

  my $fsfile=$win->{FSFile};
  if ($fsfile) {
    doEvalHook($win,"file_close_hook");
    $fsfile->currentTreeNo($win->{treeNo});
    $fsfile->currentNode($win->{currentNode});
  }

  my @wins;
  if ($opts{-all_windows} and $fsfile) {
    @wins=fsfileDisplayingWindows($win->{framegroup},$fsfile);
  } else {
    @wins=($win);
  }

  foreach my $w (@wins) {
    $w->{Nodes}=undef;
    #  undef $NodeClipboard;
    $w->{root}=undef;
    $w->{FSFile}=undef;
    $w->{treeNo}=undef;
    delete $w->{currentNode} if (exists $w->{currentNode});
    $w->{treeView}->clear_pinfo();
    set_value_line($w->{framegroup},"") if (isFocused($w));
  }
  if ($opts{-keep_postponed} and $fsfile) {
    print STDERR "Postponing ".$fsfile->filename()."\n"  if $tredDebug;
  } else {
    if ($fsfile and not fsfileDisplayingWindows($win->{framegroup},$fsfile)) {
      print STDERR "Removing ".$fsfile->filename()." from list of open files\n"  if $tredDebug;
      @openfiles=grep { $_ ne $fsfile } @openfiles;
      my $autosave = autosave_filename($fsfile->filename());
      unlink $autosave if defined $autosave;
      undef $fsfile;
    }
  }
  unless ($opts{-no_update}) {
    updateTitle($win->{framegroup});
    updatePostponed($win->{framegroup});
    foreach my $w (@wins) {
      get_nodes_win($w);
      redraw_win($w);
    }
  }
}

sub ErrorMessage {
  my ($grp,$msg)=@_;
  if ($grp->{top}) {
    $grp->{top}->toplevel->
      messageBox(-icon=> 'error',
		 -message=> $msg,
		 -title=> 'Error', -type=> 'ok');
  } else {
    print STDERR "$msg\n";
  }
}

sub dlgReturn {
  my ($w,$no_default)=@_;
  my $f=$w->focusCurrent;
  if ($f and $f->isa('Tk::Button')) {
    $f->Invoke();
  } elsif (!$no_default) {
    $w->toplevel->{default_button}->Invoke
      if $w->toplevel->{default_button};
  }
  Tk->break;
}


sub userQuery {
  my ($win, $message, %opts) = @_;

  my $d = $win->toplevel->Dialog(
				 %opts
				);
  $d->add('Label', -text => $message,
	  -wraplength => 300)->pack();
  $d->bind('<Return>', \&dlgReturn);
  if (exists($opts{-buttons}) and 
      grep { $_ eq 'Cancel' } @{$opts{-buttons}}) {
    $d->bind('<Escape>', [sub { my $w=shift;
			       $w->{selected_button}= "Cancel";
			     }] );
    $d->protocol('WM_DELETE_WINDOW' => [sub { shift->{selected_button}='Cancel'; },$d]);

  }
  $d->bind('all','<Tab>',[sub { shift->focusNext; }]);
  return $d->Show;
}


sub addToRecent {
  my ($grp,$f)=@_;
  if (defined($f)) {
    ($f)=absolutize($f);
    @recentFiles=grep { $_ ne $f } @recentFiles;
    unshift @recentFiles,$f;
  }
  @recentFiles=@recentFiles[0..min($#recentFiles,9)];

  if ($grp->{RecentFileMenu}) {
    my $menu= $grp->{RecentFileMenu}->cget(-menu);
    $menu->delete(0,'end');
    my $i=0;
    foreach my $rf (@recentFiles) {
      $grp->{RecentFileMenu}->command(-label => "$i.  $rf",
				      -underline=> 0,
				      -command=> [\&openFile,$grp,$rf]);
      $i++;
    }
  }
}

sub getNodeNo {
  my ($win,$node)=@_;
  if ($node) {
    my $root;
    my $i=0;
    $root=$win->{FSFile}->treeList->[$win->{treeNo}];
    while ($root and $root ne $node) {
      $i++;
      $root=$root->following();
    }
    if ($root) {
      return $i;
    }
  }
}

sub bookmarkThis {
  my ($grp)=@_;
  my $f=undef;
  my $win=$grp->{focusedWindow};
  if (ref($win->{FSFile})) {
    $f=$win->{FSFile}->filename()."##".($win->{treeNo}+1);
    my $nodeno=getNodeNo($win,$win->{currentNode});
    if (defined($nodeno)) {
      $f.=".$nodeno";
    }
  }
  return $f;
}

sub addBookmark {
  my ($grp)=@_;
  my $bl=bookmarkFilelist();
  return unless ref($bl);
  my $f=bookmarkThis($grp);
  if (defined($f)) {
    insertToFilelist($grp,$bl,$bl->count,$f);
    updateBookmarks($grp);
  }
}

sub lastActionBookmark {
  my ($grp,$bmk)=@_;
  my $f=defined($bmk) ? $bmk : bookmarkThis($grp);
  if (defined($f)) {
    print STDERR "Bookmarking last action at: $f\n" if $tredDebug;
    $grp->{lastActionBookmark}=$f;
    updateBookmarks($grp);
  }
}

sub updateBookmarks {
  my ($grp)=@_;

  if ($grp->{BookmarksFileMenu}) {
    print STDERR "Updating bookmark menu\n"  if $tredDebug;
    my $menu= $grp->{BookmarksFileMenu}->menu;
    $menu->delete(0,'end');
    $grp->{BookmarksFileMenu}->command(-label=> 'Add to bookmarks',
				       -underline=> 0,
				       -command=> [ \&addBookmark,$grp ]);
    $grp->{BookmarksFileMenu}->separator();
    if (defined($grp->{lastActionBookmark})) {
      $grp->{BookmarksFileMenu}->command(-label => "Last action",
					 -underline=> 0,
					 -command=> [ \&openFile,$grp,$grp->{lastActionBookmark} ]);
    }
    $grp->{BookmarksFileMenu}->separator();
    my $i=0;
    my $bl=bookmarkFilelist();
    return unless ref ($bl);
    foreach my $b (bookmarkFilelist->files()) {
      print STDERR "$b\n" if $tredDebug;
      $grp->{BookmarksFileMenu}->command(-label => "$i.  ".$b,
				      -underline=> 0,
				      -command=> [ \&openFile,$grp,$b ]);
      $i++;
    }
  }
}

sub updatePostponed {
  my ($grp)=@_;
  if ($grp->{PostponedFileMenu}) {
    print STDERR "Updating session menu\n"  if $tredDebug;
    my $menu= $grp->{PostponedFileMenu}->menu;
    $menu->delete(0,'end');
    $grp->{PostponedFileMenu}->command(-label=> 'Options',
				       -state=> 'disabled',
				       -background=> '#444444'
				      );
    $grp->{PostponedFileMenu}->checkbutton(-label => 'Don\'t close on open',
	  -variable=> \$grp->{keepfiles});
    $grp->{PostponedFileMenu}->checkbutton(-label => 'Don\'t append file-list',
	  -variable=> \$grp->{noinsert});
    $grp->{PostponedFileMenu}->checkbutton(-label => 'Build TGTS from CSTS',
					   -variable=> \$grp->{buildTGTSfromCSTS},
					   -command => [sub {
							  my ($grp)=@_;
							  if ($grp->{buildTGTSfromCSTS}) {
							    Csts2fs::setupTR();
							  } else {
							    Csts2fs::setupAR();
							  }
							},$grp]
					  );
    $grp->{PostponedFileMenu}->checkbutton(-label => 'Preserve patterns on reload',
	  -variable=> \$reloadKeepsPatterns);
    $grp->{PostponedFileMenu}->command(-label=> 'Open files',
				       -state=> 'disabled',
				       -background=> '#444444'
				      );
    my $i=0;
    foreach my $of (@openfiles) {
      $grp->{PostponedFileMenu}->command(-label => "$i.  ".$of->filename(),
				      -underline=> 0,
				      -command=> [\&openFile,$grp,
						  $of->filename(),-keep => 1]);
      $i++;
    }
    $grp->{PostponedFileMenu}->command(-label=> 'none',
				       -state=> 'disabled'
				      ) unless (@openfiles);
    $grp->{PostponedFileMenu}->command(-label=> 'File lists',
				       -state=> 'disabled',
				       -background=> '#444444'
				      );

    $i='A';
    foreach my $fl (sort {lc($a->name()) cmp lc($b->name())} @filelists) { 
      $grp->{PostponedFileMenu}->command(-label => "$i.  ".$fl->name(),
					 -underline=> 0,
					 -command=> [\&selectFilelist,$grp,$fl->name()]);
      $i++;
    }
  }
}

sub updateTitle {
  my ($grp)=@_;
  my $win = $grp->{focusedWindow};
  return unless ref($grp);
  if (defined($win->{currentFileNo}) and 
      ref($win->{FSFile}) and
      defined($win->{currentFilelist})) {
    $grp->{top}->title("$appName    ".
		       $win->{currentFilelist}->name()."(".($win->{currentFileNo}+1)."/".
		       $win->{currentFilelist}->file_count()."): ".$win->{FSFile}->filename()
		      );
  } else {
    $grp->{top}->title("$appName");
  }
}

sub newFileFromCurrent {
  my ($grp,$keep)=@_;
  $keep||=$grp->{keepopen};
  my $win=$grp->{focusedWindow};
  return unless $win->{FSFile};
  $win->toplevel->Busy(-recurse=> 1) unless $insideEval;
  my $cur=$win->{FSFile};
  my $new=FSFile->new('unnamed'.sprintf('%03d',$NewFileNo++).'.fs',
			     'FSBackend',
			     $cur->FS->clone(),
			     $cur->hint(),
			     [$cur->patterns()],
			     [$cur->tail()],
			     [],
			     1,
			     'FSBackend',
		             $cur->encoding()
		     );
  $cur=undef;
  $keep=$keep || askSaveFile($win,1);
  closeFile($win,-no_update => 1,-keep_postponed => $keep);
#  $new->new_tree(0);
  $win->{FSFile}=$new;
  push @openfiles, $win->{FSFile};
  updatePostponed($grp);

  # add file to filelist
  $win->{currentFileNo}= max(0,$win->{currentFileNo});
  updateTitle($grp);
  get_nodes_win($win);
  doEvalHook($win,"file_opened_hook");
  switchContext($win,$opt_t,1)
    if ($opt_t ne "" and
	$win->{macroContext} ne $opt_t);
  redraw_win($win);
  centerTo($win,$win->{currentNode});
  $win->toplevel->Unbusy() unless $insideEval;

#  addToRecent($grp,$new->filename);
  return 1;
}

sub reloadFile {
  my $win=cast_to_win(shift);
  if (ref($win->{FSFile}) and $win->{FSFile}->filename()) {
    my $f=$win->{FSFile}->filename();
    my @patterns=$win->{FSFile}->patterns();
    my $hint=$win->{FSFile}->hint();
    $f=~s/(##?[0-9A-Z]+(?:\.[0-9]+)?)$//; # strip the suffix
    my $no=$win->{treeNo}+1;
    my $nodeidx=0;
    do {			# $node is undefined after this block
      my $node=$win->{currentNode};
      while ($node) { $nodeidx++; $node=$node->previous() };
    };
    $nodeidx--;
    askSaveFile($win,0);
    closeFile($win,-all_windows => 1);
    openFile($win,"$f##$no.$nodeidx",
	     -noredraw => 1, -nohook=>1);
    if ($win->{FSFile} and $reloadKeepsPatterns) {
      $win->{FSFile}->changePatterns(@patterns);
      $win->{FSFile}->changeHint($hint);
    }
    get_nodes_win($win);
    redraw_win($win);
    centerTo($win,$win->{currentNode});
  }
}

sub openFile {
  my ($grp_or_win,$f,%opts)= @_;
  my ($grp,$win)=grp_win($grp_or_win);
  my $goto= undef;
  my $no_err = $grp->{noOpenFileError};

  if ($f=~/(##?[0-9A-Z]+(?:-?\.[0-9]+)?)$/) {
    $f=~s/(##?[0-9A-Z]+(?:-?\.[0-9]+)?)$//;
      $goto=$1;
    print "Goto suffix is $goto\n" if $tredDebug;
  }
  $opts{-keep} ||= $grp->{keepfiles};

  # first handle the special case of already open file
  if ($win->{FSFile} and $win->{FSFile}->filename() eq $f) {
    updateTitle($grp);
    applyFileSuffix($win,$goto);
    get_nodes_win($win, $opts{-noredraw});
    doEvalHook($win,"file_resumed_hook") unless $opts{-nohook};
    unless ($opts{-noredraw}) {
      redraw_win($win);
      centerTo($win,$win->{currentNode});
    }
    addToRecent($grp,$f) unless $opts{-norecent};
    $win->toplevel->Unbusy() unless $insideEval;
    return 2;
  }
  unless ($opts{-keep} or ref($win->{FSFile}) and $win->{FSFile}->filename() eq $f) {
    $opts{-keep} = askSaveFile($win,1) if (fsfileDisplayingWindows($grp,$win->{FSFile})<2);
  }
  $win->toplevel->Busy(-recurse=> 1) unless $insideEval;
  unless ($opts{-justheader}) {
    foreach my $of ($win->{FSFile},@openfiles) {
      if (ref($of) and $of->filename() eq $f) {
	print "Opening postponed file\n" if $tredDebug;
	resumeFile($win,$of,$opts{-keep});
	$win->{currentFileNo} =
	  max(0,$win->{currentFileNo});
	insertToFilelist($win,$win->{currentFilelist},
			 $win->{currentFileNo},
			 $f.$goto) unless $grp->{noinsert};
	updateTitle($grp);
	applyFileSuffix($win,$goto);
	get_nodes_win($win, $opts{-noredraw});
	doEvalHook($win,"file_resumed_hook") unless $opts{-nohook};
	unless ($opts{-noredraw}) {
	  redraw_win($win);
	  centerTo($win,$win->{currentNode});
	}
	addToRecent($grp,$f) unless $opts{-norecent};
	$win->toplevel->Unbusy() unless $insideEval;
	return 2;
      }
    }
  }
  closeFile($win,-no_update =>1 , -keep_postponed => $opts{-keep});

  my $recover='No';
  my $autosave=autosave_filename($f);
  if (not $no_err and defined($autosave) and -r $autosave) {
    $recover=
      userQuery($win,
		"File seems to have an auto-saved recovery file from a previous session.\n".
		"Shell I try to use the recovery file?",
		-bitmap=> 'question',
		-title => "Recover file?",
		-buttons => ['Yes', 'No', 'No, delete recovery file']);
  }
  if ($recover eq 'Yes') {
    $win->{FSFile} =
      FSFile->newFSFile($autosave,$TrEd::Convert::inputenc,@backends);
    if ($win->{FSFile}->lastTreeNo>=0 and $Fslib::FSError==0) {
      $win->{FSFile}->changeFilename($f);
      $win->{FSFile}->notSaved(2);
    } else {
      my $trees=$win->{FSFile}->lastTreeNo+1;
      if (userQuery($win,
		    "\nRecovery file is corrupted ($trees trees read)!\n\nFall back to the original file\n'$f' ?",
		    -bitmap=> 'question',
		    -title => "Recovery error!",
		    -buttons => ['Yes', 'No']) eq 'Yes') {
	closeFile($win,-no_update => 1);
	$win->{FSFile}=
	  FSFile->newFSFile($f,$TrEd::Convert::inputenc,@backends);
      } else {
	closeFile($win,-no_update => 1) unless $win->{FSFile}->lastTreeNo>=0;
	$no_err=1;
      }
    }
  } else {
    if ($recover eq 'No, delete recovery file') {
      unlink $autosave;
    }
    $win->{FSFile}=
      FSFile->newFSFile($f,$TrEd::Convert::inputenc,@backends);
  }
  if ($win->{FSFile}) {
    $win->{FSFile}->changeFileFormat(($f=~/\.gz$/ ? "gz-compressed " : "").$win->{FSFile}->backend);
  }
  unless ($no_err or ($win->{FSFile}->lastTreeNo>=0 and $Fslib::FSError==0)) {
    my $trees=$win->{FSFile}->lastTreeNo+1;
    errorMessage($win,"$f: empty or corrupted file ($trees trees read)!");
    closeFile($win,-no_update => 1);
  }

  $win->{treeNo}=0;
  if ($win->{FSFile}) {
    if ($opts{-justheader}) {
      $f=sprintf('%03d',$NewFileNo++)."_new_".filename($f);
      $win->{FSFile}->changeFilename($f);
      $win->{FSFile}->changeTrees();
#      $win->{FSFile}->new_tree(0);
      $win->{FSFile}->notSaved(1);
    }
    push @openfiles, $win->{FSFile};
  }
  updatePostponed($grp);
  # add file to filelist
  $win->{currentFileNo}= max(0,$win->{currentFileNo});
  if ($win->{FSFile} and $win->{FSFile}->lastTreeNo>=0 and !$grp->{noinsert}) {
    insertToFilelist($win,$win->{currentFilelist},$win->{currentFileNo},$f.$goto);
  }
  updateTitle($grp);

  applyFileSuffix($win,$goto);
  doEvalHook($win,"file_opened_hook") if ($win->{FSFile} and
					  !$opts{-nohook});
  switchContext($win,$opt_t,1)
    if ($opt_t ne "" and
	$win->{macroContext} ne $opt_t);

  get_nodes_win($win,$opts{-noredraw});
  unless ($opts{-noredraw}) {
    redraw_win($win);
    centerTo($win,$win->{currentNode});
  }
  $win->toplevel->Unbusy() unless $insideEval;

  addToRecent($grp,$f);
  return 1;
}

sub getNodeByNo {
  my ($win,$no)=@_;
  my $root=$win->{FSFile}->treeList->[$win->{treeNo}];
  my $i=$no;
  while ($root and $i>0) {
    $i--;
    $root=$root->following();
  }
  return $root;
}

sub applyFileSuffix {
  my ($win,$goto)= @_;
  return unless $win->{FSFile} and defined($goto) and $goto ne "";
  # -- smells like PDT-specific code, at least the second case
  # but we want it, dont we:)

  if ($goto=~/^##([0-9]+)/) {
    $win->{treeNo}=min(max(0,$1-1),$win->{FSFile}->lastTreeNo);
  } elsif ($goto=~/^#([0-9]+)/) {
    for (my $i=0;$i<=$win->{FSFile}->lastTreeNo;$i++) {
      $win->{treeNo}=$i,last if ($win->{FSFile}->treeList->[$i]->{form} eq "#$1");
    }
  }
  # new: we're the dot in .[0-9]+ (TM)
  if ($goto=~/\.([0-9]+)$/) {
    my $root=getNodeByNo($win,$1);
    if ($root) {
      $win->{currentNode}=$root;
      unless (isShown($win,$root)) {
	$win->{treeView}->set_showHidden(1);
      }

    }
  }
  # hey, caller, you should redraw after this!
}

sub autosave_filename {
  my ($f)=@_;
  my $base=filename($f);
  return undef unless ($f=~s/\Q${base}\E$/#$base#.#tred#/);
  return $f;
}

sub autoSaveAll {
  my ($grp)=@_;
  my $top=$grp->{top};
  my @files=grep { $_->notSaved == 1 } @openfiles;
  return unless @files;
  $top->title("Autosaving...");
  $top->Busy(-recurse=> 1) if (!$insideEval);
  foreach my $fsfile (@files) {
    my $f=autosave_filename($fsfile->filename);
    print STDERR "auto-saving recovery file ".$fsfile->filename." to '$f'\n" if $tredDebug;

    # this is not a kosher implementation but
    # there is no way to call a hook on fsfile
    # not owned by any windows, sigh!
    my ($win) = fsfileDisplayingWindows($grp,$fsfile);
    $win = $grp->{focusedWindow} unless $win;
    return if doEvalHook($win,"file_autosave_hook",$fsfile) eq 'stop';

    unless ($fsfile->writeFile($f)) {
      print STDERR "Error auto-saving file to '$f'\n($!)\n";
      next;
    }
    $fsfile->notSaved(2);
  }
  updateTitle($grp);
  $top->Unbusy() unless $insideEval;
}

sub saveFile {
  my $win=cast_to_win(shift);
  return unless $win->{FSFile};
  my $f=$win->{FSFile}->filename;

## you may have wr-perms on directory but not on the file
##
#   unless (-w $f) {
#     return 0 unless userQuery($win,"You don't have writing permissions to file '$f'\n".
# 			      "Do you still want to try to save it?\n",
# 			      -title => "Error",
# 			      -buttons => ["Try","Cancel"]) eq 'Try';
#   }
  rename $f,$f."~" if (-f $f);
  $win->toplevel->Busy(-recurse=> 1) unless $insideEval;
  return if doEvalHook($win,"file_save_hook",$f) eq 'stop';
  unless ($win->{FSFile}->writeFile($f)) {
    $win->toplevel->Unbusy() unless $insideEval;
    errorMessage($win,"Error saving file to '$f'\n($!)\n");
    return 0;
  }
  $win->toplevel->Unbusy() unless $insideEval;
  saveFileStateUpdate($win);
  my $autosave=autosave_filename($f);
  unlink $autosave if defined($autosave);
}

sub isShown { # test if node is shown (always 1 if $showHidden)
  my ($win,$node,$show)=@_;
  $show=$win->{treeView}->get_showHidden() unless defined $show;

  return 0 unless ($node and $win->{FSFile});
  return 1 if $show or not defined($win->{FSFile}->FS->hide());
  while ($node and ($node->{$win->{FSFile}->FS->hide()} ne 'hide')) {
    $node=$node->parent;
  }
  return ($node ? 0 : 1)
}

sub HNext { # same as Next but obey $showHidden
  my ($win,$node,$top)= @_;
  $node=Next($node,$top);
  while ($node) {
    return $node if (isShown($win,$node));
    $node=Next($node,$top);
  }
  return 0;
}

sub HPrev { # same as Next but obey $showHidden
  my ($win,$node,$top)= @_;
  $node=Prev($node,$top);
  while ($node) {
    return $node if (isShown($win,$node));
    $node=Prev($node,$top);
  }
  return 0;
}

sub get_value_line {
  my ($win,$fsfile,$no,$no_numbers,$tags)=@_;
  my $vl;
  if ($fsfile) {
    $vl=doEvalHook($win,"get_value_line_hook",$fsfile,$no);
    if (defined($vl)) {
      if (ref($vl)) {
	$vl=[ map { $_->[0]=encode($_->[0]); $_ } grep { $_->[0] ne "" } @$vl ];
      } else {
	$vl=encode($vl);
      }
    } else {
      $vl=$win->{treeView}->value_line($fsfile,$no,$no_numbers,$tags);
    }
  } else {
    $vl="";
  }
  return $vl;
}

sub reverseWrapLines {
  my ($widget,$font,$text,$width)=@_;
  use integer;
  my @toks;
  if (ref($text)) {
    @toks = @$text;
  } else {
    @toks = map { [$_,''] } split /\s+/, $text;
  }
  my @result;
  my $wd=0;
  my $w;
  my $t=pop(@toks);
  my @lines=();
  while ($t) {
    $w=$widget->fontMeasure($font," $t->[0]");
    if (($wd+$w>=$width) && (@result>0)) {
      push @lines, (@result,["\n",'space']);
      @result=($t);
      $wd=$widget->fontMeasure($font,$t->[0]);
    } else {
      $wd+=$w;
      unshift @result, $t;
    }
    $t=pop(@toks);
  }
  push @lines,@result;
  return \@lines;
}

sub set_value_line {
  my ($grp,$v)=@_;
  my $vl=$grp->{valueLine};
  $vl->configure(qw(-state normal));
  $vl->delete('0.0','end');
  if ($valueLineWrap eq 'word' and
      $valueLineReverseLines) {
    $vl->configure(qw(-wrap none));
    $v=reverseWrapLines($grp->{valueLine},$vLineFont,$v,
			$grp->{valueLine}->width()-15);
  }
  my @oldtags=grep {/^FSNode/} $vl->tagNames();
  if (@oldtags) {
    $vl->tagDelete(@oldtags);
  }
  if (ref($v)) {
    my %tags;
    @tags{ map { @$_[1..$#$_] } @$v }=();
    foreach my $tag (keys(%tags)) {
      if ($tag=~/^\s*-/) {
	eval {
	  $vl->tagConfigure(
			    $tag => (map { (/^\s*(-[[:alnum:]]+)\s*=>\s*(.*\S)\s*$/) }  split(/,/,$tag)));
	};
	print $@ if $@;
      }
    }
    $vl->Subwidget('scrolled')->insert('end','',undef,
				       map { ($_->[0], [@$_[1..$#$_]]) } @$v);
  } else {
    $vl->Subwidget('scrolled')->insert('0.0',$v);
  }
  $vl->tagAdd('all','0.0','end');
  $vl->tagConfigure('all',-justify => $valueLineAlign);
  $vl->configure(qw(-state disabled));
#   print "<dump>\n";
#   my @dump=$vl->dump('0.0','end');
#   while (@dump) {
#     my ($K,$V,$I) = (shift @dump, shift @dump, shift @dump);
#     if ($K eq 'tagon') { 
#       print "<tag value=\"$V\">";
#     } elsif ($K eq 'tagoff') {
#       print "</tag>";
#     } else {
#       print $V;
#     }
#   }
#   print "\n</dump>\n";
  return $v;
}

sub update_status_line {
  my ($win)=@_;
  return unless $win;
  return unless $displayStatusLine;
  my $l=doEvalHook($win,"get_status_line_hook");
  set_status_line($win->{framegroup},$l);
}

sub set_status_line {
  my ($grp,$text)=@_;
  my $sl=$grp->{statusLine};
  return unless $sl;
  $sl->configure(qw(-state normal));
  $sl->delete('0.0','end');
  my @oldtags=$sl->tagNames();
  if (@oldtags) {
    $sl->tagDelete(@oldtags);
  }
  $sl->insert('end',encode($grp->{statusLineText}),undef)
    unless ($grp->{statusLineText} eq "");
  $sl->insert('end'," | ",undef) if ($text);

  if (ref($text)) {
    my ($fields,$styles)=@$text;
    my $i=0;
    $sl->insert('end',map { $i=!$i; $i ? encode($_) : $_ } @$fields);
    while (@$styles) {
      my $style=shift @$styles;
      my $opts=shift @$styles;
      $sl->tagConfigure($style, @$opts);
    }
  } else {
    $sl->insert('0.0',encode($text));
  }
#  $sl->tagAdd('all','0.0','end');
#  $sl->tagConfigure('all');
  $sl->configure(qw(-state disabled));
  return $text;
}

sub update_tree_pos {
  my ($grp)=@_;
  my $win=$grp->{focusedWindow}; # only focused window uses the value line
  if ($win->{FSFile}) {
    $grp->{vLineNumLabel}->configure(-text => ($win->{treeNo}+1)."/".($win->{FSFile}->lastTreeNo+1));
  } else {
    $grp->{vLineNumLabel}->configure(-text => "-/-");
  }
#  $grp->{vLineNumLabel}->update();
}

sub update_value_line {
  my ($grp)=@_;
  my $win=$grp->{focusedWindow}; # only focused window uses the value line
  update_tree_pos($grp);
  return set_value_line($grp,get_value_line($win,$win->{FSFile},
					    $win->{treeNo},1,1));
}

### Get Nodes

sub get_nodes_win {
  my ($win,$noredraw)=@_;
  if ($win->{FSFile}) {
    $win->{treeNo}=0 if ($win->{treeNo}<0 and $win->{FSFile}->lastTreeNo>=0);
    $win->{root}=$win->{FSFile}->treeList->[$win->{treeNo}];
    print "get_nodelist_hook\n" if $tredDebug;
    my $l=doEvalHook($win,"get_nodelist_hook",
		     $win->{FSFile},
		     $win->{treeNo},
		     $win->{currentNode},
		     $win->{treeView}->get_showHidden());
    if (ref($l) eq 'ARRAY' and @$l==2) {
      print "using hook's list\n" if $tredDebug;
      ($win->{Nodes},$win->{currentNode})=@$l;
    } else {
      print "using default get_node_list\n" if $tredDebug;
      ($win->{Nodes},$win->{currentNode})= $win->{treeView}->nodes($win->{FSFile},
								   $win->{treeNo},
								   $win->{currentNode});
    }
  } else {
    print "no nodes to get\n" if $tredDebug;
    $win->{root}=undef;
    $win->{Nodes}=[];
    $win->{currentNode}=undef;
  }
  update_value_line($win->{framegroup}) if (isFocused($win) and !$noredraw);
}

sub get_nodes_fsfile {
  my ($grp,$fsfile)=@_;
  return if $insideEval;
  foreach my $w (fsfileDisplayingWindows($grp,$fsfile)) {
    get_nodes_win($w);
  }
  return;
}

sub get_nodes_fsfile_tree {
  my ($grp,$fsfile,$tree_no)=@_;
  return if $insideEval;
  foreach my $w (grep {$_->{treeNo} == $tree_no}
	   fsfileDisplayingWindows($grp,$fsfile)) {
    get_nodes_win($w);
  }
  return;
}

sub get_nodes_all {
  my ($grp)=@_;
  foreach my $w (@{ $grp->{treeWindows} }) {
    get_nodes_win($w);
  }
  return;
}

############################################################
############################################################
############################################################
# Filelists
############################################################

sub selectFilelist {
  my ($grp_or_win,$list_name)=@_;
  my ($grp,$win)=grp_win($grp_or_win);
  my $fl=switchFilelist($grp,$list_name);
  print "Switching filelist to $list_name\n" if $tredDebug;
  return unless defined($fl);

  if ($fl ne $win->{currentFilelist}) {
    # save file position in the current file-list
    # before switching
    if (ref($win->{FSFile}) and
	$win->{currentFilelist}->position($win->{FSFile}->filename())>=0) {
      $win->{currentFilelist}->set_current($win->{FSFile}->filename());
    }
    $win->{currentFilelist}=$fl;
  }

  # find current file
  $win->{currentFileNo}=max(0,0,$fl->position())-1;
  nextFile($win);
#  gotoFile($win,$win->{currentFileNo});

#  my $file=$fl->file_at($win->{currenatFileNo});
#
#  print "Setting up file $file, no. $win->{currentFileNo}\n"  if $tredDebug;
#
#  if (defined($file)) {
#    openFile($win,$file);
#  } else {
#    closeFile($win,-keep_postponed => askSaveFile($win,
#              -all_windows => 1));  #emtpy filelist
#  }
}

# Find named filelist. Return undef if no such filelist exists
sub findFilelist {
  my ($name)=@_;
  for (@filelists) {
    return $_ if ($_->name eq $name);
  }
  return undef;
}


# this is only a local switch inside the file list dialog window,
# but returns filelist of a given name as a by-product
sub switchFilelist {
  my ($grp,$list_name)=@_;
  return undef unless ref($grp);
  my $fl=undef;
  if (ref($list_name)) {
    $fl=$list_name;
    $list_name=$fl->name();
  }
  return $grp->{filelistCurrentFilelist} 
    if (ref($grp->{filelistCurrentFilelist}) and 
	$list_name eq $grp->{filelistCurrentFilelist}->name);
  $fl=findFilelist($list_name) unless ($fl);
  return undef unless $fl;
  if ($grp->{Filelist}) {
    $grp->{filelistCurrentFilelist}=$fl;
    $fl->expand();
    feedHListWithFilelist($grp,$grp->{Filelist},$fl);
    my $activate=0;
    if (defined($fl->current)) {
      $activate=max(0,$fl->position);
    }
    my $path=filelistEntryPath($fl,$activate);
    $grp->{Filelist}->selectionClear();
    if (defined($path) and $path ne "") {
      $grp->{Filelist}->anchorSet($path);
      $grp->{Filelist}->see($path);
      $grp->{Filelist}->selectionSet($path);
    }
    $grp->{Filelist}->update();
  }
  return $fl;
}


sub createFilelistBrowseEntry {
  my ($grp,$w,$filelistref)=@_;
  my $ll= $w->BrowseEntry
    (
     -label=> 'File lists:',
     -variable=> $filelistref,
     -browsecmd=>
     [
      sub {
	my ($grp,$list,$l)=@_;
	switchFilelist($grp,$$list);
      },$grp,$filelistref
     ],
     -listcmd=>
     [ sub {
	 my $l=shift;
	 $l->delete(0,'end');
	 foreach (@filelists) {
	   $l->insert(0,$_->name);
	 }
       }]
    );
  $ll->Subwidget('entry')->bind
    ('<Return>',
     [ sub {
	 my ($w, $grp, $fl)=@_;
	 my $text=$w->get;
	 if (findFilelist($text)) {
	   switchFilelist($grp,$text);
	 } else {
	   return unless $text ne "";
	   my $d=$w->toplevel->
	     Dialog(-text=> "File-list named $text does not exist.\n".
		    "Do you want to create new filelist or rename current?",
		    -bitmap=> 'question',
		    -title=> 'Create/Rename?',
		    -buttons=> ['Create', 'Rename', 'Cancel']);
	   $d->bind('<Return>', \&dlgReturn);
	   my $answer=$d->Show();
	   if ($answer eq 'Create') {
	     addFilelist(Filelist->new($text));
	     switchFilelist($grp,$text);
	     updatePostponed($grp);
	   } elsif ($answer eq 'Rename') {
	     my $oldn=$grp->{filelistCurrentFilelist}->name();
	     $grp->{filelistCurrentFilelist}->rename($text);
	     updateBookmarks($grp)
	       if ($oldn eq 'Bookmarks');
	     $$fl=$text;
	     updatePostponed($grp);
	   } else {
	     $$fl=$grp->{filelistCurrentFilelist}->name
	       if ($grp->{filelistCurrentFilelist});
	   }
	 }
       },$grp,$filelistref ]);
  $ll->Subwidget('entry')->Subwidget('entry')->configure(qw/-background white -foreground black/);
  $ll->Subwidget('slistbox')->configure(qw/-background white -foreground black/);
  return $ll;
}

sub addFilelist {
  my ($fl)=@_;
  push @filelists, $fl;
  print "adding filelist ".$fl->name()."\n";
  return $fl;
}

sub getFilelistLinePosition {
  my ($fl,$line)=@_;
  return undef unless ref($fl);
  my ($p,$f)=split /\t/,$line;
  return Index($fl->list_ref,$p);
}

sub insertToFilelist {
  my ($grp_or_win,$filelist,$position)=(shift,shift,shift);
  my ($grp,$win)=grp_win($grp_or_win);
  $filelist=$win->{currentFilelist} unless defined($filelist);
  $position=$win->{currentFileNo} unless defined($position);
  return unless ref($filelist);


  print "Insert: ",$#_," ",$_[0]," is at position ",$filelist->position($_[0]),"\n"  if $tredDebug;
  return if ($#_==0 and $filelist->position($_[0])>=0);
  # this is the case when we add a file which is actually already there

  my @list=map absolutize($_),@_;
  my $tmp;
  my $toplevel= $grp->{Filelist} ? $grp->{Filelist}->toplevel : $grp->{top};
  @list= map {
    if (-d $_) {
      $tmp=Query($toplevel,"Selection Pattern","Insert pattern for directory $_","*.*");
      $_= defined($tmp) ? File::Spec->catfile($_,$tmp) : undef;
    }
    $_;
  } @list;
  print "Inserting @list\n" if $tredDebug;
  $filelist->add($position+1,@list);

  if ($grp->{Filelist} and 
      $grp->{filelistCurrentFilelist} eq $filelist) {
    feedHListWithFilelist($grp,$grp->{Filelist},$filelist);
      $position=max(0,$filelist->position($_[0]));
    my $path=filelistEntryPath($filelist,$position);

    $grp->{Filelist}->selectionClear();
    if ($grp->{Filelist}->info('exists',$path)) {
      $grp->{Filelist}->anchorSet($path);
      $grp->{Filelist}->selectionSet($path);
      $grp->{Filelist}->see($path);
    }
    # select all files resulting from added patterns
    for (my $i=0 ; $i<$filelist->file_count ; $i++) {
      if (defined(Index(\@_,$filelist->file_pattern($i)))) {
	$grp->{Filelist}->selectionSet(filelistEntryPath($filelist,$i));
      }
    }
  }
}

sub removeFromFilelist {
  my ($grp_or_win,$filelist,$position)=(shift,shift,shift);
  my ($grp,$win)=grp_win($grp_or_win);
  $filelist=$win->{currentFilelist} if not defined($filelist);
  $position=$win->{currentFileNo} if not defined($position);
  return unless ref($filelist);

  $filelist->remove(@_);
  if ($filelist eq $win->{currentFilelist}) {
    $win->{currentFileNo}= min($win->{currentFileNo},
			       $filelist->file_count-1);
  }

  if ($grp->{Filelist} and 
      $grp->{filelistCurrentFilelist} eq $filelist) {
    $position=min($position,$filelist->file_count-1);
    feedHListWithFilelist($grp,$grp->{Filelist},$filelist);
      $grp->{Filelist}->selectionClear();
    my $path;
    $path=$grp->{filelistCurrentFilelist}->list_ref->[$position];
    if ($grp->{Filelist}->info('exists',$path)) {
      $grp->{Filelist}->anchorSet($path);
      $grp->{Filelist}->selectionSet($path);
      $grp->{Filelist}->see($grp->{Filelist}->info('anchor'));
    }
  }
}

sub addNewFilelist {
  my ($grp,$fl)=@_;
  return if not defined($fl) or $fl eq "";
  for my $l (@filelists) {
    if ($l->name eq $fl->name) {
      print STDERR "Filelist ",$fl->name," already exists, replacing!\n"
	if $tredDebug;
      @{ $l->list_ref }= $fl->list;
      $l->expand;
      if ($grp) {
	$grp->{filelistCurrentFilelist}=undef;
	switchFilelist($grp,$l);
      }
      undef $fl;
      return;
    }
  }
  if (not defined($fl->name) or $fl->name eq "") {
    undef $fl;
    return;
  }
  push @filelists, $fl;
  if ($grp) {
    switchFilelist($grp,$fl);
    updatePostponed($grp);
  }
}

sub deleteFilelist {
  my ($grp,$fl)=@_;
  return unless ref($fl);
  print "Deleting filelist $fl,".$fl->name()."\n" if $tredDebug;
  return if ($fl->name eq 'Default' or
	     $fl->name eq 'Bookmarks');
  print "Allowed\n" if $tredDebug;
  @filelists=grep($_ ne $fl, @filelists);
  print join "\n","Filelists:",@filelists,"" if $tredDebug;
  print scalar(@filelists),"\n" if $tredDebug;
  $grp->{filelistCurrentFilelist}=undef;
  undef $fl;
  switchFilelist($grp,'Default');
  updatePostponed($grp);
}

sub filelistEntryPath {
  my ($fl,$index)= @_;
  return undef unless ref($fl);

  my $f= $fl->file_at($index);
  my $p= $fl->file_pattern($index);
  return $f eq $p ? $f : "$p\t$f";
}

sub feedHListWithFilelist {
  my ($grp,$hl,$fl)=@_;
  return unless ref($hl) and ref($fl);
  $hl->delete('all');
  my $pat;
  my $f;
  for(my $i=0;$i<$fl->file_count;$i++) {
    $pat=$fl->file_pattern($i);
    $f=$fl->file_at($i);
    next unless defined($pat) and defined($f);
    if ($pat eq $f) {
      $hl->add($f,
	       -itemtype=> 'imagetext',
	       -image=> $grp->{fileImage},
	       -data=> $f,
	       -text=> $f);
      next;
    }
    unless ( $hl->info('exists', $pat) ) {
      $hl->add("$pat",
	       -itemtype=> 'imagetext',
	       -image=> $grp->{folderImage},
	       -data=> $pat,
	       -text=> $pat);
    }
    $hl->add("$pat\t$f",
	     -itemtype=> 'imagetext',
	     -image=> $grp->{fileImage},
	     -data=> $f,
	     -text=> $f);
  }
}

sub filelistDialog {

  use Tk::LabFrame;

  my ($grp,$modal)=@_;
  if (defined($grp->{Filelist})) {
    if ($modal) {
      ShowDialog($grp->{Filelist}->toplevel);
    } else {
      $grp->{Filelist}->toplevel->deiconify;
      $grp->{Filelist}->toplevel->focus;
      $grp->{Filelist}->toplevel->raise;
    }
    return;
  }
  return if ($grp->{Filelist});
  my $filelist;
  if (!ref($grp->{focusedWindow}->{currentFilelist})) {
    selectFilelist($grp,'Default');
  }
  $grp->{filelistCurrentFilelist}=$grp->{focusedWindow}->{currentFilelist};
  $filelist=$grp->{filelistCurrentFilelist}->name;
  my $d= $grp->{top}->Toplevel(-title=> "Filelist");
  $d->withdraw;
  $grp->{filelistDialog}=$d;

  my $frame=$d->Frame();
  my $labframe=$frame->LabFrame(-label=> 'Files to add',
				-labelside=> 'acrosstop'
			       )->pack(qw/-expand yes -fill both -side left/);
  my $fl= $labframe->MyFileSelect(-selectmode=> 'extended',
				   -filetypes=> \@open_types)
    ->pack(qw/-expand yes -fill both -side left -padx 5 -pady 5/);

#c  $fl->Subwidget('filelist')->configure(qw/-background white -foreground black/);

  my $midframe=$frame->Frame()->pack(qw/-side left/);

  my $lframe=$frame->Frame()->pack(qw/-expand yes -fill both -side left -padx 5 -pady 5/);
  my $ll= createFilelistBrowseEntry($grp,$lframe,\$filelist);

  $ll->pack(qw/-expand yes -fill both -side top/);
#c                     -background white

  my $t= $lframe->Scrolled(qw/HList -relief sunken
                     -selectmode extended
                     -width 60
		     -height 15 -scrollbars oe/,
			    -separator=> "\t"
			   )
    ->pack(qw/-expand yes -fill both -side top/);
  disable_scrollbar_focus($t);
  $t->BindMouseWheelVert();
  $grp->{Filelist}=$t;
  feedHListWithFilelist($grp,$t,$grp->{focusedWindow}->{currentFilelist});

  $frame->pack(qw/-expand yes -fill both -side top/);


  $midframe->Button(-text=> 'Add -->',
		    -command=>[
			       sub {
				 my ($grp,$t,$l)=@_;
				 insertToFilelist($grp,
						  $grp->{filelistCurrentFilelist},
						  getFilelistLinePosition($grp->{filelistCurrentFilelist},
									  $t->info('anchor')),
						  $l->getSelectedFiles
						 );
				 updateBookmarks($grp)
				   if (ref($grp->{filelistCurrentFilelist}) and
				       $grp->{filelistCurrentFilelist}->name eq 'Bookmarks');
			       },$grp,$t,$fl])->pack(-side=> 'top');

  $midframe->Button(-text=> 'Remove',
		    -command=>[
			       sub { 
				 my ($grp,$t)=@_;
				 removeFromFilelist($grp,
						    $grp->{filelistCurrentFilelist},
						    getFilelistLinePosition($grp->{filelistCurrentFilelist},
									    $t->info('anchor')),
						    $t->info('selection'));
				 updateBookmarks($grp)
				   if (ref($grp->{filelistCurrentFilelist}) and
				       $grp->{filelistCurrentFilelist}->name eq 'Bookmarks');
			       },$grp,$t])->pack(-side=> 'top');

  unless ($modal) {
    $t->bind('<Return>'=> [
			    sub {
			      my ($w,$grp)=@_;
			      my $anchor=$grp->{Filelist}->info('anchor');
			      my $nextentry=$grp->{Filelist}->info('next',$anchor);
			      unless ($nextentry and
					$grp->{Filelist}->info('parent',$nextentry) eq $anchor) {
				$grp->{filelistCurrentFilelist}->
				  set_current($grp->{Filelist}->
					      info('data',$grp->{Filelist}->info('anchor')));
				selectFilelist($grp,$grp->{filelistCurrentFilelist});
			      }
			    },$grp]);
    $t->bind('<Double-1>'=> [
			      sub {
				my ($w,$grp)=@_;
				my $anchor=$grp->{Filelist}->info('anchor');
				my $nextentry=$grp->{Filelist}->info('next',$anchor);
				my $data=$grp->{Filelist}->info('data',$anchor);
				if ($nextentry and
					$grp->{Filelist}->info('parent',$nextentry) eq $anchor) {
				  # pattern -> edit
				  my $position=
				    $grp->{filelistCurrentFilelist}->find_pattern($data);
				  $data=Query($grp->{Filelist}->toplevel,"Selection Pattern",
					"Edit directory pattern for $data",$data);
				  if (defined($data)) {
				    print "Removing ",$grp->{Filelist}->info('data',$anchor),"\n" if $tredDebug;
				    $grp->{filelistCurrentFilelist}->remove($grp->{Filelist}->info('data',$anchor));
				    print "Adding $data\n" if $tredDebug;
				    $grp->{filelistCurrentFilelist}->add($position,$data);
				    feedHListWithFilelist($grp,$grp->{Filelist},$grp->{filelistCurrentFilelist});
				  }
				} else {
				  # file -> go to
				  $grp->{filelistCurrentFilelist}->set_current($data);
				  selectFilelist($grp,$grp->{filelistCurrentFilelist});
				}
			      },$grp ]);
    $d->Button(-text=> 'Go',
	     -command=> [ sub {
			     my ($grp)=@_;
			     $grp->{filelistCurrentFilelist}->
			       set_current($grp->{Filelist}->
					   info('data',$grp->{Filelist}->info('anchor')));
			     selectFilelist($grp,$grp->{filelistCurrentFilelist});
			   },$grp ])->pack(-padx=>'0.5c',-pady=>'0.2c',-side => 'left');
  }
  $d->bind('<Destroy>'=> [sub { shift;
				 my $grp=shift;
				 $grp->{Filelist}=undef;
				 $grp->{filelistCurrentFilelist}=undef;
			       },$grp ]);
  $d->bind('all','<Escape>'=>
	   [sub { shift;
		  $modal ?
		    shift->{selected_button}= "Cancel" :
		      shift->destroy();
		},$d ]);

  $d->Button(-text=> 'Close',
	     -command=> [sub {
			    $modal ?
			      shift->{selected_button}= "Cancel" :
				shift->destroy();
			  },$d ])
    ->pack(-padx=>'0.5c',-pady=>'0.2c',-side => 'right');

  $d->Button(-text=> 'Save',
	     -command=> [sub {
			    my ($grp,$d)=@_;
			    my $file=$grp->{filelistCurrentFilelist}->filename;
			    unless (defined ($file)  and $file ne "") {
			      my $initdir=dirname($file);
			      $initdir=cwd if ($initdir eq './');
			      $initdir=~s!${TrEd::Convert::Ds}$!!m;
			      $file= get_save_filename($d,-filetypes=> 
								 [["Filelists",           ['.fl']]],
								 -title=> "Save filelist as ...",
								 -initialdir=> $initdir,
								 -initialfile=> filename($file));
			      $d->deiconify;
			      $d->focus;
			      $d->raise;
			      $file.=".fl" unless $file=~/\.fl$/;
			      return unless (defined $file and $file ne "");
			      $grp->{filelistCurrentFilelist}->filename($file);
			    }
			    $grp->{filelistCurrentFilelist}->save;
			  },$grp,$d ])
    ->pack(-padx=>'0.5c',-pady=>'0.2c',-side => 'right');

  $d->Button(-text=> 'Load',
	     -command=> [sub {
			    my ($grp,$d,$filelistref)=@_;
			    my $file= get_open_filename($d,-filetypes=> 
						      [["Filelists",           ['.fl']]],
						      -title=> "Load filelist ...");
			    $d->deiconify;
			    $d->focus;
			    $d->raise;
			    return unless (defined $file and $file ne "");
			    my $fl=Filelist->new(undef,$file);
			    return unless $fl;
			    print "Loading filelist: $file\n";
			    $fl->load();
			    addNewFilelist($grp,$fl);
			    $$filelistref=$fl->name();
			  },$grp,$d,\$filelist ])
    ->pack(-padx=>'0.5c',-pady=>'0.2c',-side=>'right');

  $d->Button(-text=> 'Delete',
	     -command=> [sub {
			    my ($grp,$d)=@_;
			    deleteFilelist($grp,$grp->{filelistCurrentFilelist});
			  },$grp,$d ])
    ->pack(-padx=>'0.5c',-pady=>'0.2c',-side=>'right');

  if ($grp->{focusedWindow}->{currentFileNo}) {
    my $path=filelistEntryPath($grp->{filelistCurrentFilelist},$grp->{focusedWindow}->{currentFileNo});
    $t->selectionClear();
    if ($path ne "") {
      eval {
	$t->anchorSet($path);
	$t->selectionSet($path);
	$t->see($path);
      };
    }
  }
  $t->focus;
  if ($modal) {
    ShowDialog($d);
    $d->destroy();
    return $filelist;
  } else {
    $d->Popup;
    return $filelist;
  }

}

sub generateSortedMacroTable {
  my ($grp)=@_;
  my @macroTable= map { [ 
			 $_,
			 $menuBindings{$grp->{focusedWindow}->{macroContext}}->{$_}->[1],
			] } keys %{$menuBindings{$grp->{focusedWindow}->{macroContext}}};
  if ($grp->{macroListOrder} eq 'K') {
    return sort {
      my @a= split '\+',$a->[1];
      my @b= split '\+',$b->[1];
      return $#a <=> $#b if ($#a != $#b);
      return length($a[0]) cmp length($b[0]) if (length($a[0]) ne length($b[0]));
      return $a[0] cmp $b[0] if ($a[0] ne $b[0]);
      return length($a[1]) cmp length($b[1]) if (length($a[1]) ne length($b[1]));
      return $a[1] cmp $b[1] if ($a[1] ne $b[1]);
      return length($a[2]) cmp length($b[2]) if (length($a[2]) ne length($b[2]));
      return $a[2] cmp $b[2] if ($a[2] ne $b[2]);
      return length($a[3]) cmp length($b[3]) if (length($a[3]) ne length($b[3]));
      return $a[3] cmp $b[3] if ($a[2] ne $b[3]);
      return $a cmp $b;
    } @macroTable;
  } else {
    return sort { $a->[0] cmp $b->[0] } @macroTable;
  }
}

sub macrolistCreateItems {
  my ($grp,$t)=@_;
  my $e;
  $t->delete('all');
  foreach my $entry (generateSortedMacroTable($grp)) {
    $e= $t->addchild("");
    $t->itemCreate($e, 0, -itemtype=>'text', -text=>$entry->[0]);
    $t->itemCreate($e, 1, -itemtype=>'text', -text=>$entry->[1]);
  }
}

sub macrolistDialog {
  my ($grp)=@_;
  my $context=$grp->{focusedWindow}->{macroContext};
  if ($grp->{Macrolist}) {
    $grp->{Macrolist}->deiconify;
    $grp->{Macrolist}->focus;
    $grp->{Macrolist}->raise;
    return;
  }
  unless (scalar(keys %{$menuBindings{$context}})) {
    errorMessage($grp->{focusedWindow},"No named macros in current context ($context)");
    return;
  }
  my $d= $grp->{top}->Toplevel(-title=> "List of available named macros");
  $d->withdraw;
  $d->resizable(0,1);
#c  -Background white
  my $t= $d->Scrolled(qw/HList -columns 2
           -selectmode browse
           -height 25 -relief sunken -scrollbars oe/);
  disable_scrollbar_focus($t);
  $t->BindMouseWheelVert();
  $grp->{Macrolist}=$d;
  my $e;
  my $maxw=0;
  macrolistCreateItems($grp,$t);

  $t->columnWidth(0,'');
  $t->columnWidth(1,'');
  $t->anchorSet('0');

  $t->configure(-width=> 0);
  $t->pack(qw/-expand yes -fill both/);
  $d->bind('<Return>'=>
	   [
	    sub {
	      my ($w,$grp,$t,$context)=@_;
	      doEvalMacro($grp->{focusedWindow},
			  $menuBindings{$context}->
			  {$t->itemCget($t->info('anchor'),0,'-text')}->[0]);
	    },$grp,$t,$context ]);
  $d->bind('<Double-1>'=> 
	   [
	    sub {
	      my ($w,$grp,$t,$context)=@_;
	      doEvalMacro($grp->{focusedWindow},
			  $menuBindings{$context}->
			  {$t->itemCget($t->info('anchor'),0,'-text')}->[0]);
	    },$grp,$t,$context ]);

  my $f=$d->Frame()->pack();
  $f->Radiobutton( -anchor  => 'nw',
		   -text    => 'Sort by name',
		   -variable=> \$grp->{macroListOrder},
		   -relief  => 'flat',
		   -command => [sub { #shift;
				       my ($grp,$t)=@_;
				       macrolistCreateItems($grp,$t);
				     },$grp,$t],
		   -value   => 'M'
		 )->pack(-side=> 'left',-padx=> 20);
  $f->Radiobutton( -anchor  => 'nw',
		   -text    => 'Sort by keyboard shortcut',
		   -variable=> \$grp->{macroListOrder},
		   -relief  => 'flat',
		   -command => [sub { #shift;
				       my ($grp,$t)=@_;
				       macrolistCreateItems($grp,$t);
				     },$grp,$t],
		   -value   => 'K'
		 )->pack(-side=> 'right',-padx=> 20);

  $d->Button(-text=> 'Run and Close',
	     -command=> [ sub {
			     my ($w,$grp,$t,$context)=@_;
			     my $mac=$t->itemCget($t->info('anchor'),0,'-text');
			     $w->destroy();
			     doEvalMacro($grp->{focusedWindow},
					 $menuBindings{$context}->{$mac}->[0]);


			   },$d,$grp,$t,$context ])->pack(-padx=>'0.5c',-pady=>'0.2c',-side=>'left');
  $d->bind($d,'<Destroy>'=> [sub { shift; shift->{Macrolist}=undef; },$grp ]);
  $d->bind('all','<Escape>'=> [sub { shift; shift->destroy(); },$d ]);

  $d->Button(-text=> 'Close',
		     -command=> [ sub {
				     shift->destroy();
				   },$d ])->pack(-padx=>'0.5c',-pady=>'0.2c',-side=>'right');
  $t->focus;
  $d->Popup;
}


sub copyTreesDialog {
  my ($grp)=@_;
  
  return unless $grp->{focusedWindow}->{FSFile};
  my $range=$grp->{focusedWindow}->{treeNo}+1;
  my $source=$grp->{focusedWindow}->{FSFile};
  my $destination=$grp->{focusedWindow}->{FSFile};
  my $d= $grp->{top}->DialogBox(-title=> 'Copy Trees',
				-buttons=> ['OK', 'Cancel']);
  $d->bind('<Return>',\&dlgReturn);
  $d->resizable(0,0);
  addBindTags($d,'dialog');
  $d->protocol('WM_DELETE_WINDOW' => [sub { shift->{selected_button}='Cancel'; },$d]);
  $d->bind('all','<Escape>'=> [sub { shift; shift->{selected_button}='Cancel'; },$d ]);
  $d->bind('all','<Tab>',[sub { shift->focusNext; }]);
  $d->bind('all','<Shift-Tab>',[sub { shift->focusPrev; }]);
  $d->bind('all','<Shift-ISO_Left_Tab>',[sub { shift->focusPrev; }]);
  my $ff= $d->Frame();
  $ff->Label(-text=> 'Destination file:',
	     -anchor=> 'w',
	     -justify=> 'right')->pack(-side=> 'left');
  my @items;
  my $i=1;
  foreach my $of (@openfiles) {
    push @items,$i++.". ".$of->filename();
  }
  $ff->Optionmenu(
		  -relief => $buttonsRelief,
		  -options => \@items,
		  -variable => \$destination
		 )->pack(qw/-side left -padx 10/);
  $ff->pack(qw/-pady 10 -padx 10 -side top -expand yes -fill x/);
  my $sf= $d->Frame();
  my $re=$sf->Entry(-relief=> 'sunken',
		 -width=> 20,
		 -font=> $font,
		 -textvariable=> \$range);
  $sf->Label(-text=> 'Trees selection (range):',
	     -anchor=> 'w',
	     -justify=> 'right')->pack(-side=> 'left');
  $re->pack(qw/-side left -padx 10 -fill x -expand yes/);
  $sf->Button(-image=> $grp->{top}->Pixmap(-file=>
					   "$libDir/left.xpm"),
	      -command =>
	      [sub {
		  my ($grp,$range)=@_;
		  $$range=sentViewGetSelection($grp,$grp->{sentDialogSelection});
	       },$grp,\$range])->pack(qw/-padx 10 -side left/);
  $sf->Button(-image=> $grp->{top}->Pixmap(-file=>
					   "$libDir/view_sent.xpm"),
	      -command=> [sub {
			    my ($grp,$d,$range,$source)=@_;
			    my $list=[];
			    foreach (TrEd::Print::parse_print_list($source,$$range)) {
			      $list->[$_-1]=1;
			    }
			    $$range=sentViewGetSelection($grp,
							 viewSentencesDialog($grp,$d,$source,
									     $list
									    ));
			  },$grp,$d,\$range,$source])->pack(qw/-padx 10 -side left/);
  $sf->pack(qw/-pady 10 -padx 10 -side bottom -expand yes -fill x/);


  my $result= ShowDialog($d,$re,$grp->{top});
  $d->destroy();
  undef $d;
  if ($result=~ /OK/) {
    $destination=~/^(\d+)/;
    my $fs=$openfiles[$1-1];
    return unless ref($fs);
    my @list=TrEd::Print::parse_print_list($source,$range);
    my $tree;
    my $any;
    foreach my $l (@list) {
      $tree=$source->tree($l-1);
      if ($tree) {
	$fs->insert_tree($fs->FS->clone_subtree($tree),
			 $fs->lastTreeNo+1);
	$any=1;
      }
    }
    if ($any) {
      $fs->notSaved(1);
      get_nodes_fsfile($grp,$fs);
      redraw_fsfile($grp,$fs);
    }
  }
}

sub initTTFonts {
  my ($grp)=@_;
  print STDERR "Collecting TTF fonts\n";# if $tredDebug;
  $grp->{ttfonts}=TrEd::Print::get_ttf_fonts(map TrEd::Config::tilde_expand($_),
					     split /,/,$ttFontPath)
    unless $grp->{ttfonts};
}

sub printDialog {
  my ($grp)=@_;
  my $win = $grp->{focusedWindow};
  return unless $win->{FSFile};

  my $com=$grp->{printCommand};
  my $fil=$grp->{printPsFile};
  $fil =doEvalHook($win,"print_tree_filename_hook");
  $fil=$win->{FSFile}->filename if $fil eq "";
  my $printFileExtension=$grp->{printFileExtension} || "ps";
  $fil=~s/\.[^.]*$/.$printFileExtension/;
  my $toFile=$grp->{printToFile};
  my $format=$grp->{printFormat};
  my $imageMagickResolution=$grp->{printImageMagickResolution} || 80;
#  my $useType1Font=$grp->{printUseType1Font};
#  my $printRange=$grp->{printRange};
  my $printRange=$win->{treeNo}+1;# unless $printRange ne "";
  my $snt=$grp->{printSentenceInfo};
  my $noRotate=$grp->{printNoRotate};
  my $defaultPrtFmtWidth=$prtFmtWidth;
  my $defaultPrtFmtHeight=$prtFmtHeight;

  my $initTTFont = $ttFont;
  $ttFont = '' unless ($grp->{ttfonts} and exists($grp->{ttfonts}->{$ttFont}));

  print STDERR "done.\n" if $tredDebug;

  my $d= $grp->{top}->DialogBox(-title=> "Print",
				-buttons=> ["OK", "Cancel"]);
  $d->resizable(0,0);
  addBindTags($d,'dialog');
  $d->protocol('WM_DELETE_WINDOW' => [sub { shift->{selected_button}='Cancel'; },$d]);
  $d->bind('all','<Escape>'=> [sub { shift; shift->{selected_button}='Cancel'; },$d ]);
  $d->bind('<Return>',\&dlgReturn);
  $d->bind('all','<Tab>',[sub { shift->focusNext; }]);
  $d->bind('all','<Shift-ISO_Left_Tab>',[sub { shift->focusPrev; }]);
  $d->bind('all','<Shift-Tab>',[sub { shift->focusPrev; }]);
  my $cf= $d->Frame();
  my $cl= $cf->Label(-text=> 'Print command:',
		     -anchor=> 'w',
		     -justify=> 'right')->pack(-side=> 'left');

  my $ce= $cf->Entry(-relief=> 'sunken',
		     -width=> 20,
		     -font=> $font,
		     -textvariable=> \$com)->pack(qw/-padx 10 -side left -expand yes -fill x/);

  my $defaultBg=$ce->cget('-background');
  my $disabledBg=$d->cget('-background');

  $ce->configure($toFile
		? (-state=> 'disabled',-background=> $disabledBg)
		: (-state=> 'normal', -background=> $defaultBg));
  $cf->pack(qw/-pady 10 -padx 10 -side top -expand yes -fill x/);

  my $mf = $d->Frame()->pack(qw/-pady 10 -padx 10 -side top -expand yes -fill x/);
  $mf->Label(-text=> 'Media:',
	     -anchor=> 'w',
	     -justify=> 'right')->pack(-side=> 'left');

  my $mex = $mf->Entry(-textvariable => \$prtFmtWidth,
		       -width => 5,
		       -validate => 'key',
		       -validatecommand => sub { shift =~ /^\s*\d*\s*$/ });
  my $mey = $mf->Entry(-textvariable => \$prtFmtHeight,
		       -width => 5,
		       -validate => 'key',
		       -validatecommand => sub { shift =~ /^\s*\d*\s*$/ });
  for ($mey,$mex) {
    $_->configure(($format eq 'ImageMagick' || $psMedia ne 'User')
		  ? (-state=> 'disabled',-background=> $disabledBg)
		  : (-state=> 'normal', -background=> $defaultBg));
  }
  print STDERR "PSMEDIA: $psMedia\n";
  my $ml=$mf->Optionmenu(
			 -state => $format =~ /ImageMagick|EPS/ ? 'disabled' : 'normal',
			 -relief => $buttonsRelief,
			 -options => ['BBox', 'User', sort {$a cmp $b} grep !/\d+x\d+|^ISO/, 
				      keys %TrEd::Print::media ],
			 -font => ref($font) ? $font->Clone(-size => 8) : $d->Font(-family => 'sans',
										   -size => 8),
			 -textvariable => \$psMedia, # global variable in TrEd::Config
			 -command => [sub {
					my ($x,$y,$dfw,$dfh)=@_;
					for ($x,$y) {
					  $_->configure($psMedia ne 'User'
							? (-state=> 'disabled',-background=> $disabledBg)
							: (-state=> 'normal', -background=> $defaultBg));
					}
					if ($psMedia eq 'BBox') {
					  $prtFmtWidth = $dfw;
					  $prtFmtHeight = $dfh;
					} elsif ($psMedia ne 'User') {
					  $prtFmtWidth = $TrEd::Print::media{$psMedia}[0];
					  $prtFmtHeight = $TrEd::Print::media{$psMedia}[1];
					}
				      },$mex,$mey,$defaultPrtFmtWidth,$defaultPrtFmtHeight]
			)->pack(-side=> 'left');
  $mey->raise($ml);
  $mex->raise($ml);
  $mf->Label(-text=> 'Width:',
	     -padx => 10,
	     -anchor=> 'w',
	     -justify=> 'right')->pack(-side=> 'left');
  $mex->pack(-side=> 'left');
  $mf->Label(-text=> 'Height:',
	     -padx => 10,
	     -anchor=> 'w',
	     -justify=> 'right')->pack(-side=> 'left');
  $mey->pack(-side=> 'left');
  $mf->Label(-text=> 'X margin:',
	     -padx => 10,
	     -anchor=> 'w',
	     -justify=> 'right')->pack(-side=> 'left');
  $mf->Entry(-textvariable => \$prtHMargin,
	     -width => 5,
	     -validate => 'key',
	     -validatecommand => sub { shift =~ /^\s*\d*[cimp]?\s*$/ })
    ->pack(-side=> 'left');
  $mf->Label(-text=> 'Y margin:',
	     -padx => 10,
	     -anchor=> 'w',
	     -justify=> 'right')->pack(-side=> 'left');
  $mf->Entry(-textvariable => \$prtVMargin,
	     -width => 5,
	     -validate => 'key',
	     -validatecommand => sub { shift =~ /^\s*\d*[cimp]?\s*$/ })
    ->pack(-side=> 'left');
  my $ff=$d->Frame();
  my $fl= $ff->Label(-text=> 'File name:',
		     -anchor=> 'w',
		     -justify=> 'right')->pack(-side=> 'left');

  my $fe= $ff->Entry(-relief=> 'sunken',
		     -width=> 50,
		     -font=> $font,
		     -textvariable=> \$fil)->pack(qw/-padx 10 -side left -expand yes -fill x/);
  if ($fil ne "") {
    my $start = rindex($fil,"/")+1;
    my $end = rindex($fil,".");
    if ($start<$end) {
      $fe->selectionClear();
      $fe->selectionRange($start,$end);
      $fe->icursor($start);
    }
  }
  my $sf= $d->Frame();
  my $re=$sf->Entry(-relief=> 'sunken',
		    -width=> 20,
		    -font=> $font,
		    -textvariable=> \$printRange);
  my $fb= $ff->Button(-text => '...',
		      -command =>
		      [sub {
			 my ($d,$rfil)=@_;
			 my $initdir=dirname($$rfil);
			 $initdir=cwd() if ($initdir eq './');
			 $initdir=~s!${TrEd::Convert::Ds}$!!m;
			 my $file=
			   get_save_filename($d,-title => "Print To File ...",
					   $^O eq 'MSWin32' ? () :
					   (-initialfile=> filename($$rfil)),
					   -d $initdir ? (-initialdir=> $initdir) : (),
					   -filetypes=>
					   [
					    ["PostScript files", [qw/.ps .eps .PS .EPS/]],
					    ["All files", '*']
					   ]
					  );
			 $$rfil=$file if (defined $file and $file ne '');
		       },$d,\$fil])->pack(qw/-padx 10 -side left/);

  my $of=$d->Frame();
  my $bf=$of->Frame();

  my %fmtbut;
  my $pbf = $bf->Frame();
  my $pfl=$pbf->Label(-text=> 'Font (TTF):',
		 -anchor=> 'sw',
		 -justify=> 'right');
#   my $pe=$pbf->Entry(-relief=> 'sunken',
# 		     -width=> 50,
# 		     -font=> $font,
# 		     ($format eq 'PDF') ?
# 		     (-state => 'normal', -background=> $defaultBg ) :
# 		     (-state => 'disabled', -background=> $disabledBg),
# 		     -textvariable=> \$ttFontFile);
  my $pfbe=$pbf->BrowseEntry(
			     -relief=> 'sunken',
			     -width=> 30,
			     ($toFile and $format eq 'PDF') ?
			     (-state => 'readonly', -background=> $defaultBg ) :
			     (-state => 'disabled', -background=> $disabledBg),
			     -variable => \$ttFont,
#			     -autolimitheight => 'yes',
#			     -listheight => 10,
#			     -style => 'MSWin32',
			     -choices => [$grp->{ttfonts} ? (sort {$a cmp $b} keys %{$grp->{ttfonts}}) : ()]
			    );
  $pfbe->Subwidget('slistbox')->BindMouseWheelVert();
#   my $pfb= $pbf->Button(-text => '...',
# 			-state => $format eq 'PDF' ? 'normal' : 'disabled',
# 		       -command =>
# 		       [sub {
# 			  my ($d,$rfil)=@_;
# 			  my $initdir=dirname($$rfil);
# 			  $initdir=cwd() if ($initdir eq './');
# 			  $initdir=~s!${TrEd::Convert::Ds}$!!m;
# 			  my $file=
# 			    get_open_filename($d,-title => "TrueType Font ...",
# 					    $^O eq 'MSWin32' ? () :
# 					    (-initialfile=> filename($$rfil)),
# 					    -d $initdir ? (-initialdir=> $initdir) : (),
# 					    -filetypes=>
# 					    [
# 					     ["TrueType Font files", [qw/.ttf .TTF .tt2 .TT2/]],
# 					     ["All files", '*']
# 					    ]
# 					   );
# 			  $$rfil=$file if (defined $file and $file ne '');
# 			},$d,\$ttFontFile]);
  my $imf=$bf->Frame();
  my $imr=$imf->Optionmenu(
			   -state => $format eq 'ImageMagick' ? 'normal' : 'disabled',
			   -relief => $buttonsRelief,
			   -options => ['75','80','90','100','120','135','150','160','180',
					'200','225','240','260','300','360','600','720'],
			   -variable => \$imageMagickResolution
		   );

  my $bfb=$bf->Checkbutton(-text    => 'Print to file',
		   -variable=> \$toFile,
		   -command => [sub {
				  my ($t,$fmtbut,$fmt,$c,$f,$b,$r,$e)=@_;
				  if ($$t) {
				    $f->focus;
				    $c->configure(-state=> 'disabled',
						  -background=> $disabledBg);
				    $f->configure(-state=> 'normal',
						  -background=> $defaultBg);
				    $b->configure(-state=> 'normal');
				    $c->configure(-state=> 'disabled',
						  -background=> $disabledBg);
#				    $r->configure(-state=> 'disabled',
#						  -background=> $disabledBg);
				    if ($$fmt eq 'PDF') {
				      $e->configure(-state=> 'readonly',
						    -background=> $defaultBg);
				    }
				    foreach (keys %$fmtbut) {
				      $fmtbut->{$_}->configure(-state=> 'normal');
#				      unless ($_ eq 'PDF' and !$ttFontFile);
				    }
				  } else {
				    $c->focus;
				    $f->configure(-state=> 'disabled',
						  -background=> $disabledBg);
				    $b->configure(-state=> 'disabled');
				    $c->configure(-state=> 'normal',
						  -background=> $defaultBg);
#				    $r->configure(-state=> 'normal',
#						  -background=> $defaultBg);
				    $e->configure(-state=> 'disabled',
						  -background=> $disabledBg);
				    foreach (keys %$fmtbut) {
				      $fmtbut->{$_}->configure(-state=> 'disabled');
				    }
				  }
				},\$toFile,\%fmtbut,\$format,$ce,$fe,$fb,$re,$pfbe],
		   -relief  => 'flat')->pack(-fill=> 'y',-anchor=> 'nw');

  my %fmtbuttons = ( PS => [$bf,'Create PostScript','ps'],
		     EPS =>[$bf,'Create EPS','eps'],
		     PDF =>[$pbf,'Create PDF','pdf'],
		     ImageMagick => [$imf,'Convert according to file extension (ImageMagick)','png']
		   );
  foreach (qw(PS EPS PDF ImageMagick)) {
    $fmtbut{$_} = $fmtbuttons{$_}[0]->
      Radiobutton(-text    => $fmtbuttons{$_}[1],
		  -value   => $_,
		  -variable=> \$format,
		  -relief  => 'flat',
		  -command =>
		  [sub { my ($f,$l,$ext,$I,$M,$P)=@_;
			 local $_=$$l;
			 s/\.[^.]+$/.$ext/; 
			 $$l=$_;
			 if ($f eq 'PDF' and !$grp->{ttFonts}) {
			   $win->toplevel->Busy(-recurse=> 1);
			   initTTFonts($grp);
			   $win->toplevel->Unbusy();
			   foreach (sort {$a cmp $b} keys %{$grp->{ttfonts}}) {
			     $P->insert('end',$_);
			   }
			   if (exists($grp->{ttfonts}->{$initTTFont})) {
			      $ttFont = $initTTFont;
			   } else {
			     $ttFont = '';
			   }
			 }

			 $I->configure(-state => 
				       $f eq 'ImageMagick' ?
					'normal' : 'disabled');
			 $M->configure(-state =>
				       $f !~ /ImageMagick|EPS/ ?
					'normal' : 'disabled');
			 $P->configure( $f eq 'PDF' ?
					(-state=> 'readonly',
					 -background=> $defaultBg) :
					(-state=> 'disabled',
					 -background=> $disabledBg) );
		       },$_,\$fil,$fmtbuttons{$_}[2],$imr,$ml,$pfbe]
		 );
  }
  $imr->raise($fmtbut{ImageMagick});

  foreach (qw(PS EPS)) {
    $fmtbut{$_}->pack(qw/-fill y -anchor nw/);
  }
  $fmtbut{PDF}->pack(qw/-anchor w -side left -fill y -expand 1/);
  $pfl->pack(qw/-padx 10 -side left/);
#  $pe->pack(qw/-padx 10 -side left/);
#  $pfb->pack(qw/-padx 10 -side left/);
  $pfbe->pack(qw/-padx 10 -side left/);
  $pbf->raise($fmtbut{EPS});
  $imf->raise($pbf);
  $fmtbut{ImageMagick}->pack(qw/-anchor w -side left -fill y -expand 1/);
  $fe->configure($toFile 
		? (-state=> 'normal', -background=> $defaultBg)
		: (-state=> 'disabled',-background=> $disabledBg));

  $fb->configure($toFile
		? (-state=> 'normal')
		: (-state=> 'disabled'));
  $re->configure($format eq 'ImageMagick'
		? (-state=> 'disabled',-background=> $disabledBg)
		: (-state=> 'normal', -background=> $defaultBg));

  $imf->Label(-text => "Resolution")->pack(qw/-padx 10 -side left/);
  $imr->pack(qw/-padx 10 -side left/);
  $pbf->pack(qw/-fill x -expand yes -anchor nw/);
  $imf->pack(qw/-fill x -expand yes -anchor nw/);

#    $bf->Checkbutton(-text    => 'Use Type1 Postscript Font',
#  			  -state=> $type1font ? 'normal' : 'disabled' ,
#  			  -variable=> \$useType1Font,
#  			  -relief  => 'flat')->pack(-fill=> 'y',-anchor=> 'nw');

  $bf->Checkbutton(-text=> 'Use colors',
		   -variable=> \$printColors,
		   -relief  => 'flat')->pack(-fill=> 'y',-anchor=> 'nw');
  $bf->Checkbutton(-text=> 'Print sentence',
		   -variable=> \$snt,
		   -relief  => 'flat')->pack(-fill=> 'y',-anchor=> 'nw');

  my $dlb=
    $bf->Checkbutton(-text    => 'Disable landscape rotation of wide trees',
		     -variable=> \$noRotate,
		     -relief  => 'flat')->pack(-fill=> 'y',-anchor=> 'nw');

  $bf->pack(-side=> 'left');
  $of->pack(qw/-padx 10 -pady 10 -side top -expand yes -fill x/);
  $sf->Label(-text=> 'Page range:',
	     -anchor=> 'w',
	     -justify=> 'right')->pack(-side=> 'left');

  $re->pack(qw/-side left -padx 10 -fill x -expand yes/);

  for ($sf,$ff) {
    $_->raise($of);
  }

  $sf->Button(-image=> $grp->{top}->Pixmap(-file=>
					   "$libDir/left.xpm"),
	      -command =>
	      [sub {
		 my ($grp,$rng)=@_;
		 $$rng=sentViewGetSelection($grp,$grp->{sentDialogSelection});
	       },$grp,\$printRange])->pack(qw/-padx 10 -side left/);
  $sf->Button(-image=> $grp->{top}->Pixmap(-file=>
					   "$libDir/view_sent.xpm"),
	      -command=> [sub {
			    my ($grp,$win,$d,$rng)=@_;
			    my $list=[];
			    foreach (TrEd::Print::parse_print_list(
					  $win->{FSFile},
					   $$rng)) {
			      $list->[$_-1]=1;
			    }
			    $$rng=
			      sentViewGetSelection($grp,
				 viewSentencesDialog($grp,$d,
				 $win->{FSFile},
				 $list));
			  },$grp,$win,$d,\$printRange ])->pack(qw/-padx 10 -side left/);

  $sf->pack(qw/-pady 10 -padx 10 -side bottom -expand yes -fill x/);
  $ff->pack(qw/-pady 10 -padx 10 -side bottom -expand yes -fill x/);

  foreach (qw(PS EPS PDF ImageMagick)) {
    if ($toFile) {
      $fmtbut{$_}->configure(-state=> 'normal');
#      unless ($_ eq 'PDF' and !$ttFontFile);
    } else {
      $fmtbut{$_}->configure(-state=> 'disabled');
    }
  }


#  $toFile ? $fe->focus : $ce->focus;
  my $result= ShowDialog($d,$toFile ? $fe : $ce,$grp->{top});
  $grp->{printRange}=$printRange;
#  $grp->{printSelection}= join(' ',grep { $lt->selectionIncludes($_) } (0 .. $lt->size-1));
  $grp->{printToFile}=$toFile;
  $grp->{printFormat}=$format;
  $grp->{printPsFile}=$fil;
  ($grp->{printFileExtension})=$fil=~m!\.([^.\\/]+)$!;
  $grp->{printSentenceInfo}=$snt;
  $grp->{printCommand}=$com;
  $grp->{printImageMagickResolution}=$imageMagickResolution;
  if ($toFile and $format eq 'imageMagick') {
    $com="$imageMagickConvert -density $imageMagickResolution - $fil"
  }
#  $grp->{printUseType1Font}=$useType1Font;
  $grp->{printNoRotate}=$noRotate;
  $d->destroy;
  undef $d;
  if ($result=~ /OK/) {
    return ($printRange,
	    ($toFile and $format ne 'imageMagick') ? 1 : 0,
	    $format =~ /ImageMagick|EPS/ ? 1 : 0,
	    ($toFile and $format eq 'PDF') ? 1 : 0,
	    $fil,$snt,$com,
	    #$useType1Font,
	    $printColors,$noRotate);
  } else {
    return ();
  }
}

sub printThis {
  my ($grp)=@_;
  return unless $grp->{focusedWindow}->{FSFile};
  my $canvas=$grp->{top}->Canvas();
  my @print_opts;
  my $err;
  do {{
    @print_opts=printDialog($grp);
    return unless scalar(@print_opts)>2;
    $err = ($print_opts[3] and (!$grp->{ttfonts} or !$grp->{ttfonts}->{$ttFont}));
    ErrorMessage($grp,"You must select TrueType font for PDF!") if $err;
  }} while ($err);
  $print_opts[0]=$grp->{focusedWindow}->{treeNo}+1
    if (!defined($print_opts[0]) or $print_opts[0] eq "");
  TrEd::Print::print_trees($grp->{focusedWindow}->{FSFile},
			   $grp->{top},
			   $canvas,
			   @print_opts,
			   $grp->{focusedWindow}->{treeView}->get_showHidden(),
			   {
			    'PS' => $psFontFile,
			    'AFM' => $psFontAFMFile,
			    'TTF' => ($grp->{ttfonts} ? $grp->{ttfonts}->{$ttFont} : ""),
			    'Size' => $psFontSize,
			   },
			   $prtFmtWidth,
			   $prtHMargin,
			   $prtFmtHeight,
			   $prtVMargin,
			   $maximizePrintSize,
			   $psMedia,
			   $treeViewOpts
			  );
  $canvas->destroy();
}

sub getWindowPatterns {
  my ($win)=@_;
  if ($win->treeView->patterns()) {
    return @{$win->treeView->patterns()}
  } elsif ($win->{FSFile}) {
    return $win->{FSFile}->patterns();
  } else {
    return ();
  }
}

sub getWindowHint {
  my ($win)=@_;
  if (defined($win->treeView->hint)) {
    return ${$win->treeView->hint()};
  } elsif ($win->{FSFile}) {
    return $win->{FSFile}->hint();
  } else {
    return undef;
  }
}

sub setWindowPatterns {
  my $win=shift;
  if ($win->treeView->patterns()) {
    @{$win->treeView->patterns()}=@_;
  } elsif ($win->{FSFile}) {
    $win->{FSFile}->changePatterns(@_);
  }
}

sub setWindowHint {
  my ($win,$hint)=@_;
  if ($win->treeView->hint()) {
    ${$win->treeView->hint()}=$hint;
  } elsif ($win->{FSFile}) {
    $win->{FSFile}->changeHint($hint);
  }
}

sub applyWindowStylesheet {
  my ($win,$stylesheet)=@_;
  return unless $win;
  my $s=$win->{framegroup}->{stylesheets}->{$stylesheet};
  if ($stylesheet eq STYLESHEET_FROM_FILE()) {
    $win->treeView()->set_patterns(undef);
    $win->treeView()->set_hint(undef);
  } else {
    if ($s) {
      $win->treeView()->set_patterns($s->{patterns});
      $win->treeView()->set_hint(\$s->{hint});
    }
  }
  $win->{stylesheet}=$stylesheet;
}

sub getStylesheetMenuList {
  my ($grp)=@_;
  [STYLESHEET_FROM_FILE(),NEW_STYLESHEET(),DELETE_STYLESHEET(),
   sort keys %{$grp->{stylesheets}}];
}

sub switchStylesheet {
  my ($grp,$stylesheet)=@_;
  my $win=$grp->{focusedWindow};
  return unless ref($win);
  my $prevstylesheet=$win->{stylesheet};
  return if $prevstylesheet eq $stylesheet;
  if ($stylesheet eq NEW_STYLESHEET()) {
    $stylesheet=QueryString($grp,"Stylesheet name", "Name: ");
    if (!defined($stylesheet)) {
      $stylesheet=$prevstylesheet;
    } elsif (exists($grp->{stylesheets}->{$stylesheet})) {
      errorMessage($win,
		   "Stylesheet named '$stylesheet' already exists!\n");
      $stylesheet=$prevstylesheet;
    } else {
      $grp->{stylesheets}->{$stylesheet}->{patterns}=[getWindowPatterns($win)];
      $grp->{stylesheets}->{$stylesheet}->{hint}=getWindowHint($win);
      $grp->{StylesheetMenu}->configure(-options =>
					getStylesheetMenuList($grp));
      # $grp->{StylesheetMenu}->addOptions($stylesheet);
      saveStyleSheets($grp);
    }
    applyWindowStylesheet($win,$stylesheet);
    $grp->{selectedStylesheet} = $stylesheet;
  } elsif ($stylesheet eq DELETE_STYLESHEET()) {
    if ($prevstylesheet eq STYLESHEET_FROM_FILE()) {
      $grp->{selectedStylesheet} = $prevstylesheet;
      return 0;
    }
    $stylesheet=$prevstylesheet;
    my $answer=userQuery($win,
			 "Really delete stylesheet '$stylesheet'?",
			 -bitmap=> 'question',
			 -title => "Delete stylesheet?",
			 -buttons => ['Yes', 'No']);
    if ($answer eq 'Yes') {
      delete $grp->{stylesheets}->{$stylesheet};
      $grp->{StylesheetMenu}->configure(-options =>
					getStylesheetMenuList($grp));
      foreach my $w (@{ $grp->{treeWindows} }) {
	if ($w->{stylesheet} eq $stylesheet) {
	  applyWindowStylesheet($win,STYLESHEET_FROM_FILE());
	  if ($win->{FSFile}) {
	    get_nodes_win($win);
	    redraw_win($win);
	  }
	}
      }
      $grp->{selectedStylesheet} = STYLESHEET_FROM_FILE();
      saveStyleSheets($grp);
    } else {
      $grp->{selectedStylesheet} = $stylesheet;
      return 0;
    }
  } else {
    return 0 if (doEvalHook($win,"pre_switch_stylesheet_hook",
			    $prevstylesheet,$stylesheet) eq 'stop');
    applyWindowStylesheet($win,$stylesheet);
    doEvalHook($win,"switch_stylesheet_hook",$prevstylesheet,$stylesheet);
    if ($win->{FSFile}) {
      get_nodes_win($win);
      redraw_win($win);
    }
  }
  return 1;
}

sub switchContext {
  my ($win,$context,$noredraw)=@_;
  my $prevcontext=$win->{macroContext};
  return 0 if (doEvalHook($win,"pre_switch_context_hook",$prevcontext,$context)
	       eq 'stop');
  $win->{macroContext}=$context;
  $win->{framegroup}{selectedContext}=$context if (isFocused($win));
  doEvalHook($win,"switch_context_hook",$prevcontext,$context);
  if ($noredraw) {
    get_nodes_win($win);
    redraw_win($win);		# something should be done with display attrs vs windows maybe
  }
}

sub onGetNodeStyle {
  my ($treeview,$node,$styles,$win)=@_;
  doEvalHook($win,"node_style_hook",$node,$styles);
}
sub onGetRootStyle {
  my ($treeview,$node,$styles,$win)=@_;
  doEvalHook($win,"root_style_hook",$node,$styles);
}

sub onTreeChange {
  my ($win)=@_;
  get_nodes_fsfile_tree($win->{framegroup},$win->{FSFile},$win->{treeNo});
  redraw_fsfile_tree($win->{framegroup},$win->{FSFile},$win->{treeNo});
  centerTo($win,$win->{currentNode});
}

sub onNodeChange {
  my ($win)=@_;
  get_nodes_fsfile_tree($win->{framegroup},$win->{FSFile},$win->{treeNo});
  redraw_fsfile_tree($win->{framegroup},$win->{FSFile},$win->{treeNo});
}

sub update_value_line_current {
  my ($win,$node)=@_;
  my $grp=$win->{framegroup};
  my $vl=$grp->{valueLine};
  if ($win == $grp->{focusedWindow}) {
    eval {
      $vl->tagRemove('current','0.0','end');
      $vl->tagRemove('sel','0.0','end');
      if ($vl->tagNextrange("$node",'0.0') ne "") {
	$vl->tagAdd('current',
		    $node.".first",
		    $node.".last",
				 );
	$vl->see('current.first');
      }
    };
  }
}

sub onCurrentChange {
  my ($win,$node,$prev)=@_;
  my $n;
  my $tv=$win->{treeView};
  update_value_line_current($win,$node);
  foreach $n ($node,$prev) {
    $tv->canvas->itemconfigure($tv->get_node_pinfo($n,"Oval"),
			       nodeOptions($win,$n));
    if ($tv->get_node_pinfo($n,"NodeHasBox")) {
      $tv->canvas->itemconfigure($tv->get_node_pinfo($n,"TextBox"),
				 nodeBoxOptions($win,$n,0));
    }
    if ($tv->get_node_pinfo($n,"EdgeHasBox")) {
      $tv->canvas->itemconfigure($tv->get_node_pinfo($n,"EdgeTextBox"),
				 nodeBoxOptions($win,$n,1));
    }
    $tv->canvas->coords($tv->get_node_pinfo($n,"Oval"),
			$tv->node_coords($n,$win->{currentNode}));
  }
  unless ($prev eq $node) {
    $tv->apply_stored_style_opts("Oval",$prev);
    $tv->apply_stored_style_opts("TextBox",$prev);
    $tv->apply_stored_style_opts("EdgeTextBox",$prev);
    doEvalHook($win,"current_node_change_hook",$node,$prev) unless $insideEval;
    update_status_line($win);
  }
}

sub prepareFont {
  my ($grp,$font,$fn)=@_;
  print STDERR "Preparing fonts.\n" if $tredDebug;
  if ($$font!~/^\s*-/ and $$font!~/^\s*\{/) {
    my @a=split(/\s*,\s*/,$$font);
    my ($option,$value);
    my @b;
    foreach (@a) {
      ($option, $value)= split(/\s*:\s*/, $_, 2);
      push @b, "-".$option, $value if ($option=~/^(?:size|weight|family|slant|underline|overstrike)$/);
    }
      # try
    eval { $grp->{top}->fontDelete($fn) }; 
      # error would be displayed otherwise if yet undefined
      # and I'm lazy to remember or find out how to check
      # :)
    $grp->{top}->fontCreate($fn,@b);
    $$font=$fn;
  }
  #
  # There were problems with the following lines, so I'm skipping them  
  #
  # else {
  #  $grp->{top}->fontCreate('C_normal',$grp->{top}->fontActual($$font));
  #  $$font='C_normal';
  # }
}

sub prepareFonts {
  my ($grp)=@_;
  prepareFont($grp,\$font,'C_normal');
  $treeViewOpts->{font}=$font;
  prepareFont($grp,\$vLineFont,'C_vline');
}

sub addBindTags {
  my $w=shift @_;
  $w->bindtags([@_,$w,ref($w),$w,$w->toplevel,'all']);

}

sub cascadeMenus {
  my $uM=[ @_[0..min($maxMenuLines-1,$#_)] ];
  my $uuM=$uM;
  my $i=$maxMenuLines;
  while ($i<=$#_) {
    $_=[@_[$i..min($i+$maxMenuLines-1,$#_)]];
    push @$uuM,[Cascade=> 'More...', -menuitems=> $_];
    $uuM=$_;
    $i+=$maxMenuLines;
  }
  return $uM;
}

sub saveFileStateUpdate {
  my ($win)=@_;
  return unless isFocused($win);
  return unless $win->{framegroup}->{saveButton};
  $win->{framegroup}->{saveButton}->
    configure(-image=>
	      ($win->{FSFile} and $win->{FSFile}->notSaved)
	      ? $normalSavePixmap : $savedSavePixmap);
}


sub About {
  my ($grp)=@_;
  my $message="";
  my $contextinfo="";
  my $fileinfo="";
  my $colinf="";
  if ($grp->{focusedWindow}->{FSFile}) {
    $fileinfo=
      "Current file:\n".
	$grp->{focusedWindow}->{FSFile}->filename."\n".
	  "Format: ".$grp->{focusedWindow}->{FSFile}->fileFormat.", ".$grp->{focusedWindow}->{FSFile}->lastTreeNo." trees\n";
    $contextinfo="Current context: ".$grp->{focusedWindow}->{macroContext}."\n";
    my %colinf=(Shadow=> [], Hilite=>, XHilite=> []);
    foreach ($grp->{focusedWindow}->{FSFile}->FS->attributes) {
      push @{$colinf{$grp->{focusedWindow}->{FSFile}->FS->color($_)}},$_
	unless ($grp->{focusedWindow}->{FSFile}->FS->color($_) eq 'normal');
    }
    $colinf="Coloured attributes:\n    Highlited: ".join(",",@{$colinf{Hilite}}).
      "\n    XHighlited: ".join(",",@{$colinf{XHilite}}).
	"\n    Shadow: ".join(",",@{$colinf{Shadow}})."\n";
  }

  doEvalHook($grp->{focusedWindow},"about_file_hook",\$message);
  my $ver=$version;
  $ver=~s/\$//g;
  $grp->{top}->toplevel->
    messageBox(-icon=> 'info',
			  -type=> 'ok',
			  -message=>
			  "TrEd $ver\nTk $Tk::VERSION\n\n$fileinfo$contextinfo$colinf$message\n$about\n\nLast update: $lastupdate",
			  -title=> 'About');
}

sub newTrEdWindow {
  my ($grp)=@_;

  my $win= new TrEd::Window(newTreeView($grp),framegroup=>$grp);
  $win->{macroContext}= $opt_t && exists($keyBindings{$opt_t}) 
    ? $opt_t : 'TredMacro';
  $win->{stylesheet} = STYLESHEET_FROM_FILE();
  push @{$grp->{treeWindows}}, $win;
  return $win;
}

sub newTreeView {
  my ($grp)=@_;

  my $canvas=
    $grp->{top}->Scrolled('Canvas',
		   -width=> $defCWidth,
		   -height=> $defCHeight,
		   qw /-relief sunken
		       -borderwidth 2
                       -scrollbars osoe/,
		   -scrollregion=> [qw/0c 0c 1c 1c/],
		   $treeViewOpts->{backgroundColor} 
		   ? (-background=> $treeViewOpts->{backgroundColor}) : ()
		  );
  canvasBindMouseWheelVert($canvas);
  canvasBindMouseWheelHoriz($canvas,"Shift");
  createCanvasBindings($grp,$canvas);
  addBindTags($canvas,'my');
  addBindTags($canvas->Subwidget('scrolled'),'canvas');

  my $balloon=$grp->{top}->Balloon(-initwait=> $canvasBalloonInitWait,
				  -state=> 'balloon',
				 );
  $balloon->Subwidget('message')->configure(-foreground=> $canvasBalloonForeground);

  $balloon->Tk::Toplevel::configure(-background=> $canvasBalloonBackground);
  $balloon->Subwidget('message')->configure(-justify=> 'left',-font=> $font);
  my $treeView=new TrEd::TreeView($canvas,'CanvasBalloon'=> $balloon);
  $treeView->apply_options($treeViewOpts);
  return $treeView;
}

sub findCanvasWindow {
  my ($grp,$canvas)=@_;
  foreach my $w (@{$grp->{treeWindows}}) {
    return $w if $w->contains($canvas);
  }
  return undef;
}

sub focusCanvas {
  my ($c,$grp)=@_;
  if ($grp->{focusedWindow}) {
    return if $grp->{focusedWindow}->contains($c);
    $grp->{focusedWindow}->canvas()->configure(@normal_win_opts);
    $grp->{focusedWindow}->canvas()->update();
  }
  if ($c) {
    $c->configure(@focused_win_opts);
    $c->update();
  }
  my $newfocus=findCanvasWindow($grp,$c);
  if ($newfocus) {
    $grp->{selectedContext}=$newfocus->{macroContext};
    $grp->{selectedStylesheet}=$newfocus->{stylesheet};
    $treeViewOpts->{drawBoxes}=$newfocus->{treeView}->get_drawBoxes();
    $treeViewOpts->{drawEdgeBoxes}=$newfocus->{treeView}->get_drawEdgeBoxes();
    $treeViewOpts->{showHidden}=$newfocus->{treeView}->get_showHidden();
    $treeViewOpts->{highlightAttributes}=$newfocus->{treeView}->get_highlightAttributes;
    $grp->{focusedWindow}=$newfocus;
    update_value_line($grp);
    update_status_line($grp->{focusedWindow});
    update_value_line_current($newfocus,$newfocus->{currentNode});
    updateTitle($grp);
    resetUndoStatus($newfocus);
    resetTreePosStatus($grp);
  } else {
    print STDERR "DID NOT FIND Window of $c\n";
  }
}

sub splitWindow {
  my ($grp,$dir,$nofocus)=@_;
  my $twin     = newTrEdWindow($grp);
  my $canvas=$twin->canvas();
  $canvas->configure(@normal_win_opts);
  $grp->{focusedWindow}->split_frame($canvas,$dir);
  foreach (qw(FSFile treeNo currentNode currentFileNo macroContext currentFilelist)) {
    $twin->{$_}=$grp->{focusedWindow}->{$_};
  }
  applyWindowStylesheet($twin,$grp->{selectedStylesheet});
  get_nodes_win($twin);
  redraw_win($twin);
  focusCanvas($canvas,$grp) unless $nofocus;
}

sub removeWindow {
  my ($grp)=@_;
  my $win=$grp->{focusedWindow};
  if (@{$grp->{treeWindows}}>1) {
    @{$grp->{treeWindows}}=grep {$_ ne $win} @{$grp->{treeWindows}};
    closeFile($win,-no_update => 1, -keep_postponed => 1);
    my $brother=$win->canvas_destroy();
    delete $grp->{focusedWindow};
    focusCanvas($brother,$grp);
    $win->{treeView}=undef;
    undef $win;
  }
}

sub canvasBindMouseWheelVert {
    my($w,$modifier)= @_;
    $modifier.="-" if ($modifier);
    $w->CanvasBind("<$modifier"."MouseWheel>",
              [ sub { $_[0]->yview('scroll',-($_[1]/120)*3,'units') }, Tk::Ev("D")]);
#    if ($Tk::platform eq 'unix') {
    $w->CanvasBind("<$modifier"."4>", sub { $_[0]->yview('scroll', -3, 'units')
					      unless $Tk::strictMotif; });
    $w->CanvasBind("<$modifier"."5>", sub { $_[0]->yview('scroll', 3, 'units')
					      unless $Tk::strictMotif; });
    if ($modifier eq "") {
      $w->CanvasBind("<6>", sub { $_[0]->xview('scroll', -3, 'units')
				    unless $Tk::strictMotif; });
      $w->CanvasBind("<7>", sub { $_[0]->xview('scroll', 3, 'units')
				    unless $Tk::strictMotif; });
    }

#    }
}

sub canvasBindMouseWheelHoriz {
    my($w,$modifier)= @_;
    $modifier.="-" if ($modifier);
    $w->CanvasBind("<$modifier"."MouseWheel>",
              [ sub { $_[0]->xview('scroll',-($_[1]/120)*3,'units') }, Tk::Ev("D")]);
    if ($Tk::platform eq 'unix') {
        $w->CanvasBind("<$modifier"."4>", sub { $_[0]->xview('scroll', -3, 'units')
				      unless $Tk::strictMotif; });
        $w->CanvasBind("<$modifier"."5>", sub { $_[0]->xview('scroll', 3, 'units')
				      unless $Tk::strictMotif; });
    }
}

sub keyBind {
  local $_=shift;
  s/-/+/g;
  s/Control/CTRL/g;
  return uc($_);
}

sub createCanvasBindings {
  my ($grp,$canvas) = @_;

  ## Canvas bindings 
  $canvas->CanvasBind('<ButtonPress>',[\&focusCanvas,$grp]);
  $canvas->bind('text',
		'<Any-Enter>'
		=> [sub{
		      my ($c,$grp)=@_;
		      my $win=findCanvasWindow($grp,$c);
		      my $tv=$win->{treeView};
		      my ($t)=$tv->find_item('withtag','current');
		      my $node=$tv->get_obj_pinfo($t);
		      $tv->store_node_pinfo($node,"SaveColor",
					    $c->itemcget($t,'-fill'));
		      $c->itemconfigure($t,-fill=> $activeTextColor);
		    }, $grp]);

  $canvas->bind('text',
		'<Any-Leave>'
		=> [sub{
		      my ($c,$grp)=@_;
		      my $win=findCanvasWindow($grp,$c);
		      my $tv=$win->{treeView};
		      my ($t)=$tv->find_item('withtag','current');
		      my $node=$tv->get_obj_pinfo($t);
		      $c->itemconfigure('current',
					-fill=>
					$tv->get_node_pinfo($node,"SaveColor"));
		    }, $grp]);

  # Button-1
  $canvas->bind('point', '<1>'=> [sub {node_down(@_) },$grp,0]);
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('point', "<$_-Button-1>"=> [sub {node_click_modif(@_)},$grp,$_]);
  }
  $canvas->bind('point', '<ButtonRelease-1>'=> [sub {node_release(@_)},$grp,0]);
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('point', "<$_-ButtonRelease-1>"=> [sub {node_release_modif(@_)},$grp,$_]);
  }
  $canvas->bind('point', '<B1-Motion>'=> [sub {node_move(@_)},$grp]);
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('point', "<$_-B1-Motion>"=> [sub {node_motion_modif(@_)},$grp]);
  }

  # Button-3
  $canvas->bind('point','<3>'=> [sub {node_down(@_)},$grp,1]);
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('point', "<$_-Button-3>"=> [sub {node_click_modif(@_)},$grp,$_."-3"]);
  }
  $canvas->bind('point', '<ButtonRelease-3>'=> [sub {node_release(@_)},$grp,3]);
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('point', "<$_-ButtonRelease-3>"=> [sub {node_release_modif(@_)},$grp."-3"]);
  }
  $canvas->bind('point','<B3-Motion>'=> [sub {node_move(@_)},$grp,1]);
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('point', "<$_-B3-Motion>"=> [sub {node_motion_modif(@_)},$grp."-3"]);
  }

  # Button-2
  $canvas->CanvasBind('<2>'=> [sub {follow_mouse_press(@_)},$grp]);
  $canvas->CanvasBind('<B2-Motion>'=> [sub {follow_mouse(@_)},$grp]);

  # Button-2
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('point', "<$_-Button-2>"=> [sub {node_click_modif(@_)},$grp,$_."-2"]);
  }
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('point', "<$_-ButtonRelease-2>"=> [sub {node_release_modif(@_)},$grp."-2"]);
  }
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('point', "<$_-B2-Motion>"=> [sub {node_motion_modif(@_)},$grp."-2"]);
  }


  # Double-1
  $canvas->bind('point', '<Double-1>'=> [sub { editAttrs(@_); Tk->break; },$grp]);
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('point', "<$_-Double-1>"=> [sub {node_doubleclick_modif(@_)},$grp,$_]);
  }

  # Text 1
  $canvas->bind('text', '<1>'=> [sub {node_down(@_) },$grp,0]);
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('text', "<$_-Button-1>"=> [sub {text_click_modif(@_)},$grp,$_]);
  }

  # Text Dobule-1
  $canvas->bind('text', '<Double-1>'=> [sub { editAttr(@_); Tk->break; },$grp]);
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('text', "<$_-Double-1>"=> [sub {text_doubleclick_modif(@_)},$grp,$_]);
  }

  # TextBg
  $canvas->bind('textbg', '<1>'=> [sub {node_down(@_) },$grp,0]);
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('textbg', "<$_-Button-1>"=> [sub {text_click_modif(@_)},$grp,$_]);
  }
  $canvas->bind('textbg', '<Double-1>'=> [sub { editAttr(@_); Tk->break; },$grp]);
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('textbg', "<$_-Double-1>"=> [sub {text_doubleclick_modif(@_)},$grp,$_]);
  }

  # TextBg 3
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('textbg', "<$_-Button-3>"=> [sub {text_click_modif(@_)},$grp,$_."-3"]);
  }
  # TextBg Double-3
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('textbg', "<$_-Double-3>"=> [sub {text_doubleclick_modif(@_)},$grp,$_."-3"]);
  }
}

sub startMain {
  my $firstFile=shift;
  my $node;
  my $parent;
  my %group;
  if ($opt_W) {
    $group{top}=MainWindow->new(-use => $opt_W);
  } else {
    $group{top}=MainWindow->new();
  }
  for (qw(ROText Text Entry Listbox HList CodeText)) {
    $group{top}->option('add',"\*$_.background","white");
    $group{top}->option('add',"\*$_.foreground","black");
    $group{top}->option('add',"\*$_.disabledBackground","lightgray");
    $group{top}->option('add',"\*$_.disabledForeground","gray20");
  }
  if ($TrEd::Convert::support_unicode) {
    $group{top}->useinputmethods(1);
  }
  readStyleSheets(\%group);

  $group{autoSaveCallback}=$group{top}->repeat($autoSave*60000,
					       [\&autoSaveAll,\%group]) if $autoSave>0;

  $group{folderImage}= $group{top}->Pixmap(-file=> Tk->findINC('folder.xpm'));
  $group{fileImage}  = $group{top}->Pixmap(-file=> Tk->findINC('file.xpm'));
  $group{lastActionBookmark}= $lastAction;
  $group{selectedContext}=$opt_t || 'TredMacro';
  $group{buildTGTSfromCSTS}=$opt_R;

  if (not $opt_G and defined($geometry)) {
    if ($geometry=~/^(.*)x(.*)\+([0-9]+)\+([0-9]+)/) {
        $geometry
	 = "$1x$2+".min($3,$group{top}->vrootwidth-$1).
	    "+".min($4,$group{top}->vrootheight-$2);
    }
    $group{top}->geometry($geometry);
  }
  if ($opt_W) {

    $geometry = "600x400";
    $group{top}->sizefrom('program');
    $group{top}->geometry($geometry);
  }
  prepareFonts(\%group);
  $group{treeWindows}=[];
  $group{focusedWindow}=newTrEdWindow(\%group);
  my $canvas = $group{focusedWindow}->canvas();
  $canvas->configure(@focused_win_opts);

  print "Starting in context $group{focusedWindow}->{macroContext}\n" if $tredDebug;

  $group{templateMatchMethod}=$defaultTemplateMatchMethod;
  $group{macroListOrder}=$defaultMacroListOrder;
  print STDERR "Main window created.\n" if $tredDebug;

  if (-f $appIcon) {
    print STDERR "adding icon-image.\n" if $tredDebug;
    $group{top}->iconimage($group{top}->Pixmap(-file=> "$appIcon"));
    print STDERR "done.\n" if $tredDebug;
  }

#  $group{top}->focusFollowsMouse;
  addBindTags($group{top},'my');

  print STDERR "Asking wm for exit-hook.\n" if $tredDebug;

  $group{top}->
    protocol('WM_DELETE_WINDOW'=> 
	     [sub { my $grp=shift;
		    doEvalHook($grp->{focusedWindow},"exit_hook");
		    # run user's exit_hook
		    askSaveFiles($grp);
		    closeFile($grp->{focusedWindow}, -all_windows => 1);
		    $grp->{top}->destroy;
		    $grp->{top}=undef;
		  },\%group]);


  print STDERR "Exit hook created.\n" if $tredDebug;

  $group{Balloon}=$group{top}->Balloon(-initwait=> $toolbarBalloonInitWait,
				       -balloonposition=> 'mouse',
				       -state=> 'balloon',
				      );
  $group{Balloon}->Subwidget('message')->configure(-foreground=> $toolbarBalloonForeground);
  $group{Balloon}->Tk::Toplevel::configure(-background=> $toolbarBalloonBackground);
  $group{frame}=$group{top}->Frame;


  print STDERR "Creating menubar.\n" if $tredDebug;


  $group{Menubar}=$group{top}->Frame(-relief=> $menubarRelief, -borderwidth=> 2);
  $group{Menubar}->pack(qw/-fill x/);
  $group{top}->Frame(qw/-relief sunken -height 2 -borderwidth 2/)->pack(qw/-fill x/);
  addBindTags($group{Menubar},'my');

  $group{FileMenu}= $group{Menubar}->Menubutton(qw/-text File -underline 0/);
  $group{FileMenu}->command(-label=> 'Open ...',
			    -underline=> 0,
			    -command=> [\&fileDialog, \%group]);
  $group{FileMenu}->command(-label=> 'Open URL ...',
			    -underline=> 5,
			    -command=> [\&urlDialog, \%group]);
  $group{FileMenu}->cascade(-label=> 'New',
			    -underline=>2,
			    -menuitems=>
			    [
			     [Button => 'From Template ...',
			      -underline=> 5,
			      -command=> [ \&fileDialog, \%group,1]
			     ],
			     [Button => 'From Current ...',
			      -underline=> 5,
			      -command=> [\&newFileFromCurrent, \%group, 1]
			     ]
			    ]
			   );
  $group{FileMenu}->command(-label=> 'Close',
			    -underline=> 0,
			    -command=> [ sub {
					    my ($grp)=@_;
					    my $lr = $grp->{focusedWindow}->{currentFilelist}->list_ref;
					    removeFromFilelist($grp,
							       undef,
							       undef,
							       $lr->[$grp->{focusedWindow}->{currentFileNo}]) if $lr;
					    askSaveFile($grp->{focusedWindow},0);
					    closeFile($grp->{focusedWindow},-all_windows => 1);
					  }
					 , \%group]);
  $group{FileMenu}->command(-label=> 'Close in Window',
			    -underline=> 0,
			    -command=> [ sub {
					    my ($grp)=@_;
					    my $keep=askSaveFile($grp->{focusedWindow},1)
					      if (fsfileDisplayingWindows($grp,
									  $grp->{focusedWindow}->{FSFile})<2);
					    closeFile($grp->{focusedWindow}, -keep_postponed => $keep);
					  }
					 , \%group]);
  $group{FileMenu}->command(-label=> 'File List...',
			    -underline=> 5,
			    -command=> [\&filelistDialog, \%group]);
#	 [Button=> 'New',         -command=> [\&menus_error2, 'New']],
  $group{FileMenu}->command(-label=> 'Save',
			    -underline=> 0,
			    -command=> [ sub { saveFile($_[0]->{focusedWindow}); },\%group]);
  $group{FileMenu}->command(-label=> 'Save As ...', 
			    -underline=> 5 ,
			    -command=> [ sub { saveFileAs($_[0]->{focusedWindow}); }, \%group]);
  $group{FileMenu}->separator();
  $group{RecentFileMenu}=$group{FileMenu}->cascade(-label=> "Recent Files",
						   -underline=> 0);
  my $i=0;
  foreach (@recentFiles) {
    $group{RecentFileMenu}->command(-label => "$i.  $_",
				    -underline=> 0,
				    -command=> [\&openFile,\%group,$_]);
    $i++;
  }
#  $group{PostponedFileMenu}=$group{FileMenu}->cascade(-label=> "Postponed Files", -underline=> 0);

  $group{FileMenu}->separator();
  $group{FileMenu}->command(-label=> 'Previous File',
			    -underline=> 3,
			    -command=> [\&tiePrevFile,\%group]);
  $group{FileMenu}->command(-label=> 'Next File',
			    -underline=> 0,
			    -command=> [\&tieNextFile,\%group]);
  $group{FileMenu}->separator();
  $group{FileMenu}->command(-label=> 'Print ...',
			    -underline=> 0,
			    -command=> [\&printThis,\%group]);
  $group{FileMenu}->separator();
  $group{FileMenu}->command(-label=>'Edit config file ...',
			    -underline=> 0,
			    -command=> [\&editConfig,\%group]);
  $group{FileMenu}->command(-label=>'Reload config ...',
			    -underline=> 3,
			    -command=> [sub {
					  read_config();
					  reconfigure($_[0]);
					  redraw_all($_[0]);
					},\%group]);
  $group{FileMenu}->separator();
  $group{FileMenu}->command(-label=>'Quit',
			    -underline=> 0,
			    -command=> [sub {
					  my $grp=shift;
					  askSaveFiles($grp);
					  $grp->{top}->destroy;
					},\%group]);
	
  $group{FileMenu}->pack(qw/-side left/);

  $group{ViewMenu}= $group{Menubar}->Menubutton(qw/-text View -underline 0 -menuitems/=>
	[
	 [Button=> 'Previous Tree',
	  -underline=> 0,
	  -command=> [sub {
			tiePrevTree($_[0]);
		      },\%group]],
	 [Button=> 'Next Tree',
	  -underline=> 0,
	  -command=> [sub {
			tieNextTree($_[0]);
		      },\%group]],
	 [Separator=> ''],
	 [Checkbutton=> 'Draw boxes around labels', -underline=> 0,
	  -variable=> \$treeViewOpts->{drawBoxes},
	  -command => [sub {
			 my ($grp)=@_;
			 # vice versa setting should be done when focus changes
			 $grp->{focusedWindow}->{treeView}->set_drawBoxes($treeViewOpts->{drawBoxes});
			 redraw_win($grp->{focusedWindow});
		       },\%group]],
	 [Checkbutton=> 'Draw boxes around edge labels', -underline=> 1,
	  -variable=> \$treeViewOpts->{drawEdgeBoxes},
	  -command => [sub {
			 my ($grp)=@_;
			 # vice versa setting should be done when focus changes
			 $grp->{focusedWindow}->{treeView}->set_drawEdgeBoxes($treeViewOpts->{drawEdgeBoxes});
			 redraw_win($grp->{focusedWindow});
		       },\%group]],
	 [Checkbutton=> 'Show Hidden Nodes', -underline=> 0,
	  -underline=> 5,
	  -variable=> \$treeViewOpts->{showHidden},
	  -command => [sub {
			 my $win=$_[0]->{focusedWindow};
			 $win->{treeView}->set_showHidden($treeViewOpts->{showHidden});
			 get_nodes_win($win);
			 currentUnhiden($win);
			 redraw_win($win) },\%group]],
	 [Checkbutton=> 'Highlight Attributes', -underline=> 1,
	  -variable=> \$treeViewOpts->{highlightAttributes},
	  -command => [sub {
			   my ($grp)=@_;
			   $grp->{focusedWindow}->{treeView}->set_highlightAttributes($treeViewOpts->{highlightAttributes});
			   redraw_win($grp->{focusedWindow});
			 },\%group]],
	 [Checkbutton=> 'Sort Attributes in Dialogs', -underline=> 1,
	  -variable=> \$sortAttrs],
	 [Separator=> ''],
	 [Button=> "[1] Close current view", -underline=> 1,
	  -command=> [\&removeWindow,\%group]],
	 [Button=> "[2] Split view horizontally", -underline=> 1,
	  -command=> [\&splitWindow,\%group,'horiz']],
	 [Button=> "[3] Split view vertically", -underline=> 1,
	  -command=> [\&splitWindow,\%group,'vert']],
	 [Separator=> ''],
	 [Button=> 'List of sentences ...', -underline=> 1,
	  -command=> [\&viewSentences,\%group]],
	 [Button=> 'Select context ...', -underline=> 12,
	  -command=> [\&selectContext,\%group]],
	 [Separator=> ''],
	 [Button=> 'Customize Attributes ...', -underline=> 0,
	  -command=> [\&customAttrsDialog,\%group]],
	 [Separator=> ''],
	 [Button=> 'List of Named Macros ...', -underline=> 0,
	  -command=> [\&macrolistDialog,\%group]]
	])->pack(qw/-side left/);
  $group{NodeMenu}= $group{Menubar}->Menubutton(qw/-text Node -underline 0 -menuitems/=>
	[
	 [Button=> 'New Node', -underline=> 0, -command=> [sub {
					       my ($grp)=@_;
					       my $win=$grp->{focusedWindow};
					       save_undo($win,prepare_undo($win));
					       newNode($win);
					     },\%group]],
	 [Button=> 'Remove Active Node', -underline=> 0, -command=> [sub {
					       my ($grp)=@_;
					       my $win=$grp->{focusedWindow};
					       save_undo($win,prepare_undo($win));
					       pruneNode($win,$win->{currentNode});
					     },\%group]],
	 [Button=> 'Insert New Tree', -underline=> 0, -command=> [sub {
						      my ($grp)=@_;
						      newTree($grp->{focusedWindow});
						    },\%group]],
	 [Button=> 'Insert New Tree After', -underline=> 16, -command=> [sub {
						      my ($grp)=@_;
						      newTreeAfter($grp->{focusedWindow});
						    },\%group]],
	 [Button=> 'Remove Whole Current Tree', -underline=> 7, -command=> [sub {
						      my ($grp)=@_;
						      pruneTree($grp->{focusedWindow});
						    },\%group]],
	 [Separator=> ''],
	 [Button=> 'Copy Trees ...', -underline=> 1,
	  -command=> [\&copyTreesDialog,\%group]],
	 [Separator=> ''],
	 [Button=> 'Edit Attributes ...',
	  -underline=> 0,
	  -command=> [sub {
			my ($grp)=@_;
			editAttrsDialog($grp->{focusedWindow},
					$grp->{focusedWindow}->{currentNode})
			  if ($grp->{focusedWindow}->{currentNode});
		      },\%group]],
	 [Separator=> ''],
	 [Button=> 'Find ...',
	  -underline=> 0,
	  -command=> [sub {
			my ($grp,$template)=@_;
			findNodeDialog($grp,$template)
			  if ($grp->{focusedWindow}->{currentNode});
		      },\%group,\%searchTemplate]],
	 [Button=> 'Find Next', -underline=> 7,
	  -command=> [\&doFindFirstTemplated,\%group,\%searchTemplate,1]],
	 [Button=> 'Find Previous', -underline=> 5,
	  -command=> [\&doFindPrevTemplated,\%group,\%searchTemplate,1]]

	])->pack(qw/-side left/);
  print STDERR "Creating user menu.\n" if $tredDebug;


  $group{PostponedFileMenu}= $group{Menubar}->Menubutton(qw/-text Session -underline 0/)
    ->pack(qw/-side left/);
  updatePostponed(\%group);

  $group{BookmarksFileMenu}= $group{Menubar}->Menubutton(qw/-text Bookmarks -underline 0/)
    ->pack(qw/-side left/);
  updateBookmarks(\%group);

  $group{ContextsMenu}=$group{Menubar}->
    Optionmenu(-options => [sort(keys(%keyBindings))],
	       -textvariable=> \$group{selectedContext},
	       -command=> [sub { my ($grp,$context) = @_;
				 switchContext($grp->{focusedWindow}, $context);
			       },\%group],
	       -relief=> 'groove', #$menubarRelief,
	       -borderwidth=> 2)->pack(qw/-side right -padx 5/);

  my $cM=[];
  if ($createMacroMenu) {
    push @$cM, 
      @{cascadeMenus(map { $keyBindings{TredMacro}->{$_}=~/TredMacro\-\>(.*)/;
			   [Button=> $1,
			    -command=> [ sub {
					   doEvalMacro($_[0]->{focusedWindow},
						       $_[1]);
					 },\%group,
					 $keyBindings{TredMacro}->{$_}],
			    -accelerator=> "($_)"
			   ]
			 } sort(keys(%{$keyBindings{TredMacro}})))};

    foreach my $context (sort(keys(%keyBindings))) {
      if ($context ne "TredMacro") {
	push @$cM, 
	  [Cascade=> $context,
	   -menuitems=>
	   cascadeMenus(map { $keyBindings{$context}->{$_}=~/(?:$context\-\>)?(.*)/;
			      [Button=> $1,
			       -command=> [sub {
					   doEvalMacro($_[0]->{focusedWindow},
						       $_[1]);
					 },\%group,
					   $keyBindings{$context}->{$_}],
			       -accelerator=> "($_)"
			      ]
			    } sort(keys(%{$keyBindings{$context}})))];
      }
    }

    $group{MacroMenu}=$group{Menubar}->
      Menubutton(qw/-text Shortcuts -underline 2 -menuitems/=>
		 $cM)->pack(qw/-side left/);
  }
  $cM=[];
  push @$cM,
    @{cascadeMenus(map ([Button=> $_,
			 -command=> [sub {
				       doEvalMacro($_[0]->{focusedWindow},
						   $_[1]);
				     },
				     \%group,$menuBindings{TredMacro}->{$_}->[0]],
			 ($menuBindings{TredMacro}->{$_}->[1]) ?
			 (-accelerator=> "(".$menuBindings{TredMacro}->{$_}->[1].")") : ()],
			sort(keys(%{$menuBindings{TredMacro}}))))};

  foreach my $context (sort(keys(%menuBindings))) {
   if ($context eq "TredMacro") { 
   } else {
        push @$cM,
  	[Cascade=> $context,
  	 -menuitems=>
  	 cascadeMenus(map ([Button=> $_,
  			    -command=> [sub {
					  doEvalMacro($_[0]->{focusedWindow},
						      $_[1]);
					 },
					\%group,
					$menuBindings{$context}->{$_}->[0]],
  			    ($menuBindings{$context}->{$_}->[1]) ?
  			    (-accelerator=> "(".$menuBindings{$context}->{$_}->[1].")") : ()],
  			   sort(keys(%{$menuBindings{$context}}))))];
      }
  }
  $group{UserMenu}=$group{Menubar}->
    Menubutton(qw/-text User-defined -underline 0 -menuitems/=>
	       $cM)->pack(qw/-side left/);




  addBindTags($group{frame},'my');

  $group{HelpMenu}= $group{Menubar}->Menubutton(qw/-text Help -underline 0 -menuitems/=>
	[
	 [
	  Button=> 'About',
	  -underline=> 0,
	  -command=> [\&About,\%group]
	 ],
	 [
	  Cascade=> 'Debugging messages',
	  -underline => 0,
	  -menuitems => [
			 [Checkbutton => 'tred', -underline => 0,
			  -variable => \$tredDebug],
			 [Checkbutton => 'macros', -underline => 0,
			  -variable => \$macroDebug],
			 [Checkbutton => 'hooks', -underline => 0,
			  -variable => \$hookDebug],
			 [Checkbutton => 'keyboard', -underline => 0,
			  -variable => \$keyboardDebug],
			 [Checkbutton => 'backend', -underline => 0,
			  -variable => \$Fslib::Debug],
			 [Button => 'Reload macros', -underline => 0,
			  -command => sub { read_macros($macroFile,$libDir) }]
			]
	 ]
	])->pack(qw/-side left/);

  require Tk::Adjuster;
  $group{vLineFrame}=$group{top}->Frame();
  $group{valueLine}=
    $group{vLineFrame}->
      Scrolled(qw/ROText
		  -takefocus 0
		  -state disabled
                  -relief sunken -borderwidth 2
		  -scrollbars ose/,
		  -font => $vLineFont,
		  -height => $valueLineHeight,
	          ($valueLineReverseLines ? () : (-wrap => $valueLineWrap))
	      );
  if ($displayStatusLine) {
#c		  -background white
    $group{statusLine}=
      $group{top}->
	ROText(qw(-takefocus 0
		  -state disabled
		  -borderwidth 2
		  -height 1
		 ),
	       -relief => 'sunken',
	       -font => $vLineFont);

    $group{statusLine}->bind('<1>',
			    [sub {
				my ($w,$grp)=@_;
				my $Ev=$w->XEvent;
				my $win=$grp->{focusedWindow};
				doEvalHook($win,"status_line_click_hook",
					   $w->tagNames($w->index($Ev->xy)));
				Tk->break;
			      },\%group]
			   );
    $group{statusLine}->bind('<Double-1>',
			    [sub {
				my ($w,$grp)=@_;
				my $Ev=$w->XEvent;
				my $win=$grp->{focusedWindow};
				doEvalHook($win,"status_line_doubleclick_hook",
					   $w->tagNames($w->index($Ev->xy)));
				Tk->break;
			      },\%group]
			   );

  }
  $group{valueLine}->tagConfigure('current',
				  -background => $valueLineFocusBackground,
				  -foreground => $valueLineFocusForeground,
				 );
  $group{valueLine}->bind('<Double-1>',
			     [sub {
				my ($w,$grp)=@_;
				my $Ev=$w->XEvent;
				my $win=$grp->{focusedWindow};
				my (@tags)=
				  $w->tagNames($w->index($Ev->xy));
				if (doEvalHook($win,
					       "value_line_doubleclick_hook",
					       @tags) ne 'stop') {
				  my $node=$win->{root};
				  while ($node) {
				    if (index(join("",@tags),${node})>=0) {
				      setCurrent($win,$node);
				      centerTo($win,$node);
				      Tk->break;
				      return;
				    }
				    $node=$node->following();
				  }
				}
				Tk->break;
			      },\%group]
			     );

  $group{vLineSeparator}=$group{top}->Adjuster();
  eval { # supported only on some platforms/version of Tk
    $group{valueLine}->configure(-foreground => $valueLineForeground,
                                 -background => $valueLineBackground);
  };
  $group{valueLine}->BindMouseWheelHoriz();


  print STDERR "Creating buttons.\n" if $tredDebug;

  $group{nextButton}=
    $group{frame}->Button(-takefocus=>0,
			  -text=> "Next",
			  -relief=> $buttonsRelief,
			  -image=> $group{top}->Pixmap(-file=>"$libDir/right.xpm"),
			  -state=> 'disabled',
			  -borderwidth=> $buttonBorderWidth,
			  -command=>
			  [\&tieNextTree,\%group]);
  $group{Balloon}->attach($group{nextButton},
			  -balloonmsg=> "see the next tree");
  addBindTags($group{nextButton},'my');

  $group{prevButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Prev",
			  -relief=> $buttonsRelief,
			  -image=> $group{top}->Pixmap(-file=>"$libDir/left.xpm"),
			  -state=> 'disabled',
			  -borderwidth=> $buttonBorderWidth,
			  -command=>
			  [\&tiePrevTree,\%group]);
  $group{Balloon}->attach($group{prevButton},
			  -balloonmsg=> "see the previous tree");
  addBindTags($group{prevButton},'my');

  $group{openButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Open",
			  -relief=> $buttonsRelief,
			  -image=>
			  $group{top}->Pixmap(-file=>
					      "$libDir/fileopen.xpm"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=>
			  [\&fileDialog,\%group])
      ->pack(-side=>'left',-padx=>'1');
  $group{Balloon}->attach($group{openButton},
		 -balloonmsg=> "open file");
  addBindTags($group{openButton},'my');
  $normalSavePixmap=$group{top}->Pixmap(-file=>"$libDir/filefloppy.xpm");
  $savedSavePixmap=$group{top}->Pixmap(-file=>"$libDir/filesaved.xpm");
  $group{saveButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Save",
			  -relief=> $buttonsRelief,
			  -image=> $savedSavePixmap,
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&saveFile,\%group])->pack(-side=>'left',-padx=>'1');

  $group{Balloon}->attach($group{saveButton},
			  -balloonmsg=> "save current file");
  addBindTags($group{saveButton},'my');

  $group{reloadButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Reload",
			  -relief=> $buttonsRelief,
			  -image=> $group{top}->Pixmap(-file=>
						       "$libDir/reload.xpm"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&reloadFile,\%group])->pack(-side=>'left',-padx=>'1');

  $group{Balloon}->attach($group{reloadButton},
			  -balloonmsg=> "reload current file");
  addBindTags($group{reloadButton},'my');

  # Undo button

  $group{undoButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Undo",
			  -relief=> $buttonsRelief,
			  -image=> $group{top}->Pixmap(-file=>"$libDir/undo.xpm"),
			  -state=> 'disabled',
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&undo,\%group])->pack(-side=>'left',-padx=>'1');
  $group{Balloon}->attach($group{undoButton},
			  -balloonmsg=> "undo current file");
  addBindTags($group{undoButton},'my');

  # Redo button

  $group{redoButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Redo",
			  -relief=> $buttonsRelief,
			  -image=> $group{top}->Pixmap(-file=>"$libDir/redo.xpm"),
			  -state=> 'disabled',
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&re_do,\%group])->pack(-side=>'left',-padx=>'1');
    
  $group{Balloon}->attach($group{redoButton},
			  -balloonmsg=> "redo current file");
  addBindTags($group{redoButton},'my');



  $group{prevFileButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Prev file",
			  -relief=> $buttonsRelief,
			  -image=> $group{top}->Pixmap(-file=>
						       "$libDir/start.xpm"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&tiePrevFile,\%group])->pack(-side=>'left',
									    -padx=>'1');
  $group{Balloon}->attach($group{prevFileButton},
			  -balloonmsg=> "visit the previous open file");
  addBindTags($group{prevFileButton},'my');

  $group{nextFileButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Next file",
			  -relief=> $buttonsRelief,
			  -image=> $group{top}->Pixmap(-file=>
						       "$libDir/finish.xpm"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&tieNextFile,\%group])->pack(-side=>'left',
									    -padx=>'1');
  $group{Balloon}->attach($group{nextFileButton},
			  -balloonmsg=> "visit the next open file");
  addBindTags($group{nextFileButton},'my');


  $group{printButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Print",
			  -relief=> $buttonsRelief,
			  -image      => $group{top}->Pixmap(-file=>
							     "$libDir/fileprint.xpm"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [sub { printThis(@_) },\%group])->pack(-side=>'left',
									    -padx=>'1');
  $group{Balloon}->attach($group{printButton},
			  -balloonmsg=> "print ...");
  addBindTags($group{printButton},'my');

  $group{findButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Find",
			  -relief=> $buttonsRelief,
			  -image      => $group{top}->Pixmap(-file=>
							     "$libDir/find.xpm"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [sub {
					my ($grp,$template)=@_;
					findNodeDialog($grp,$template)
					  if ($grp->{focusedWindow}->{currentNode});
				      },\%group,\%searchTemplate])->pack(-side=>'left',
									 -padx=>'1');
  $group{Balloon}->attach($group{findButton},
			  -balloonmsg=> "Find node ...");
  addBindTags($group{findButton},'my');

  $group{findNextButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Find Next",
			  -relief=> $buttonsRelief,
			  -image      => $group{top}->Pixmap(-file=>
							     "$libDir/findnext.xpm"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&doFindFirstTemplated,\%group,\%searchTemplate,1])
      ->pack(-side=>'left', -padx=>'1');
  $group{Balloon}->attach($group{findNextButton},
			  -balloonmsg=> "Find next ...");
  addBindTags($group{findNextButton},'my');


  $group{findPrevButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Find Previous",
			  -relief=> $buttonsRelief,
			  -image=> $group{top}->Pixmap(-file=>
						       "$libDir/findprev.xpm"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&doFindPrevTemplated,\%group,\%searchTemplate,1])
      ->pack(-side=>'left', -padx=>'1');
  $group{Balloon}->attach($group{findPrevButton},
			  -balloonmsg=> "Find previous ...");
  addBindTags($group{findPrevButton},'my');


  $group{frame}->Frame()->pack(-side=> 'left', -padx=>'10');
  $group{prevButton}->pack(-side=> 'left', -padx=>'1');
  $group{nextButton}->pack(-side=> 'left', -padx=> '1');

  $group{attrButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Attributes",
			  -relief=> $buttonsRelief,
			  -image=> $group{top}->Pixmap(-file=>
						       "$libDir/tick.xpm"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [sub { customAttrsDialog(@_) },\%group])->pack(-side=>'right',
										    -padx=>'1');
  $group{Balloon}->attach($group{attrButton},
			  -balloonmsg=> "select visible attributes");

  $group{StylesheetMenu}=$group{frame}->
    Optionmenu(-options => getStylesheetMenuList(\%group),
	       -textvariable=> \$group{selectedStylesheet},
	       -command=> [sub { my ($grp,$stylesheet) = @_;
				 switchStylesheet($grp, $stylesheet);
			       },\%group],
	       -relief=> 'groove', #$menubarRelief,
	       -borderwidth=> 2)->pack(qw/-side right -padx 3/);

  $group{tieWinddowsButton}=
    $group{frame}->Checkbutton(-takefocus=>0,
			      -text=> "Tie Displayed Windows",
			      -variable=> \$group{tieWindows},
			       -relief=> $buttonsRelief,
			      -indicatoron => 0,
			      -image=>$group{top}->Pixmap(-file=>
							  "$libDir/tiewins.xpm"),
			      -borderwidth=> $buttonBorderWidth)->pack(-side=>'right',
								       -padx=>'1');
  $group{Balloon}->attach($group{tieWinddowsButton},
			  -balloonmsg=> "tie all views");


  $group{rmsplitButton}=
    $group{frame}->Button(-takefocus=>0, 
			  -text=> "Remove Current View",
			  -relief=> $buttonsRelief,
			  -image=> $group{top}->Pixmap(-file=>
						       "$libDir/rmsplit.xpm"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&removeWindow,\%group])->pack(-side=>'right',
								     -padx=>'1');
  $group{Balloon}->attach($group{rmsplitButton},
			  -balloonmsg=> "remove current view");

  $group{hsplitButton}=
    $group{frame}->Button(-takefocus=>0, 
			  -text=> "Split View Horizontally",
			  -relief=> $buttonsRelief,
			  -image=> $group{top}->Pixmap(-file=>
						       "$libDir/hsplit.xpm"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&splitWindow,\%group,'horiz'])->pack(-side=>'right',
									    -padx=>'1');


  $group{Balloon}->attach($group{hsplitButton},
			  -balloonmsg=> "split view horizontally");
  $group{vsplitButton}=
    $group{frame}->Button(-takefocus=>0, 
			  -text=> "Split View Vertically",
			  -relief=> $buttonsRelief,
			  -image=> $group{top}->Pixmap(-file=>
						       "$libDir/vsplit.xpm"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&splitWindow,\%group,'vert'])->pack(-side=>'right',
									   -padx=>'1');
  $group{Balloon}->attach($group{vsplitButton},
			  -balloonmsg=> "split view vertically");


  print STDERR "Packing widgets.\n" if $tredDebug;

  $group{frame}->pack(-fill=> 'x', -padx=> '1', -pady=> 1);
  my $vlsubframe=$group{vLineFrame}->Frame();
  $group{vLineNumLabel}=$vlsubframe->Label(-text => '-/-')->pack(qw/-side top -fill x/);
  $group{sentButton}=
    $vlsubframe->Button(-takefocus=>0, -text=> "Sentences",
			-relief=> $buttonsRelief,
			-image=> $group{top}->Pixmap(-file=>
						     "$libDir/view_sent.xpm"),
			-borderwidth=> $buttonBorderWidth,
			-command=> [\&viewSentences,\%group])
      ->pack(qw/-side top -fill x/);
  $vlsubframe->pack(qw/-fill x -side right -padx 1 -anchor n/);
  $group{valueLine}->pack(qw/-side left -fill both -expand yes/);
  $group{vLineFrame}->pack(qw/-fill x -expand no/);


  $group{vLineSeparator}->packAfter($group{vLineFrame},-side => 'top');

  $group{statusLine}->pack(qw/-pady 2 -side bottom -fill x -expand no/) if $group{statusLine};

  # frame canvas here
  $group{focusedWindow}->frame_widget($canvas,[],
				      [qw/-side left/])->pack(qw/-expand yes -fill both/);
#  $group{sLineFrame}->pack(qw/-fill x -expand yes/);

  print STDERR "Binding keystrokes...\n" if $tredDebug;
  $group{Menubar}->bind('Menubutton','<Escape>', [sub { shift->Leave(); }] );

  foreach my $prefix ('Alt','Meta') {
    $group{frame}->
      bind('my',"<$prefix-KeyPress>"=>
	   [sub {
	      if (defined(evalMacro(@_))) {
		Tk->break;
	      } else {
		# Actually, this should work by it self. And it realy
		# does, but not under windows :-) Well, do not laugh,
		# too early, Linux users. With menu (not menubutton)
		# this is the same there, only vice versa.
		my ($w,$grp,$mod)=@_;
		my $mbar=$grp->{Menubar};
		foreach my $child ($mbar->children) {
		  if ($child->class eq 'Menubutton' and $child->FindMenu($w->XEvent->K)) {
		    $child->ButtonUp() if ($^O eq "MSWin32"); 
		    # This ButtonUp is needed for some reason under
		    # Windows, otherwise the button remains active even
		    # when you leave the window! Window$ suck anyway!
		    last;
		  }
		}
		Tk->break;
	      }
	    }, \%group,uc($prefix).'+']);
  }

  #  $group{frame}->bind('my','<Control-x><KeyPress>'=>
  #			[sub { evalMacro(@_); Tk->break; }, \%group, 'CTRL-X+' ]);

  $group{frame}->bind('my','<KeyPress>'=>
			[sub {
			   evalMacro(@_); Tk->break;
			 }, \%group, '' ]);

  foreach (qw(Shift Control Meta Alt Control-Shift Control-Alt
              Control-Meta Alt-Shift Meta-Shift)) {
    foreach my $event (qw(KeyPress Right Left Up Down
                          Return comma period Next Prior greater less)) {
      $group{frame}->bind('my',"<$_-$event>"=>
			    [sub { evalMacro(@_); Tk->break; },
			     \%group, keyBind($_)."+"])
	unless ("$_-$event" eq "Alt-KeyPress" or "$_-$event" eq "Meta-KeyPress")
    }
  }

  $group{top}->bind('all','<Tab>',undef);

  # New Busy window bindings
  $group{frame}->Tk::bind('Busy','<Escape>',[\&_search_busy, \%group]);
  $group{top}->Tk::bind('Busy','<Escape>',[\&_search_busy, \%group]);
  $group{top}->Tk::bind('Busy','<Any-KeyPress>',[\&Tk::Widget::_busy => 1]);
  $group{top}->Tk::bind('Busy','<Any-KeyRelease>',[\&Tk::Widget::_busy => 0]);
  $group{top}->Tk::bind('Busy','<Any-ButtonPress>',[\&Tk::Widget::_busy => 1]);
  $group{top}->Tk::bind('Busy','<Any-ButtonRelease>',[\&Tk::Widget::_busy => 0]);
  $group{top}->Tk::bind('Busy','<Any-Motion>',[\&Tk::Widget::_busy => 0]);
  $group{top}->bind('Tk::Listbox','<KeyPress>',\&list_isearch);

  $group{top}->bind('my', '<Tab>'=>
		    [sub { currentNext($_[1]->{focusedWindow});
			   Tk->break; },\%group]);
  $group{frame}->bind('my',
		      '<Shift-ISO_Left_Tab>'=>
		      [sub { currentPrev($_[1]->{focusedWindow});
			     Tk->break; },\%group]);
  $group{frame}->bind('my',
		      '<Shift-Tab>'=>
		      [sub { currentPrev($_[1]->{focusedWindow});
			     Tk->break; },\%group]);

  $group{frame}->bind('my',
		      '<period>'=> 
		      [sub { onIdleNextTree($_[1]->{focusedWindow}); },
		       \%group]);
  $group{frame}->bind('my','<comma>'=> 
		      [sub { onIdlePrevTree($_[1]->{focusedWindow}); },
		       \%group]);
  $group{frame}->bind('my','<Next>'=> 
		      [sub { onIdleNextTree($_[1]->{focusedWindow}); },
		       \%group]);
  $group{frame}->bind('my','<Prior>'=> 
		      [sub { onIdlePrevTree($_[1]->{focusedWindow}); }
		       ,\%group]);
  $group{frame}->bind('my','<greater>'=>
		      [sub { my $fw=$_[1]->{focusedWindow};
			     gotoTree($fw,
				      $fw->{FSFile}->lastTreeNo);
			     Tk->break;
			   },\%group]);
  $group{frame}->bind('my','<less>'=> 
		      [sub { gotoTree($_[1]->{focusedWindow},0);
			     Tk->break;
			   },\%group]);

  $group{frame}->bind('my',
		      '<KeyPress-Return>'=>
		      [sub { editAttrsDialog($_[1]->{focusedWindow},
			     $_[1]->{focusedWindow}->{currentNode});
			 Tk->break;
		       },\%group]);
  $group{frame}->bind('my','<KeyPress-Left>'=>
		      [sub {
			 $treeViewOpts->{reverseNodeOrder} ?
			 currentRight($_[1]) :
			 currentLeft($_[1]);
			 Tk->break;
		       },\%group]);
  $group{frame}->bind('my','<Shift-Left>'=>
		      [sub {
			 $treeViewOpts->{reverseNodeOrder} ?
			 currentRightWholeLevel($_[1]) :
			 currentLeftWholeLevel($_[1]);
			 Tk->break;
		       },\%group]);
  $group{frame}->bind('my','<KeyPress-Right>'=>
		      [sub {
			 $treeViewOpts->{reverseNodeOrder} ?
			 currentLeft($_[1]) :
			 currentRight($_[1]);
			 Tk->break;
		       },\%group]);
  $group{frame}->bind('my','<Shift-Right>'=>
		      [sub {
			 $treeViewOpts->{reverseNodeOrder} ?
			 currentLeftWholeLevel($_[1]) :
			 currentRightWholeLevel($_[1]);
			 Tk->break;
		       },\%group]);
  $group{frame}->bind('my','<KeyPress-Up>'=>
		      [sub {
			 currentUp($_[1]);
			 Tk->break;
		       },\%group]);
  $group{frame}->bind('my','<KeyPress-Down>'=>
		      [sub {
			 currentDown($_[1]);
			 Tk->break;
		       },\%group]);

  $group{focusedWindow}->canvas->focus;

  $group{printToFile}=0;
  $group{printCommand}=$defaultPrintCommand;
  $group{printPsFile}=$psFile;

  print STDERR "Binding canvas destroy...\n" if $tredDebug;
  $group{top}->bind($group{frame},
		    '<Destroy>',
		      [ sub {
			  shift;
			  my $grp=shift;
			  $geometry=$group{top}->geometry();
			  print "geometry is $geometry\n" if $tredDebug;
			  if ($^O eq "MSWin32" and $group{top}->state() eq 'zoomed') {
			    $geometry=~s/\+[-0-9]+\+[-0-9]+/+-3+-3/;
			  }
			  print "state is ",$group{top}->state(),"\n"  if $tredDebug;
			},\%group ]);

  print STDERR "GUI prepared.\nOpenning first file ...." if $tredDebug;
  $group{top}->update;
  $group{top}->Busy(-recurse=> 1);
  if (doEvalHook($group{focusedWindow},"init_hook") eq 'stop') {
    $group{top}->Unbusy;
    print STDERR "Stopped by init_hook\n";
    exit;
  }
  my $stylesheet=$opt_s || STYLESHEET_FROM_FILE();
  $group{selectedStylesheet}=$stylesheet;
  applyWindowStylesheet($group{focusedWindow},$stylesheet);

  if ($opt_p) {
    my $dir=$opt_p>0 ? 'vert' : 'horiz';
    for (my $i=1;$i<$opt_p;$i++) {
      splitWindow(\%group,$dir);
    }
    focusCanvas($group{treeWindows}->[0]->canvas,\%group);
  }
  selectFilelist(\%group,'Default');
  if ($opt_p) {
    my $dir=$opt_p>0 ? 'vert' : 'horiz';
    my $fl=($opt_l=~/,/g)+1;
    if ($fl>1) {
      $fl=min($opt_p,$fl);
      my $i;
      for (my $i=1;$i<$fl;$i++) {
	focusCanvas($group{treeWindows}->[$i]->canvas,\%group);
	selectFilelist($group{treeWindows}->[$i],"Default-".($i+1));
	gotoFile($group{treeWindows}->[$i],0);
      }
    } else {
      for (my $i=1;$i<$opt_p;$i++) {
	focusCanvas($group{treeWindows}->[$i]->canvas,\%group);
	gotoFile($group{treeWindows}->[$i],$i);
      }
    }
    focusCanvas($group{treeWindows}->[0]->canvas,\%group);
  }

#  $group{noinsert} = ($group{focusedWindow}{currentFilelist}->count()>0);
#    $group{focusedWindow}{currentFilelist}=$filelists[0];
#    if ($group{focusedWindow}{currentFilelist}->file_at(0)) {
#      openFile(\%group,$group{focusedWindow}{currentFilelist}->file_at(0));
#    }

  print STDERR "done.\nStarting main loop.\n" if $tredDebug;
  # run start_hook
  if (doEvalHook($group{focusedWindow},"start_hook") eq 'stop') {
    $group{top}->Unbusy;
    print STDERR "Stopped by start_hook\n";
    exit;
  }

  # Starting ------------------------------------------
  $group{top}->Unbusy;

  MainLoop;


  # Finished ------------------------------------------

  # Save configuration
  print STDERR "Saving some configuration options.\n" if $tredDebug;
  my @conf;
  my $ommit="canvasheight|canvaswidth|recentfile[0-9]+|geometry|lastaction|filelist[0-9]+";
  if (open(F,"<$configFile")) {
    @conf= grep { !/^\s*(?:$ommit)\s*=/i } <F>;
    close(F);
  }
  #  $geometry=~s/^[0-9]+x[0-9]+//;
  if ($group{lastActionBookmark}) {
    $group{lastActionBookmark}=~s/\\/\\\\/g;
    push @conf,"LastAction\t=\t".$group{lastActionBookmark}."\n" if $group{lastActionBookmark};
  }
  do {
    my $s;
    push @conf,
      "Geometry\t=\t".$geometry."\n",
      "CanvasHeight\t=\t".$defCHeight."\n",
      "CanvasWidth\t=\t".$defCWidth."\n",
	map { 
	  $s=$recentFiles[$_];
	  $s=~s/\\/\\\\/g;
	  "RecentFile$_\t=\t$s\n"
	} 0..$#recentFiles;

    my $i=0;
    foreach (@filelists) {
      if (ref($_) and defined($_->filename) and $_->filename ne "") {
	$_->save;
	$s=$_->filename();
	$s=~s/\\/\\\\/g;
	push @conf,"filelist".$i++."\t=\t".$s."\n";
      }
    }
  };
  chomp $conf[$#conf];
  $group{top}=undef;
  saveConfig(\%group,@conf);
  print STDERR "Done.\n" if $tredDebug;
}

sub _do_goto_tree {
  my $win=shift;
  update_value_line($win->{framegroup});
  my $no=$win->{treeNo};
  $win->{treeNo}=-1;  # this is to force getNodes & redraw
  gotoTree($win,$no);
  $win->{framegroup}->{IdleTask}=undef;
}

sub onIdleNextTree {
  my ($grp,$win)=grp_win(shift);
  return unless $win->{FSFile};
  $win->toplevel->afterCancel($grp->{IdleTask}) if ($grp->{IdleTask});
  $win->{treeNo}=max(0,min($win->{treeNo}+1,$win->{FSFile}->lastTreeNo));
  update_tree_pos($grp);
  #  update_value_line($grp);
  #  $grp->{valueLine}->idletasks();
  $grp->{vLineNumLabel}->idletasks();
  $grp->{IdleTask}=$win->toplevel->afterIdle([\&_do_goto_tree,$win]);
  Tk->break;
}

sub onIdlePrevTree {
  my ($grp,$win)=grp_win(shift);
  return unless $win->{FSFile};
  if ($win->{treeNo}>0) {
    $win->toplevel->afterCancel($grp->{IdleTask}) if ($grp->{IdleTask});
    $win->{treeNo}--;
    update_tree_pos($grp);
    #    update_value_line($grp);
    #    $grp->{valueLine}->idletasks();
    $grp->{vLineNumLabel}->idletasks();
    $grp->{IdleTask}=$win->toplevel->afterIdle([\&_do_goto_tree,$win]);
  }
  Tk->break;
}

sub RepeatedShowDialog {
  my ($cw, $focus, $oldFocus)= @_;
  $oldFocus= $cw->focusCurrent unless $oldFocus;
  my $oldGrab= $cw->grabCurrent;
  my $grabStatus= $oldGrab->grabStatus if ($oldGrab);

  # instead of Popup
  $cw->deiconify;
  $cw->waitVisibility;

  Tk::catch {
    $cw->grab;
  };
  $focus->focusForce if ($focus);
  Tk::DialogBox::Wait($cw);
  eval {
    $oldFocus->focusForce;
  };
  $cw->withdraw;
  $cw->grabRelease;
  if ($oldGrab) {
    if ($grabStatus eq 'global') {
      $oldGrab->grabGlobal;
    } else {
      $oldGrab->grab;
    }
  }
  return $cw->{selected_button};
}

# This patches $dialog->Show which implicitly focuses the default button;
# here focus stays where it is.
# Usage: my $dlg=DialogBox(); ...; ShowDialog($dlg);
sub ShowDialog {
  my ($cw, $focus, $oldFocus)= @_;
  $oldFocus= $cw->focusCurrent unless $oldFocus;
  my $oldGrab= $cw->grabCurrent;
#  my $old_grab= $cw->grabSave;
#  my $old_focus= $cw->grabSave;
  my $grabStatus= $oldGrab->grabStatus if ($oldGrab);

#  $cw->grab;

  $cw->Popup();

  Tk::catch {
    $cw->grab;
  };
  $focus->focusForce if ($focus);
  Tk::DialogBox::Wait($cw);
  eval {
    $oldFocus->focusForce;
  };
  #&$old_grab;
  #&$old_focus;
  
  $cw->withdraw;
  $cw->grabRelease;
  if ($oldGrab) {
    if ($grabStatus eq 'global') {
      $oldGrab->grabGlobal;
    } else {
      $oldGrab->grab;
    }
  }

  return $cw->{selected_button};
}

sub fileDialog {
  my ($grp,$header_only)= @_;
  my $file;

#  use Tk::FileSelect;
#  my $FSref= $grp->{top}->FileSelect(-selectmode=> extended);
#  print $FSref->Show;

  $file= get_open_filename($grp->{top},-filetypes=> \@open_types);
  __debug "$file";
  if (defined $file and $file ne '') {
    return openFile($grp,$file,-justheader => $header_only);
  }
  return 0;
}

sub urlDialog {
  my ($grp,$header_only)= @_;
  if (not(defined $grp->{lastURL}) and
      defined($grp->{focusedWindow}->{FSFile})) {
    $grp->{lastURL} = $grp->{focusedWindow}->{FSFile}->filename();
  }
  my $file = QueryString($grp,"Enter URL", "URL: ",$grp->{lastURL});
  if (defined $file and $file ne '') {
    $grp->{lastURL} = $file;
    return openFile($grp,$file,-justheader => $header_only);
  }
  return 0;
}

sub saveFileAs {
  my ($win)= @_;
  my $initdir;
  return unless $win->{FSFile};
  my $file=$win->{FSFile}->filename;

  $initdir=dirname($file);
  $initdir=cwd if ($initdir eq './');
  $initdir=~s!${TrEd::Convert::Ds}$!!m;

  my $response=userQuery($win, "\nPlease,\nchoose one of the following output formats.\n\n".
			 "\nWARNING:\nsome formats may be incompatible with current file.\n",
			 -title => "Save As ...",
			 -buttons => ["FS","CSTS","TrXML","TEIXML","Storable","Cancel"]);
  return if ($response eq "Cancel");

  $win->{FSFile}->changeBackend($backend_map{lc($response)});
  if ($response eq 'FS') {
    $file=~s/\.(?:csts|sgml|sgm|cst|trxml|trx|tei|xml)/.fs/i;
    $file=~s/\.(amt|am|m|a)/$1.fs/;
  } elsif ($response eq 'CSTS') {
    $file=~s/\.(?:fs|tei|trxml|trx|xml)/.csts/i;
  } elsif ($response eq 'TrXML') {
    $file=~s/\.(?:csts|sgml|sgm|cst|fs|tei)/.trxml/i;
  } elsif ($response eq 'TEIXML') {
    $file=~s/\.(?:csts|sgml|sgm|cst|fs|trxml|trx)/.xml/i;
  } elsif ($response eq 'Storable') {
    $file=~s/\.(?:csts|sgml|sgm|cst|fs|trxml|trx|tei|xml)/.pls/i;
  }
  $file= get_save_filename($win->toplevel,-filetypes=> $save_types{lc($response)},
				     -title=> "Save As ...",
				     -d $initdir ? (-initialdir=> $initdir) : (),
     				     $^O eq 'MSWin32' ? () : (-initialfile=> filename($file)));
  if (defined $file and $file ne '') {
    $win->{FSFile}->changeFilename($file);
    $win->{FSFile}->changeFileFormat(($file=~/\.gz$/ ? "gz-compressed " : "").
				     $win->{FSFile}->backend);
    updateTitle($win->{framegroup});
    return saveFile($win);
  }
  return 0;
}

sub askSaveFiles {
  my ($grp)= @_;

  @{$grp->{treeWindows}} = grep { $_ ne $grp->{focusedWindow} } @{$grp->{treeWindows}};
  unshift @{$grp->{treeWindows}},$grp->{focusedWindow};
  my $win;
  foreach $win (@{ $grp->{treeWindows} }) {
    if ($win->{FSFile}) {
      focusCanvas($win->canvas(),$win->{framegroup});
      askSaveFile($win);
      closeFile($win,-no_update => 1,-all_windows => 1);
    }
  }

  while (@openfiles) {
    resumeFile($grp->{focusedWindow},shift @openfiles);
    updateTitle($grp);
    get_nodes_win($grp->{focusedWindow});
    redraw_win($grp->{focusedWindow});
    centerTo($grp->{focusedWindow},$grp->{focusedWindow}->{currentNode});
    $grp->{top}->update();
    askSaveFile($grp->{focusedWindow},0);
  }
}


# ask user whether the current file should be saved (and save it if yes)
# if $keepbutton parameter is 1, allow user to keep the file
# return 0 if file saved, 1 if file should be kept and undef if no

sub askSaveFile {
  my ($win,$keepbutton)=@_;
  return 0 unless
    ref($win->{FSFile}) and
      $win->{FSFile}->notSaved;
  my $answer=userQuery($win,
			$win->{FSFile}->filename().
			"\n\nFile may be changed!\nDo you want to save it?",
			-bitmap=> 'question',
			-title => "Should I save the file?",
			-buttons => ['Yes', 'No', $keepbutton ? 'Keep' : ()]);
  if ($answer eq 'Yes') {
    saveFile($win);
    return 0;
  } elsif ($answer eq 'Keep') {
    return 1;
  }
}

sub saveConfig {
 my ($grp)=shift;

 if (open(F,">$configFile")) {
   print STDERR "SAVING CONFIG TO: $configFile\n";
   print F @_;
   close(F);
 } else {
   my $lasterr=$!;
   my ($trc)=TrEd::Config::tilde_expand('~/.tredrc');
   my ($dc,$ic)=stat($configFile);
   my ($dh,$ih)=stat($trc);
   if ($configFile ne $trc and ($dc != $dh or $ic != $ih) and
       (!defined($grp->{top}) or
       $grp->{top}->toplevel->
       messageBox(-icon=> 'warning',
		  -message=> "Cannot write configuration to $configFile\n($lasterr)\n\n".
		  "Shell I try to save it to ~/.tredrc?\n",
		  -title=> 'Configuration cannot be saved',
		  -type=> 'YesNo',
		  #			  -default=> 'Yes' # problem: Windows 'yes', UNIX 'Yes'
		 )=~ /yes/i)) {
     if (open(F,">".$trc)) {
       print STDERR "SAVING CONFIG TO: $trc\n";
       print F @_;
       close(F);
       $configFile=$trc;
     } else {
       errorMessage($grp->{focusedWindow},'Cannot write to "'.$trc.'"!'."\n($!)\n".
		    "\nConfiguration could not be saved!\n");
     }
   } else {
     errorMessage($grp->{focusedWindow},"Cannot write to \"$configFile\"!"."\n($lasterr)\n".
		  "\nConfiguration could not be saved!");
   }
 }
}

sub reconfigure {
  my ($grp)=@_;
  addToRecent($grp);
  prepareFonts($grp);
  updateTitle($grp);
  $grp->{valueLine}->configure(-font=> $vLineFont);
  $grp->{statusLine}->configure(-font=> $vLineFont) if $grp->{statusLine};
  foreach (@{$grp->{treeWindows}}) {
    $_->treeView->apply_options($treeViewOpts);
  }
  ApplyGlobalConfig($grp);
}

sub editConfig {
  my ($grp)=@_;
  return unless $grp;
  if ($grp->{configDialog}) {
    $grp->{configDialog}->deiconify;
    $grp->{configDialog}->focus;
    $grp->{configDialog}->raise;
    return;
  }
  $grp->{configDialog}= 
    $grp->{top}->Toplevel(-title=> "Edit Resource File ($configFile)" , 
			  -width=> "10c");
  my $d=$grp->{configDialog};
  $d->withdraw;
  $d->bind('<Return>'=> [\&dlgReturn,1]);
  my $t= $d->
    Scrolled(qw/Text -relief sunken -borderwidth 2
		     -height 20 -scrollbars oe/);
  $t->bind('<Alt-f>'  => sub {
	     my ($w)=@_;
	     my $pop=$w->FindPopUp();
	     my ($entry) = grep { $_->isa('Tk::Entry') } $pop->children();
	     $pop->bind('all','<Tab>',[sub { shift->focusNext; }]);
	     $pop->bind('all','<Escape>',[sub { shift; shift->destroy; },$pop]);
	     if (ref($entry)) {
	       $entry->focus();
	     }
	   });
  $t->bind('<Alt-r>'  => sub {
	     my ($w)=@_;
	     my $pop=$w->FindAndReplacePopUp();
	     my ($entry) = grep { $_->isa('Tk::Entry') } $pop->children();
	     $pop->bind('all','<Tab>',[sub { shift->focusNext; }]);
	     $pop->bind('all','<Escape>',[sub { shift; shift->destroy; },$pop]);
	     if (ref($entry)) {
	       $entry->focus();
	     }
	   });
  $t->pack(qw/-side top -expand yes -fill both/);
  disable_scrollbar_focus($t);
  $t->BindMouseWheelVert();
  my $bottom=$d->Frame()->pack(qw/-side bottom -fill x/);
  $bottom->
    Button(-text=> "  Save and Apply  ",
	   -command=> [sub {
			  my ($grp,$d,$t)=@_;
			  saveConfig($grp,$t->get("0.0","end"));
			  apply_config(split(/\n/,$t->get("0.0","end")));
			  reconfigure($grp);
			  redraw_all($grp);
			},$grp,$d,$t])
      ->pack(-side=> 'left', -expand=> 1,  -padx=> 1, -pady=> 1);
  $bottom->Button(-text=> "  Apply  ",
		  -command=> [sub {
				 my ($grp,$w)=@_;
				 apply_config(split(/\n/,$w->get("0.0","end")));
				 reconfigure($grp);
				 redraw_all($grp);
			       },$grp,$t])
    ->pack(-side=> 'left', -expand=> 1,  -padx=> 1, -pady=> 1);

  $bottom->Button(-text=> "  Close  ", -command=> [sub { shift->destroy; },$d])
    ->pack(-side=> 'left', -expand=> 1,  -padx=> 1, -pady=> 1);

  $d->bind('<Destroy>'=> [sub { shift; shift->{configDialog}=undef; },$grp ]);
  $d->bind($d,'<Escape>'=> [sub { shift; shift->destroy(); },$d]);
  if (open(F,"<$configFile")) {
    $t->insert('0.0',join "",<F>);
    close(F);
  }
  $t->mark(qw/set insert 0.0/);
  $t->focus();
  $d->Popup;
}

sub QueryString {
  my ($grp, $title, $label,$default_text)=@_;
  my $newvalue=encode($default_text);
  my $d=$grp->{top}->DialogBox(-title=> $title,
				 -buttons=> ["OK", "Cancel"]);
  $d->protocol('WM_DELETE_WINDOW' => [sub { shift->{selected_button}='Cancel'; },$d]);
  $d->bind('all','<Escape>'=> [sub { shift; shift->{selected_button}='Cancel'; },$d ]);
  $d->bind('<Return>',\&dlgReturn);
  $d->bind('all','<Tab>',[sub { shift->focusNext; }]);
  $d->bind('all','<Shift-Tab>',[sub { shift->focusPrev; }]);

  addBindTags($d,'dialog');
  my $e=$d->add('Entry',-relief=> 'sunken',
		    -width=> 70,
		    -takefocus=> 1,
		    -font=> $font,
		    -textvariable=> \$newvalue);
  my $l= $d->Label(-text=> encode($label),
		    -anchor=> 'e',
		    -justify=> 'right');

  $l->pack(-side=>'left');
  $e->pack(-side=>'right');
  $d->resizable(0,0);
#  $e->focus;
  my $result= ShowDialog($d,$e,$grp->{top});
  $d->destroy;
  undef $d;
  if ($result=~ /OK/) {
    return decode($newvalue);
  } else {
    return undef;
  }
}

sub Query {
  my ($w, $title, $label,$default_text)=@_;
  my $newvalue=encode($default_text);
  my $d=$w->DialogBox(-title=> $title,
				 -buttons=> ["OK", "Cancel"]);
  $d->bind('<Return>', \&dlgReturn );
  $d->bind('all','<Escape>'=> [sub { shift; shift->{selected_button}='Cancel'; },$d ]);
  addBindTags($d,'dialog');
  my $e=$d->add('Entry',-relief=> 'sunken',
		    -width=> 40,
		    -takefocus=> 1,
		    -font=> $font,
		    -textvariable=> \$newvalue);
  my $l= $d->Label(-text=> encode($label),
		    -anchor=> 'e',
		    -justify=> 'right');
  $l->pack(-side=>'top');
  $e->pack(-side=>'left');
  $d->resizable(0,0);
#  $e->focus;
  my $result= ShowDialog($d,$e,$w);
  $d->destroy;
  undef $d;
  if ($result=~ /OK/) {
    return decode($newvalue);
  } else {
    return undef;
  }
}

sub ListQuery {
  my ($w,$title,$select_mode,$vals,$selected)=@_;
  my $top=$w->toplevel;
  my $d=$w->DialogBox(-title	  => $title,
		      -width	  => '8c',
		      -buttons  => ["OK", "Cancel"]);
  $d->bind('<Return>', \&dlgReturn );
  $d->protocol('WM_DELETE_WINDOW' => [sub { shift->{selected_button}='Cancel'; },$d]);
  $d->bind('all','<Escape>'=> [sub {
				 shift;
				 shift->{selected_button}='Cancel';
			       },$d ]);
  my $l=$d->Scrolled(qw/Listbox -relief sunken
                        -takefocus 1
                        -scrollbars e/,
		     -font=> $font,
		     -selectmode => $select_mode,
		     -height=> min($maxDisplayedValues,scalar(@$vals))
		    )->pack(qw/-expand yes -fill both/);
  $l->insert('end',@$vals);
  $l->BindMouseWheelVert();
  if ($select_mode eq 'multiple') {
    my $f=$d->Frame()->pack(qw/-expand yes -fill both/);
    $f->Button(-text => 'All',
	       -command => [
			    sub{
			      my ($list)=@_;
			      $list->selectionSet(0,'end');
			    },
			    $l
			   ])->pack(-side => 'left');
    $f->Button(-text => 'None',
	       -command => [
			    sub{
			      my ($list)=@_;
			      $list->selectionClear(0,'end');
			    },
			    $l
			   ])->pack(-side => 'left');
  }
  my $act=0;
  my %selected = map { $_ => 1 } @$selected;
  for ($a=0;$a<@$vals;$a++)  {
    if ($selected{$$vals[$a]}) {
      $l->selectionSet($a);
      if (not $act) {
	$act=1;
	$l->activate($a);
	$l->see($a);
      }
    }
  }
 $l->focus;
 my $result= &main::ShowDialog($d,$l,$top);

 if ($result=~ /OK/) {
   @$selected=();
   foreach (0 .. $l->size-1) {
     push @$selected, $$vals[$_] if $l->selectionIncludes($_);
   }
   $d->destroy;
   return 1;
 }
 $d->destroy;
 return 0;
}

sub selectContext {
  my ($grp)=@_;
  my $selection = [$grp->{focusedWindow}->{macroContext}];
  ListQuery($grp->{top},'Select Context','browse',[sort(keys(%keyBindings))],
	    $selection) || return;
  if (@$selection) {
    switchContext($grp->{focusedWindow},$selection->[0]);
  }
}

sub selectValuesDialog {
 my ($grp, $attr, $vals, $selected, $may_add, $lastFocus,$force)=@_;
 my $a;
 my $multi=0;
 my @prevSelectionSet;

 my $top=$grp->{top};
 $top->Busy(-recurse=> 1);
 my $enabled=($force or doEvalHook($grp->{focusedWindow},
				   'enable_attr_hook',
				   $attr,
				   "ambiguous") ne 'stop');

 my $d=$top->DialogBox(-title=> ($enabled ? "$attr: select values" : "$attr: values"),
		       -width=> '8c',
		       -buttons=> ($enabled ? ["OK", "Cancel"] : ["Cancel"]));
  $d->bind('<Return>', \&dlgReturn );
  $d->protocol('WM_DELETE_WINDOW' => [sub { shift->{selected_button}='Cancel'; },$d]);
 $d->bind('all','<Escape>'=> [sub { shift; shift->{selected_button}='Cancel'; },$d ]);
 $d->resizable(0,0);
 my $l=$d->Scrolled(qw/Listbox -relief sunken -takefocus 1 -scrollbars oe/,
		    -height=> min($maxDisplayedValues,scalar(@$vals)),
		    -font=> $font)->pack(qw/-expand yes -fill both/);
 disable_scrollbar_focus($l);
 $l->insert('end',@$vals);
 $l->BindMouseWheelVert();
 if ($enabled) {
   $l->bind('<Double-ButtonPress-1>'=>
	    [sub { my $w=shift;
		   my $d=shift;
		   my $e= $w->XEvent;
		   $w->BeginSelect($w->index($e->xy));
		   $d->{selected_button}='OK';
		 },$d
	    ]);
 }
 my $act=0;
 for ($a=0;$a<@$vals;$a++)  {
   if (grep { $$vals[$a] eq $_ } @$selected) {
     $l->selectionSet($a);
     if (not $act) {
       print "Activating $a\n"  if $tredDebug;
       $act=1;
       $l->activate($a);
       $l->see($a);
     }
   }
 }
 if ($enabled) {
   $d->Checkbutton(-text    => 'multiple select',
		   -variable=> \$multi,
		   -command => [sub {
				   shift->configure(-selectmode=> $multi ? 'multiple' : 'browse');
				 },$l],
		   -relief  => 'flat')->pack();
   if ($may_add) {
     $d->Button(-text=> 'Add',
		-command=> [sub {
			       my ($grp,$l,$vals)=@_;
			       my $val=QueryString($grp,"Add new value","Value");
			       return unless defined $val;
			       push @$vals,$val;
			       $l->insert('end',$val);
			       $l->selectionClear(0,$l->size-1) unless $multi;
			       $l->selectionSet($l->size-1);
			     },$grp,$l,$vals])->pack();
   }
 }
 $top->Unbusy();
 $l->focus;
 my $result= ShowDialog($d,$l,$lastFocus);
 if ($result=~ /OK/) {
   # Hajic wanted this (I wash my hands):
   # first we store the values, which were selected originaly and
   # stayed selected
   foreach my $s (@$selected) { 
     push @prevSelectionSet, (grep { $$vals[$_] eq $s } (0 .. $l->size-1));
   }
   @$selected=();
   foreach (@prevSelectionSet) {
     if ($l->selectionIncludes($_)) {
       $l->selectionClear($_);
       push @$selected,$$vals[$_];
     }
   }
   foreach (0 .. $l->size-1) {
     push @$selected, $$vals[$_] if $l->selectionIncludes($_);
   }
   $d->destroy;
   undef $d;
   return 1;
 }
 $d->destroy;
 undef $d;
 return 0;
}

sub reloadSentenceView {
  my ($grp,$t,$selref)=@_;
  return unless $t;
  my $d=$grp->{sentDialog};
  $t->delete('0.0','end'); #something smells here!! 
  $grp->{sentDialog}=$d;
  my $filename=$grp->{focusedWindow}->{FSFile}->filename();
  for (my $i=0; $i<=$grp->{focusedWindow}->{FSFile}->lastTreeNo();$i++) {
    $t->window('create', 'end', -window =>
	       $t->Checkbutton(-selectcolor => undef,
			       -indicatoron => 0,
			       -height => 19,
			       -width => 19,
			       -selectimage => $grp->{top}->Pixmap(-file=>
							     "$libDir/green_belly3.xpm"),
			       -image => $grp->{top}->Pixmap(-file=>
							     "$libDir/gray_belly3.xpm"),
			       -variable => \$selref->[$i]
			      ));
    $t->window('create', 'end', -window =>
	       $t->Button(-height => 16,
			  -width => 16,
			  -image => $grp->{top}->Pixmap(-file=>
							"$libDir/right.xpm"),
			  -command => [\&openFile, $grp, "$filename##".($i+1)]
			 ));

    my $v = get_value_line($grp->{focusedWindow},
			   $grp->{focusedWindow}->{FSFile},$i,1,1);
    my %tags;
    @tags{ map { @$_[1..$#$_] } @$v }=();
    foreach my $tag (keys(%tags)) {
      if ($tag=~/^\s*-/) {
	eval {
	  $t->tagConfigure(
			   $tag => (map { (/^\s*(-[[:alnum:]]+)\s*=>\s*(.*\S)\s*$/) }
				    split(/,/,$tag)));
	};
	print $@ if $@;
      }
    }


    $t->insert('end',"(".($i+1).") ",'treeno',
	       map { ($_->[0], [@$_[1..$#$_]]) } @$v);
    $t->insert('end',"\n",'newline');
	       #	       get_value_line($grp->{focusedWindow},
	       #			      $grp->{focusedWindow}->{FSFile},$i,1),'tline',
    #	       "\n",'newline');
  }
  $t->tagAdd('all','0.0','end');
  $t->tagConfigure('all',-lmargin2 => 50);
}

sub sentViewSelectAll {
  my ($grp,$selref)=@_;
  return unless ref($selref) eq 'ARRAY';
  foreach (@{$selref}) {
    $_=1;
  }
}

sub sentViewSelectNone {
  my ($grp,$selref)=@_;
  return unless ref($selref) eq 'ARRAY';
  foreach (@{$selref}) {
    $_=0;
  }
}

sub sentViewGetSelection {
 my ($grp,$selref)=@_;
 $selref||=$grp->{sentDialogSelection};
 my $rng='';
 
 if (ref($selref) eq 'ARRAY') {
   for (my $i=0;$i<=$#{$selref};$i++) {
     $rng.=($i+1)."," if $selref->[$i];
   }
   $rng=~s/,$//;
 }
 return $rng;
}

sub viewSentences {
  my ($grp)=@_;
  return unless $grp and ref($grp->{focusedWindow}->{FSFile});
  if ($grp->{sentDialog}) {
    my $d=$grp->{sentDialog};
    $d->deiconify;
    $d->focus;
    $d->raise;
    return;
  }
  $grp->{sentDialogSelection}=[];
  my $d=$grp->{sentDialog}=
    $grp->{top}->Toplevel(-title=> "List of sentences for ".
			  $grp->{focusedWindow}->{FSFile}->filename(),
			  -width=> "10c");
  $d->withdraw;
  $d->bind('<Return>'=> [\&dlgReturn,1]);
  $d->bind('all','<Escape>'=> [sub { $_[1]->destroy(); },$d]);
  $d->bind('<Destroy>'=> [sub { $_[1]->{sentDialog}=undef; },$grp ]);
  populateSentencesDialog($grp,$grp->{sentDialog},
			  $grp->{focusedWindow}->{FSFile},
			  $grp->{sentDialogSelection},
			  1
			 );
  $d->Popup;
}

sub viewSentencesDialog {
  my ($grp,$top,$fsfile,$selref)=@_;
  return unless $grp and ref($grp->{focusedWindow}->{FSFile});
  my $d=
    $top->DialogBox(-title=> "List of sentences for ".
		    $fsfile->filename(),
		    -width=> "10c");
  $d->bind('<Return>', \&dlgReturn );
  $d->protocol('WM_DELETE_WINDOW' => [sub { shift->{selected_button}='Cancel'; },$d]);
  $d->bind('all','<Escape>'=> [sub { $_[1]->{selected_button}='Cancel'; },$d ]);
  $selref||=[];
  populateSentencesDialog($grp,$d,$fsfile,$selref,0);
  ShowDialog($d,$top);
  $d->destroy;
  undef $d;
  return $selref;
}

sub dumpSentView {
  my ($grp, $fsfile, $t)=@_;
  my $file=$fsfile->filename;
  $file=~s/\.(?:csts|sgml|sgm|cst|trxml|trx|tei|xml|fs)/.html/i;

  my $initdir=dirname($file);
  $initdir=cwd if ($initdir eq './');
  $initdir=~s!${TrEd::Convert::Ds}$!!m;

  $file= get_save_filename($grp->{top},-filetypes=>
				  [["HTML",           [qw/.html .htm .HTM .HTML/]],
				   ["All files",        '*']],
				  -title=> "Save Sentences As HTML ...",
				  -d $initdir ? (-initialdir=> $initdir) : (),
				  $^O eq 'MSWin32' ? () : (-initialfile=> filename($file)));
  open my $html, ">$file" ||
    errorMessage($grp->{focusedWindow},"Cannot write to \"$file\"!"."\n($!)\n".
		 "\nSentences could not be saved!");
  my $encoding=$TrEd::Convert::outputenc;
  if ($]>=5.008 and not $TrEd::Convert::support_unicode) {
    _set_encoding($html,':bytes',"html-out");
    __debug("HTML encoding $encoding, bytes output");
  } else {
    _set_encoding($html,$encoding,"html-out");
    __debug("HTML encoding $encoding");
  }

  print $html "<html>\n";
  print $html "<head>\n";
  print $html "  <meta http-equiv=\"Content-Type\" content=\"text/html;charset=".$encoding."\" />\n";
  print $html "</head>\n";
  print $html "<body>\n";
  my @dump=$t->dump('0.0','end');
  @dump=$t->dump('0.0','end');
  while (@dump) {
    my ($K,$V,$I) = (shift @dump, shift @dump, shift @dump);
    if ($K eq 'tagon') {
      print $html "<p>" if $V eq 'treeno';
      print $html "<u>" if $t->tagCget($V,'-underline');
      print $html "<font color=\"".$t->tagCget($V,'-foreground')."\">"
	if $t->tagCget($V,'-foreground');
      print $html "<span class=\"$1\">" if $V =~ /^tag\s*=>\s*(.*)$/;
    } elsif ($K eq 'tagoff') {
      print $html "</span>" if $V =~  /^tag\s*=>\s*.*$/ ;
      print $html "</font>" if $t->tagCget($V,'-foreground');
      print $html "</u>" if $t->tagCget($V,'-underline');
      print $html "</p>\n" if $V eq 'newline';
    } elsif ($K eq 'text') {
      print $html $V;
    } else {
      #print $html "<other key=\"$K\" value=\"$V\"/>";
    }
  }
  print $html "\n</body>\n";
  print $html "\n</html>\n";
  close($html);
}

sub populateSentencesDialog {
  my ($grp,$d,$fsfile,$selref,$close_button)=@_;
  return unless $grp and $fsfile;

  use Tk::ROText;
#c -background white
  my $t= $d->
    Scrolled(qw/ROText -relief sunken -borderwidth 2 -setgrid true
                     -spacing3 6 -wrap word
		     -height 20 -scrollbars oe/,
	     -font=>$font
	    );
  disable_scrollbar_focus($t);
  $t->pack(qw/-expand yes -fill both/);
  $t->BindMouseWheelVert();
  $grp->{sentDialogText}=$t;
  my $bottom=$d->Frame()->pack(qw/-expand yes -fill both/);

  if ($close_button) {
    $bottom->Button(-text=> "Close", -command=> [sub { $_[0]->destroy; },$d])
      ->pack(-side=> 'left', -expand=> 1,  -padx=> 1, -pady=> 1);
  }

  $bottom->Button(-text=> "Reload", -command=> [\&reloadSentenceView,$grp,$t,$selref])
    ->pack(-side=> 'left', -expand=> 1,  -padx=> 1, -pady=> 1);
  $bottom->Button(-text=> "Select All", -command=>[ \&sentViewSelectAll,$grp,$selref])
    ->pack(-side=> 'left', -expand=> 1,  -padx=> 1, -pady=> 1);
  $bottom->Button(-text=> "Clear selection", -command=>[ \&sentViewSelectNone,$grp,$selref])
    ->pack(-side=> 'left', -expand=> 1,  -padx=> 1, -pady=> 1);
  $bottom->Button(-text=> "Save As HTML", -command=>[ \&dumpSentView,$grp,$fsfile,$t])
    ->pack(-side=> 'left', -expand=> 1,  -padx=> 1, -pady=> 1);

  reloadSentenceView($grp,$t,$selref);
}


sub editListAttr {
  my ($win, $value, $attr,$d)=@_;
  return unless $win->{FSFile};
  my @vals= map { encode($_) } $win->{FSFile}->FS->listValues($attr);
  #print "splitting ",$value{$attr},"\n";
  my @selected= map { encode($_) } split /\|/,$value;
  #print "splitted to ", join ('-',@selected),"\n";

  if (selectValuesDialog($win->{framegroup},$attr,\@vals,\@selected,0,$d)) {
    return decode(join('|',@selected));
  }
  return undef;
}

sub editAmbiguousAttr {
  my ($win, $value, $attr)=@_;
  my @vals= map { encode($_) }split /\|/,$value;
  my @selected= @vals;
  
  if (selectValuesDialog($win->{framegroup},$attr,\@vals,\@selected,1,$win->toplevel)) {
    return decode(join('|',@selected));
  }
  return undef;
}

sub focusxEditDn {
  my ($w,$i,$e,$f,$atord)=@_;
  if ($i+1<@$atord) {
    $f->see($e->{$atord->[$i+1]});
    $e->{$atord->[$i+1]}->focus;
  }
  Tk->break;
}

sub focusxEditUp {
  my ($w,$i,$e,$f,$atord)=@_;
  if ($i>0) {
    $f->see($e->{$atord->[$i-1]});
    $e->{$atord->[$i-1]}->focus;
  }
  Tk->break;
}

sub focusxFind {
  my ($w,$i,$e,$f,$atord)=@_;
  my $ev= $w->XEvent;
  my $A= $ev->A;
  if ($A ne "") {
    my $count=scalar(@$atord);
    for (my $j=$i+1;$j<=$i+$count;$j++) {
      if (($atord->[$j % $count]) =~ /^\Q$A\E/i) {
	$f->see($e->{$atord->[$j % $count]});
	$e->{$atord->[$j % $count]}->focus();
	Tk->break;
	return;
      }
    }
  }
}


sub editAttrsDialog {
  my ($win,$node)=@_;
  return if (doEvalHook($win,"do_edit_node_hook",$node) eq 'stop');
  return unless $win->{FSFile};
  my @vals;
  my %e=();
  my @atord=$win->{FSFile}->FS->attributes;

  if ($sortAttrs) {
    @atord=sort {uc($a) cmp uc($b)} $win->{FSFile}->FS->attributes
      unless (doEvalHook($win,"sort_attrs_hook",\@atord));
  }
  my $rows=min($maxDisplayedAttributes,$#atord+1);
  my ($a,$b,$r);

  $win->toplevel->Busy(-recurse=>1);
  my $d=$win->toplevel->DialogBox(-title=> "Edit Node Attributes", -width=> '10c',
				  -buttons=> ["OK", "Cancel"]
				 );
  $d->bind('<Return>',\&dlgReturn);
  $d->bind('<Control-Return>',\&dlgReturn);
  $d->bind('all','<Escape>'=> [sub { shift; shift->{selected_button}='Cancel'; },$d ]);
  $d->protocol('WM_DELETE_WINDOW' => [sub { shift->{selected_button}='Cancel'; },$d]);

  my $ff=$d->Frame(-relief=> 'groove',
		   -bd => 1);
  my $f= $ff->Scrolled('Pane',
		      -sticky => 'we',
		      -scrollbars=> 'oe');
  disable_scrollbar_focus($f);
  $f->BindMouseWheelVert("","EditEntry");

  my $lwidth;
  foreach (@atord) {
    $lwidth=max($lwidth,length($_));
  }
  my $height=0;


  for (my $i=0;$i<=$#atord;$i++) {
    $_=$atord[$i];
    # Reliefs: raised, sunken, flat, ridge, and groove.
    my $eef=$f->Frame()->pack(qw/-side top -expand yes -fill x/);
    $eef->Label(-text=> $_,
		-justify => 'left',
		-width =>$lwidth,
		-anchor=> 'nw')->pack(qw/-side left/);

    if  ($win->{FSFile}->FS->isList($_) or
	 $node->getAttribute($_)=~/^(?:[^\|\\]|\\.)*\|/) { # readonly entry and buttons for list
      $r= $eef->Frame();
      $e{$_}= $r->Entry(-relief=> 'sunken', -takefocus=> 1,
			 -font=> $font)->pack(qw/-expand yes -fill both -side left/);
      addBindTags($e{$_},"EditEntry");
	$b=$r->Button(-text=> "...", -takefocus=> 0,
 		      -command=> [sub {
 				     my ($e,$win,$node,$attr,$d)=@_;
 				     my $result=
 				       ($win->{FSFile}->FS->isList($attr)
 					? editListAttr($win,$e->get,$attr)
 					: editAmbiguousAttr($win,$e->get,$attr,$d));
 				     if (defined $result) {
 				       $e->configure(-state=> 'normal');
 				       $e->delete(0,length($e->get));
 				       $e->insert(0,$result);
 				       $e->configure(-state=> 'disabled');
 				     }
				   },$e{$_},$win,$node,$_,$d]
		     )->pack(qw/-side right/);
	$e{$_}->bind($e{$_},'<space>',[sub { shift; shift->invoke; Tk->break; },$b]);
	$e{$_}->bind($e{$_},'<Return>',[sub { shift; shift->invoke; Tk->break; },$b]);
	$e{$_}->bind($e{$_},'<Double-ButtonPress-1>',[sub { shift; shift->invoke; Tk->break; },$b]);
      $e{$_}->insert(0,encode($node->getAttribute($_)));
      $e{$_}->configure(-state=> 'disabled');
      $r->pack(qw/-side right -expand yes -fill both/);
      $height += max($b->reqheight,$e{$_}->reqheight()) if ($i<$rows);
    } else {
      $e{$_}= $eef->Entry(-relief=> 'sunken', -takefocus=> 1,
			 -font=> $font)->pack(qw/-side right -expand yes -fill both/);
      addBindTags($e{$_},"EditEntry");
      $e{$_}->insert(0,encode($node->getAttribute($_)));
      if (doEvalHook($win,'enable_attr_hook',$_,"normal") eq 'stop') {
	$e{$_}->configure(-state=> 'disabled');
      }
      $height += $e{$_}->reqheight() if ($i<$rows);
    }
    $f->bind($e{$_}, '<Tab>',       [\&focusxEditDn,$i,\%e,$f,\@atord]);
    $f->bind($e{$_}, '<Down>',      [\&focusxEditDn,$i,\%e,$f,\@atord]);
    $f->bind($e{$_}, '<Shift-Tab>', [\&focusxEditUp,$i,\%e,$f,\@atord]);
    $f->bind($e{$_}, '<Shift-ISO_Left_Tab>',
	                            [\&focusxEditUp,$i,\%e,$f,\@atord]);
    $f->bind($e{$_}, '<Up>',        [\&focusxEditUp,$i,\%e,$f,\@atord]);
    $f->bind($e{$_}, '<Alt-KeyPress>', [\&focusxFind,$i,\%e,$f,\@atord]);
  }

  $f->configure(-height => $height);
  $f->pack(qw/-expand yes -fill both/);
  $ff->pack(qw/-expand yes -fill both/);
  $win->toplevel->Unbusy();

  my $result= ShowDialog($d,(
			     $atord[0] ? $e{$atord[0]}->focus : undef
			    ),$win->toplevel);

  if ($result=~ /OK/) {
    $win->{FSFile}->notSaved(1);
    save_undo($win,prepare_undo($win));
    lastActionBookmark($win->{framegroup});
    foreach $a (@atord) {
      $node->setAttribute($a,decode($e{$a}->get));
    }
    doEvalHook($win,"after_edit_node_hook",$node,1);
    get_nodes_fsfile_tree($win->{framegroup},$win->{FSFile},$win->{treeNo});
    redraw_fsfile_tree($win->{framegroup},$win->{FSFile},$win->{treeNo});
  } else {
     doEvalHook($win,"after_edit_node_hook",$node,0);
  }

  undef %e;
  $d->destroy;
}

sub disable_scrollbar_focus {
  my ($scrolled)=@_;
  $scrolled->Subwidget('xscrollbar')->configure(qw(-takefocus 0));
  $scrolled->Subwidget('yscrollbar')->configure(qw(-takefocus 0));
}

sub customAttrsDialog {
  my ($grp)=@_;
  my $win=$grp->{focusedWindow};
  return if (doEvalHook($win,"customize_attrs_hook") eq 'stop');

  return unless $win->{FSFile};

  $grp->{top}->Busy(-recurse=>1);
  my $d=$grp->{top}->
    DialogBox(-title=> "Customize Visible Attributes",
	      -width=> '10c',
	      -buttons=> ["OK", "Cancel"]);

  $d->Subwidget('top')->configure(qw(-takefocus 0));
  $d->Subwidget('bottom')->configure(qw(-takefocus 0));

  # Pattern Editor
  my $e= $d->Scrolled(qw/Text -scrollbars osoe -height 4
                              -relief sunken -borderwidth 2/);
  disable_scrollbar_focus($e);
  my $eff=$d->Frame(qw/-relief sunken -bd 1 -takefocus 0/)->
    pack(qw/-padx 3 -pady 3 -side top -fill x/);
  $eff->Frame(qw/-height 6 -takefocus 0/)->pack();
  $d->Label(-text => "Edit attribute pattern (press ^I to insert tab)",
	    -anchor => 'nw', -justify => 'left')
    ->pack(-in => $eff, qw/-padx 3 -pady 3 -side top -expand yes -fill x/);
  $e->pack(-in => $eff,qw/-padx 3 -pady 3 -side top -expand yes -fill x/);
  $e->raise($eff);


  # All wrapping frame with attribute selection and buttons
  my $f= $d->Frame(qw/-relief sunken -bd 1 -takefocus 0/);
  $f->Frame(qw/-height 6 -takefocus 0/)->pack(qw/-side bottom/);

  # Frame with attribute selection
  my $af= $f->Frame(qw(-takefocus 0));
  $af->Frame(qw/-height 6 -takefocus 0/)->pack();
  # Attributes listbox
  $af->Label(qw/-text Attributes -anchor nw -justify left/)->pack(qw/-fill both/);
  my $al= $af->Scrolled(qw/Listbox
                     -bg white
                     -width 0
                     -relief sunken
                     -borderwidth 2 -setgrid true
                     -scrollbars oe
                     -exportselection 0/)->pack(qw/-pady 3 -expand yes -fill y/);
  disable_scrollbar_focus($al);
  $al->BindMouseWheelVert();
  my @atord=$win->{FSFile}->FS->attributes;
  if ($sortAttrs) {
    @atord=sort {uc($a) cmp uc($b)} $win->{FSFile}->FS->attributes
      unless (doEvalHook($win,"sort_attrs_hook",\@atord));
  }
  $al->insert('end',@atord);
  if (@atord) {
    $al->activate(0);
    $al->selectionSet(0);
  }
  $af->pack(qw/-padx 5 -side left -fill y/);

  # Frame with pattenrs listbox
  my $cf= $f->Frame(qw(-takefocus 0));
  $cf->Frame(qw/-height 6 -takefocus 0/)->pack();
  $cf->Label(-text=> 'Display patterns',qw/-anchor nw -justify left/)->pack(qw/-fill x/);
  my $cl=
    $cf->Scrolled(qw/Listbox -relief sunken
                     -bg white
                     -borderwidth 2
                     -setgrid true
		     -scrollbars osoe
                     -selectmode extended
                     -exportselection 0/
		 )->pack(qw/-side top -expand yes
                            -fill both
                            -padx 3 -pady 3/);
  disable_scrollbar_focus($cl);
  $cl->BindMouseWheelVert();
  $cl->insert('end',getWindowPatterns($win),'   ');
  $cl->activate('end');
  $cl->selectionSet('end');
  $cf->Frame(qw/-height 6 -takefocus 0/)->pack();
  $cf->Label(-text=> 'Hint pattern',qw/-anchor nw -justify left/)->pack(qw/-fill x/);
  # Hint box
  my $t=
    $cf->Scrolled(qw/Text -relief sunken
                     -borderwidth 2 -setgrid true
		     -height 4 -scrollbars osoe
                     -width 50
                     -exportselection 1
                     -wrap none/
		 )->pack(qw/-side top -expand yes
                            -fill both
                            -padx 3 -pady 3/);
  disable_scrollbar_focus($t);
  $t->insert('0.0',getWindowHint($win));
  $t->BindMouseWheelVert();

  # Frame with buttons
  my $bf= $f->Frame(qw(-takefocus 0));
  $bf->Button(-text=> "Add/Paste",
	      -command=>
	      sub {
		my $txt=$e->get('0.0','end');
		chomp $txt;
		if ($txt ne "") {
		  $cl->insert('active',$txt);
		} elsif($al->selectionIncludes($al->index('active'))) {
		  $cl->insert('active','${'.$al->get('active').'}');
		}
		$e->tagAdd('sel','0.0','end');
	      }
	     )->pack(qw/-side top -expand yes -padx 3 -pady 3/);

  $bf->Button(-text=> "Replace",
	      -command=>
	      sub {
		my $txt=$e->get('0.0','end');
		chomp $txt;
		if ($txt eq "") {
		  $txt='${'.$al->get('active').'}';
		}
		my $index=$cl->index('active');
		if ($index != $cl->index('end')-1) {
		  $cl->delete($index);
		  $cl->insert($index,$txt);
		} else {
		  $cl->insert($index,$txt);
		  $cl->activate($index);
		}
	      }
	     )->pack(qw/-side top -expand yes -padx 3 -pady 3/);

  $bf->Button(-text=> "Cut",
	      -command=>
	      [sub {
		$cl->selectionClear($cl->index('end')-1)
		  if ($cl->selectionIncludes($cl->index('end')-1));
		while (defined(($cl->curselection)[0])) {
		  $e->delete('0.0','end');
		  $e->insert('insert',$cl->get(($cl->curselection)[0]));
		  $cl->delete(($cl->curselection)[0]);
		}
	      }]
	     )->pack(qw/-side top -expand yes -padx 3 -pady 3/);
  $bf->Button(-text=> "Delete",
	      -command=>
	      [sub {
		$cl->selectionClear($cl->index('end')-1)
		  if ($cl->selectionIncludes($cl->index('end')-1));
		while (defined(($cl->curselection)[0])) {
		  $cl->delete(($cl->curselection)[0]);
		}
	      }]
	     )->pack(qw/-side top -expand yes -padx 3 -pady 3/);


  $bf->Button(-text=> "Add as hint",
	      -command=>
	      [sub {
		my $txt=$e->get('0.0','end');
		chomp $txt;
		if ($txt ne "") {
		  Tk::catch { $t->delete('sel.first','sel.last') };
		  $t->insert('insert',$txt);
		}
		$e->tagAdd('sel','0.0','end');
	      }]
	     )->pack(qw/-side top -expand yes -padx 3 -pady 3/);


  $bf->pack(qw/-padx 5 -side left -fill y/);
  $cf->pack(qw/-padx 5 -side left -expand yes -fill both/);


  $f->pack(qw/-padx 3 -pady 3 -side top -expand yes -fill both/);

  $d->bind('all','<Tab>',[sub { shift->focusNext; }]);
  $e->bind('Tk::Text','<Tab>',[sub { shift->focusNext; }]);
  $d->bind('all','<Shift-Tab>',[sub { shift->focusPrev; }]);
  $d->bind('all','<Shift-ISO_Left_Tab>',[sub { shift->focusPrev; }]);
  $d->protocol('WM_DELETE_WINDOW' => [sub { shift->{selected_button}='Cancel'; },$d]);
  $d->bind('all','<Escape>'=>
	   [sub { shift;
		  shift->{selected_button}='Cancel';
		},$d ]);
  $al->bind('<Double-1>'=>
	   [sub {
	     $e->delete('sel.first','sel.last') 
	       if ($e->tagNextrange('sel','0.0'));
	     $e->insert('insert','${'.$al->get('active').'}');
	     $e->focus();
	   }]
	  );
  $al->bind('<space>'=>
	   [sub {
	     $e->delete('sel.first','sel.last') 
	       if ($e->tagNextrange('sel','0.0'));
	     $e->insert('insert','${'.$al->get('active').'}');
	   }]
	  );
  $al->bind('<Return>'=>
	   [sub {
	     $e->delete('sel.first','sel.last') 
	       if ($e->tagNextrange('sel','0.0'));
	     $e->insert('insert','${'.$al->get('active').'}');
	     $e->focus();
	   }]
	  );
  $cl->bind('<Double-1>'=> 
	   [sub {
	     return if ($cl->index('active')== $cl->index('end')-1);
	     if ($e->tagNextrange('sel','0.0')) {
	       $e->delete('sel.first','sel.last')
	     }
	     $e->insert('insert',$cl->get('active'));
	     $e->focus();
	   }]
	  );
  $d->bind('<Return>'=> [\&dlgReturn,1]);
  $e->focus();
#  $d->resizable(0,0);
  $grp->{top}->Unbusy();
  my $result= ShowDialog($d,$e,$grp->{top});

  if ($result=~ /OK/) {
    setWindowPatterns($win,$cl->get(0,$cl->index('end')-2));
    setWindowHint($win,$t->get('0.0','end - 1 chars'));
    saveStyleSheets($grp) unless $win->{stylesheet} eq STYLESHEET_FROM_FILE();
    update_value_line($grp);
    redraw_fsfile($grp,$win->{FSFile});
  }
  $d->destroy;
  undef $d;
}


#####################################################
#####################################################
#####################################################
# Node searching
#####################################################

sub findNodeDialog {
  my ($grp,$template)=@_;
  return unless $grp->{focusedWindow}->{FSFile};
  my $r;
  my @vals;
  my @atord=$grp->{focusedWindow}->{FSFile}->FS->attributes;
  if ($sortAttrs) {
    @atord=sort {uc($a) cmp uc($b)} $grp->{focusedWindow}->{FSFile}->FS->attributes
      unless (doEvalHook($grp->{focusedWindow},"sort_attrs_hook",\@atord));
  }

  my $b;
  my $a;
  my $rows=min($maxDisplayedAttributes,$#atord+1);
  my %e=();
  $grp->{top}->Busy(-recurse=>1);
  my $d=$grp->{top}->DialogBox(-title=> "Find Node By Attributes", -width=> '10c',
				 -buttons=> ["Find"]);
  my $bcl=$d->Subwidget('bottom')->Button(-text=> "Clear",
				  -command=> [sub { my $e=shift;
						     foreach (keys %$e) {
						       $e->{$_}->delete(0,'end');
						     }
						   },\%e] );
  my $bca=$d->Subwidget('bottom')->Button(-text=> "Cancel", 
				  -command=> [sub { shift->{selected_button}= "Cancel"},$d] );
  foreach ($bcl,$bca) {
    $_->configure(-width=> 10, -pady=> 0) if ($Tk::platform eq 'MSWin32');
    $_->pack(-side=> 'left', -expand=> 1,  -padx=> 1, -pady=> 1);
  }
  $d->bind('<Return>', \&dlgReturn );
  $d->protocol('WM_DELETE_WINDOW' => [sub { shift->{selected_button}='Cancel'; },$d]);
  $d->bind('all','<Escape>'=> [sub { shift; shift->{selected_button}='Cancel'; },$d ]);
  my $ff=$d->Frame(-relief=> 'groove',
		   -bd => 1);
  my $f= $ff->Scrolled('Pane',
		      -sticky => 'we',
		      -scrollbars=> 'oe');
  disable_scrollbar_focus($f);
  $f->BindMouseWheelVert("","EditEntry");

  my $lwidth;
  foreach (@atord) {
    $lwidth=max($lwidth,length($_));
  }
  my $height=0;
  for (my $i=0;$i<=$#atord;$i++) {
    $_=$atord[$i];
    # Reliefs: raised, sunken, flat, ridge, and groove.
    my $eef=$f->Frame()->pack(qw/-side top -expand yes -fill x/);
    $eef->Label(-text=> $_,
		-justify => 'left',
		-width =>$lwidth,
		-anchor=> 'nw')->pack(qw/-side left/);
    $e{$_}= $eef->Entry(-relief=> 'sunken', -takefocus=> 1,
			-font=> $font)->pack(qw/-side right -expand yes -fill both/);
    addBindTags($e{$_},"EditEntry");
    $e{$_}->insert(0,encode($template->{$_}));
    $height += $e{$_}->reqheight() if ($i<$rows);
    $f->bind($e{$_}, '<Tab>',       [\&focusxEditDn,$i,\%e,$f,\@atord]);
    $f->bind($e{$_}, '<Down>',      [\&focusxEditDn,$i,\%e,$f,\@atord]);
    $f->bind($e{$_}, '<Shift-Tab>', [\&focusxEditUp,$i,\%e,$f,\@atord]);
    $f->bind($e{$_}, '<Shift-ISO_Left_Tab>',
	                            [\&focusxEditUp,$i,\%e,$f,\@atord]);
    $f->bind($e{$_}, '<Up>',        [\&focusxEditUp,$i,\%e,$f,\@atord]);
    $f->bind($e{$_}, '<Alt-KeyPress>', [\&focusxFind,$i,\%e,$f,\@atord]);
  }
  $f->configure(-height => $height);
  $f->pack(qw/-expand yes -fill both/);
  $ff->pack(qw/-expand yes -fill both/);

  do {
    my $of=$d->Frame()->pack(qw/-expand yes -fill x/);
    $of->Label(-text=> 'Search method: ')->pack(qw/-side left/);
    $of->Optionmenu(-variable=> \$grp->{templateMatchMethod},
		    -textvariable=> \$grp->{templateMatchMethod},
		    -options=> ['Regular expression',
				'Exhaustive regular expression',
				'Wildcard pattern',
				'Literal'])->pack(qw/-side left/);
  };
  my $of=$d->Frame()->pack(qw/-expand yes -fill x/);
  $of->Label(-text=> 'Search file-list: ')->pack(qw/-side left/);
  my $om=$of->Optionmenu(-textvariable=> \$grp->{searchFilelist})->pack(qw/-side left/);
  $om->options(['[Current file only]', map { $_->name } @filelists]);
  
  $of->Button(-text=> 'Edit',
	      -command=> [ sub {
			      my ($grp)=@_;
			      my $name=filelistDialog($grp,1);
			      $om->options(['[Current file only]',map { $_->name } @filelists]);
			      $grp->{searchFilelist}=$name if (ref(findFilelist($name)));
			    },$grp,$om])->pack(qw/-side left/);
  $grp->{top}->Unbusy();
  my $result= ShowDialog($d,($atord[0] ? $e{$atord[0]}->focus : undef),$grp->{top});
  if ($result=~ /Find/) {
    foreach $a (@atord) {
      $template->{$a}=decode($e{$a}->get);
    }
    # Clear all empty rules
    foreach (keys %$template) {
      delete $template->{$_} unless defined($template->{$_}) and $template->{$_} ne '';
    }
    if ($grp->{searchFilelist} ne '[Current file only]') {
      my $fl=findFilelist($grp->{searchFilelist});
      if (ref($fl) and $fl->file_count>0 ) {
	local $insideEval=1;                 # no redraw
	$fl->set_current($fl->file_at(0));
	selectFilelist($grp,$fl);
      }
    } else { 
      $grp->{searchFilelist}=undef;
    }
    doFindFirstTemplated($grp,$template,0);
  }
  $d->destroy;
  undef $d;
}

#####################################
# bound to Escape for busy widgets
#####################################
sub _search_busy {
  my ($w,$grp)=@_;
  print STDERR $grp->{focusedWindow}->{currentFileNo}."stopped by user\n" if ($tredDebug);
  $grp->{stopSearch}=1;
  Tk->break;
}

#####################################
# called after file open to process
# event queue and let user interrupt
# the search process
#####################################
sub _quick_update {
  my $grp=$_[0];
  $grp->{top}->Unbusy();
  $grp->{top}->update();
  $grp->{top}->Busy(-recurse=> 1);
}

######################################
# start searching for a next node
# and display result unless succeeded
######################################
sub doFindFirstTemplated {
  my ($grp,$template,$cont)=@_;
  return undef unless ($grp->{focusedWindow}->{currentNode});
  my $result;
  $grp->{top}->Busy(-recurse=> 1);

  print "Starting search!\n"  if $tredDebug;
  unless ($result=findFirstTemplated($grp,$template,$cont)) {
    redraw_win($grp->{focusedWindow});
    $grp->{top}->toplevel->
      messageBox(-icon=> 'warning',
		 -message=> $grp->{stopSearch} ? "Interrupted by user!" : "No matching node found!",
		 -title=> 'Find',
		 -type=> 'ok');
  }
  $grp->{top}->Unbusy();
  return $result;
}

######################################
# start searching for a prev node
# and display result unless succeeded
######################################
sub doFindPrevTemplated {
  my ($grp,$template,$cont)=@_;
  return undef unless ($grp->{focusedWindow}->{currentNode});
  my $result;
  $grp->{top}->Busy(-recurse=> 1);

  unless ($result=findPrevTemplated($grp,$template,$cont)) {
    redraw_win($grp->{focusedWindow});
    $grp->{top}->toplevel->
      messageBox(-icon=> 'warning',
		 -message=> $grp->{stopSearch} ? "Interrupted by user!" : "No matching node found!",
		 -title=> 'Find',
		 -type=> 'ok');
  }
  $grp->{top}->Unbusy();
  return $result;
}

######################################
# compare nodes with template
######################################
sub cmpTemplateField {
  my ($grp,$val,$templ)=@_;
  my $method=substr($grp->{templateMatchMethod},0,1);
  return $val=~ /^$templ$/ if ($method eq 'E');
  return $val=~ /$templ/ if ($method eq 'R');
  return $val eq $templ if ($method eq 'L');
  if ($method eq 'W') {
    $templ=~s/[.^$(){}<>\\]/\\\&/g;
    $templ=~s/\*/.\*/g;
    $templ=~s/\?/./g;
    return $val=~ /^$templ$/;
  }
  return $val eq $templ;
}

######################################
# go to next node in searchlist
######################################
sub nextNodeInSearchFilelist {
  my ($grp,$node,$tree)=@_;
  my $win=$grp->{focusedWindow};

  $node=(HNext($win,$node) || 
	 $win->{FSFile}->treeList->[(++$$tree)]);
  return $node if ($node or !defined($grp->{searchFilelist}));

  # this realises filelist search
  local $insideEval=1;
  my $result=nextFile($grp,1);
  $win->{treeNo}=-1; # force redraw in gotoTree
  $$tree=0;
  # we especially wait for Escape
  _quick_update($grp);
  while (!$grp->{stopSearch} and $result and !$win->{currentNode}) {
    $result=nextFile($grp,1);
    # we especially wait for Escape
    _quick_update($grp);
    $win->{treeNo}=-1; # force redraw in gotoTree
  }
  return (!$grp->{stopSearch} and $result) ? $win->{currentNode} : undef;
}

######################################
# find next matching node
######################################
sub findFirstTemplated {
  my ($grp,$template,$skipfirst)=@_;

  my $win=$grp->{focusedWindow};

  return unless $win->{FSFile};
  my $node=$win->{currentNode};
  my $tree=$win->{treeNo};
  my $a;
  $grp->{stopSearch}=0;

  $node=nextNodeInSearchFilelist($grp,$node,\$tree) if ($skipfirst);
  while ($node) {
    unless (grep (!cmpTemplateField($grp,$node->getAttribute($_),$template->{$_}), keys (%$template)))
      {
	gotoTree($win,$tree);
	setCurrent($win, $node);
	centerTo($win,$node);
	return $node;
      }
    $node=nextNodeInSearchFilelist($grp,$node,\$tree);
  }
  return undef;
}

######################################
# go to the last node of a tree
######################################
sub lastSubtreeNode {
  my ($top)=@_;
  return undef unless $top;
  while ($top->firstson) {
    $top=$top->firstson;
    $top=$top->rbrother while ($top->rbrother);
  }
  return $top;
}

######################################
# go to previous node in search list
######################################
sub prevNodeInSearchFilelist {
  my ($grp,$node,$tree)=@_;
  $node=HPrev($grp->{focusedWindow},$node);
  unless ($node or $$tree==0) {
    $node=lastSubtreeNode($grp->{focusedWindow}->{FSFile}->treeList->[(--$$tree)]);
    $node=HPrev($grp->{focusedWindow},$node) unless (isShown($grp->{focusedWindow},$node));
  }
  return $node if $node or !defined($grp->{searchFilelist});

  # this realises filelist search
  local $insideEval=1;
  my $result=prevFile($grp,1);
  # we especially wait for Escape
  _quick_update($grp);
  $grp->{focusedWindow}->{treeNo}=-1; # force redraw in gotoTree
  while ($result and !$grp->{stopSearch}
	 and !$grp->{focusedWindow}->{FSFile} || $grp->{focusedWindow}->{FSFile}->lastTreeNo<0) {
    $result=prevFile($grp,1);
    # we especially wait for Escape
    _quick_update($grp);
    $grp->{focusedWindow}->{treeNo}=-1; # force redraw in gotoTree
  }
  if ($result and !$grp->{stopSearch}) {
    $$tree=$grp->{focusedWindow}->{FSFile}->lastTreeNo;
    $node=lastSubtreeNode($grp->{focusedWindow}->{FSFile}->treeList->[$$tree]);
    return $node;
  }
  return undef;
}

######################################
# find previous matching node
######################################
sub findPrevTemplated {
  my ($grp,$template,$skipfirst)=@_;
  return unless $grp->{focusedWindow}->{FSFile};
  my $node=$grp->{focusedWindow}->{currentNode};
  my $tree=$grp->{focusedWindow}->{treeNo};
  my $a;
  $grp->{stopSearch}=0;

  $node=prevNodeInSearchFilelist($grp,$node,\$tree) if ($skipfirst);

  while ($node) {
    unless (grep (!cmpTemplateField($grp,$node->getAttribute($_),$template->{$_}), keys (%$template)))
      {
	gotoTree($grp->{focusedWindow}, $tree);
	setCurrent($grp->{focusedWindow}, $node);
	centerTo($grp->{focusedWindow},$node);
	return $node;
      }
    $node=prevNodeInSearchFilelist($grp,$node,\$tree);
  }
  return undef;
}

#############################################
#End of Searching functions
#############################################
#############################################
#############################################


sub node_doubleclick_modif {
  my ($w,$grp,$mod)=@_;
  my $win=findCanvasWindow($grp,$w);
  my $tv=$win->{treeView};
  my $node=$tv->get_obj_pinfo($tv->find_item('withtag','current'));
  doEvalHook($win,"node_doubleclick_hook",$node,$mod, $w->XEvent);
}

sub node_click_modif {
  my ($w,$grp,$mod)=@_;
  my $win=findCanvasWindow($grp,$w);
  my $tv=$win->{treeView};
  my $node=$tv->get_obj_pinfo($tv->find_item('withtag','current'));
  doEvalHook($win,"node_click_hook",$node,$mod, $w->XEvent);
}

sub node_motion_modif {
  my ($w,$grp,$mod)=@_;
  my $win=findCanvasWindow($grp,$w);
  my $tv=$win->{treeView};
  my $node=$tv->get_obj_pinfo($tv->find_item('withtag','current'));
  doEvalHook($win,"node_motion_hook",$node,$mod, $w->XEvent);
}

sub text_doubleclick_modif {
  my ($w,$grp,$mod)=@_;
  my $win=findCanvasWindow($grp,$w);
  return unless($win and $win->{FSFile});
  my $attr;
  my $newvalue;

  my $tv=$win->{treeView};
  my ($t)=$tv->find_item('withtag','current');
  my $node=$tv->get_obj_pinfo($t);
  my $d;
  setCurrent($win,$node);
  $attr=$tv->get_gen_pinfo("attr:$t");

  doEvalHook($win,"text_doubleclick_hook",$node,$attr,$mod, $w->XEvent);
}

sub text_doubleclick_modif {
  my ($w,$grp,$mod)=@_;
  my $win=findCanvasWindow($grp,$w);
  return unless($win and $win->{FSFile});
  my $attr;
  my $newvalue;

  my $tv=$win->{treeView};
  my ($t)=$tv->find_item('withtag','current');
  my $node=$tv->get_obj_pinfo($t);
  my $d;
  setCurrent($win,$node);
  $attr=$tv->get_gen_pinfo("attr:$t");

  doEvalHook($win,"text_click_hook",$node,$attr,$mod, $w->XEvent);
}

sub editAttrs {
  my ($w,$grp)=@_;
  my $win=findCanvasWindow($grp,$w);
  my $tv=$win->{treeView};
  my $node=$tv->get_obj_pinfo($tv->find_item('withtag','current'));
  editAttrsDialog($win,$node);
}

sub editAttr {
  my ($w,$grp)=@_;
  my $win=findCanvasWindow($grp,$w);
  return unless($win and $win->{FSFile});
  my $attr;
  my $newvalue;

  my $tv=$win->{treeView};
  my ($t)=$tv->find_item('withtag','current');
  my $node=$tv->get_obj_pinfo($t);
  my $d;
  setCurrent($win,$node);
  $attr=$tv->get_gen_pinfo("attr:$t");

  doEditAttr($win,$node,$attr);
}


sub doEditAttr {
  my ($win,$node,$attr)=@_;
  my $grp=$win->{framegroup};
  my $result= doEvalHook($win,'do_edit_attr_hook',$attr,$node);
  return 0 if $result eq 'stop';
  my $newvalue;
  if ($win->{FSFile}->FS->isList($attr)) {
    $newvalue= editListAttr($win,$node->getAttribute($attr),$attr,$grp->{top});
    if (defined($newvalue)) {
      $win->toplevel->Busy(-recurse=> 1);
      $win->{FSFile}->notSaved(1);
      save_undo($win,prepare_undo($win));
      lastActionBookmark($grp);
      $node->setAttribute($attr,$newvalue);
      doEvalHook($win,"after_edit_attr_hook",$node,$attr,1);
      get_nodes_fsfile_tree($grp,$win->{FSFile},$win->{treeNo});
      redraw_fsfile_tree($grp,$win->{FSFile},$win->{treeNo});
      $win->toplevel->Unbusy();
    } else {
      doEvalHook($win,"after_edit_attr_hook",$node,$attr,0);
    }
    return;
  }

  if ($node->getAttribute($attr)=~/^(?:[^\|\\]|\\.)*\|/) {
    $newvalue= editAmbiguousAttr($win,$node->getAttribute($attr),$attr);
    if (defined $newvalue) {
      $grp->{top}->Busy(-recurse=> 1);
      $win->{FSFile}->notSaved(1);
      save_undo($win,prepare_undo($win));
      lastActionBookmark($grp);
      $node->setAttribute($attr,$newvalue);
      doEvalHook($win,"after_edit_attr_hook",$node,$attr,1);
      get_nodes_fsfile_tree($grp,$win->{FSFile},$win->{treeNo});
      redraw_fsfile_tree($grp,$win->{FSFile},$win->{treeNo});
      $grp->{top}->Unbusy();
    } else {
      doEvalHook($win,"after_edit_attr_hook",$node,$attr,0);
    }
    return;
  }

  $grp->{top}->Busy(-recurse=> 1);
  my $enabled=doEvalHook($win,'enable_attr_hook',$attr,"normal") ne 'stop';
  $newvalue=encode($node->getAttribute($attr));
  my $d= $grp->{top}->DialogBox(-title=> ($enabled ? "Edit Node Attribute" : "Disabled Node Attribute"),
			     -buttons=> [($enabled ? ("OK", "Cancel") : "Cancel")]);
  $d->protocol('WM_DELETE_WINDOW' => [sub { shift->{selected_button}='Cancel'; },$d]);
  $d->bind('<Return>', \&dlgReturn );
  $d->bind('all','<Escape>'=> [sub { shift; shift->{selected_button}='Cancel'; },$d]);
  $d->resizable(0,0);
  addBindTags($d,'dialog');
  my $l= $d->Label(-text=> $attr,
		    -anchor=> 'e',
		    -justify=> 'right')->pack(-side=>'left');
  my $e= $d->Entry(-relief=> 'sunken',
		    -width=> 40,
		    -state=> $enabled ? 'normal' : 'disabled',
		    -takefocus=> 1,
		    -font=> $font,
		    -textvariable=> \$newvalue)->pack();
  $e->icursor('end');
  $grp->{top}->Unbusy();
  $result= ShowDialog($d,$e,$grp->{top});
  if ($result=~ /OK/) {
    $win->{FSFile}->notSaved(1);
    save_undo($win,prepare_undo($win));
    lastActionBookmark($grp);
    $node->setAttribute($attr,decode($newvalue));
    doEvalHook($win,"after_edit_attr_hook",$node,$attr,1);
    get_nodes_fsfile_tree($grp,$win->{FSFile},$win->{treeNo});
    redraw_fsfile_tree($grp,$win->{FSFile},$win->{treeNo});
  } else {
    doEvalHook($win,"after_edit_attr_hook",$node,$attr,0);
  }
  $d->destroy;
  undef $d;
  return ($result =~ /OK/) ? 1 : 0;
}

#############################################
# redraw tree etc.
#############################################

sub nodeOptions {
  my ($win,$node)=@_;
  return $win->{treeView}->node_options($node,
					$win->{FSFile}->FS,
					$win->{currentNode});
}

sub nodeBoxOptions {
  my ($win,$node,$edge)=@_;
  return $win->{treeView}->node_box_options($node,
					 $win->{FSFile}->FS,
					 $win->{currentNode},$edge);
}

sub redraw_win {
  my ($win)=@_;
  return if $insideEval;
  if ($win == $win->{framegroup}->{focusedWindow}) {
    saveFileStateUpdate($win);
    resetUndoStatus($win);
    resetTreePosStatus($win->{framegroup});
    update_status_line($win);
  }
  #------------------------------------------------------------
  #{
  #use Benchmark;
  #my $t0= new Benchmark;
  #for (my $i=0;$i<=50;$i++) {
  #------------------------------------------------------------
  $TrEd::TreeView::on_get_root_style = [\&onGetRootStyle,$win];
  $TrEd::TreeView::on_get_node_style = [\&onGetNodeStyle,$win];
  my $vl;
  if ($win->{FSFile} and $win->{treeView}->get_drawSentenceInfo) {
    $vl=$win->{treeView}->value_line($win->{FSFile},$win->{treeNo},1,0);
  }
  $win->{treeView}->
      redraw($win->{FSFile},
	     $win->{currentNode},
	     $win->{Nodes},
	     # CHANGE THIS (this is just for printing) :
	     (defined($vl) ? $vl : "")
	    );
  setCurrent($win,$win->{currentNode}) if $win->{FSFile};
  $TrEd::TreeView::on_tree_redraw= undef; #forget the reference on $win
  $TrEd::TreeView::on_node_redraw= undef;

  #------------------------------------------------------------
  #}
  #my $t1= new Benchmark;
  #my $td= timediff($t1, $t0);
  #print "redraw: the code took:",timestr($td),"\n";
  #}
  #------------------------------------------------------------

  return;
}

sub redraw_fsfile {
  my ($grp,$fsfile)=@_;
  return if $insideEval or !$fsfile;
  foreach (fsfileDisplayingWindows($grp,$fsfile)) {
    redraw_win($_);
  }
  return;
}

sub redraw_fsfile_tree {
  my ($grp,$fsfile,$tree_no)=@_;
  return if $insideEval or !$fsfile;
  foreach (grep {$_->{treeNo} == $tree_no}
	   fsfileDisplayingWindows($grp,$fsfile)) {
    redraw_win($_);
  }
  return;
}

sub redraw_all {
  my ($grp)=@_;
  foreach (@{ $grp->{treeWindows} }) {
    redraw_win($_);
  }
  return;
}

sub follow_mouse {
  my ($w, $grp)= @_;
  my $e= $w->XEvent;
  my $win=findCanvasWindow($grp,$w);
  my($x, $y)= ($w->fpixels($e->x), $w->fpixels($e->y));
  scrollCanvasToXY($w, $win, $x, $y);
}

sub follow_mouse_press {
  my ($w, $grp)= @_;
  my $win=findCanvasWindow($grp,$w);
  my $tv=$win->{treeView};
  my $e= $w->XEvent;
  my($x, $y)= ($w->fpixels($e->x), $w->fpixels($e->y));

  $tv->store_gen_pinfo("lastX",$x);
  $tv->store_gen_pinfo("lastY",$y);
  $tv->store_gen_pinfo("lastCanvasX",$w->canvasx($x));
  $tv->store_gen_pinfo("lastCanvasY",$w->canvasy($y));
}



sub scrollCanvasToXY {
  my ($w, $win, $X, $Y)=@_;
  my ($ax,$bx)=$w->xview;
  my ($ay,$by)=$w->yview;
  my $canvasX;
  my $tv=$win->{treeView};
  no integer;
  my $sizeX=$w->fpixels($tv->{canvasWidth})*($bx-$ax);
  my $x=min($X,$sizeX);
  my $shiftX=($x-$tv->get_gen_pinfo("lastX"));
  if ($shiftX>0) {
    if ($tv->get_gen_pinfo("lastX")== $sizeX) {
      $shiftX=0;
    } else {
      $shiftX/=$sizeX-$tv->get_gen_pinfo("lastX");
      # a fraction of our right move in window
    }
    $canvasX=$shiftX*
      ($w->fpixels($tv->{canvasWidth})-
       $tv->get_gen_pinfo("lastCanvasX"));
    # this is where we should get on the canvas
  } else {
    if ($tv->get_gen_pinfo("lastX")== 0) {
      $shiftX=0;
    } else {
      $shiftX/=$tv->get_gen_pinfo("lastX");
    }
    $canvasX=$shiftX*
      $tv->get_gen_pinfo("lastCanvasX");
    # this is where we should get on the canvas
  }
  $canvasX+=$tv->get_gen_pinfo("lastCanvasX");
  $w->xview(moveto=>
	    max(0,min(1,($canvasX-$x+1+$w->fpixels($w->cget('-borderwidth')))
		      /$tv->{canvasWidth})));

  # the same for Y
  my $sizeY=$w->fpixels($tv->{canvasHeight})*($by-$ay);
  my $y=min($Y,$sizeY);
  my $shiftY=($y-$tv->get_gen_pinfo("lastY"));
  my $canvasY;
  if ($shiftY>0) {
    if ($tv->get_gen_pinfo("lastY")== $sizeY) {
      $shiftY=0;
    } else {
      $shiftY/=$sizeY-$tv->get_gen_pinfo("lastY");
      # a fraction of our right move in window
    }
    $canvasY=$shiftY*
      ($w->fpixels($tv->{canvasHeight})-
       $tv->get_gen_pinfo("lastCanvasY"));
    # this is where we should get on the canvas
  } else {
    if ($tv->get_gen_pinfo("lastY")==0) {
      $shiftY=0;
    } else {
      $shiftY/=$tv->get_gen_pinfo("lastY");
    }
    $canvasY=$shiftY*
      $tv->get_gen_pinfo("lastCanvasY");
    # this is where we should get on the canvas
  }
  $canvasY+=$tv->get_gen_pinfo("lastCanvasY");
  $w->yview(moveto=>
	    max(0,min(1,($canvasY-$y+1+$w->fpixels($w->cget('-borderwidth')))
		      /$tv->{canvasHeight})));


  $tv->store_gen_pinfo("lastX",$x);
  $tv->store_gen_pinfo("lastY",$y);
  $tv->store_gen_pinfo("lastCanvasX",$w->canvasx($x));
  $tv->store_gen_pinfo("lastCanvasY",$w->canvasy($y));
}

sub currentUnhiden {
  my ($win)=@_;
  return unless $win->{FSFile};
  unless ($win->{treeView}->{showHidden}) {
    my $node=$win->{FSFile}->FS->isHidden($win->{currentNode});
    setCurrent($win,$node->parent) if ($node and $node->parent);
  }
}

sub currentLeft {
  my $grp=$_[0];
  my $win=$grp->{focusedWindow};
  return unless $win->{FSFile};
  if ($win->{treeView}->{showHidden}) {
    if ($win->{currentNode}->lbrother) {
      setCurrent($win,$win->{currentNode}->lbrother);
      centerTo($win,$win->{currentNode});
    }
  } else {
    my $n=$win->{currentNode}->lbrother;
    my $hide=$win->{FSFile}->FS->hide;
    $n=$n->lbrother while ($n and defined($hide)
			   and ($n->getAttribute($hide) eq 'hide'));
    if ($n) {
      setCurrent($win,$n);
      centerTo($win,$win->{currentNode});
    }
  }
}

sub currentRight {
  my $grp=$_[0];
  my $win=$grp->{focusedWindow};
  return unless $win->{FSFile};
  if ($win->{treeView}->{showHidden}) {
    if ($win->{currentNode}->rbrother) {
      setCurrent($win,$win->{currentNode}->rbrother);
      centerTo($win,$win->{currentNode});
    }
  } else {
    my $n=$win->{currentNode}->rbrother;
    my $hide=$win->{FSFile}->FS->hide;
    $n=$n->rbrother while ($n and defined($hide)
			   and ($n->getAttribute($hide) eq 'hide'));
    if ($n) {
      setCurrent($win,$n);
      centerTo($win,$win->{currentNode});
    }
  }
}

sub currentRightWholeLevel {
  my $grp=$_[0];
  my $win=$grp->{focusedWindow};
  return unless $win->{FSFile};
  my $node = $win->{currentNode};
  return unless $node;
  my $level=$node->level;
  do {
    $node=HNext($win,$node);
  } while ($node and $level!=$node->level);
  if ($node) {
    setCurrent($win,$node);
    centerTo($win,$win->{currentNode});
  }
}

sub currentLeftWholeLevel {
  my $grp=$_[0];
  my $win=$grp->{focusedWindow};
  return unless $win->{FSFile};
  my $node = $win->{currentNode};
  return unless $node;
  my $level=$node->level;
  do {
    $node=HPrev($win,$node);
  } while ($node and $level!=$node->level);
  if ($node) {
    setCurrent($win,$node);
    centerTo($win,$win->{currentNode});
  }
}

sub currentDown {
  my $grp=$_[0];
  my $win=$grp->{focusedWindow};
  return unless $win->{FSFile};
  if ($win->{treeView}->{showHidden}) {
    if ($win->{currentNode}->firstson) {
      setCurrent($win,$win->{currentNode}->firstson);
      centerTo($win,$win->{currentNode});
    }
  } else {
    my $n=$win->{currentNode}->firstson;
    my $hide=$win->{FSFile}->FS->hide;
    $n=$n->rbrother while ($n and $n->getAttribute($hide) eq 'hide');
    if ($n) {
      setCurrent($win,$n);
      centerTo($win,$win->{currentNode});
    }
  }
}

sub currentUp {
  my $grp=$_[0];
  my $win=$grp->{focusedWindow};
  if ($win->{currentNode} && $win->{currentNode}->parent) {
    setCurrent($win,$win->{currentNode}->parent);
    centerTo($win,$win->{currentNode});
  }
}

sub centerToXY {
  my ($win, $x, $y)= @_;
  my ($ax,$bx)=$win->{treeView}->canvas->xview;
  my ($ay,$by)=$win->{treeView}->canvas->yview;

  my $shiftx=($bx-$ax)/2;
  my $shifty=($by-$ay)/2;
  eval {
    $win->{treeView}->canvas->xview(moveto=> min(max(0,$x/$win->{treeView}->{canvasWidth}-$shiftx),1))
      if ($win->{treeView}->{canvasWidth}-$shiftx);
    $win->{treeView}->canvas->yview(moveto=> min(max(0,$y/$win->{treeView}->{canvasHeight}-$shifty),1))
      if ($y/$win->{treeView}->{canvasHeight}-$shifty);
  }
}

sub centerTo {
  my ($win, $node)= @_;
  return unless $node;
  my $tv=$win->{treeView};
  centerToXY($win,
	     $tv->get_node_pinfo($node,"XPOS"),
	     $tv->get_node_pinfo($node,"YPOS"));
}

sub doEvalHook {
  my ($win,$hook)=(shift,shift);

  return unless $hook; # and $win->{currentNode};
  my $bookmark=bookmarkThis($win->{framegroup});
  # Save current position (as last action position)

  local $insideEval=1;
  my $oldgrp=$TredMacro::grp;
  my $oldthis=$TredMacro::this;
  my $oldroot=$TredMacro::root;
  my $context='TredMacro';
  $TredMacro::FileNotSaved='?';
  if ($win) {
    $TredMacro::this=$win->{currentNode};
    $TredMacro::root=$win->{root};
    $context=$win->{macroContext} || 'TredMacro';
  }
  $TredMacro::libDir=$libDir;
  $TredMacro::forceFileSaved=0;
  my $result=do_eval_hook($win,$context,$hook,@_);
  warn "$@\n" if $@;
  my $file_changed=$TredMacro::FileNotSaved;

  if ($win) {
    if ($win->{FSFile}) {
      if ($file_changed ne '?' and $file_changed) {
	lastActionBookmark($win->{framegroup},$bookmark);
	$win->{FSFile}->notSaved(1);
      }
    }
    saveFileStateUpdate($win);
  }

  $TredMacro::this=$oldthis;
  $TredMacro::root=$oldroot;
  $TredMacro::grp=$oldgrp;

  print STDERR "Hook $hook resulted with $result\n" if $hookDebug;
  return $result;
}

sub doEvalMacro {
  my ($win,$macro)=(shift,shift);
  return unless $macro;# and $win->{currentNode};

  my $bookmark=bookmarkThis($win->{framegroup});
  $win->toplevel->Busy(-recurse=> 1);
  $insideEval=1;

  $TredMacro::this=$win->{currentNode};
  $TredMacro::root=$win->{root};
  $TredMacro::libDir=$libDir;
  $TredMacro::FileNotSaved='?';
  $TredMacro::forceFileSaved=0;
  $TredMacro::Redraw='file';
  my $undo=prepare_undo($win);
  my $result=do_eval_macro($win,$macro);
  my $current=$TredMacro::this;
  my $file_not_saved=$TredMacro::FileNotSaved;
  $file_not_saved=1 if $file_not_saved eq '?';
  if ($win->{FSFile}) {
    if ($TredMacro::forceFileSaved) {
      print STDERR "Macro forsly claims file saved.\n";
      $win->{FSFile}->notSaved($file_not_saved ? 1 : 0);
      lastActionBookmark($win->{framegroup},$bookmark) if $file_not_saved;
    } else {
      if ($file_not_saved) {
	save_undo($win,$undo);
	$win->{FSFile}->notSaved(1);
	lastActionBookmark($win->{framegroup},$bookmark);
      } else {
	print STDERR "Macro claims file untouched\n"
      }
    }
  }
  $insideEval=0;
  #------------------------------------------------------------
  #use Benchmark;
  #my $t0= new Benchmark;
  #for (my $i=0;$i<=50;$i++) {
  ### ??? 4kb/50 runs memory leaks in redraw (probably in Tk)
  #------------------------------------------------------------
  if ($TredMacro::Redraw eq 'all') {
    redraw_all($win->{framegroup});
    get_nodes_all($win->{framegroup});
  } elsif ($TredMacro::Redraw eq 'win') {
    get_nodes_win($win);
    redraw_win($win);
  } elsif ($TredMacro::Redraw eq 'tree') {
    get_nodes_fsfile_tree($win->{framegroup},$win->{FSFile},$win->{treeNo});
    redraw_fsfile_tree($win->{framegroup},$win->{FSFile},$win->{treeNo});
  } elsif ($TredMacro::Redraw eq 'tie') {
    if ($win->{framegroup}->{tieWindows}) {
      get_nodes_all($win->{framegroup});
      redraw_all($win->{framegroup});
    } else {
      get_nodes_win($win);
      redraw_win($win);
    }
  } elsif ($TredMacro::Redraw eq 'none') {
    # do nothing
  } else {
    get_nodes_fsfile($win->{framegroup},$win->{FSFile});
    redraw_fsfile($win->{framegroup},$win->{FSFile});
  }
  #------------------------------------------------------------
  #}
  #my $t1= new Benchmark;
  #my $td= timediff($t1, $t0);
  #print "$TredMacro::FileNotSaved the code took:",timestr($td),"\n";
  #------------------------------------------------------------

  # the rest of this routine is:
  # memory ok, speed ok
  setCurrent($win,$current) if ($current);
  currentUnhiden($win);

  $TredMacro::this=undef;
  $TredMacro::root=undef;
  $TredMacro::grp=undef;

  centerTo($win,$win->{currentNode});

  $win->toplevel->Unbusy;
  return $result;
}

sub resolveKey {
  my $grp=$_[0];
 context:
  foreach my $context ($grp->{focusedWindow}->{macroContext},$grp->{focusedWindow}->{macroContext} eq "TredMacro" ? () : "TredMacro") {
    foreach my $key (@_) {
      if (exists ($keyBindings{$context}->{$key})) {
	return $keyBindings{$context}->{$key};
      }
    }
  }
  return undef;
}

sub evalMacro {
  my ($w,$grp,$prefix)=@_;
  my $win=$grp->{focusedWindow};
  my $key;
  my $e= $w->XEvent;
  my $A= $e->A;
  my $K= $e->K;
  my @possib=();
  my $macro=undef;

  print STDERR "Prefix: $prefix\n" if $keyboardDebug;
  $prefix=~s/SHIFT\+//g unless ($K=~/^(?:left|right|up|down|next|prior|space|backspace|insert|delete|return|pause|escape|home|end|begin|select|print|execute|undo|redo|menu|find|cancel|help|break|F[0-9]+|L[0-9]+|R[0-9]+|ISO_Left_Tab)$/i);
  if ($keyboardDebug) {
    print STDERR "Pressed: (".ord($A)."), prefix $prefix, keysym $K/",$e->N,"\n";
    print STDERR "Maybe: $prefix$K\n";
  }
  if ($K =~ /^XF86_Switch_VT_(\d+)$/) {
    print STDERR "Translating $shift $K to SHIFT+F$1\n" if $keyboardDebug;
    $prefix='SHIFT+';
    $K='F'.$1;
  }
  push @possib, ($prefix.$A,$prefix.$K);

  $macro=resolveKey($grp,@possib);
  if (defined $macro) {
    $grp->{statusLineText}="$prefix$A" if $tredDebug;
    $grp->{statusLineText}.=", $macro" if $tredDebug;
    update_status_line($win) if $tredDebug;
#    use Benchmark;
#    my $t0= new Benchmark;
#    # ... your code here ...
#    for (my $i=0;$i<=50;$i++) {
    doEvalMacro($win,$macro);
#    }
#    my $t1= new Benchmark;
#    my $td= timediff($t1, $t0);
#    print "the code took:",timestr($td),"\n";

    return 1;
  } else {
    $grp->{statusLineText}="$prefix$K" if $tredDebug;
    update_status_line($win) if $tredDebug;
  }
  return undef;
}

sub tieGotoTree {
  my ($grp,$no)=@_;
  if ($grp->{tieWindows}) {
    foreach (@{$grp->{treeWindows}}) {
      gotoTree($_,$no) if ($_->{FSFile});
    }
  } else {
    gotoTree($grp->{focusedWindow}) if ($grp->{focusedWindow}->{FSFile});
  }
}

sub tieNextTree {
  my ($grp)=@_;
  if ($grp->{tieWindows}) {
    foreach (@{$grp->{treeWindows}}) {
      nextTree($_) if ($_->{FSFile});
    }
  } else {
    nextTree($grp->{focusedWindow}) if ($grp->{focusedWindow}->{FSFile});
  }
}

sub tiePrevTree {
  my ($grp)=@_;
  if ($grp->{tieWindows}) {
    foreach (@{$grp->{treeWindows}}) {
      prevTree($_) if ($_->{FSFile});
    }
  } else {
    prevTree($grp->{focusedWindow}) if ($grp->{focusedWindow}->{FSFile});
  }
}

sub currentNext {
  my ($win)=@_;
  my $next=HNext($win,$win->{currentNode});
  if ($next) {
    setCurrent($win,$next);
    centerTo($win,$win->{currentNode});
  }
}


sub currentPrev {
  my ($win)=@_;
  my $prev=HPrev($win,$win->{currentNode});
  if ($prev) {
    setCurrent($win,$prev);
    centerTo($win,$win->{currentNode});
  }
}


sub node_down {
  my($w,$grp)= @_;
  my $win=findCanvasWindow($grp,$w);
  my $tv=$win->{treeView};
  my $e= $w->XEvent;
  my($x, $y)= ($e->x, $e->y);
  my $node=$tv->get_obj_pinfo($tv->find_item('withtag','current'));

  setCurrent($win,$node);
  $w->dtag('selected');
  $w->addtag('selected', 'withtag', 'current');
  $w->raise('current');
  $tv->store_gen_pinfo("lastX",$x);
  $tv->store_gen_pinfo("lastY",$y);
  $tv->store_gen_pinfo("lastCanvasX",$w->canvasx($x));
  $tv->store_gen_pinfo("lastCanvasY",$w->canvasy($y));
}				# end plot_down

sub node_move {
  my($w,$grp,$scroll)= @_;
  my $win=findCanvasWindow($grp,$w);
  my $tv=$win->{treeView};
  my $e= $w->XEvent;
  my($x, $y)= ($e->x, $e->y);
  my $node=$tv->get_obj_pinfo($tv->find_item('withtag','selected'));

  my $lcx=$tv->get_gen_pinfo('lastCanvasX');
  my $lcy=$tv->get_gen_pinfo('lastCanvasY');
  my ($ncolor,$ocolor);

  if ($scroll) {
    $ncolor=$w->itemcget('selected','-fill');
    $ocolor=$w->itemcget('selected','-outline');
    $w->itemconfigure('selected',
		      -fill=> $tv->canvas->cget('-background'),
		      -outline=> $tv->canvas->cget('-background')
		     );
    scrollCanvasToXY($w, $win, $x, $y);
  } else {
    $tv->store_gen_pinfo('lastCanvasX',$w->canvasx($x));
    $tv->store_gen_pinfo('lastCanvasY',$w->canvasy($y));
  }
  my ($cx, $cy)= ($w->canvasx($x),$w->canvasy($y));
  my $flop;
  my ($nx,$ny) = $w->coords('selected');
  my ($deltax,$deltay) = ($cx-$nx, $cy-$ny);
  $w->coords('selected', map { ($flop++%2) ? $deltay+$_ : $deltax+$_ }
	     $w->coords('selected'));
#  $w->move('selected',  $cx-$lcx, $cy-$lcy);
  $w->itemconfigure('selected', -fill=> $ncolor, -outline=> $ocolor ) if $scroll;
  my $nearest=$tv->get_obj_pinfo($tv->find_item('withtag','nearest'));
  if ($nearest) {
    $w->itemconfigure('nearest',nodeOptions($win,$nearest));
    $tv->apply_stored_style_opts("Oval",$nearest);
    $w->dtag('nearest');
  }

  my @dots= $tv->find_item('withtag','point');
  my $nearestNode=0;
  my $bestDist=10000;
  my $dist;
  foreach my $p (@dots) {
    my $n=$tv->get_obj_pinfo($p);
    if ($n and $n!=$node) {
      $dist=
	($cx-$tv->get_node_pinfo($n,"XPOS"))*
	  ($cx-$tv->get_node_pinfo($n,"XPOS"))+
	    ($cy-$tv->get_node_pinfo($n,"YPOS"))*
	      ($cy-$tv->get_node_pinfo($n,"YPOS"));
      if ($bestDist>$dist) {
	$bestDist=$dist;
	$nearestNode=$n;
      }
    }
  }
  if ($bestDist<800) {
    $w->addtag('nearest','withtag',$tv->get_node_pinfo($nearestNode,"Oval"));
    $w->itemconfigure($tv->get_node_pinfo($nearestNode,"Oval"),
		      -fill=> $tv->get_nearestNodeColor);
  }
}				# end plot_move

sub node_release {
  my($w,$grp,$button)= @_;
  my $win=findCanvasWindow($grp,$w);
  my $tv=$win->{treeView};
  return unless $win->{FSFile};
  my $e= $w->XEvent;
  my($x, $y)= ($e->x, $e->y);
  my $parent;
  my $node;
  my $center=0;
  my ($sel)=$tv->find_item('withtag','selected');
  $node=$tv->get_obj_pinfo($sel) if (defined ($sel));

  if ($node) {
    my ($p)=$tv->find_item('withtag','nearest');
    $w->dtag('selected');
    if (defined $p) {
      $parent=$tv->get_obj_pinfo($p);
      $w->itemconfigure($tv->get_node_pinfo($parent,"Oval"),
			  nodeOptions($win,$parent));
      if (doEvalHook($win,"node_release_hook",$node,$parent,"$button") ne 'stop') {
	while ($parent) {
	  $p=0, last if ($node eq $parent);
	  $parent=$parent->parent;
	}
	if ($p and $tv->get_obj_pinfo($p) 
	    and $node->parent!=$tv->get_obj_pinfo($p)) {
	  save_undo($win,prepare_undo($win));
	  my $oldparent=$node->parent;
	  Paste(Cut($node),
		$tv->get_obj_pinfo($p),
		$win->{FSFile}->FS->defs);
	  $win->{FSFile}->notSaved(1);
          doEvalHook($win,"node_moved_hook",$node,$oldparent);
	  lastActionBookmark($grp);
	  redraw_fsfile_tree($grp,$win->{FSFile},$win->{treeNo});
	  centerTo($win,$win->{currentNode});
	  return;
	}
      }
    }
    # returning node to its position
    $w->coords($sel, $tv->node_coords($node,$win->{currentNode}));
  } else { redraw_fsfile_tree($grp,$win->{FSFile},$win->{treeNo}); }
}

sub node_release_modif {
  my($w,$grp,$mod)= @_;
  my $win=findCanvasWindow($grp,$w);
  my $tv=$win->{treeView};
  return unless $win->{FSFile};
  my $e= $w->XEvent;
  my($x, $y)= ($e->x, $e->y);
  my $parent;
  my $node;
  my $center=0;
  my ($sel)=$tv->find_item('withtag','selected');
  $node=$tv->get_obj_pinfo($sel) if (defined ($sel));

  if ($node) {
    my ($p)=$tv->find_item('withtag','nearest');
    $w->dtag('selected');
    if (defined $p) {
      $parent=$tv->get_obj_pinfo($p);
      $w->itemconfigure($tv->get_node_pinfo($parent,"Oval"),
			  nodeOptions($win,$parent));
      doEvalHook($win,"node_release_hook",$node,$parent,$mod,$e);
    }
    # returning node to its position
    $w->coords($sel, $tv->node_coords($node,$win->{currentNode}));
  } else { redraw_fsfile_tree($grp,$win->{FSFile},$win->{treeNo}); }
}

sub prepare_undo {
  my ($win)=@_;
  return unless $maxUndo;
  my $fsfile=$win->{FSFile};
  return undef unless $fsfile;
  my $tree;
  require Data::Dumper;
  Fslib::PrintTree($win->{root},
	    $fsfile->FS->list,
	    $fsfile->FS->defs,
	    \$tree);
  return [$win->{treeNo},$tree,getNodeNo($win,$win->{currentNode})];
#  local $Data::Dump::Purity = 1;
#  return Data::Dumper->Dump([$win->{treeNo},$win->{root},$win->{currentNode}],
#			    [qw(treeNo root currentNode)]);
}

sub save_undo {
  my ($win,$undo)=@_;
  return unless $maxUndo;
  my $fsfile=$win->{FSFile};
  return unless ref($fsfile) and $undo;
  unless ($fsfile->userData) {
    $fsfile->changeUserData({ undostack => [], undo => -1});
  }

  my $stack=$fsfile->userData()->{undostack};
  splice @$stack, $fsfile->userData->{undo}+1; # remove redo
  push @$stack,$undo;
  if ($maxUndo>0 and @$stack>$maxUndo) {
    splice @$stack, 0, (@$stack-$maxUndo);
    print STDERR "Undo-stack: overflow, removing ",(@$stack-$maxUndo)," items\n" if $tredDebug;
  }
  $fsfile->userData->{undo}=$#$stack;
  resetUndoStatus($win);
  print STDERR "Undo-stack: $#$stack items\n" if $tredDebug;
}

sub re_do {
  my ($grp_or_win)=@_;
  my $win = cast_to_win($grp_or_win);
  return unless $maxUndo;
  my $fsfile=$win->{FSFile};
  return unless $fsfile and ref($fsfile->userData());
  my $stack=$fsfile->userData()->{undostack};
  return unless (@$stack>$fsfile->userData->{undo}+2);
  print STDERR "Redo: ",$fsfile->userData->{undo}+2,"/$#$stack\n" if $tredDebug;
  $fsfile->userData()->{undo}+=2;
  undo($win,1);
}

sub undo {
  my ($grp_or_win,$redo)=@_;
  my $win = cast_to_win($grp_or_win);
  return unless $maxUndo;
  my $fsfile=$win->{FSFile};
  return unless $fsfile and ref($fsfile->userData());
  my $stack=$fsfile->userData()->{undostack};
  my $stackpos=$fsfile->userData()->{undo};
  return unless (ref($stack) and (@$stack>0) and ($stackpos>=0) and ($stackpos <= $#$stack));
  my $undo=$stack->[$stackpos];
  if ($undo) {
    my $new_undo;
    $new_undo=prepare_undo($win) if (!$redo and $#$stack == $stackpos);
    my $treeNo=$undo->[0];
    my $tree=$undo->[1];
    $fsfile->treeList->[$treeNo]=
      GetTree2($tree,
	       $fsfile->FS->list,
	       $fsfile->FS->defs);
    if ($#$stack == $stackpos) {
      if ($redo) {
	pop @$stack;
      } else {
	push @$stack, $new_undo;
      }
    }
    print STDERR "Undo: ",$stackpos."/$#$stack\n" if $tredDebug;
    $fsfile->userData->{undo}--;
    resetUndoStatus($win);
    $fsfile->notSaved(1);
    $win->{treeNo}=$treeNo;
    $win->{currentNode}=getNodeByNo($win,$undo->[2]);

#    my ($treeNo,$root,$currentNode);
#    print STDERR "$undo\n";
#    eval $undo;
#    $win->{treeNo}=$treeNo;
#    $win->{root}=$root;
#    $fsfile->treeList->[$treeNo]=$root;
#    $win->{currentNode}=$currentNode;
    get_nodes_fsfile_tree($win->{framegroup},$fsfile,$treeNo);
    redraw_fsfile_tree($win->{framegroup},$fsfile,$treeNo);
  } else {
    errorMessage($win,"Corrupted undo stack!");
  }
}

sub resetUndoStatus {
  my ($win)=@_;
  my $fsfile=$win->{FSFile};
  my ($undostatus,$redostatus);

  if ($maxUndo!=0 and ref($fsfile) and $fsfile->userData()) {
    my $stack=$fsfile->userData()->{undostack};
    my $stackpos=$fsfile->userData()->{undo};
    print STDERR "STATUS: $stackpos/",$#$stack+1,"\n" if $tredDebug;
    $undostatus=(ref($stack) && (@$stack>0));
    $redostatus=($undostatus && (@$stack>$stackpos+2));
    $undostatus &&= (($stackpos>=0) && ($stackpos <= $#$stack));
  } else {
    $undostatus=0;
    $redostatus=0;
  }
  if ($win->{framegroup}->{undoButton}) {
    $win->{framegroup}->{undoButton}->
      configure(-state => ($undostatus ? 'normal' : 'disabled'));
  }
  if ($win->{framegroup}->{redoButton}) {
    $win->{framegroup}->{redoButton}->
      configure(-state => ($redostatus ? 'normal' : 'disabled'));
  }
}

sub resetTreePosStatus {
  my ($grp)=@_;
  my $win=$grp->{focusedWindow};
  my $fsfile=$win->{FSFile};

  my $prevstatus=ref($fsfile) && $fsfile->lastTreeNo>=0 && $win->{treeNo}>0;
  my $nextstatus=ref($fsfile) && $fsfile->lastTreeNo>$win->{treeNo};
  if ($win->{framegroup}->{nextButton}) {
    $win->{framegroup}->{nextButton}->
      configure(-state => ($nextstatus ? 'normal' : 'disabled'));
  }
  if ($win->{framegroup}->{prevButton}) {
    $win->{framegroup}->{prevButton}->
      configure(-state => ($prevstatus ? 'normal' : 'disabled'));
  }
}


sub list_isearch {
  my ($w)=@_;
  my $e= $w->XEvent;
  my $A= $e->A;
  if ($A ne "") {
    my @items=$w->get(0,'end');
    my $count=$w->index('end');
    my $active=$w->index('active');
    for (my $i=$active+1;$i<=$active+$count;$i++) {
      if ($items[$i % $count] =~ /^$A/i) {
	$w->activate($i % $count);
	unless ($w->isa('Tk::Listbox') and
	    $w->cget('-selectmode') eq 'multiple' or
	    $w->cget('-selectmode') eq 'extended') {
	  $w->selectionClear(0,'end');
	  $w->selectionSet($i % $count);
	}
	$w->see($i % $count);
	Tk->break;
	return;
      }
    }
  }
}

sub _set_encoding {
  my ($fh, $enc, $what)=@_;
  if ($enc and $]>=5.008) {
    eval {
      print STDERR ("forcing encoding $enc for $what\n") if $debug;
      $fh->flush();
      binmode $fh; # first get rid of all I/O layers
      if ($enc =~ /^:/) {
	binmode $fh,$enc;
      } else {
	binmode $fh,":encoding($enc)";
      }
    };
    print STDERR $@ if $@;
  }
}
