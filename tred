#!/usr/bin/perl
#
# Tred ver. 0.3 - Copyright (C) 2000 by Petr Pajas
# This software is covered by GPL - The General Public Licence
# Full text of the GPL can be found at http://www.gnu.org/copyleft/gpl.html.
#
# This is "Tred" - a simple viewer/editor of tree graphs in fs
# file-format used in Graph - program developed by M. Kren. It is
# written entirely in Perl and for graphical output it uses PerlTk
# library as a frontend to Tk toolkit
#
# Usage:
# tred [-m <macro-file>] file1[##N|#N] [file2[##N|#N] [...]]
#
# Files file1,etc. given on the command-line must be in fs-format (for
# not a little bit obsolete description see:
# http://ufal.ms.mff.cuni.cz/local/doc/trees/format_fs.html)
#
# The name of each file may be followed by a suffices of the
# following form:
#
# #N   where N is a number possibly followed by one or more upper-case
#      letters
# ##N  where N is a number
#
# In the firstcase, #N tells tred to skip, after opening the file, to
# the first tree the root of which has #N as a value of attribute
# called 'form' (this feature is optimized for specific instances of
# fs-format used while working on The Prague Dependency Treebank)
#
# The later form '##N' simply makes tred to go to the N-th tree in the
# given file.
#
#
# -m may be used to specify a macro to be used different from the
# given in ~/.tredrc (or whatsoever) configuration file
#
# -c may be used to specify a config-file to be used (overrides
# ~/.tredrc and all the other files Tred would otherwise try to search for).
#

# this variable is used when searching for rc-file (i.e. the inicialisation file)
my @configFileSearchList=($ENV{HOME}.'/.tredrc',
			  (exists $ENV{TREDHOME}) ? $ENV{TREDHOME}.'/tredrc' : (),
			  dirname($0).'tredrc',
			  dirname($0).'../lib/tredlib/tredrc',
			  dirname($0).'tredlib/tredrc',
			  dirname($0).'../lib/tred/tredrc',
			  '/usr/X11R6/lib/X11/app-defaults');

# other configuration should be given in that file


my $libDir;
# Default values of $libDir used to search for macro-file (tred.mac)
# and default-macro file (tred.def) are specified here. They may be
# overriden by value of LibDir in tred resource file (tredrc or ~/.tredrc - see above).

if (exists $ENV{TREDHOME}) {
  $libDir=$ENV{TREDHOME};
} elsif (-d dirname($0).'tredlib') {
  $libDir=dirname($0).'tredlib';
} elsif (-d dirname($0).'../lib/tredlib') {
  $libDir=dirname($0).'../lib/tredlib';
} elsif (-d dirname($0).'../lib/tred') {
  $libDir=dirname($0).'../lib/tred';
}
print "Trying $libDir\n" if ($libDir);


$macroFile=undef;

if ($ARGV[0] eq '-c') {
  shift @ARGV;
  @configFileSearchList=(shift @ARGV); # override any other possible config files
}

readConfig();

$macroFile="$libDir/tred.mac" unless (defined $macroFile);

if ($ARGV[0] eq '-m') {
  shift @ARGV;
  $macroFile=shift @ARGV;
}



unless (-d $libDir) {
  print <<'EOL';
 Tred couldn't find a tredlib directory. You may need to point
 to its location by the TREDHOME variable or add a correct LibDir
 field to your .tredrc.

EOL
    die "Error: Couldn't find lib-directory.";
}


##################### character encoding functions ########################

%encodings = (
	      'iso-8859-2' => "ì¹èø¾ýáíéìúùóò»ïµà¶å¼æñÌ©ÈØ®ÝÁÍÉÌÚÙÓÒ«Ï¥À¦Å¬ÆÑ",
	      'ascii' => "escrzyaieeuuontdlrslzcnESCRZYAIEEUUONTDLRSLZCN",
	      'iso-8859-1' => "escrzýáíéeúuóntdlrslzcnESCRZÝÁÍÉEÚUÓNTDLRSLZCN",
	      'windows-1250' => "ìšèøžýáíéìúùóòï¾àœåŸæñÌŠÈØŽÝÁÍÉÌÚÙÓÒÏ¼ÀŒÅÆÑ"
	     );

sub encode {
  return join("",@_) if ($inputenc eq $outputenc);

  local $_=join "",@_;
  eval " tr/$encodings{$inputenc}/$encodings{$outputenc}/";
  return $_;
}

sub decode {
  return join("",@_) if ($inputenc eq $outputenc);

  local $_=join "",@_;
  eval " tr/$encodings{$outputenc}/$encodings{$inputenc}/";
  return $_;
}

$inputenc="iso-8859-2";
if ($^O =~ /^MS/) {
  $outputenc="windows-1250";
} else {
  $outputenc="iso-8859-2";
}

################ end of character encoding functions ########################

use Tk;
use Tk::LabFrame;
use Tk::Listbox;
use Tk::Balloon;
use Tk::DialogBox;
use Tk::Tiler;
use locale;
use POSIX qw(locale_h);



Tk::CmdLine::SetArguments();	# handle standard arguments for X resources

push @INC,$libDir;
require Fslib;
import Fslib;
import Fslib qw(&Ord &Value &Hide &SentOrd &AOrd &AValue &AHide &ASentOrd);


my @macros=();

if ($useCzechLocales) {
  setlocale(LC_COLLATE,"cs_CZ");
  setlocale(LC_NUMERIC,"us_EN");
  setlocale(LANG,"czech");
}

my %attribs = ();
my @atord = ();

my @files=@ARGV;
my @trees=();
my @header=();
my @nodes=();
my @rest=();

my $root, $this;
my $_NoSuchTree; # for compatibility with Graph2Tred
my $NodeClipboard;


my $insideEval=0;
my $FileNotSaved=0;
my $fileNo=0;
my $filecount=$#files+1;

%pckey_shift_translates = (exclam => 1, at => 2, numbersign => 3,
			   dollar => 4, percent => 5, asciicircum => 6,
			   ampersand => 7, asterisk => 8, parenleft => 9,
			   parenright => 0, plus => 'equal', underscore => 'minus',
			   less => 'comma', greater => 'period', question => 'slash',
			   colon => 'semicolon', quotedbl => 'apostroph',
			   braceleft => 'bracketleft', braceright => 'bracketright',
			   bar => 'backslash', asciitilde => 'grave'
			  );

sub dirname {
  $_=shift;  
  return (m!/!)? (substr($_,0,rindex($_,"/")+1)) : "./";
}

print STDERR "Reading macros from $macroFile\n";
readMacros($macroFile);		# read macros
startMain($files[$fileNo]);	# display first tree

closeFile();

exit;

############################
############################
############################

sub min {
  my ($a,$b)=@_;
  return ($a<$b)?$a:$b;
}

sub max {
  my ($a,$b)=@_;
  return ($a<$b)?$b:$a;
}


sub readConfig {
  #
  # Simple configuration file handling
  #
  my %confs;
  my $key;
  local *F;

  # open first existing file in config-file list
  while ($_=shift @configFileSearchList) {
    if (open(F,"<$_")) {
      print "Using resource file $_\n";
      last;
    }
  }
  if (defined($_)) {
    while (<F>) {
      unless (/^[;#]/ or /^$/) {
	chomp;
	if (/^\s*([a-zA-Z_]+[a-zA-Z_0-9]*)\s*=\s*('(?:[^\\']|\\.)*'|"(?:[^\\"]|\\.)*"|(?:\s*(?:[^;\\\s]|\\.)+)*)/) {
	  $confs{$1}=$2;
	  $key=$1;
	  $confs{$key}=~s/\\//g;
	  $confs{$key}=$1 if ($confs{$key}=~/^'(.*)'$/ or $confs{$key}=~/^"(.*)"$/);
	  #print "$key=$confs{$key};\n";
	}
      }
    }
    close F;
  } else {
    print 
      "Warning: Cannot open any file in:\n",join(":",@configFileSearchList),"\n" .
      "         Using configuration defaults!\n";
  }
  $appName=(exists $confs{AppName}) ? $confs{AppName} : "Tred ver. 0.3";
  $baseXPos=(exists $confs{BaseXPos}) ? $confs{BaseXPos} : 15;
  $baseYPos=(exists $confs{BaseYPos}) ? $confs{BaseYPos} : 15;
  $nodeWidth=(exists $confs{NodeWidth}) ? $confs{NodeWidth} : 5;
  $nodeHeight=(exists $confs{NodeHeight}) ? $confs{NodeHeight} : 5;
  $nodeXSkip=(exists $confs{NodeXSkip}) ? $confs{NodeXSkip} : 5;
  $nodeYSkip=(exists $confs{NodeYSkip}) ? $confs{NodeYSkip} : 10;
  $xmargin=(exists $confs{Xmargin}) ? $confs{Xmargin} : 2;
  $ymargin=(exists $confs{Ymargin}) ? $confs{Ymargin} : 2;
  $buttonsRelief=(exists $confs{ButtonsRelief}) ? $confs{ButtonsRelief} : 'raised';
  $menubarRelief=(exists $confs{MenubarRelief}) ? $confs{MenubarRelief} : 'raised';
  $lineWidth=(exists $confs{LineWidth}) ? $confs{LineWidth} : 1;
  $lineColor=(exists $confs{LineColor}) ? $confs{LineColor} : 'black';
  $lineArrow=(exists $confs{LineArrow}) ? $confs{LineArrow} : 'none';  
  $nodeColor=(exists $confs{NodeColor}) ? $confs{NodeColor} : 'yellow';  
  # $activeNodeColor=(exists $confs{ActiveNodeColor}) ? $confs{ActiveNodeColor} : 'blue';
  $currentNodeColor=(exists $confs{CurrentNodeColor}) ? $confs{CurrentNodeColor} : 'red';
  $nearestNodeColor=(exists $confs{NearestNodeColor}) ? $confs{NearestNodeColor} : 'green';
  $textColor=(exists $confs{TextColor}) ? $confs{TextColor} : 'black';
  $textColorShadow=(exists $confs{TextColorShadow}) ? $confs{TextColorShadow} : 'darkgrey';
  $textColorHilite=(exists $confs{TextColorHilite}) ? $confs{TextColorHilite} : 'darkgreen';
  $textColorXHilite=(exists $confs{TextColorXHilite}) ? $confs{TextColorXHilite} : 'darkred';
  $activeTextColor=(exists $confs{ActiveTextColor}) ? $confs{ActiveTextColor} : 'blue';
  $boxColor=(exists $confs{BoxColor}) ? $confs{BoxColor} : 'wheat';
  $currentBoxColor=(exists $confs{CurrentBoxColor}) ? $confs{CurrentBoxColor} : 'white';
  $backgroundColor=(exists $confs{BackgroundColor}) ? $confs{BackgroundColor} : undef;
  $font=(exists $confs{Font}) ? $confs{Font} : '-*-helvetica-medium-r-normal-*-12-*-*-*-*-*-*-2';
  # $font=(exists $confs{Font}) ? $confs{Font} : '-misc-fixed-*-*-*-*-15-*-2';
  $type1font=(exists $confs{Type1Font}) ? $confs{Type1Font} : '-ult1mo-arial-medium-r-*-*-*-*-*-*-*-*-*-2';
  $libDir=(exists $confs{LibDir}) ? <$confs{LibDir}> : $libDir;
  $appIcon=(exists $confs{AppIcon}) ? <$confs{AppIcon}> : "$libDir/tred.xpm";
  $psFontFile=(exists $confs{PsFontFile}) ? 
    ((-d <$confs{PsFontFile}>) ? <$confs{PsFontFile}> : "$libDir/".$confs{PsFontFile}) : 
      "$libDir/csarialm.pfa";
  $psFontName=(exists $confs{PsFontName}) ? <$confs{PsFontName}> : "Arial-Medium";
  $psFontSize=(exists $confs{PsFontSize}) ? <$confs{PsFontSize}> : "12";
  $macroFile=(exists $confs{MacroFile}) ? <$confs{MacroFile}> : $macroFile;
  $defaultMacroFile=(exists $confs{DefaultMacroFile}) ? <$confs{DefaultMacroFile}> : "$libDir/tred.def";
  $prtFmtWidth=(exists $confs{PrtFmtWidth}) ? $confs{PrtFmtWidth} : '21c';
  $prtFmtHeight=(exists $confs{PrtFmtHeight}) ? $confs{PrtFmtHeight} : '297m';
  $prtVMargin=(exists $confs{PrtVMargin}) ? $confs{PrtVMargin} : '3c';
  $prtHMargin=(exists $confs{PrtHMargin}) ? $confs{PrtHMargin} : '1c';
  $psMedia=(exists $confs{PsMedia}) ? $confs{PsMedia} : '%%DocumentMedia: A4 595 842 white()';
  $psFile=(exists $confs{PsFile}) ? <$confs{PsFile}> : 'tred.ps';
  $drawBoxes=(exists $confs{DrawBoxes}) ? $confs{DrawBoxes} : 0;
  $highlightAttributes=(exists $confs{HighlightAttributes}) ? $confs{HighlightAttributes} : 1;
  $maximizePrintSize=(exists $confs{MaximizePrintSize}) ? $confs{MaximizePrintSize} : 0;
  $showHidden=exists ($confs{ShowHidden}) ? $confs{ShowHidden} : 0;
  $createMacroMenu=(exists $confs{CreateMacroMenu}) ? $confs{CreateMacroMenu} : 0;
  $maxMenuLines=(exists $confs{MaxMenuLines}) ? $confs{MaxMenuLines} : 30;
  $useCzechLocales=(exists $confs{UseCzechLocales}) ? $confs{UseCzechLocales} : 1;
  print "finished reading ini-file\n";
}


sub readMacros {
  # This subroutine reads macro file. Macros are usual perl
  # subroutines and may use this program's namespace. They are also
  # provided some special names for certain variables which override
  # the original namespace.

  # Macros may be bound to a keysym with a special form of a comment.
  # The synax is:
  #
  # # bind MacroName to key [[Modifyer+]*]KeySym
  #
  # which causes subroutine MacroName to be bound to keyboard event of
  # simoultaneous pressing the optionally specified Modifyer(s) (which
  # should be some of Shift, Ctrl and Alt) and the specified KeySym
  # (this probabbly depends on platform too :( ).


  my ($file)=@_;
  my $nextBind=undef;
  my $macro;
  my $key;
  local *F;

  %keyBindings=();
  %menuBindings=();
  @macros=();

  print "ERROR: Cannot open macros!\n", return 
    unless open(F,"<$defaultMacroFile");
  push @macros, <F>;
  close F;

  print "ERROR: Cannot open macros!\n", return 
    unless open(F,"<$file");
  
  while (<F>) {
    push @macros,$_;
    if (/\#[ \t]*bind[ \t]+(\w*)[ \t]+(?:to[ \t]+)?(?:key(?:sym)?[ \t]+)?([^ \t\r\n]+)(?:[ \t]+menu[ \t]+(.+))?/) {
      $macro=$1;
      $key=uc($2);
      $menu=$3;
      #print "binding $key [$menu] => $macro\n";
      $keyBindings{$key}=$macro;
      $menuBindings{$menu}=[$macro,$key] if ($menu);
    } elsif (/\#[ \t]*insert[ \t]+(\w*)[ \t]+(?:as[ \t]+)?(?:menu[ \t]+)?(.+)/) {
      $macro=$1;
      $menu=$2;
      #print "binding [$menu] => $macro\n";
      $menuBindings{$menu}=[$macro,undef];
    }
  }
  close(F);
}

sub nextFile {
  return 0 if ($fileNo >= $#files);
  my ($grp)=@_;
  askSaveFile($grp);
  $fileNo++;
  openFile($files[$fileNo],$grp);
  return 1;
}
sub prevFile {
  return 0 unless ($fileNo > 0);
  my ($grp)=@_;
  askSaveFile($grp);
  $fileNo--;
  openFile($files[$fileNo],$grp);
  return 1;
}

sub closeFile {
  my $grp=shift;
  my $key;

  @nodes=();
  undef $NodeClipboard;
  undef $root;
  delete $grp->{'currentNode'} if (exists $grp->{'currentNode'});
  undef %{$grp->{pinfo}} if ($grp->{pinfo});
  foreach (@trees) { DeleteTree($_); }
  undef @trees;
  undef @header;
  undef @rest;

  @trees = ();
  @header = ();
  @rest = ();
  @atord=();
  %attribs=();
}

sub openFile {
  my $f = shift;
  my $grp = shift;
  my $goto = undef;
  my @d=();

  $grp->{'top'}->Busy(-recurse => 1);

  closeFile($grp);

  if ($f=~/(##?[0-9A-Z]+)$/) {
    $f=~s/(##?[0-9A-Z]+)$//;
    $goto=$1;
  }

  # opening file
  die "cannot open $f!\n" unless open(F,"<$f");

  #reading attribs
  %attribs=ReadAttribs(\*F,\@atord,2,\@header);

  # reading trees 
  while ($_=ReadTree(\*F)) {
    if (/^\[/) {
      $root=GetTree($_,\@atord,\%attribs);
      push(@trees, $root) if $root;
    } else { push(@rest, $_); }
  }
  close (F);

  #parse Rest
  #print "@rest\n";
  @d= $rest[0]=~/[,\(]([0-9]+)/g;
  #print "Displaying:\n@d\n";
  @displayAttrs = map { $atord[$_] } @d;
  #print "That is:\n@displayAttrs\n";
  
  print STDERR "empty file!\n" if ($#trees<0);

  $treeNo=0;

  # -- smells like proprietary code, at least the second case
  if (defined $goto) {
    if ($goto=~/^##([0-9]+)$/) {
      $treeNo=min(max(0,$1),$#trees);
    }
    for (my $i=0;$i<=$#trees;$i++) {
      $treeNo=$i,last if ($trees[$i]->{'form'} eq $goto);
    }
  }
  # --
  $grp->{'currentFile'}=$f;
  $grp->{'top'}->title("$appName ".$f);
  getNodes($grp);
  $FileNotSaved=0;
  redraw_tree($grp);
  $grp->{'top'}->Unbusy();
  return 1;
}

sub saveFile {
  my $grp=shift;
  my $f=$grp->{'currentFile'};
  my @atrIds=();

  return unless $grp->{'currentFile'};

  rename $f,$f."~";
  die "cannot open $f for writing!\n" unless open(FO,">$f");
  print FO @header;
  PrintFS(\*FO,\@header,\@trees,\@atord,\%attribs);
  my $atrLine=shift @rest;

  for (my $i=0;$i<=$#atord;$i++) {    
    push @atrIds, $i if (grep {$_ eq $atord[$i]} @displayAttrs);
  }
  print FO "(";
  print FO join ",",@atrIds;
  print FO ")\n";
  #print "Saving with", join ",",@atrIds;
  #print "\n";
  print FO @rest;
  close(FO);
  $FileNotSaved=0;
  #print STDERR "wrote $f, $f~ is a backup.\n";
}


sub getNodes {
# prepare value line and @nodes list with deleted/saved hidden
# and ordered by real Ord

  my ($grp)=@_;
  my @unsorted=();
  $treeNo=0 if ($treeNo<0);
  $treeNo=$#trees if ($treeNo>$#trees);
  @nodes=();
  my @sent=();
  $root=$trees[$treeNo];
  my $node=$root;
  my $current=$root;

  $valueLine="";

  while ($node) {
    push @sent,$node;
    $node=Next($node);
  }
  my $defs = join ",", values %attribs;

  # this is a workaround for TR vs. ATS (ATS trees use only @N to sort
  # @V to a sentence while on TR there is @W defined for this purpose)

  if ($defs=~/W/) {
    @sent = sort { SentOrd($a,\%attribs) <=> SentOrd($b,\%attribs) } @sent;
  } else {
    @sent = sort { Ord($a,\%attribs) <=> Ord($b,\%attribs) } @sent;
  }
  $valueLine = encode(join(" ", map { Value($_,\%attribs) } @sent));

  $node=$root;
  loop: while($node)
  {
    #skip hidden subtrees
    if (not $showHidden and
	defined(Hide($node,\%attribs)) and
	(Hide($node,\%attribs) eq 'hide')) {
      while ($node) {
	if (RBrother($node)) {
	  $node=RBrother($node);
	  next loop;
	}
	$node = Parent($node);
      }
      next loop;
    }
    push @unsorted, $node;
    $node=Next($node);

    $current=$node if (exists $grp->{'currentNode'} and
		       $grp->{'currentNode'} eq $node);
  }
  $grp->{'currentNode'}=$current;
  @nodes=sort { Ord($a,\%attribs) <=> Ord($b,\%attribs)} @unsorted;

  # jus for sure
  undef @sent;
  undef @unsorted;

  # this is actually a workaround for TR, where two different nodes
  # may have the same Ord
}

sub printDialog {
  my $grp=shift;

  return unless $grp->{currentFile};

  my $com=$grp->{'printCommand'};
  my $fil=$grp->{'printPsFile'};
  my $toFile=$grp->{'printToFile'};
  my $toEPS=$grp->{'printToEPS'};
  my $useType1Font=$grp->{'printUseType1Font'};
  my $printRange=$grp->{'printRange'};

  my $d = $grp->{'top'}->DialogBox(-title => "Print current tree",
				-buttons => ["OK", "Cancel"]);
  $d->resizable(0,0);
  addBindTags($d,'dialog');
  $d->bind('all','<Tab>',[sub { shift->focusNext; }]);
  $d->bind('all','<Shift-Tab>',[sub { shift->focusPrev; }]);
  my $cf = $d->Frame();
  my $cl = $cf->Label(-text => 'Print command:',
		     -anchor => 'w',
		     -justify => 'right')->pack(-side => 'left');

  my $ce = $cf->Entry(-relief => 'sunken',
		     -width => 20,
		     -font => $font,
		     -state => $toFile ? 'disabled' : 'normal',
		     -textvariable => \$com)->pack(-side => 'left');

  $cf->pack(-pady => '5m', -side=>'top');
  my $ff=$d->Frame();
  my $fl = $ff->Label(-text => 'File name:',
		     -anchor => 'w',
		     -justify => 'right')->pack(-side => 'left');

  my $fe = $ff->Entry(-relief => 'sunken',
		     -width => 20,
		     -state => $toFile ? 'normal' : 'disabled' ,
		     -font => $font,
		     -textvariable => \$fil)->pack(-side => 'left');

  my $of=$d->Frame();
  my $bf=$of->Frame();
  $bf->Checkbutton(-text     => 'Print to file',
		   -variable => \$toFile,
		   -command  => [sub {
				  my ($t,$c,$f)=@_;
				  if ($$t) {
				    $f->focus;
				    $c->configure(-state => 'disabled');
				    $f->configure(-state => 'normal');
				  } else {
				    $c->focus;
				    $f->configure(-state => 'disabled');
				    $c->configure(-state => 'normal');
				  }
				},\$toFile,$ce,$fe ],
		   -relief   => 'flat')->pack(-fill => 'y',-anchor => 'nw');

  $bf->Checkbutton(-text     => 'Create EPS',
			  -variable => \$toEPS,
			  -relief   => 'flat')->pack(-fill => 'y',-anchor => 'nw');

  $bf->Checkbutton(-text     => 'Use Type1 Postscript Font',
			  -state => $type1font ? 'normal' : 'disabled' ,
			  -variable => \$useType1Font,
			  -relief   => 'flat')->pack(-fill => 'y',-anchor => 'nw');

  $bf->pack(-side => 'right');
  $of->pack(-fill => 'x',-padx=>'1c');
  my $sf = $d->Frame();
  $sf->Label(-text => 'Page range:',
	     -anchor => 'w',
	     -justify => 'right')->pack(-side => 'left');
  $sf->Entry(-relief => 'sunken',
	     -width => 20,
	     -font => $font,
	     -textvariable => \$printRange)->pack(-side => 'left', -padx=>'2m');
  $sf->pack(-side => 'bottom', -pady => '5m');
  $ff->pack(-side => 'bottom', -pady => '5m');

  $toFile ? $fe->focus : $ce->focus;
  my $result = ShowDialog($d);
  $grp->{'printRange'}=$printRange;
#  $grp->{'printSelection'}= join(' ',grep { $lt->selectionIncludes($_) } (0 .. $lt->size-1));
  $grp->{'printToFile'}=$toFile;
  $grp->{'printToEPS'}=$toEPS;
  $grp->{'printPsFile'}=$fil;
  $grp->{'printCommand'}=$com;
  $grp->{'printUseType1Font'}=$useType1Font;
  undef $d;
  return ($result =~ /OK/);
}

sub printThis {
  my ($grp)=@_;
  my $i;
  my $c=$grp->{'canvas'};
  my $saveTreeNo=$treeNo;
  my $savefont=$font;
  my $pagewidth;
  my $pageheight;
  my $printMultiple;
  my @printList=();
  my %pso;

  if (not printDialog($grp)) {
    #print "Printing aborted!\n";
    return;
  }

  {
    local $outputenc='iso-88859-2';
    local $lineColor='black';
    local $nodeColor='black';
    local $backgroundColor='white';
    local $currentBoxColor='white';
    local $boxColor='white';
    local $currentNodeColor = 'white';
    local $nearestNodeColor= 'white';
    local $textColor = 'black';
    local $textColorShadow = 'black';
    local $textColorHilite = 'black';
    local $textColorXHilite = 'black';
    local $activeTextColor='black';
    local $lineWidth=1;
    local $font=$savefont;
    print "$font\n";
    

    my $pbeg;
    my $pend;
    foreach (split /,/,$grp->{'printRange'}) {
      print "Parsing $_\n";
      if (/^\s*([0-9]+)\s*$/ and $1<=$#trees) {
	print "Prepairing $1\n";
	push @printList,$1;
	next;
      }
      if (/^\s*([0-9]*)\s*-\s*([0-9]*)\s*$/) {
	print "Prepairing $1-$2\n";
	($pbeg,$pend)=($1,$2);
	$pend=$#trees if ($pend eq '');
	$pbeg=0 if ($pbeg eq '');
	$pend=min($#trees,$pend);
	next unless ($pbeg<=$pend);
	push @printList,$pbeg..$pend;
      }
    }
    #  @printList=split ' ',$grp->{'printSelection'};
    push @printList,$treeNo+1 unless (@printList);

    unless (open(F,"<$psFontFile")) {
      print STDERR "Aborting: failed to open font file $psFontFile\n";
      return 0;
    }
    if ($grp->{'printToFile'}) {
      #print "Trying to print to ",$grp->{'printPsFile'},"\n";
      return 0 unless open(O,">".$grp->{'printPsFile'});
      #print "File successfully opend!\n";
    } else {
      #print "Trying to print via command ",$grp->{'printCommand'},"\n";
      $SIG{'PIPE'} = sub {};
      return 0 unless open(O, "| ".$grp->{'printCommand'});
      #print "Pipe successfully opend!\n";
    }

#    $grp->{top}->Busy(-recurse => 1);

    for (my $t=0;$t<=$#printList;$t++) {
      print "Printing $printList[$t]\n";
      $font=$type1font if ($grp->{printUseType1Font});
      $printList[$t]!=$treeNo+1 ? gotoTree($printList[$t]-1,$grp) : redraw_tree($grp);
      my $rotate =  (!$grp->{printToEPS} and ($grp->{canvasHeight}<$grp->{canvasWidth}));
      print $grp->{canvasHeight},"x",$grp->{canvasWidth}," $rotate\n";
      if (not $rotate) {
	$pagewidth=$c->fpixels($prtFmtWidth)-2*$c->fpixels($prtHMargin);
	$pageheight=$c->fpixels($prtFmtHeight)-2*$c->fpixels($prtVMargin);
      } else {
	$pagewidth=$c->fpixels($prtFmtHeight)-2*$c->fpixels($prtVMargin);
	$pageheight=$c->fpixels($prtFmtWidth)-2*$c->fpixels($prtHMargin);
      }

      %pso = (qw/-colormode gray -x 0 -y 0/,
	      -fontmap => { $font => [$psFontName, $psFontSize] },
	      -width => $grp->{canvasWidth},
	      -height => $grp->{canvasHeight},
	      -rotate => $rotate);

      unless ($grp->{printToEPS}) {
	#print "Maximizing: $maximizePrintSize\n";
	if ($maximizePrintSize or $c->fpixels($grp->{canvasWidth})>$pagewidth or
	    $c->fpixels($grp->{canvasHeight})>$pageheight) {
	  print "Adjusting print size\n";
	  if ($c->fpixels($grp->{canvasWidth})/$pagewidth*$pageheight>$c->fpixels($grp->{canvasHeight})) {
	    #print "Applying width\n";	  
	    $pso{-pagewidth} = 
	      $pagewidth; 
	    print "Scaling by tree width,\n";
	    print "forcing box width to $pagewidth\n";
	    #$c->fpixels($prtFmtWidth)-2*$c->fpixels($prtHMargin);
	  } else {
	    #print "Applying height\n";
	    $pso{-pageheight} = 
	      $pageheight; 
	    print "Scaling by tree height,\n";
	    print "forcing box height to $pageheight\n";
	    #$c->fpixels($prtFmtHeight)-2*$c->fpixels($prtVMargin);
	  }
	}
      }

      my @ps = split /\n/,$c->postscript(%pso);
      $i=0;
      if ($t>0) { 
	$i++  while ($i<=$#ps and $ps[$i]!~/^%%Page:/);      
	print O '%%Page: ',$t+1," ",$t+1,"\n";
	my $now=localtime;
	unless ($grp->{printToEPS}) {
	  print O "gsave\n",
	    "/Arial-Medium findfont 8 scalefont setfont\n",
	      "0.000 0.000 0.000 setrgbcolor AdjustColor\n",
		"40 40 [\n",
		  "(File ",$grp->{currentFile},".    Printed by Tred on $now.)\n",
		    "] 13 -0 0 0 false DrawText\ngrestore\n";
	}
	$i++;
      } else {
	$i=0;
	print "Lines:",$#ps,"\n";
	unless ($grp->{printToEPS}) {
	  print O $ps[$i++],"\n" while ($i<=$#ps and $ps[$i]!~/^%%BoundingBox:/);
	  #	print "Bounding Box:\n";
	  #	print $ps[$i],"\n";
	  print O $ps[$i++],"\n";
	  print O $psMedia,"\n";	
	  print O '%%Pages: ',$#printList+1,"\n";
	  $i++;
	}
	print O $ps[$i++],"\n" while ($i<=$#ps and $ps[$i] !~ /^%%DocumentNeededResources: font Arial-Medium/);
	print O $ps[$i++],"\n" while ($i<=$#ps and $ps[$i]!~/^%%BeginProlog/);
	print O $ps[$i++],"\n";
	print O '%%beginFont arialm',"\n";
	print O <F>;
	print O '%%EndFont',"\n\n";
	$i++ while ($i<=$#ps and $ps[$i]!~/% StrokeClip/);
	print O $ps[$i++],"\n" while ($i<=$#ps and $ps[$i]!~/^%%IncludeResource: font Arial-Medium/);
	$i++;
      }

      # replacing ISOEncode
      while ($i<=$#ps && $ps[$i]!~/^%%Trailer\w*$/) {
	$ps[$i]=~s/ISOEncode //g;
	print O $ps[$i++],"\n";
      }
    }
    print O '%%EOF',"\n";
    #print "$i: Done.\n";
    close (F);
    close (O);

    #print "$psFile written!\n";
  }

  if ($treeNo eq $saveTreeNo) { redraw_tree($grp); }
  else { gotoTree($saveTreeNo,$grp); }
  $grp->{top}->Unbusy();

  return 1;
}

sub gotoTree {
  my $no = max(0,min(shift,$#trees));
  return $no if ($no == $treeNo);
  my ($grp)=@_;
  @nodes=();
  $treeNo=$no;
  getNodes($grp);
  redraw_tree($grp);
  return $no;
}

sub nextTree {
  return 0 if ($treeNo >= $#trees);
  my ($grp)=@_;
  @nodes=();
  $treeNo++;
  getNodes($grp);
  redraw_tree($grp);
  return 1;
}

sub prevTree {
  return 0 if ($treeNo <= 0);
  my ($grp)=@_;
  @nodes=();
  $treeNo--;
  getNodes($grp);
  redraw_tree($grp);
  return 1;
}

sub newTree {
  my ($grp)=@_;
  my $nr={};
  NewNode($nr); # blessing new root

  splice(@trees, $treeNo, 0, $nr);

  @nodes=();
  getNodes($grp);
  redraw_tree($grp);
  return 1;
}

sub newTreeAfter {
  my ($grp)=@_;
  my $nr={};
  NewNode($nr); # blessing new root

  splice(@trees, ++$treeNo, 0, $nr);

  @nodes=();
  getNodes($grp);
  redraw_tree($grp);
  return 1;
}

sub pruneTree {
  my ($grp)=@_;

  return unless $trees[$treeNo];
  $root=$trees[$treeNo];
  splice(@trees, $treeNo, 1);
  DeleteTree($root);

  $treeNo=max(0,min($treeNo,$#trees));
  undef $root;
  @nodes=();
  getNodes($grp);
  redraw_tree($grp);
  return 1;
}


sub newNode {
  ## Adds new son to current node
  my ($grp)=@_;
  my $parent=$grp->{currentNode};
  return unless $parent;
  my $nd={};
  NewNode($nd);            # initializing new node
  Paste($nd,$parent,\%attribs);
  $node->{AOrd(\%attribs)}=Ord($parent,\%attribs);
  setCurrent($grp,$nd);

  getNodes($grp);
  redraw_tree($grp);

  return $nd;
}


sub addBindTags {
  my $w=shift @_;
  $w->bindtags([@_,$w,ref($w),$w->toplevel,'all']);

} 

sub startMain {
  my $firstFile=shift;
  my $node;
  my $parent;
  my %group;

  $group{top}=MainWindow->new;
  if (-f $appIcon) {
    $group{top}->iconimage($group{top}->Pixmap(-file => "$appIcon"));
  }

  addBindTags($group{'top'},'my');

  $group{top}->protocol('WM_DELETE_WINDOW' => [sub { $grp=shift; 
						       askSaveFile($grp); 
						       $grp->{'top'}->destroy; },\%group]);


  $group{Balloon}=$group{'top'}->Balloon(-initwait => 450, -balloonposition => 'mouse',
					-state => 'balloon', -background => '#fff3b0');
  $group{'frame'}=$group{'top'}->Frame;





  $group{Menubar}=$group{top}->Frame(-relief => $menubarRelief, -borderwidth => 2);
  $group{Menubar}->pack(qw/-fill x/);
  addBindTags($group{Menubar},'my');
  $group{FileMenu} = $group{Menubar}->Menubutton(qw/-text File -underline 0 -menuitems/ =>
        [
         [Button => 'Open ...',    -command => [\&fileDialog, \%group]],
#	 [Button => 'New',         -command => [\&menus_error2, 'New']],
	 [Button => 'Save',        -command => [\&saveFile,\%group]],
#	 [Button => 'Save As ...', -command => [\&menus_error2, 'Save As']],
	 [Separator => ''],
#	 [Button => 'Setup ...',   -command => [\&menus_error2, 'Setup']],
	 [Button => 'Print ...',   -command => [\&printThis,\%group]],
	 [Separator => ''],
	 [Button => 'Quit',        -command => [$group{top} => 'destroy']],
	])->pack(qw/-side left/);

  $group{ViewMenu}= $group{Menubar}->Menubutton(qw/-text View -underline 0 -menuitems/ =>
        [
	 [Button => 'Previous File', -command => [\&prevFile,\%group]],
	 [Button => 'Next File', -command => [\&nextFile,\%group]],
	 [Separator => ''],
	 [Checkbutton => 'Draw boxes',
	   -variable => \$drawBoxes,
	   -command  => [\&redraw_tree,\%group]],
	 [Checkbutton => 'Show Hidden',
	  -variable => \$showHidden,
	  -command  => [sub { getNodes(@_); 
			      currentUnhiden(@_);
			      redraw_tree(@_) },\%group]],
	 [Checkbutton => 'Highlight Attributes',
	  -variable => \$highlightAttributes,
	  -command  => [\&redraw_tree,\%group]],
	 [Separator => ''],
	 [Button => 'Visible Attributes', -command => [\&selectAttrs,\%group]]
	])->pack(qw/-side left/);
  $group{NodeMenu}= $group{Menubar}->Menubutton(qw/-text Node -underline 0 -menuitems/ =>
        [
	 [Button => 'New Node', -command => [sub {
					       my ($grp)=@_;
					       newNode($grp);
					     },\%group]],
	 [Button => 'Insert New Tree', -command => [sub {
						      my ($grp)=@_;
						      newTree($grp);
						    },\%group]],
	 [Button => 'Insert New Tree After', -command => [sub {
						      my ($grp)=@_;
						      newTreeAfter($grp);
						    },\%group]],
	 [Button => 'Prune Current Tree', -command => [sub {
						      my ($grp)=@_;
						      pruneTree($grp);
						    },\%group]],
	 [Button => 'Edit Attributes', -command => [sub {
						      my ($grp)=@_;
						      editAttrsDialog($grp,$grp->{currentNode})
							if ($grp->{currentNode});
						    },\%group]],
	])->pack(qw/-side left/);


  my @umenus = map (
		    [Button => $_,
		   -command => [\&doEvalMacro,\%group,$menuBindings{$_}->[0]],
		     ($menuBindings{$_}->[1]) ?
		     (-accelerator => "(".$menuBindings{$_}->[1].")") : ()],
		    sort(keys(%menuBindings)));
  my $uM,$uuM;
  $uM=[ @umenus[0..min($maxMenuLines-1,$#umenus)] ];
  $uuM=$uM;
  my $i=$maxMenuLines;
  while ($i<=$#umenus) {
    $_=[@umenus[$i..min($i+$maxMenuLines-1,$#umenus)]];
    push @$uuM,[Cascade => 'More...', -menuitems => $_];
    $uuM=$_;
    $i+=$maxMenuLines;
  }


  $group{UserMenu}=$group{Menubar}->Menubutton(qw/-text User-defined -underline 0 -menuitems/ =>
					       $uM)->pack(qw/-side left/);
  $group{MacroMenu}=$group{Menubar}->Menubutton(qw/-text Key-Macros -underline 0 -menuitems/ =>
					       [ map ([Button => $keyBindings{$_}, -accelerator => "($_)",
						       -command => [\&doEvalMacro,\%group,$keyBindings{$_}]],
						 keys(%keyBindings))
					       ])->pack(qw/-side left/) if ($createMacroMenu);

  addBindTags($group{'frame'},'my');
  my $canvas = $group{'top'}->Scrolled(qw/Canvas -width 20c -height 20c -relief sunken
			   -borderwidth 2 -scrollbars se -scrollregion/ =>
				       [qw/0c 0c 100c 100c/], 
				       $backgroundColor ? (-background => $backgroundColor) : ());
  $group{'valueLine'}=$group{'top'}->Scrolled(qw/Entry -state disabled -relief sunken
			   -borderwidth 2 -scrollbars s/, -font => $font,-textvariable => \$valueLine);
  $group{'canvas'}=$canvas;
  addBindTags($canvas,'my');
  $group{'nextButton'}=$group{'frame'}->Button(-text => "Next",
					       -relief => $buttonsRelief,
					       -image => $group{top}->Pixmap(-file => 
									     "$libDir/right.xpm"),
					       -borderwidth => 2,

			    -command => [sub { nextTree(@_) },\%group]);
  $group{Balloon}->attach($group{'nextButton'},
		 -balloonmsg => "see the next tree");
  addBindTags($group{'nextButton'},'my');
  $group{'prevButton'}=$group{'frame'}->Button(-text => "Prev",
					       -relief => $buttonsRelief,
					       -image => $group{top}->Pixmap(-file => 
									     "$libDir/left.xpm"),
					       -borderwidth => 2,
					       -command => [sub { prevTree(@_) },\%group]);
  $group{Balloon}->attach($group{prevButton},
		 -balloonmsg => "see the previous tree");
  addBindTags($group{'prevButton'},'my');
  $group{'attrDialog'}=undef;

  $group{'openButton'}=$group{'frame'}->Button(-text => "Open",
					       -relief => $buttonsRelief,
					       -image       => $group{top}->Pixmap(-file => "$libDir/fileopen.xpm"),
					       -borderwidth => 2,
			 -command => [sub { fileDialog(@_) },\%group])->pack(-side=>'left',-padx=>'1');
  $group{Balloon}->attach($group{openButton},
		 -balloonmsg => "open file");
  addBindTags($group{'openButton'},'my');
  $group{'saveButton'}=
    $group{'frame'}->Button(-text => "Save",
			    -relief => $buttonsRelief,
			    -image => $group{top}->Pixmap(-file =>
							  "$libDir/filefloppy.xpm"),
			    -borderwidth => 2,
			    -command => [sub { 
					   saveFile(@_) 
					 },\%group])->pack(-side=>'left',-padx=>'1');

  $group{Balloon}->attach($group{saveButton},
			  -balloonmsg => "save current file");
  addBindTags($group{'saveButton'},'my');
  $group{'printButton'}=
    $group{'frame'}->Button(-text => "Print",
			    -relief => $buttonsRelief,
			    -image       => $group{top}->Pixmap(-file => 
								"$libDir/fileprint.xpm"),
			    -borderwidth => 2,
			    -command => [sub { printThis(@_) },\%group])->pack(-side=>'left',
									       -padx=>'1');
  $group{Balloon}->attach($group{printButton},
		 -balloonmsg => "print ...");
  addBindTags($group{'printButton'},'my');

  $group{'prevFileButton'}=
    $group{'frame'}->Button(-text => "Prev file",
			    -relief => $buttonsRelief,
			    -image => $group{top}->Pixmap(-file => 
							  "$libDir/start.xpm"),
			    -borderwidth => 2,
			    -command => [sub { prevFile(@_); },\%group])->pack(-side=>'left',
									       -padx=>'1');
  $group{Balloon}->attach($group{prevFileButton},
			  -balloonmsg => "visit the previous open file");
  addBindTags($group{'prevFileButton'},'my');

  $group{'nextFileButton'}=
    $group{'frame'}->Button(-text => "Next file",
			    -relief => $buttonsRelief,
			    -image => $group{top}->Pixmap(-file => 
							  "$libDir/finish.xpm"),
			    -borderwidth => 2,
			    -command => [sub { nextFile(@_); },\%group])->pack(-side=>'left',
									       -padx=>'1');
  $group{Balloon}->attach($group{nextFileButton},
		 -balloonmsg => "visit the next open file");
  addBindTags($group{'nextFileButton'},'my');



  $group{'attrButton'}=
    $group{'frame'}->Button(-text => "Attributes",
			    -relief => $buttonsRelief,
			    -image => $group{top}->Pixmap(-file => 
							  "$libDir/tick.xpm"),
			    -borderwidth => 2,
			    -command => [sub { selectAttrs(@_) },\%group])->pack(-side=>'right',
										 -padx=>'1');
  $group{Balloon}->attach($group{attrButton},
		 -balloonmsg => "select visible attributes");
  $group{'nextButton'}->pack(-side => 'right', -padx => '1');
  $group{'prevButton'}->pack(-side => 'right', -padx =>'1');

  $group{'frame'}->pack(-fill => 'x', -padx => '1', -pady => 1);
  $group{'valueLine'}->pack(qw/-fill x/);
  $group{'canvas'}->pack(qw/-expand yes -fill both/);
  addBindTags($group{'canvas'},'my');

  $group{'canvas'}->focus;

  $group{'printToFile'}=0;
  $group{'printCommand'}='lpr';
  $group{'printPsFile'}=$psFile;

  if ($firstFile) {
    openFile($firstFile,\%group);
  }
  MainLoop;
}


# This patches $dialog->Show which implicitly focuses the default button;
# here focus stays where it is.
# Usage: my $dlg=DialogBox(); ...; ShowDialog($dlg);
sub ShowDialog {
    my ($cw, $grab) = @_;
    my $old_focus = $cw->focusSave;
    my $old_grab = $cw->grabSave;

    $cw->Popup();

    Tk::catch {
    if (defined $grab && length $grab && ($grab =~ /global/)) {
	$cw->grabGlobal;
    } else {
	$cw->grab;
    }
    };
    $cw->Wait;
    &$old_focus;
    &$old_grab;
    return $cw->{'selected_button'};
}

sub fileDialog {
  my $grp = shift;
  my $types;
  my $file;
  @types =
    (["Fs files",           [qw/.fs .FS .Fs/]],
     ["Backup files",           [qw/.fb .FB .Fb/]],
     ["All files",        '*']
    );
    $file = $grp->{'top'}->getOpenFile(-filetypes => \@types);
    if (defined $file and $file ne '') {
      #print "File: $file\n";
      return openFile($file,$grp);
    }
  return 0;
}

sub askSaveFile {
  my ($grp)=@_;  
  return unless $FileNotSaved;
  #print "was her4e!\n";
  #print $grp->{'top'}->toplevel;
  #print "\n..\n";

  saveFile($grp) 
  #print "OK\n"
   if ( #$grp->{'top'}->toplevel->getOpenFile() or 
       $grp->{'top'}->toplevel->messageBox(-icon => 'questhead', 
					   -message => "File may be changed!\nDo you want to save it?",
					   -title => 'File not saved', 
					   -type => 'YesNo',
					   -default => 'Yes') eq 'Yes');
  #print "..\n";
}


sub selectAttrs {
  my ($grp)=@_;
  my %datr;
  my $a;
  my $d;
  my %e=();
  my @r=();
  my $rows=min(10,$#atord+1);
  return unless $grp->{currentFile};
  $grp->{'top'}->Busy(-recurse => 1);
  foreach $a (@atord) {
    $datr{$a} = grep {$a eq $_} @displayAttrs;
  }
  $d = $grp->{'top'}->DialogBox(-title => "Select", -width => "10c",
			     -buttons => ["OK", "Cancel"]);
  $d->resizable(0,0);
  my $f = $d->Scrolled('Tiler',
		       -columns =>1,
		       -rows =>$rows,
		       -relief => 'groove',
		       -borderwidth => 0,
		       -highlightthickness =>0,
		       -scrollbars => 'e');
  $f->bind($f,'<Tab>', 
	   [sub {
	      if ($e{$atord[0]}) {
		$e{$atord[0]}->focus;
		$f->moveto(0);
	      } else {
		shift->focusNext;
	      }
	      Tk->break;
	    }]);
  foreach (@atord) {
    $e{$_}=$f->Checkbutton(-text     => $_."              ",
			   -command  => [
					 sub { 
					   my $da=shift; 
					   my $ka=shift; 
					   $$da{$ka}=!$$da{$ka} 
					 },
						 \%datr,$_],
			   -anchor => 'nw',
			   -justify => 'left',
			   -relief   => 'flat')->pack();
    $e{$_}->bind($e{$_},'<Tab>',[sub {
				   my ($w,$t)=@_; 
				   my $i=0;
				   $i++ while ($i<=$#atord and $atord[$i] ne $t);
				   if ($i+1>$#atord) {
				     $w->focusNext;
				   } else {
				     $f->scroll(1,'pages') 
				       if (($i+1)/$f->cget('-columns')>=
					   ($f->{SubWidget}{tiler}{Start}+$f->cget('-rows')));
				     $e{$atord[$i+1]}->focus;
				     # D'ya like dirty tricks ? :)
				   }
				   Tk->break;
				 },$_]);
    push @r, $e{$_};
    $e{$_}->select if ($datr{$_});
  }
  $e{$atord[0]}->focus if $atord[0];
  $f->Manage(@r);
  $f->pack();
  $grp->{'top'}->Unbusy();
  my $result = $d->Show;
  $grp->{'top'}->Busy(-recurse => 1);
  if ($result =~ /OK/) {
    @displayAttrs = grep { $datr{$_} } @atord;
    redraw_tree($grp);
  }
  $d=undef;
  $grp->{'top'}->Unbusy();
}

sub QueryString {
  my $newvalue;
  my ($grp, $title, $label)=@_;

  my $d=$grp->{'top'}->DialogBox(-title => $title,
				 -buttons => ["OK", "Cancel"]);
  addBindTags($d,'dialog');
  my $e=$d->add(Entry,-relief => 'sunken',
		    -width => 40, 
		    -takefocus => 1,
		    -font => $font, 
		    -textvariable => \$newvalue);
  my $l = $d->Label(-text => encode($label),
		    -anchor => 'e',
		    -justify => 'right');
  $l->pack(-side=>'left');
  $e->pack(-side=>'right');
  $d->resizable(0,0);
  $e->focus;
  my $result = ShowDialog($d);
  if ($result =~ /OK/) {
    return decode($newvalue);
  } else {
    return undef;
  }
}


sub selectValuesDialog {
 my ($grp, $vals, $selected, $may_add)=@_;
 my $a;
 my $multi=0;

 $grp->{'top'}->Busy(-recurse => 1);
 my $d=$grp->{'top'}->DialogBox(-title => "Select Values", -width => '8c',
				-buttons => ["OK", "Cancel"]);
 $d->resizable(0,0);
 my $l=$d->Scrolled(qw/Listbox -relief sunken -takefocus 1/,
		    -font => $font)->pack(qw/-expand yes -fill both/);
 $l->insert('end',@$vals);
 for ($a=0;$a<@$vals;$a++)  {
   $l->selectionSet($a) if grep { $$vals[$a] eq $_ } @$selected;
 }
 $d->Checkbutton(-text     => 'multiple select',
		 -variable => \$multi,
		 -command  => [sub {
				 shift->configure(-selectmode => $multi ? 'multiple' : 'single');
				 },$l],
		 -relief   => 'flat')->pack();
 if ($may_add) {
   $d->Button(-text => 'Add',
	      -command => [sub {
			     my ($grp,$l,$vals)=@_;
			     my $val=QueryString($grp,"Add new value","Value");
			     return unless defined $val;
			     push @$vals,$val;
			     $l->insert('end',$val);
			   $l->selectionClear(0,$l->size-1) unless $multi;
			     $l->selectionSet($l->size-1);
			   },$grp,$l,$vals])->pack();
 }
 $grp->{'top'}->Unbusy();
 my $result = $d->Show;
 if ($result =~ /OK/) {
   @$selected = (map { $$vals[$_] } ( grep { $l->selectionIncludes($_) } (0 .. $l->size-1) )); 
   return 1;
 }
 return 0;
}

sub editListAttr {
  my ($grp, $value, $attr) =@_;
  my @vals = map { encode($_) } ListValues($attr,\%attribs);
  #print "splitting ",$value{$attr},"\n";
  my @selected = map { encode($_) } split /\|/,$value;
  #print "splitted to ", join ('-',@selected),"\n";

  if (selectValuesDialog($grp,\@vals,\@selected,0)) {
    return decode(join('|',@selected));
  }
  return undef;
}

sub editAmbiguousAttr {
  my ($grp, $value, $attr) =@_;
  my @vals = map { encode($_) }split /\|/,$value;
  my @selected = @vals;
  if (selectValuesDialog($grp,\@vals,\@selected,1)) {
    return decode(join('|',@selected));
  }
  return undef;
}

sub editAttrsDialog {
  my ($grp,$node)=@_;
  my $r;
  my $b;
  my $a;
  my @vals;
  my $rows=min(10,$#atord+1);
  my @r=();
  $grp->{'top'}->Busy(-recurse =>1);
  my $d=$grp->{'top'}->DialogBox(-title => "Edit Node Attributes", -width => '10c',
				 -buttons => ["OK", "Cancel"]);
  $d->resizable(0,0);
  my $f = $d->Scrolled('Tiler',
		       -columns =>2,
		       -rows =>$rows,
		       -relief => 'groove',
		       -scrollbars => 'e');
  sub focusxDn {
    my ($w,$i,$e,$f,$rows)=@_; 
    if ($i+1>$#atord) {
      $w->focusNext;
    } else {
      $e->{$atord[$i+1]}->focus;
      $f->scroll(1,'pages') 
	if ($i+1>=($f->{SubWidget}{tiler}{Start}+$rows));
      # D'ya like dirty tricks ? :)
    }
    Tk->break;
  };
  sub focusxUp {
    my ($w,$i,$e,$f)=@_; 
    if ($i<=0) {
      $w->focusPrev;
    } else {
      $e->{$atord[$i-1]}->focus;
      $f->scroll(-1,'pages') 
	if ($i-1<($f->{SubWidget}{tiler}{Start}));
      # D'ya like dirty tricks ? :)
    }
    Tk->break;
  };

  $f->bind($f,'<Tab>',[sub {
			     if ($e{$atord[0]}) {
			       $e{$atord[0]}->focus;
			       $f->moveto(0);
			     } else {
			       shift->focusNext;
			     }
			     Tk->break;
			   }]);
  for (my $i=0;$i<=$#atord;$i++) {
    $_=$atord[$i];
    # Reliefs: raised, sunken, flat, ridge, and groove.
    push @r,$f->Label(-text => $_, -anchor => 'nw')->pack();

    if  (IsList($_,\%attribs) or 
	 $$node{$_}=~/^(?:[^\|\\]|\\.)*\|/) { # readonly entry and buttons for list
      $r = $f->Frame;
      $e{$_} = $r->Entry(-relief => 'sunken', -takefocus => 1, 
			 -font => $font)->pack(qw/-expand yes -fill both -side left/);
      $b=$r->Button(-text => "...", -takefocus => 0,
		    -command => [sub { 
				my ($e,$grp,$node,$attr)=@_;
				my $result =  
				  (IsList($attr,\%attribs)
				   ? editListAttr($grp,$e->get,$attr) 
				   : editAmbiguousAttr($grp,$e->get,$attr));
				if (defined $result) {
				  $e->configure(-state => 'normal');
				  $e->delete(0,length($e->get));
				  $e->insert(0,$result);
				  $e->configure(-state => 'disabled');
				}
			      },$e{$_},$grp,$node,$_])->pack(-side => 'right');
      $e{$_}->bind($e{$_},'<Return>',[sub { shift; shift->invoke; Tk->break; },$b]);
      $e{$_}->bind($e{$_},'<Double-ButtonPress-1>',[sub { shift; shift->invoke; Tk->break; },$b]);
      $e{$_}->insert(0,encode($$node{$_}));
      $e{$_}->configure(-state => 'disabled');
      push @r, $r;
    } else {
      $e{$_} = $f->Entry(-relief => 'sunken', -takefocus => 1,
			 -font => $font)->pack(qw/-expand yes -fill both/);
      $e{$_}->insert(0,encode($$node{$_}));
      push @r, $e{$_};
    }

    $e{$_}->bind($e{$_},'<Tab>',[\&focusxDn,$i,\%e,$f,$rows]);
    $e{$_}->bind($e{$_},'<Down>',[\&focusxDn,$i,\%e,$f,$rows]);
    $e{$_}->bind($e{$_},'<Shift-Tab>',[\&focusxUp,$i,\%e,$f]);
    $e{$_}->bind($e{$_},'<Up>',[\&focusxUp,$i,\%e,$f]);
  }
  $e{$atord[0]}->focus if $atord[0];
  $f->Manage(@r);
  $f->pack();
  $grp->{'top'}->Unbusy();
  my $result = ShowDialog($d);
  $grp->{'top'}->Busy(-recurse =>1);
  if ($result =~ /OK/) {
    $FileNotSaved=1;
    foreach $a (@atord) {
      $$node{$a}=decode($e{$a}->get);
    }
    getNodes($grp);
    redraw_tree($grp);
  }
  $d=undef;
  $grp->{'top'}->Unbusy();
}

sub editAttrs {
  my ($w,$grp)=@_;
  my $node=$grp->{'pinfo'}{$w->find('withtag','current')};
  editAttrsDialog($grp,$node);
}

sub editAttr {
  my ($w,$grp)=@_;
  my $attr;
  my $newvalue;

  my $t=$w->find('withtag','current');
  my $node=$grp->{'pinfo'}{$t};
  my $d;
  $attr= (grep {$$node{$_} eq $t} keys %$node)[0];

  return unless ($attr=~/^_tkText(?:Bg)*(\d+)_$/ or $1>$#displayAttrs);
  $attr=$displayAttrs[$1];

  if (IsList($attr,\%attribs)) {
    $newvalue = editListAttr($grp,$$node{$attr},$attr);
    if (defined $newvalue) {
      $grp->{'top'}->Busy(-recurse => 1);
      $FileNotSaved=1;
      $$node{$attr}=$newvalue;
      getNodes($grp);
      redraw_tree($grp);
      $grp->{'top'}->Unbusy();
    }
    return;
  }

  if ($$node{$attr}=~/^(?:[^\|\\]|\\.)*\|/) {
    $newvalue = editAmbiguousAttr($grp,$$node{$attr},$attr);
    if (defined $newvalue) {
      $grp->{'top'}->Busy(-recurse => 1);
      $FileNotSaved=1;
      $$node{$attr}=$newvalue;
      getNodes($grp);
      redraw_tree($grp);
      $grp->{'top'}->Unbusy();
    }
    return;
  }

  $grp->{'top'}->Busy(-recurse => 1);


  $newvalue=encode($$node{$attr});
  $d = $grp->{'top'}->DialogBox(-title => "Edit Node Attribute",
				-buttons => ["OK", "Cancel"]);
  $d->resizable(0,0);
  addBindTags($d,'dialog');
  my $l = $d->Label(-text => $attr,
		    -anchor => 'e',
		    -justify => 'right')->pack(-side=>'left');
  my $e = $d->Entry(-relief => 'sunken',
		    -width => 40,
		    -takefocus => 1,
		    -font => $font,
		    -textvariable => \$newvalue)->pack();
  $e->icursor('end');
  $e->focus;
  $grp->{'top'}->Unbusy();
  my $result = ShowDialog($d);
  $grp->{'top'}->Busy(-recurse => 1);
  if ($result =~ /OK/) {
    $FileNotSaved=1;
    $$node{$attr}=decode($newvalue);
    getNodes($grp);
    redraw_tree($grp);
  }
  $grp->{'top'}->Unbusy();
  $d=undef;
}


sub PrepareText {
  my $text=shift;
  $text=$1."*" if ($text =~/^([^\|]*)\|/);

  return encode($text);
}


sub whichTextColor {
  my $i=shift;

  return $textColor unless ($highlightAttributes);

  if (index($attribs{$displayAttrs[$i]}," 1")>=0) {
    return $textColorShadow;
  } elsif (index($attribs{$displayAttrs[$i]}," 2")>=0) {
    return $textColorHilite;
  } elsif (index($attribs{$displayAttrs[$i]}," 3")>=0) {
    return $textColorXHilite;
  } else {
    return $textColor;
  }
}

sub redraw_tree {
  my ($grp)=@_;
  my $node;
  my $parent;

  return if $insideEval;
  recalculate_positions($grp);
  #print $grp->{'canvasWidth'},'x',$grp->{'canvasHeight'},"\n";
  $grp->{'canvas'}->configure(-scrollregion =>['0c', '0c', $grp->{canvasWidth}, $grp->{canvasHeight}]);
  $grp->{'canvas'}->addtag('delete','all');
  $grp->{'canvas'}->delete('delete');

#  undef %{$grp->{pinfo}} if (exists $grp->{pinfo});
#  print keys(%{$grp->{pinfo}}),"---\n";
  $grp->{'pinfo'}={lastX => 0, lastY => 0};
#  $grp->{'pinfo'}{'lastX'}=0;
#  $grp->{'pinfo'}{'lastY'}=0;
  foreach $node (@nodes) {
    foreach (keys(%$node)) {
      delete $node->{$_}
	if (/^_tkText/);
    }
    $parent=Parent($node);
    use integer;
    if ($parent) {
      $$node{"_tkLine_"}=$grp->{'canvas'}->createLine($$node{"_tkXPOS_"}+$nodeWidth/2,
					     $$node{"_tkYPOS_"}+$nodeHeight/2,
					     $$parent{"_tkXPOS_"}+$nodeWidth/2,
					     $$parent{"_tkYPOS_"}+$nodeHeight/2,
						      '-arrow' =>$lineArrow,
						     '-width' => $lineWidth,
						     '-fill' => $lineColor);
      $grp->{'pinfo'}{$$node{"_tkLine_"}}=$node;
    }
  }
#  print "drawing ovals and texts...\n";
  foreach $node (@nodes) {    
    $$node{"_tkOval_"}=$grp->{'canvas'}->createOval($$node{"_tkXPOS_"},$$node{"_tkYPOS_"},
					   $$node{"_tkXPOS_"}+$nodeWidth,
					   $$node{"_tkYPOS_"}+$nodeWidth, 
						    -fill => 
						    ($grp->{'currentNode'} eq $node) ?
						    $currentNodeColor : $nodeColor);
    $grp->{'canvas'}->addtag('point', 'withtag', $$node{"_tkOval_"});

    my $lineHeight=$grp->{'canvas'}->fontMetrics($font, -linespace);
    my $textWidth=0;
    my $i;
    foreach (@displayAttrs) {
      $i=$grp->{'canvas'}->fontMeasure($font,PrepareText($$node{$_}));
      $textWidth=$i if ($i>$textWidth);
    }
    if ($drawBoxes) {
      $$node{"_tkTextBox_"}=$grp->{'canvas'}->createRectangle($$node{"_tkXPOS_"}-$xmargin,
						     $$node{"_tkYPOS_"}+$nodeHeight+$nodeYSkip-$ymargin,
						     $$node{"_tkXPOS_"}+
						     $textWidth+$xmargin,
						     $$node{"_tkYPOS_"}+
						     ($#displayAttrs+1)*$lineHeight+
						     $nodeHeight+$nodeYSkip+$ymargin,
						     -fill => ($grp->{'currentNode'} eq $node) ? 
						    $currentBoxColor : $boxColor);
    }
    for ($i=0;$i<=$#displayAttrs;$i++) {
      $$node{"_tkTextBg".$i."_"}=
	$grp->{'canvas'}->createRectangle($$node{"_tkXPOS_"},
				 $$node{"_tkYPOS_"}+$nodeHeight+$nodeYSkip+$i*$lineHeight,
				 $$node{"_tkXPOS_"}+
				 $grp->{'canvas'}->fontMeasure($font,PrepareText($$node{$displayAttrs[$i]}))+1,
				 $$node{"_tkYPOS_"}+$nodeHeight+$nodeYSkip+($i+1)*$lineHeight,
				 -fill => $grp->{'canvas'}->cget('-background'), -outline => undef)
	unless ($drawBoxes);
      $grp->{'canvas'}->addtag('textbg', 'withtag', $$node{"_tkTextBg".$i."_"});
      $grp->{'pinfo'}{$$node{"_tkTextBg".$i."_"}}=$node;
      $$node{"_tkText".$i."_"}=
	$grp->{'canvas'}->createText($$node{"_tkXPOS_"},$$node{"_tkYPOS_"}+
				     $nodeHeight+$nodeYSkip+$i*$lineHeight,
				     -anchor => 'nw', 
				     -text => PrepareText($$node{$displayAttrs[$i]}),
				     -fill => whichTextColor($i),
				     -font => $font);
      $grp->{'canvas'}->addtag('text', 'withtag', $$node{"_tkText".$i."_"});
      $grp->{'pinfo'}{$$node{"_tkText".$i."_"}}=$node;
    }
#    print "done\n";
    $grp->{'pinfo'}{$$node{"_tkOval_"}}=$node;
    $grp->{'pinfo'}{$$node{"_tkTextBox_"}}=$node
      if exists $$node{"_tkTextBox_"};
  }

#  $grp->{'canvas'}->bind('point', '<Any-Enter>' => [sub{shift->itemconfigure(@_)},
#				      'current', -fill => $activeNodeColor]);
#  $grp->{'canvas'}->bind('point', '<Any-Leave>' => [sub{ shift->itemconfigure(@_)},
#				      'current', -fill => $nodeColor]);
  $grp->{'canvas'}->bind('text', '<Any-Enter>' => [sub{shift->itemconfigure(@_)},
				      'current', -fill => $activeTextColor]);
  $grp->{'canvas'}->bind('text', 
			 '<Any-Leave>' 
			 => [sub{ 
			       my $c=shift;
			       my $grp=shift;
			       my $t=$c->find('withtag','current');
			       my $node=$grp->{'pinfo'}{$t};
			       my $attr= (grep {$node->{$_} eq $t} keys %$node)[0];

			       return unless ($attr=~/^_tkText(?:Bg)*(\d+)_$/
					      or $1>$#displayAttrs);
			       $c->itemconfigure('current',
						 -fill => whichTextColor($1));
			     }, $grp]);

  $grp->{'frame'}->bind('my','<KeyPress>' =>
			[sub { evalMacro(@_); Tk->break; }, $grp, '' ]);
#  $grp->{'frame'}->bind('my','<Control-x><KeyPress>' =>
#			[sub { evalMacro(@_); Tk->break; }, $grp, 'CTRL-X+' ]);
  $grp->{'frame'}->bind('my','<Shift-KeyPress>' =>
			[sub { evalMacro(@_); Tk->break; }, $grp,'SHIFT+']);
  $grp->{'frame'}->bind('my','<Control-KeyPress>' =>
			[sub { evalMacro(@_); Tk->break; }, $grp,'CTRL+']);
  $grp->{'frame'}->bind('my','<Alt-KeyPress>' =>
			[sub { evalMacro(@_); Tk->break; }, $grp,'ALT+']);
  $grp->{'frame'}->bind('my','<Meta-KeyPress>' =>
			[sub { evalMacro(@_); Tk->break; }, $grp,'META+']);
  $grp->{'frame'}->bind('my','<Control-Shift-KeyPress>' =>
			[sub { evalMacro(@_); Tk->break; }, $grp,'CTRL+SHIFT+']);
  $grp->{'frame'}->bind('my','<Control-Alt-KeyPress>' =>
			[sub { evalMacro(@_); Tk->break; }, $grp,'CTRL+ALT+']);
  $grp->{'frame'}->bind('my','<Control-Meta-KeyPress>' =>
			[sub { evalMacro(@_); Tk->break; }, $grp,'CTRL+META+']);
  $grp->{'frame'}->bind('my','<Alt-Shift-KeyPress>' =>
			[sub { evalMacro(@_); Tk->break; }, $grp,'ALT+SHIFT+']);
  $grp->{'frame'}->bind('my','<Meta-Shift-KeyPress>' =>
			[sub { evalMacro(@_); Tk->break; }, $grp,'META+SHIFT+']);


#  $grp->{'frame'}->bind('all','<Tab>' => [sub {1;}]);
#  $grp->{'top'}->bind('dialog','<Tab>' => [sub { shift->focusNext(); }] );
#  $grp->{'top'}->bind('dialog','<Shift-Tab>' => [sub { shift->focusPrev(); }] );
#  $grp->{'frame'}->bind('all','<Shift-Tab>' => [sub {1;}]);
#  $grp->{'frame'}->bind('all','<Control-Tab>' => [sub {1;}]);
  
  $grp->{'frame'}->bind('my','<Tab>' => [sub { currentNext(@_); Tk->break; },$grp]);
  $grp->{'frame'}->bind('my','<Control-Tab>' => [sub { currentPrev(@_); Tk->break; },$grp]);
  $grp->{'frame'}->bind('my','<Return>' => [sub {
					      my ($w,$grp)=@_;
					      editAttrsDialog($grp,$grp->{'currentNode'});
					      Tk->break;
					    },$grp]);
  $grp->{'frame'}->bind('my','<Left>' => [sub {
					   my ($w,$grp)=@_; 
					   currentLeft($grp);
					   Tk->break;
					 },$grp]);
  $grp->{'frame'}->bind('my','<Right>' => [sub {
					    my ($w,$grp)=@_;
					    currentRight($grp);
					   Tk->break;
					  },$grp]);
  $grp->{'frame'}->bind('my','<Up>' => [sub {
					 my ($w,$grp)=@_;
					 currentUp($grp);
					 Tk->break;
				       },$grp]);
  $grp->{'frame'}->bind('my','<Down>' => [sub {
					   my ($w,$grp)=@_; 
					   currentDown($grp);
					   Tk->break;
					 },$grp]);

  $grp->{'canvas'}->bind('point', '<1>' => [sub {node_down(@_) },$grp,0]);  
  $grp->{'canvas'}->bind('point', '<ButtonRelease-1>' => [sub {node_release(@_)},$grp,0]);
  $grp->{'canvas'}->bind('point', '<B1-Motion>' => [sub {node_move(@_)},$grp]);
  $grp->{'canvas'}->bind('point','<3>' => [sub {node_down(@_)},$grp,1]);
  $grp->{'canvas'}->bind('point', '<ButtonRelease-3>' => [sub {node_release(@_)},$grp]);
  $grp->{'canvas'}->bind('point','<B3-Motion>' => [sub {node_move(@_)},$grp,1]);
  $grp->{'canvas'}->CanvasBind('<2>' => [sub {follow_mouse_press(@_)},$grp]);
  $grp->{'canvas'}->CanvasBind('<B2-Motion>' => [sub {follow_mouse(@_)},$grp]);
  $grp->{'canvas'}->bind('point', '<Double-ButtonPress-1>' => [sub { editAttrs(@_) },$grp]);
  $grp->{'canvas'}->bind('text', '<Double-ButtonPress-1>' => [sub { editAttr(@_) },$grp]);  
  $grp->{'canvas'}->bind('textbg', '<Double-ButtonPress-1>' => [sub { editAttr(@_) },$grp]);  
}


sub follow_mouse {
  my ($w, $grp) = @_;
  my $e = $w->XEvent;
  my($x, $y) = ($w->fpixels($e->x), $w->fpixels($e->y));
  scrollCanvasToXY($w, $grp, $x, $y);
}

sub follow_mouse_press {
  my ($w, $grp) = @_;
  my $e = $w->XEvent;
  my($x, $y) = ($w->fpixels($e->x), $w->fpixels($e->y));

  $grp->{'pinfo'}{'lastX'}=$x;
  $grp->{'pinfo'}{'lastY'}=$y;
  $grp->{'pinfo'}{'lastCanvasX'}=$w->canvasx($x);
  $grp->{'pinfo'}{'lastCanvasY'}=$w->canvasy($y);
}



sub scrollCanvasToXY {
  my ($w, $grp, $x, $y)=@_;
  my ($ax,$bx)=$w->xview;
  my ($ay,$by)=$w->yview;
  my $canvasX;

  my $sizeX=$w->fpixels($grp->{'canvasWidth'})*($bx-$ax);
  my $shiftX=($x-$grp->{'pinfo'}{'lastX'});
  if ($shiftX>0) { 
    if ($grp->{'pinfo'}{'lastX'} == $sizeX) {
      $shiftX=0;
    } else {
      $shiftX/=$sizeX-$grp->{'pinfo'}{'lastX'}; # a fraction of our right move in window
    }
    $canvasX=$shiftX*
      ($w->fpixels($grp->{'canvasWidth'})-
	$grp->{'pinfo'}{'lastCanvasX'}); # this is where we should get on the canvas
  }
  else {
    if ($grp->{'pinfo'}{'lastX'} == 0) {
      $shiftX=0;
    } else{
      $shiftX/=$grp->{'pinfo'}{'lastX'} 
    }
    $canvasX=$shiftX*
	$grp->{'pinfo'}{'lastCanvasX'}; # this is where we should get on the canvas
  }
  $canvasX+=$grp->{'pinfo'}{'lastCanvasX'};
  $w->xview(moveto => 
	    max(0,min(1,($canvasX-$x+1+$w->fpixels($w->cget('-borderwidth')))
		      /$grp->{'canvasWidth'})));

  # the same for Y
  my $sizeY=$w->fpixels($grp->{'canvasHeight'})*($by-$ay);
  my $shiftY=($y-$grp->{'pinfo'}{'lastY'});
  if ($shiftY>0) { 
    if ($grp->{'pinfo'}{'lastY'} == $sizeY) {
      $shiftY=0;
    } else {
      $shiftY/=$sizeY-$grp->{'pinfo'}{'lastY'}; # a fraction of our right move in window
    }
    $canvasY=$shiftY*
      ($w->fpixels($grp->{'canvasHeight'})-
	$grp->{'pinfo'}{'lastCanvasY'}); # this is where we should get on the canvas
  }
  else { 
    if ($grp->{'pinfo'}{'lastY'}==0) {
      $shiftY=0;
    } else {
      $shiftY/=$grp->{'pinfo'}{'lastY'}; 
    }
    $canvasY=$shiftY*
	$grp->{'pinfo'}{'lastCanvasY'}; # this is where we should get on the canvas
  }
  $canvasY+=$grp->{'pinfo'}{'lastCanvasY'};
  $w->yview(moveto => 
	    max(0,min(1,($canvasY-$y+1+$w->fpixels($w->cget('-borderwidth')))
		      /$grp->{'canvasHeight'})));


  $grp->{'pinfo'}{'lastX'}=$x;
  $grp->{'pinfo'}{'lastY'}=$y;
  $grp->{'pinfo'}{'lastCanvasX'}=$w->canvasx($x);
  $grp->{'pinfo'}{'lastCanvasY'}=$w->canvasy($y);
}

sub recalculate_positions {
  my ($grp)=@_;
  my $xpos=$baseXPos;
  my $ypos;
  my $minxpos; # used temporarily to place a node far enough from its left neighbour
  my $maxypos; # has different meaning from $minxpos; this one's used for canvasHeight 
  my $canvasWidth=0; 
  my $node;

  my $fontHeight=$grp->{'canvas'}->fontMetrics($font, -linespace);

  #print "Calculating positions ...\n";
  %prevnode=();
  $maxypos=0;  
  foreach $node (@nodes) {
    $ypos=0;
    $parent=Parent($node);
    while ($parent) {
      #print "!\n";
      $ypos++;
      $parent=Parent($parent);
    }
    $maxypos=max($maxypos,$ypos);
    $$node{"_tkYPOS_"}=$baseYPos+$ypos*(2*($nodeYSkip+$ymargin)+($#displayAttrs+1)*$fontHeight+$nodeHeight);

    #print "got y position for ",$$node{"form"},"\n";


    my $textWidth=0;
    my $i;
    foreach (@displayAttrs) {
      $i=$grp->{'canvas'}->fontMeasure($font,PrepareText($$node{$_}));
      $textWidth=max($i,$textWidth);
    }
    $$node{"_tkXWidth_"}=$textWidth;

    $minxpos=0;
    if ($prevnode{$ypos}) {
      $minxpos=$prevnode{$ypos}{"_tkXPOS_"}+$prevnode{$ypos}{"_tkXWidth_"}+
	$nodeXSkip+$nodeWidth+2*$xmargin;
    }
    $xpos=max($xpos,$minxpos);
    $$node{"_tkXPOS_"}=$xpos;    
    $xpos+=$nodeXSkip+$nodeWidth;
    $canvasWidth=
      max($canvasWidth,
	  $$node{"_tkXPOS_"}+$$node{"_tkXWidth_"}+$baseXPos+$nodeWidth+2*$xmargin+$nodeXSkip);
    #print "got x position\n";

    $prevnode{$ypos}=$node;
    #print "$ypos ... ",$$node{"_tkYPOS_"},"\n";
  }
  #print "Width: $canvasWidth\n";
  $grp->{'canvasWidth'}=$canvasWidth;
  $grp->{'canvasHeight'}=$baseYPos+
    ($maxypos+1)*(2*($nodeYSkip+$ymargin)+($#displayAttrs+1)*$fontHeight+$nodeHeight);
  #print "Done.\n";
}

sub IsHidden {
  # Tests if given node is hidden or not
  # Returns the ancesor that hides it or undef
  my $node=shift;
  $node=Parent($node) while ($node and (Hide($node,\%attribs) ne 'hide'));
  return ($node ? $node : undef);
}

sub currentUnhiden {
  my $grp=shift;
  unless ($showHidden) {
    my $node=IsHidden($grp->{'currentNode'});
    setCurrent($grp,Parent($node)) if ($node and Parent($node));
  }
}

sub currentLeft {
  my $grp=shift;
  if ($showHidden) {
    if (LBrother($grp->{'currentNode'})) {
      setCurrent($grp,LBrother($grp->{'currentNode'}));
      centerTo($grp,$grp->{'currentNode'});
    }
  } else {
    my $n=LBrother($grp->{'currentNode'});
    $n=LBrother($n) while ($n and defined(Hide($n,\%attribs)) 
			   and (Hide($n,\%attribs) eq 'hide'));
    if ($n) {
      setCurrent($grp,$n);
      centerTo($grp,$grp->{'currentNode'});
    }
  }
}

sub currentRight {
  my $grp=shift;
  if ($showHidden) {
    if (RBrother($grp->{'currentNode'})) {
      setCurrent($grp,RBrother($grp->{'currentNode'}));
      centerTo($grp,$grp->{'currentNode'});
    }
  } else {
    my $n=RBrother($grp->{'currentNode'});

    $n=RBrother($n) while ($n and defined(Hide($n,\%attribs)) 
			   and (Hide($n,\%attribs) eq 'hide'));
    if ($n) {
      setCurrent($grp,$n);
      centerTo($grp,$grp->{'currentNode'});
    }
  }
}

sub currentDown {
  my $grp=shift;
  if ($showHidden) {
    if (FirstSon($grp->{'currentNode'})) {
      setCurrent($grp,FirstSon($grp->{'currentNode'}));
      centerTo($grp,$grp->{'currentNode'});
    }
  } else {
    my $n=FirstSon($grp->{'currentNode'});
    $n=RBrother($n) while ($n and defined(Hide($n,\%attribs))
			   and Hide($n,\%attribs) eq 'hide');
    if ($n) {
      setCurrent($grp,$n);
      centerTo($grp,$grp->{'currentNode'});
    }
  }
}



sub currentUp {
  my $grp=shift;
  if (Parent($grp->{'currentNode'})) {
    setCurrent($grp,Parent($grp->{'currentNode'}));
    centerTo($grp,$grp->{'currentNode'});
  }
}

sub setCurrent {
  my ($grp,$node)=@_;
  $grp->{'canvas'}->itemconfigure($grp->{'currentNode'}->{'_tkOval_'}, 
				  -fill => $nodeColor);
  $grp->{'canvas'}->itemconfigure($grp->{'currentNode'}->{'_tkTextBox_'}, 
				  -fill => $boxColor)
    if ($drawBoxes and $grp->{'currentNode'}->{'_tkTextBox_'});

  $grp->{'currentNode'}=$node;
  $grp->{'canvas'}->itemconfigure($grp->{'currentNode'}->{'_tkOval_'}, 
				  -fill => $currentNodeColor);    
  $grp->{'canvas'}->itemconfigure($grp->{'currentNode'}->{'_tkTextBox_'}, 
				  -fill => $currentBoxColor)
    if ($drawBoxes and $grp->{'currentNode'}->{'_tkTextBox_'});
}

sub centerToXY {
  ($grp, $x, $y) = @_;
  ($ax,$bx)=$grp->{'canvas'}->xview;
  ($ay,$by)=$grp->{'canvas'}->yview;

  $shiftx=($bx-$ax)/2;
  $shifty=($by-$ay)/2;

  $grp->{'canvas'}->xview(moveto => min(max(0,$x/$grp->{'canvasWidth'}-$shiftx),1));
  $grp->{'canvas'}->yview(moveto => min(max(0,$y/$grp->{'canvasHeight'}-$shifty),1));
}

sub centerTo {
  ($grp, $node) = @_;
  centerToXY($grp,$$node{'_tkXPOS_'},$$node{'_tkYPOS_'});
}

sub doEvalMacro {
  my ($grp,$macro)=@_;
  print "$macro\n";
  local $this;
  $this=$grp->{'currentNode'};
  my $result;
  my $FileNotSavedOrig=$FileNotSaved;

  return unless $this;
  $grp->{'top'}->Busy(-recurse => 1);
  $FileNotSaved=1; # Macro may want to override this :)
  $insideEval=1;

  unless ($macrosEvaluated) {
    eval ("@macros\n return 1;");
    $macrosEvaluated=1;
  }
#  $result=eval("return ".$macro."();\n@macros\n");  # this consumes memory!!!!
    $result=eval("return ".$macro."();\n");
  if (!$result or $@) {
    print STDERR "Had run: ",$macro,"\n";
    print STDERR "Returned with: $result\n$@\n";
  }
  print "File must not saved: $FileNotSaved\n";
  $FileNotSaved=($FileNotSavedOrig or $FileNotSaved);
  $insideEval=0;
  $grp->{'top'}->Unbusy;
  setCurrent($grp,$this);
  getNodes($grp);
  redraw_tree($grp);
  centerTo($grp,$this);
}

sub evalMacro {
  my ($w,$grp,$prefix)=@_;
  my $key;
  my $e = $w->XEvent;
  my $A = uc($e->A);

#  print STDERR "Pressed: ($A), prefix $prefix, keysym ",$e->K,"/",$e->N,"\n";
#  print STDERR "Maybe: ",$prefix.$pckey_shift_translates{$e->K},"\n";

  if (defined $keyBindings{$prefix.$A}) {
    $key=$prefix.$A;
  } elsif ($prefix =~/SHIFT/ and exists($pckey_shift_translates{$e->K}) 
	  and defined $keyBindings{$prefix.$pckey_shift_translates{$e->K}}) {
    $key=$prefix.$pckey_shift_translates{$e->K};
    print STDERR "Trying: ",$prefix.$pckey_shift_translates{$e->K},"\n";
  } else {
    $key=$prefix.uc($e->K);
  }
  #print "Got $prefix$A (",ord($e->A),",",ord($A),",",ord($e->B),") looking for macro\n";
  if (defined $keyBindings{$key}) {
    doEvalMacro($grp,$keyBindings{$key});
  }
}

sub currentNext {
  my ($w,$grp)=@_; 
  if (Next($grp->{'currentNode'})) {
    setCurrent($grp,Next($grp->{'currentNode'}));
    centerTo($grp,$grp->{'currentNode'});
  }
}


sub currentPrev {
  my ($w,$grp)=@_; 
  if (Prev($grp->{'currentNode'})) {
    setCurrent($grp,Prev($grp->{'currentNode'}));
    centerTo($grp,$grp->{'currentNode'});
  }
}


sub node_down {

    my($w,$grp) = @_;

    my $e = $w->XEvent;
    my($x, $y) = ($e->x, $e->y);
    my $node=$grp->{'pinfo'}{$w->find('withtag','current')};

    setCurrent($grp,$node);
    $w->dtag('selected');
    $w->addtag('selected', 'withtag', 'current');
    $w->raise('current');
    $grp->{'pinfo'}{'lastX'} = $x;
    $grp->{'pinfo'}{'lastY'} = $y;
    $grp->{'pinfo'}{'lastCanvasX'}=$w->canvasx($x);
    $grp->{'pinfo'}{'lastCanvasY'}=$w->canvasy($y);
} # end plot_down

sub node_move {

    my($w,$grp,$scroll) = @_;

    my $e = $w->XEvent;
    my($x, $y) = ($e->x, $e->y);
    my $node=$grp->{'pinfo'}->{$w->find('withtag','selected')};

    my $lcx=$grp->{'pinfo'}{'lastCanvasX'};
    my $lcy=$grp->{'pinfo'}{'lastCanvasY'};

    if ($scroll) {
      scrollCanvasToXY($w, $grp, $x, $y);
    } else {
      $grp->{'pinfo'}{'lastCanvasX'}=$w->canvasx($x);
      $grp->{'pinfo'}{'lastCanvasY'}=$w->canvasy($y);
    }
    my($cx, $cy) = ($w->canvasx($x),$w->canvasy($y));
    $w->move('selected',  $cx-$lcx, $cy-$lcy);

    $w->itemconfigure('nearest', -fill => $nodeColor);
    $w->dtag('nearest');

    my @dots= $w->find('withtag','point');
    my $nearestNode=0;
    my $bestDist=10000;
    my $dist;
    foreach $p (@dots) {
      if ($grp->{'pinfo'}{$p} and $grp->{'pinfo'}{$p}!=$node) {
  	$dist=
	  ($cx-$grp->{'pinfo'}{$p}{'_tkXPOS_'})*
	    ($cx-$grp->{'pinfo'}{$p}{'_tkXPOS_'})+
	      ($cy-$grp->{'pinfo'}{$p}{'_tkYPOS_'})*
		($cy-$grp->{'pinfo'}{$p}{'_tkYPOS_'});
  	if ($bestDist>$dist) {
  	  $bestDist=$dist;
  	  $nearestNode=$grp->{'pinfo'}{$p};
  	}
      }
    }
    if ($bestDist<800) {
      $w->addtag('nearest','withtag',$$nearestNode{"_tkOval_"});
      $w->itemconfigure($$nearestNode{"_tkOval_"}, -fill => $nearestNodeColor);
    }
} # end plot_move

sub node_release {
  my($w,$grp) = @_;
  my $parent;
  my $node;
  my $sel=$w->find('withtag','selected');
  $node=$grp->{'pinfo'}{$sel} if (defined ($sel));

  if ($node) {
    $p=$w->find('withtag','nearest');
    $w->dtag('selected');
    if (defined $p) {
      $parent=$grp->{'pinfo'}{$p};
      while ($parent) {
	$p=0, last if ($node eq $parent);
	$parent=Parent($parent);
      }
      if ($node and $p and $grp->{'pinfo'}{$p} and Parent($node)!=$grp->{'pinfo'}{$p}) {
	Paste(Cut($node),$grp->{'pinfo'}{$p},\%attribs);
	$FileNotSaved=1;
      }
    }
  }
  redraw_tree($grp);
  centerTo($grp,$grp->{currentNode});
}

### Local Variables:
### mode:cperl
### End:
