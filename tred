#!/usr/bin/perl
# -*- cperl -*-
#
################################################################################
$version="1.48";
$timestamp="Time-stamp: <2001-03-09 18:23:47 pajas>";
$about=
  "Copyright (c) 2001 by Petr Pajas\n".
  "This software is distributed under GPL - The General Public Licence\n".
  "Full text of the GPL can be found at http://www.gnu.org/copyleft/gpl.html";
$lastupdate=$1 if ($timestamp=~/<([0-9-: ]+) /);
################################################################################
#
# This is "TrEd" - a simple viewer/editor of tree graphs in fs
# file-format used in Graph - program developed by M. Kren. TrEd is
# written entirely in Perl and for graphical output it uses PerlTk
# library as a frontend to Tk toolkit
#
################################################################################
#
# Usage:
# tred [-c <config-file>] [-m <macro-file>] [-l <filelist>] file1[##N|#N] [file2[##N|#N] [...]]
#
# or
#
# tred -u  for usage
#
# or
#
# tred -h  for help
#
################################################################################


# Once we got rid of them we call getopt to read all the other options
use Tk;
use Tk::Wm;

package Tk::Wm;
# overwriting the original Tk::Wm::Post:
sub Post
{
 my ($w,$X,$Y) = @_;
 $X = int($X);
 $Y = int($Y);
 $w->positionfrom('user');
 #$w->geometry("+$X+$Y");
 $w->MoveToplevelWindow($X,$Y);
 $w->deiconify;
## This causes the "slowness":
# $w->raise;
}

package main;


use Tk::Xrm;
# process the standard arguments for X resources
Tk::CmdLine::SetArguments();


use Getopt::Std;
getopts('m:c:l:hu');

if ($opt_u) {
  print <<EOH;
Usage:
  tred [-c config-file] [-m macro-file] [-l file-list] files...
or
  tred -u          to show usage
or
  tred -h          to show help
EOH
  exit;
}

if ($opt_h) {
  print <<EOF;
Usage:
tred [-c <config-file>] [-m <macro-file>] [-l <filelist>] file1[##N|#N] [file2[##N|#N] [...]]

or

tred -u|-h    for usage/help

This is `TrEd' - a simple viewer/editor of tree graphs in FS-format
used in `GRAPH' - a program developed by M. Kren. TrEd (which stands
for The TRee EDitor) is written entirely in Perl and it uses PerlTk
module for GUI.

Files file1, etc. given on the command-line must be in fs-format (for
not a little bit obsolete description see:
	http://ufal.ms.mff.cuni.cz/local/doc/trees/format_fs.html)

The name of each file may be followed by a suffices of the following
forms:

#N      where N is a number possibly followed by one or more
	upper-case letters. In this case, #N tells TrEd to skip to the
	first tree the root of which has `#N' as a value of attribute
	called `form' (this feature is optimized for specific
	instances of fs-format used while working on The Prague
	Dependency Treebank)

##N     where N is a number. This makes TrEd to go to the N-th tree in
	the given file after the file is opened.

-m      may be used to specify a macro file different from the one
	given in ~/.tredrc (or whatsoever) configuration file

-c      may be used to specify a config-file to be used (overrides
	~/.tredrc and all the other files TrEd would otherwise try to
	search for).

EOF
  exit;
}

# platform specific stuff
$inputenc="iso-8859-2";
if ($^O =~ /^MS/) {
  $outputenc="windows-1250";
  $Ds="\\"; # how filenames and directories are separated
} else {
  $Ds='/';
  $outputenc="iso-8859-2";
}

use FindBin;

# this variable is used when searching for rc-file (i.e. the inicialisation file)
my @configFileSearchList=($ENV{HOME}.'/.tredrc',
			  (exists $ENV{TREDHOME}) ? $ENV{TREDHOME}.'/tredrc' : (),
			  "$FindBin::RealBin/tredrc",
			  "$FindBin::RealBin/../lib/tredlib/tredrc",
			  "$FindBin::RealBin/tredlib/tredrc",
			  "$FindBin::RealBin/../lib/tred/tredrc",
			  '/usr/usr/share/config/tredrc');

my $configFile;
# other configuration should be given in that file


my $libDir;
# Default values of $libDir used to search for macro-file (tred.mac)
# and default-macro file (tred.def) are specified here. They may be
# overriden by value of LibDir in tred resource file (tredrc or ~/.tredrc - see above).

if (exists $ENV{TREDHOME}) {
  $libDir=$ENV{TREDHOME};
} elsif (-d "$FindBin::RealBin/tredlib") {
  $libDir="$FindBin::RealBin/tredlib";
} elsif (-d "$FindBin::RealBin/../lib/tredlib") {
  $libDir="$FindBin::RealBin/../lib/tredlib";
} elsif (-d "$FindBin::RealBin/../lib/tred") {
  $libDir="$FindBin::RealBin/../lib/tred";
}
print "Trying $libDir\n" if ($libDir);


$macroFile=undef;

if (defined $opt_c) {
  @configFileSearchList=($opt_c); # override any other possible config files
}

readConfig();

$macroFile="$libDir/tred.mac" unless (defined $macroFile);

if (defined $opt_m) {
  $macroFile=$opt_m;
}

unless (-d $libDir) {
  print <<'EOL';
 TrEd couldn't find a tredlib directory. You may need to point
 to its location by the TREDHOME variable or add a correct LibDir
 field to your ~/.tredrc.

EOL
    die "Error: Couldn't find lib-directory.";
}


##################### character encoding functions ########################

%encodings = (
    'iso-8859-2' => "ÏπË¯æ˝·ÌÈÏ˙˘ÛÚªÔµ‡∂ÂºÊÒÃ©»ÿÆ›¡Õ…Ã⁄Ÿ”“´œ•¿¶≈¨∆—",
	      'ascii' => "escrzyaieeuuontdlrslzcnESCRZYAIEEUUONTDLRSLZCN",
	      'iso-8859-1' => "escrz˝·ÌÈe˙uÛntdlrslzcnESCRZ›¡Õ…E⁄U”NTDLRSLZCN",
	      'windows-1250' => "ÏöË¯û˝·ÌÈÏ˙˘ÛÚùÔæ‡úÂüÊÒÃä»ÿé›¡Õ…Ã⁄Ÿ”“çœº¿å≈è∆—"
	     );

sub encode {
  return join("",@_) if ($inputenc eq $outputenc);

  local $_=join "",@_;
  eval " tr/$encodings{$inputenc}/$encodings{$outputenc}/";
  return $_;
}

sub decode {
  return join("",@_) if ($inputenc eq $outputenc);

  local $_=join "",@_;
  eval " tr/$encodings{$outputenc}/$encodings{$inputenc}/";
  return $_;
}


################ end of character encoding functions ########################

use Cwd;

use Tk::LabFrame;
use Tk::Listbox;
use Tk::HList;
use Tk::ItemStyle;
use Tk::Balloon;
use Tk::DialogBox;
use Tk::Tiler;

push @INC,$libDir;
require Fslib;
import Fslib;
import Fslib qw(&Ord &Value &Hide &SentOrd &AOrd &AValue &AHide &ASentOrd);

require Tk::MyFileSelect;

use Exporter;

@EXPORT = qw($root $this $_NoSuchTree $NodeClipboard
	     $forceFileSaved $insideEval $FileNotSaved
             $filecount @files &min &max);

my @macros=();

my @customColors=('darkgreen','darkblue','darkmagenta',,'orange','darkred','green1',
		  'slategray1','gold','cyan','midnightblue');


@open_types =
  (["Fs files",           [qw/.fs .FS .Fs/]],
   ["Gzipped Fs files",   [qw/.fgz .fs.gz .FGZ .FS.gz .FS.GZ/]],
   ["CSTS files",           [qw/.am .cst .csg .csts/]],
   ["Gzipped CSTS files",           [qw/.am.gz .cst.gz .csg.gz .csts.gz/]],
   ["Backup Fs files",           [qw/.fs~ .fb .FB .Fb/]],
   ["Backup gzipped Fs files",           [qw/.fgz~ .fs.gz~ .FGZ~ .FS.gz~ .FS.GZ~/]],
   ["All files",        '*']
  );

@save_types =
  (["Fs files",           [qw/.fs .FS .Fs/]],
   ["Gzipped Fs files",   [qw/.fgz .fs.gz .FGZ .FS.gz .FS.GZ/]],
   ["CSTS files",           [qw/.cst .csts/]],
   ["Gzipped CSTS files",           [qw/.cst.gz .csts.gz/]],
   ["All files",        '*']
  );



# it seems, that under Windoze setting LC_NUMERIC back to us does not
# work, so I recommend not to use czech locales there, unless you
# really want the decimal points to be replaced by commas in
# postscript:)

if ($useCzechLocales) {
  use locale;
  use POSIX qw(locale_h);
  setlocale(LC_COLLATE,"cs_CZ");
  setlocale(LC_NUMERIC,"us_EN");
  setlocale(LANG,"czech");
}

$fsF=undef;
@files=();

if ($opt_l and -f $opt_l) {
  if (open(F,"<$opt_l")) {
    @files=<F>;
    close(F);
    chomp @files;
  }
}

if ($^O =~ /^MS/) {
  foreach (@ARGV) {
    push @files, /[\*\?]/ ? glob : $_;
  }
} else {
  push(@files, @ARGV);
}

use File::Spec::Functions (rel2abs);
@files = map { rel2abs($_) } @files;

# These are used only in macros!!!
$root=undef;
$this=undef;


$_NoSuchTree; # for compatibility with Graph2Tred
$NodeClipboard;

$drawSentenceInfo=0;
$forceFileSaved=0;
$insideEval=0;
$FileNotSaved=0;
$filecount=$#files+1;

my %searchTemplate;

%pckey_shift_translates = (exclam => 1, at => 2, numbersign => 3,
			   dollar => 4, percent => 5, asciicircum => 6,
			   ampersand => 7, asterisk => 8, parenleft => 9,
			   parenright => 0, plus => 'equal',
			   underscore => 'minus',
			   less => 'comma', greater => 'period', 
			   question => 'slash',
			   colon => 'semicolon', quotedbl => 'apostroph',
			   braceleft => 'bracketleft', 
			   braceright => 'bracketright',
			   bar => 'backslash', asciitilde => 'grave'
			  );

sub dirname {
  my $a=shift;  
  return (index($a,$Ds)>=0)? substr($a,0,rindex($a,$Ds)+1) : ".$Ds";
}

sub filename {
  my $a=shift;
  return (index($a,$Ds)>=0)? substr($a,rindex($a,$Ds)+1) : $a;
}


print STDERR "Reading macros from $macroFile...\n";
readMacros($macroFile);		# read macros
print STDERR "done.\n";

startMain($files[0]);	# display first tree

exit;

############################
############################
############################

sub min {
  my ($a,$b)=@_;
  return ($a<$b)?$a:$b;
}

sub max {
  my ($a,$b)=@_;
  return ($a<$b)?$b:$a;
}


sub parseConfigLine {
  local $_=shift;
  my $confs=shift;
  my $key;
  unless (/^[;#]/ or /^$/) {
    chomp;
    if (/^\s*([a-zA-Z_]+[a-zA-Z_0-9]*)\s*=\s*('(?:[^\\']|\\.)*'|"(?:[^\\"]|\\.)*"|(?:\s*(?:[^;\\\s]|\\.)+)*)/) {
      $key=lc($1);
      $confs->{$key}=$2;
      $confs->{$key}=~s/\\(.)/\1/g;
      $confs->{$key}=$1 if ($confs->{$key}=~/^'(.*)'$/ or $confs->{$key}=~/^"(.*)"$/);
      #print "$key=$confs->{$key};\n";
    }
  }
}

sub readConfig {
  #
  # Simple configuration file handling
  #
  my %confs;
  my $key, $f;
  local *F;
  my $openOk=0;

  foreach $f (@_,@configFileSearchList) {
    if (defined($f), open(F,"<$f")) {
      print "Using resource file $f\n";
      while (<F>) {
	parseConfigLine($_,\%confs);
      }
      close F;
      $openOk=1;
      $configFile=$f;
      last;
    }
  }
  unless ($openOk) {
    print
      "Warning: Cannot open any file in:\n",
      join(":",@configFileSearchList),"\n" .
      "         Using configuration defaults!\n";
  }
  setConfig(\%confs);
}

sub applyConfig {
  my %confs;
  foreach (@_) {
    parseConfigLine($_,\%confs);
  }
  setConfig(\%confs);
}

sub setConfig {
  my $confs=shift;

  $appName=(exists $confs->{appname}) ? $confs->{appname} : "TrEd ver. 0.5";
  $baseXPos=(exists $confs->{basexpos}) ? $confs->{basexpos} : 15;
  $baseYPos=(exists $confs->{baseypos}) ? $confs->{baseypos} : 15;
  $nodeWidth=(exists $confs->{nodewidth}) ? $confs->{nodewidth} : 7;
  $nodeHeight=(exists $confs->{nodeheight}) ? $confs->{nodeheight} : 7;
  $currentNodeWidth=(exists $confs->{currentnodewidth}) ? $confs->{currentnodewidth} : $nodeWidth;
  $currentNodeHeight=(exists $confs->{currentnodeheight}) ? $confs->{currentnodeheight} : $nodeHeight;
  $nodeXSkip=(exists $confs->{nodexskip}) ? $confs->{nodexskip} : 5;
  $nodeYSkip=(exists $confs->{nodeyskip}) ? $confs->{nodeyskip} : 10;
  $xmargin=(exists $confs->{xmargin}) ? $confs->{xmargin} : 2;
  $ymargin=(exists $confs->{ymargin}) ? $confs->{ymargin} : 2;
  $buttonsRelief=(exists $confs->{buttonsrelief}) ? $confs->{buttonsrelief} : 'flat';
  $menubarRelief=(exists $confs->{menubarrelief}) ? $confs->{menubarrelief} : 'flat';
  $buttonBorderWidth=(exists $confs->{buttonsborder}) ? $confs->{buttonsborder} : 2;
  $lineWidth=(exists $confs->{linewidth}) ? $confs->{linewidth} : 1;
  $lineColor=(exists $confs->{linecolor}) ? $confs->{linecolor} : 'black';
  $lineArrow=(exists $confs->{linearrow}) ? $confs->{linearrow} : 'none';
  $nodeColor=(exists $confs->{nodecolor}) ? $confs->{nodecolor} : 'yellow';
  $nodeOutlineColor=(exists $confs->{nodeoutlinecolor}) ? $confs->{nodeoutlinecolor} : 'black';
  $hiddenNodeColor=(exists $confs->{hiddennodecolor}) ? $confs->{hiddennodecolor} : 'black';
  # $activeNodeColor=(exists $confs->{activenodecolor}) ? $confs->{activenodecolor} : 'blue';
  $currentNodeColor=(exists $confs->{currentnodecolor}) ? $confs->{currentnodecolor} : 'red';
  $nearestNodeColor=(exists $confs->{nearestnodecolor}) ? $confs->{nearestnodecolor} : 'green';
  $textColor=(exists $confs->{textcolor}) ? $confs->{textcolor} : 'black';
  $textColorShadow=(exists $confs->{textcolorshadow}) ? $confs->{textcolorshadow} : 'darkgrey';
  $textColorHilite=(exists $confs->{textcolorhilite}) ? $confs->{textcolorhilite} : 'darkgreen';
  $textColorXHilite=(exists $confs->{textcolorxhilite}) ? $confs->{textcolorxhilite} : 'darkred';

  foreach (0..9) {
    $customColors[$_]=$confs->{"customcolor$_"} if $confs->{"customcolor$_"};
  }

  $canvasBalloonInitWait=(exists $confs->{hintwait}) ? $confs->{hintwait} : 1000;
  $activeTextColor=(exists $confs->{activetextcolor}) ? $confs->{activetextcolor} : 'blue';
  $boxColor=(exists $confs->{boxcolor}) ? $confs->{boxcolor} : 'wheat';
  $currentBoxColor=(exists $confs->{currentboxcolor}) ? $confs->{currentboxcolor} : 'white';
  $hiddenBoxColor=(exists $confs->{hiddenboxcolor}) ? $confs->{hiddenboxcolor} : 'gray';
  $backgroundColor=(exists $confs->{backgroundcolor}) ? $confs->{backgroundcolor} : undef;
  $noColor=(exists $confs->{allowcustomcolors}) ? $confs->{allowcustomcolors} : 0;
  $font=(exists $confs->{font}) ? $confs->{font} :
    (($^O=~/^MS/) ? 'family:Helvetica,size:10' : '-*-helvetica-medium-r-normal-*-12-*-*-*-*-*-iso8859-2');
  $vLineFont=(exists $confs->{vlinefont}) ? $confs->{vlinefont} : $font;
  $type1font=(exists $confs->{type1font}) ? $confs->{type1font} :
    (($^O=~/^MS/) ? $font : '-ult1mo-arial-medium-r-*-*-*-*-*-*-*-*-iso8859-2');

  ($libDir)=<$$confs{libdir}>
    if (exists $confs->{libdir});
  if (exists $$confs{psfontfile}) {
    ($psFontFile)=<$$confs{psfontfile}>;
    $psFontFile="$libDir/".$psFontFile if (not -f $psFontFile and -f 
					   "$libDir/".$psFontFile);
  } else {
    $psFontFile="$libDir/csarialm.pfa";
  }
  ($appIcon)=(exists $confs->{appicon}) ? <$$confs{appicon}> : ("$libDir/tred.xpm");
  $sortAttrs=(exists $$confs{sortAttributes}) ? $$confs{sortAttributes} : 1;
  $psFontName=(exists $$confs{psfontname}) ? $$confs{psfontname} : "Arial-Medium";
  $psFontSize=(exists $$confs{psfontsize}) ? $$confs{psfontsize} : "12";
  ($macroFile)=<$$confs{macrofile}> if (exists $$confs{macrofile});
  ($defaultMacroFile)=(exists $confs->{defaultmacrofile}) ? <$$confs{defaultmacrofile}> : ("$libDir/tred.def");
  $prtFmtWidth=(exists $confs->{prtfmtwidth}) ? $confs->{prtfmtwidth} : '21c';
  $prtFmtHeight=(exists $confs->{prtfmtheight}) ? $confs->{prtfmtheight} : '297m';
  $prtVMargin=(exists $confs->{prtvmargin}) ? $confs->{prtvmargin} : '3c';
  $prtHMargin=(exists $confs->{prthmargin}) ? $confs->{prthmargin} : '1c';
  $psMedia=(exists $confs->{psmedia}) ? $confs->{psmedia} : '%%DocumentMedia: A4 595 842 white()';
  ($psFile)=(exists $confs->{psfile}) ? <$$confs{psfile}> : ('tred.ps');
  $drawBoxes=(exists $confs->{drawboxes}) ? $confs->{drawboxes} : 0;
  $highlightAttributes=(exists $confs->{highlightattributes}) ? $confs->{highlightattributes} : 1;
  $maximizePrintSize=(exists $confs->{maximizeprintsize}) ? $confs->{maximizeprintsize} : 0;
  $showHidden=exists ($confs->{showhidden}) ? $confs->{showhidden} : 0;
  $createMacroMenu=(exists $confs->{createmacromenu}) ? $confs->{createmacromenu} : 0;
  $maxMenuLines=(exists $confs->{maxmenulines}) ? $confs->{maxmenulines} : 20;
  $useCzechLocales=(exists $confs->{useczechlocales}) ? $confs->{useczechlocales} : ($^O !~ /^MS/);
  $Tk::strictMotif=(exists $confs->{strictmotif}) ? $confs->{strictmotif} : 0;
  $printColors=(exists $confs->{printcolors}) ? $confs->{printcolors} : 0;
  $cstsToFs=(exists $confs->{cststofs}) ? $confs->{cststofs} : undef;
  $fsToCsts=(exists $confs->{fstocsts}) ? $confs->{fstocsts} : undef;
  $gzip=(exists $confs->{gzip}) ? $confs->{gzip} : (-x "/bin/gzip" ? "/bin/gzip -c" : undef);
  $zcat=(exists $confs->{zcat}) ? $confs->{zcat} : (-x "/bin/zcat" ? "/bin/zcat" : $gzip." -c");
  $keyboardDebug=(exists $confs->{keyboarddebug}) ? $confs->{keyboarddebug} : 0;
  $hookDebug=(exists $confs->{hookdebug}) ? $confs->{hookdebug} : 0;
  $macroDebug=(exists $confs->{macrodebug}) ? $confs->{macrodebug} : 0;
  $tredDebug=(exists $confs->{treddebug}) ? $confs->{treddebug} : 0;
  
  $defaultTemplateMatchMethod=(exists $confs->{searchmethod}) ? $confs->{searchmethod} : 'E';
  $defaultMacroListOrder=(exists $confs->{macrolistorder}) ? $confs->{macrolistorder} : 'M';

  $defCWidth=(exists $confs->{canvaswidth}) ? $confs->{canvaswidth} : '18c';
  $defCHeight=(exists $confs->{canvasheight}) ? $confs->{canvasheight} : '12c';

  $geometry=(exists $confs->{geometry}) ? $confs->{geometry} : undef;
  $maxDisplayedValues=(exists $confs->{maxDisplayedValues}) ? $confs->{maxDisplayedValues} : 30;

  foreach (0..9) {
    @recentFiles[$_]=$confs->{"recentfile$_"};
  }
  @recentFiles=grep {$_} @recentFiles;
  print STDERR "Applying configuration.\n" if $tredDebug;
}


sub readMacros {
  # This subroutine reads macro file. Macros are usual perl
  # subroutines and may use this program's namespace. They are also
  # provided some special names for certain variables which override
  # the original namespace.

  # Macros may be bound to a keysym with a special form of a comment.
  # The synax is:
  #
  # # bind MacroName to key [[Modifyer+]*]KeySym
  #
  # which causes subroutine MacroName to be bound to keyboard event of
  # simoultaneous pressing the optionally specified Modifyer(s) (which
  # should be some of Shift, Ctrl and Alt) and the specified KeySym
  # (this probabbly depends on platform too :( ).


  my ($file,$keep)=(shift,shift);
  my $macro;
  my $key;
  local *F;
  my @contexts=@_;

  @contexts=("TredMacro") unless (@contexts);
  unless ($keep) {
    %keyBindings=();
    %menuBindings=();
    @macros=();
    print "ERROR: Cannot open macros!\n", return
      unless open(F,"<$defaultMacroFile");
    push @macros, <F>;
  }
  close F;

  print "ERROR: Cannot open macros!\n", return
    unless open(F,"<$file");

#
# new "pragmas":
#
# include <file>
# include "file"
#
# binding-context <context> [<context> [...]]
#
# key-binding-adopt <contexts>
# menu-binding-adopt <contexts>
#
# bind <method> [to] [key[sym]] <key> [menu <menu>[/submenu[/...]]]
#
# insert <method> [as] [menu] <menu>[/submenu[/...]]
#


  while (<F>) {
    push @macros,$_;
    if (/\#[ \t]*binding-context[ \t]+(.*)/) {
      @contexts=(split /[ \t]+/,$1);
    } elsif (/\#[ \t]*key-binding-adopt[ \t]+(.*)/) {
      my @toadopt=(split /[ \t]+/,$1);
      my $context;
      my $toadopt;
      foreach $context (@contexts) {
	$keyBindings{$context}={} unless exists($keyBindings{$context});
	foreach $toadopt (@toadopt) {
	  foreach (keys %{$keyBindings{$toadopt}}) {
	    $keyBindings{$context}->{$_}=$keyBindings{$toadopt}->{$_};
	  }
	}
      }
    } elsif (/\#[ \t]*menu-binding-adopt[ \t]+(.*)/) {
      my @toadopt=(split /[ \t]+/,$1);
      my $context;
      my $toadopt;
      foreach $context (@contexts) {
	$menuBindings{$context}={} unless exists($menuBindings{$context});
	foreach $toadopt (@toadopt) {
	  foreach (keys %{$menuBindings{$toadopt}}) {
	    $menuBindings{$context}->{$_}=$menuBindings{$toadopt}->{$_};
	  }
	}
      }
    } elsif (/\#[ \t]*bind[ \t]+(\w*)[ \t]+(?:to[ \t]+)?(?:key(?:sym)?[ \t]+)?([^ \t\r\n]+)(?:[ \t]+menu[ \t]+(.+))?/)
      {
	$macro=$1;
	$key=uc($2);
	$menu=encode($3);
	#print "binding $key [$menu] => $macro\n";
	foreach (@contexts) {
	  $keyBindings{$_}={} unless exists($keyBindings{$_});
	  $keyBindings{$_}->{$key}="$_"."->"."$macro";
	  if ($menu) {
	    $menuBindings{$_}={} unless exists($menuBindings{$_});
	    $menuBindings{$_}->{$menu}=["$_"."->"."$macro",$key] if ($menu);
	  }
	}
      } elsif (/\#[ \t]*insert[ \t]+(\w*)[ \t]+(?:as[ \t]+)?(?:menu[ \t]+)?(.+)/) {
	$macro=$1;
	$menu=encode($2);
	foreach (@contexts) {
	  $menuBindings{$_}={} unless exists($menuBindings{$_});
	  $menuBindings{$_}->{$menu}=["$_"."->"."$macro",$key] if ($menu);
	}
      } elsif (/\#[[ \t]*include[ \t]+(.+)/) {
	my $mf=$1;
	print STDERR "including $mf\n";
	unless (-f $mf) {
	  $mf=dirname($file).$m1;
	  print STDERR "trying $mf\n";
	  unless (-f $mf) {
	    $mf="$libDir/$1";
	    print STDERR "not found, trying $mf\n";
	  }
	}
	if (-f $mf) {
	  readMacros($mf,1,@contexts);
	} else {
	  print STDERR "Cannot include macros $1: file not found!\n";
	}
      }
  }
  close(F);
}

sub gotoFile {
  my ($grp,$fn)=@_;
  return 0 if doEvalHook($grp,"goto_file_hook") eq 'stop';
  return 0 if ($fn > $#files or $fn<0);
#  askSaveFile($grp);
  $grp->{currentFileNo}=$fn;
  openFile($grp,$files[$grp->{currentFileNo}]);
  if ($grp->{Filelist}) {
    $grp->{Filelist}->activate($grp->{currentFileNo});
    $grp->{Filelist}->selectionClear(0,'end');
    $grp->{Filelist}->selectionSet($grp->{currentFileNo});
  }
  return 1;
}

sub nextFile {
  my $grp=shift;
  return gotoFile($grp,$grp->{currentFileNo}+1);
}
sub prevFile {
  my $grp=shift;
  return gotoFile($grp,$grp->{currentFileNo}-1);
}

sub closeFile {
  my $grp=shift;
  my $key;

  $grp->{Nodes}=undef;
  undef $NodeClipboard;
  $grp->{root}=undef;
  $grp->{FSFile}=undef;
  delete $grp->{'currentNode'} if (exists $grp->{'currentNode'});
  undef %{$grp->{pinfo}} if ($grp->{pinfo});
  $grp->{'top'}->title("$appName");
  $valueLine="";
  redraw_tree($grp);

#  foreach ($grp->{FSFile}->trees) { DeleteTree($_); }
}

sub ErrorMessage {
  my ($grp,$msg)=@_;
  if ($grp->{top}) {
    $grp->{top}->
      messageBox(-icon => 'error',
		 -message => $msg,
		 -title => 'Error', -buttons => qw/OK/);
  } else {
    print STDERR "$msg\n";
  }
}

sub addToRecent {
  my ($grp,$f)=@_;

  if ($f) {
    @recentFiles=grep { $_ ne $f } @recentFiles;
    unshift @recentFiles,rel2abs($f);
  }
  @recentFiles=@recentFiles[0..min($#recentFiles,9)];

  if ($grp->{RecentFileMenu}) {
    my $menu = $grp->{RecentFileMenu}->cget(-menu);
    $menu->delete(0,'end');
    my $i=0;
    foreach (@recentFiles) {
      $grp->{RecentFileMenu}->command(-label  => "$i.  $_",
				      -underline => 0,
				      -command => [\&openFile,$grp,$_]);
      $i++;
    }
  }
}

sub openFile {
  my $grp = shift;
  my $f = shift;
  my $goto = undef;
  my $fs;
  my $gz='';
  my $in1='<';
  my $in2='';
  my %fs=(fs => 'FS format', 
	  fgz => 'gzipped FS format', 
	  any => 'any non-specific format (csts?), using CstsToFs');

  askSaveFile($grp);
  $grp->{top}->Busy(-recurse => 1);

  closeFile($grp);

  if ($f=~/(##?[0-9A-Z]+)$/) {
    $f=~s/(##?[0-9A-Z]+)$//;
      $goto=$1
  }

  #########################################
  # opening file to find out the file type
  #
  if ($f=~/\.f?gz$/i) {
    $gz='gzipped ';
    $in1="$zcat ";
    $in2=" |";
  }
  unless (open(F,"$in1$f$in2")) {
    ErrorMessage($grp, "Cannot read from $in1$f$in2\n($!)\n");
    $grp->{top}->Unbusy();
    return 0;
  }
   else {
    # peep on the first character
    $fs=($_=<F> and /^\@/) ? 'fs' : 'any';
  }
  close(F);
  #
  #########################################


  print STDERR "File \'$f\' is in $gz", $fs{$fs},"\n" if $tredDebug;

  if ($fs eq 'any') {
    if ($in1 eq '<') {
      $in1=$cstsToFs." ";
      $in2=" |";
    } else {
      $in2.=$cstsToFs." |";
    }
  }
  print STDERR "Reading from $in1$f$in2\n" if $tredDebug;
  # opening file again, know it is fs
  unless (open(F,"$in1$f$in2")) {
    ErrorMessage($grp,"Cannot read from $in1$f$in2\n($!)\n");
    $grp->{top}->Unbusy();
    return 0;
  }

  $grp->{'FSFile'} = FSFile->new();
  $grp->{'FSFile'}->changeFilename($f);
  $grp->{'FSFile'}->changeFileFormat($gz.$fs);
  $grp->{'FSFile'}->readFrom(\*F);
  print STDERR "empty or corrupt file!\n" if ($grp->{FSFile}->lastTreeNo<0);


  close (F);
  

  #parse Rest
  @displayAttrs = map { /^\/\/Tred:Custom-Attribute:(.*)$/ ? $1 : () } $grp->{FSFile}->tail;
  unless (@displayAttrs) {
    my ($peep)=$grp->{FSFile}->tail;
    @displayAttrs = map { "\$\{".$grp->{FSFile}->FS->atno($_)."\}" } 
      ($peep=~/[,\(]([0-9]+)/g);
  }

  $grp->{BalloonPattern}=join "\n", map { /^\/\/Tred:Balloon-Pattern:(.*)$/ ? $1 : () } $grp->{FSFile}->tail;

  #print "That is:\n@displayAttrs\n";

  $grp->{treeNo}=0;

  # -- smells like PDT-specific code, at least the second case
  if (defined $goto) {
    if ($goto=~/^##([0-9]+)$/) {
      $grp->{treeNo}=min(max(0,$1),$grp->{FSFile}->lastTreeNo);
    }
    for (my $i=0;$i<=$grp->{FSFile}->lastTreeNo;$i++) {
      $grp->{treeNo}=$i,last if ($grp->{FSFile}->treeList->[$i]->{'form'} eq $goto);
    }
  }
  # --

  # add file to filelist
  $grp->{currentFileNo} = max(0,$grp->{currentFileNo});
  insertToFilelist($grp,$grp->{currentFileNo},$f);
  $grp->{'top'}->title("$appName $f (".($grp->{currentFileNo}+1)."/".@files.")");
  if ($grp->{currentNode}) {
    centerToXY($grp,0,0);
  }
  getNodes($grp);
  $grp->{FSFile}->notSaved(0);
  doEvalHook($grp,"file_opened_hook");
  redraw_tree($grp);
  $grp->{'top'}->Unbusy();

  addToRecent($grp,$f);
  return 1;
}

sub saveFile {
  my $grp=shift;

  return unless $grp->{'FSFile'};

  my $f=$grp->{'FSFile'}->filename;
  my $out="";
  my $of;
  my $gz;

  rename $f,$f."~" if (-f $f);

  if ($grp->{'FSFile'}->fileFormat =~/gzipped/ or $f=~/\.f?gz$/i) {
    if ($gzip) {
      $gz='gzipped ';
      $out.="| $gzip ";
    } else {
      ErrorMessage($grp,"Cannot write gzipped file (No gzip utility defined)\n".
		   "Use file name without the gz suffix to save the file\n".
		   "in a non-gzipped format.\n"
		  );
      return 0;
    }
  }
  if ($grp->{'FSFile'}->fileFormat =~/any/ or $f=~/csts?$|csts?.gz$/i) {
    if ($fsToCsts) {
      $out="| $fsToCsts ".$out;
    } else {
      ErrorMessage($grp,"Cannot export to CSTS file (No option FsToCsts defined)\n".
		   "Use file name without the csts suffix to save the file\n".
		   "in a FS or gzipped FS format.\n"
		  );
      return 0;
    }
  }
  unless (open(FO,"$out> $f")) {
    ErrorMessage($grp,"Cannot write to '$out > $f'\n($!)\n");
    return 0;
  }
  print STDERR "Writing to $out> $f\n" if $tredDebug;
  print FO @{$grp->{FSFile}->FS->unparsed};
  PrintFS(\*FO,$grp->{FSFile}->FS->unparsed,$grp->{FSFile}->treeList,$grp->{FSFile}->FS->list,$grp->{FSFile}->FS->defs); #\@atord,\%attribs);

  ## Tredish custom attributes:
  $grp->{FSFile}->changeTail(
			     (grep { $_!~/\/\/Tred:(?:Custom-Attribute|Balloon-Pattern):/ } $grp->{FSFile}->tail),
			     (map {"//Tred:Custom-Attribute:$_\n"} @displayAttrs),
			     (map {"//Tred:Balloon-Pattern:$_\n"}
			      split /\n/,$grp->{BalloonPattern}));

  #print "Saving with", join ",",@atrIds;
  #print "\n";
  
  print FO $grp->{FSFile}->tail;
  close(FO);
  $grp->{FSFile}->notSaved(0);
  saveFileStateUpdate($grp);
  #print STDERR "wrote $f, $f~ is a backup.\n";
}

sub isShown { # test if node is shown (always 1 if $showHidden)
  my ($grp,$node,$show)=@_;
  $show=$showHidden unless defined $show;

  return 0 unless ($node and $grp->{'FSFile'});
  return 1 if $show or not defined($grp->{FSFile}->FS->hide());
  while ($node and ($node->{$grp->{FSFile}->FS->hide()} ne 'hide')) {
    $node=$node->parent;
  }
  return ($node ? 0 : 1)
}

sub HNext { # same as Next but obey $showHidden
  my ($grp,$node,$top) = @_;
  $node=Next($node,$top);
  while ($node) {
    return $node if (isShown($grp,$node));
    $node=Next($node,$top);
  }
  return 0;
}

sub HPrev { # same as Next but obey $showHidden
  my ($grp,$node,$top) = @_;
  $node=Prev($node,$top);
  while ($node) {
    return $node if (isShown($grp,$node));
    $node=Prev($node,$top);
  }
  return 0;
}

sub getValueLine {
  my ($grp)=@_;
  return unless $grp->{'FSFile'};

  my $node=$grp->{root};
  my @sent=();

  #$valueLine="";

  my $attr=$grp->{FSFile}->FS->sentord;
  while ($node) {
    push @sent,$node unless $node->{$attr}>=999; # this is TR specific
    $node=Next($node);
  }
  my $defs = join ",", values %{$grp->{FSFile}->FS->defs};

  # this is a workaround for TR vs. ATS (ATS trees use only @N to sort
  # @V to a sentence while on TR there is @W defined for this purpose)
  $attr=$grp->{FSFile}->FS->order unless ($defs=~/W/);

  @sent = sort { $a->{$attr} <=> $b->{$attr} } @sent;

  $attr=$grp->{FSFile}->FS->value;
  $valueLine = 
    ($grp->{treeNo}+1)."/".($grp->{FSFile}->lastTreeNo+1).": ".
    encode(join(" ", map { $_->{$attr} } @sent));
  undef @sent;
}


sub getNodes {
# prepare value line and @nodes list with deleted/saved hidden
# and ordered by real Ord

  my ($grp)=@_;
  return unless $grp->{FSFile};
  $grp->{Nodes}=[];
  my @unsorted=();
  $grp->{treeNo}=0 if ($grp->{treeNo}<0);
  $grp->{treeNo}=$grp->{FSFile}->lastTreeNo if ($grp->{treeNo}>$grp->{FSFile}->lastTreeNo);
  $grp->{root}=$grp->{FSFile}->treeList->[$grp->{treeNo}];
  my $node=$grp->{root};
  my $current=$grp->{root};
  my $prevcurrent=$grp->{currentNode};

#  use Benchmark;
#  my $t=timeit(100, 'getValueLine($grp);');
#  print "$count loops of getNodes took: ",timestr($t),"\n";
  getValueLine($grp);

  while($node)
  {
    push @unsorted, $node;
    $current=$node if ($prevcurrent eq $node);
    $node=HNext($grp,$node);  #skip also hidden subtrees unless showHidden

  }
  $grp->{'currentNode'}=$current;
  my $ord=$grp->{FSFile}->FS->order;
  @{$grp->{Nodes}}=
    sort { $a->{$ord} <=> $b->{$ord} } 
      @unsorted;

  # just for sure
  undef @unsorted;

  # this is actually a workaround for TR, where two different nodes
  # may have the same Ord
}

sub insertToFilelist {
  my ($grp,$position)=(shift,shift);
  $position=$grp->{currentFileNo} if not defined($position);

  unless ($files[$position] eq @_[0]) {
    splice @files,$position+1,0, map { rel2abs($_) } @_;
    if ($grp->{Filelist}) {
      $grp->{Filelist}->delete(0,'end');
      $grp->{Filelist}->insert('end',@files);
      $grp->{Filelist}->activate($position+1);
      $grp->{Filelist}->see('active');
      $grp->{Filelist}->selectionClear(0,'end');
      $grp->{Filelist}->selectionSet($position+1);
    }
  }
}

sub removeFromFilelist {
  my ($grp,$position)=(shift,shift);
  print "Removing @_\n";
  print "Position is $position\n";
  foreach (@_) {
    splice @files,$_,1;
  }
  if ($grp->{Filelist}) {
    $grp->{currentFileNo} = min($grp->{currentFileNo},$#files);
    if (not defined($position)) {
      $position=$grp->{currentFileNo} 
    } else {
      $position=min($position,$#files);
    }
    $grp->{Filelist}->delete(0,'end');
    $grp->{Filelist}->insert('end',@files);
    $grp->{Filelist}->activate($position) if (defined($position));
    $grp->{Filelist}->see('active');
    $grp->{Filelist}->selectionClear(0,'end');
    $grp->{Filelist}->selectionSet($position) if (defined($position));
  }
}

sub filelistDialog {

  use Tk::LabFrame;

  my $grp=shift;
  return if ($grp->{Filelist});
  my $d = $grp->{'top'}->Toplevel(-title => "Filelist");
  $d->withdraw;
  $grp->{'filelistDialog'}=$d;
  #  $d->resizable(0,0);
  my $frame=$d->Frame();
  my $labframe=$frame->LabFrame(-label => 'Files to add',
				-labelside => 'acrosstop'
			       )->pack(qw/-expand yes -fill both -side left/);
  my $fl = $labframe->MyFileSelect(-selectmode => extended,
				   -filetypes => \@open_types)
    ->pack(qw/-expand yes -fill both -side left -padx 5 -pady 5/);

  $fl->Subwidget('filelist')->configure(qw/-background white -foreground black/);
#  $fl->Subwidget('entry')->configure(qw/-background white -foreground black/);

  my $midframe=$frame->Frame()->pack(qw/-side left/);

  my $t = $frame->Scrolled(qw/Listbox -relief sunken 
                     -borderwidth 2 -setgrid true
    		     -background white
		     -foreground black
                     -selectmode extended
                     -width 60
		     -height 15 -scrollbars e/)
    ->pack(qw/-expand yes -fill both -side left -padx 5 -pady 5/);
  $grp->{Filelist}=$t;
  $t->insert('end',@files);
#  $grp->{Filelist}->configure(-width=>0) if (@files);
  $frame->pack(qw/-expand yes -fill both -side top/);

  my $addbutton=
    $midframe->Button(-text => 'Add -->',
	       -command=>[
			  sub { 
				my ($grp,$t,$l)=@_;
				insertToFilelist($grp,$t->index('active'),$l->getSelectedFiles);
				$t->see('active');
			      },$grp,$t,$fl])->pack(-side => top);
  my $addbutton=
    $midframe->Button(-text => 'Remove',
	       -command=>[
			  sub { 
				my ($grp,$t,$l)=@_;
				removeFromFilelist($grp,$t->index('active'),$t->curselection);
				$t->see('active');
			      },$grp,$t,$fl])->pack(-side => top);

  $t->bind('<Return>' => [
			  sub {
			    shift;
			     gotoFile(shift,shift->index('active'));
			   },$grp,$t ]);
  $t->bind('<Double-1>' => [
			    sub {
			      shift;
			      gotoFile(shift,shift->index('active'));
			   },$grp,$t ]);

  $d->Button(-text => 'Go',
	     -command => [ sub {
			     gotoFile(shift,shift->index('active'));
			   },$grp,$t ])->pack(-padx=>'0.5c',-pady=>'0.2c',-side=>left);
  $d->bind('<Destroy>' => [sub { shift; shift->{Filelist}=undef; },$grp ]);
  $d->bind('all','<Escape>' =>
	   [sub {
	      shift; shift->destroy();
	    },$d ]);

  $d->Button(-text => 'Close',
		     -command => [ sub {
				     #shift->{Filelist}=undef;
				     shift->destroy();
				   },$d ])->pack(-padx=>'0.5c',-pady=>'0.2c',-side=>right);
  if ($grp->{currentFileNo}) {
    $t->activate($grp->{currentFileNo});
    $t->selectionSet($grp->{currentFileNo});
    $t->see('active');
  }
  $t->focus;
  $d->Popup;

}

sub generateSortedMacroTable {
  my ($grp)=@_;
  @macroTable = map { [ 
		       $_,
		       $menuBindings{$grp->{macroContext}}->{$_}->[1],
		      ] } keys %{$menuBindings{$grp->{macroContext}}};
  if ($grp->{macroListOrder} eq 'K') {
    return sort {
      my @a= split '\+',$a->[1];
      my @b= split '\+',$b->[1];
      return $#a <=> $#b if ($#a != $#b);
      return length($a[0]) cmp length($b[0]) if (length($a[0]) ne length($b[0]));
      return $a[0] cmp $b[0] if ($a[0] ne $b[0]);
      return length($a[1]) cmp length($b[1]) if (length($a[1]) ne length($b[1]));
      return $a[1] cmp $b[1] if ($a[1] ne $b[1]);
      return length($a[2]) cmp length($b[2]) if (length($a[2]) ne length($b[2]));
      return $a[2] cmp $b[2] if ($a[2] ne $b[2]);
      return length($a[3]) cmp length($b[3]) if (length($a[3]) ne length($b[3]));
      return $a[3] cmp $b[3] if ($a[2] ne $b[3]);
      return $a cmp $b;
    } @macroTable;
  } else {
    return sort { $a->[0] cmp $b->[0] } @macroTable;
  }
}

sub macrolistCreateItems {
  my ($grp,$t)=@_;
  $t->delete('all');
  foreach my $entry (generateSortedMacroTable($grp)) {
    $e = $t->addchild("");
    $t->itemCreate($e, 0, -itemtype=>'text', -text=>$entry->[0]);
    $t->itemCreate($e, 1, -itemtype=>'text', -text=>$entry->[1]);
  }
}

sub macrolistDialog {
  my $grp=shift;
  my $context=$grp->{macroContext};
  if ($grp->{Macrolist}) {
    $grp->{Macrolist}->deiconify;
    $grp->{Macrolist}->focus;
    $grp->{Macrolist}->raise;
    return;
  }
  unless (scalar(keys %{$menuBindings{$context}})) {
    ErrorMessage($grp,"No named macros in current context ($context)");
    return;
  }
  my $d = $grp->{'top'}->Toplevel(-title => "List of available named macros");
  $d->withdraw;
  $d->resizable(0,1);
  my $t = $d->Scrolled(qw/HList -columns 2 -background white 
           -selectmode browse
           -height 25 -relief sunken -scrollbars e/);
  $grp->{Macrolist}=$d;
  my $e;
  my $maxw=0;
  macrolistCreateItems($grp,$t);

  $t->columnWidth(0,'');
  $t->columnWidth(1,'');
  $t->anchorSet('0');

  $t->configure(-width => 0);
  $t->pack(qw/-expand yes -fill both/);
  $d->bind('<Return>' =>
	   [
	    sub {
	      my ($w,$grp,$t)=@_;
	      doEvalMacro($grp,
			  $menuBindings{$context}->
			  {$t->itemCget($t->info('anchor'),0,'-text')}->[0]);
	    },$grp,$t ]);
  $d->bind('<Double-1>' => 
	   [
	    sub {
	      my ($w,$grp,$t)=@_;
	      doEvalMacro($grp,
			  $menuBindings{$context}->
			  {$t->itemCget($t->info('anchor'),0,'-text')}->[0]);
	    },$grp,$t ]);

  my $f=$d->Frame()->pack();
  $f->Radiobutton( -anchor   => 'nw',
		   -text     => 'Sort by name',
		   -variable => \$grp->{macroListOrder},
		   -relief   => 'flat',
		   -command  => [sub { #shift;
				       my ($grp,$t)=@_;
				       macrolistCreateItems($grp,$t);
				     },$grp,$t],
		   -value    => 'M'
		 )->pack(-side => 'left',-padx => 20);
  $f->Radiobutton( -anchor   => 'nw',
		   -text     => 'Sort by keyboard shortcut',
		   -variable => \$grp->{macroListOrder},
		   -relief   => 'flat',
		   -command  => [sub { #shift;
				       my ($grp,$t)=@_;
				       macrolistCreateItems($grp,$t);
				     },$grp,$t],
		   -value    => 'K'
		 )->pack(-side => 'right',-padx => 20);

  $d->Button(-text => 'Run and Close',
	     -command => [ sub {
			     my ($w,$grp,$t)=@_;
			     doEvalMacro($grp,
			       $menuBindings{$context}->
				 {$t->itemCget($t->info('anchor'),0,'-text')}->[0]);
			     $w->destroy();
			   },$d,$grp,$t ])->pack(-padx=>'0.5c',-pady=>'0.2c',-side=>left);
  $d->bind('<Destroy>' => [sub { shift; shift->{Macrolist}=undef; },$grp ]);
  $d->bind('all','<Escape>' =>
	   [sub {
	      shift; shift->destroy();
	    },$d ]);

  $d->Button(-text => 'Close',
		     -command => [ sub {
				     shift->destroy();
				   },$d ])->pack(-padx=>'0.5c',-pady=>'0.2c',-side=>right);
  $t->focus;
  $d->Popup;
}

sub printDialog {
  my $grp=shift;

  return unless $grp->{FSFile};

  my $com=$grp->{'printCommand'};
  my $fil=$grp->{'printPsFile'};
  my $toFile=$grp->{'printToFile'};
  my $toEPS=$grp->{'printToEPS'};
  my $useType1Font=$grp->{'printUseType1Font'};
  my $printRange=$grp->{'printRange'};
  my $snt=$grp->{'printSentenceInfo'};

  my $d = $grp->{'top'}->DialogBox(-title => "Print",
				-buttons => ["OK", "Cancel"]);
  $d->resizable(0,0);
  addBindTags($d,'dialog');
  $d->bind('all','<Escape>' => [sub { shift; shift->{'selected_button'}='Cancel'; },$d ]);
  $d->bind('all','<Tab>',[sub { shift->focusNext; }]);
  $d->bind('all','<Shift-Tab>',[sub { shift->focusPrev; }]);
  my $cf = $d->Frame();
  my $cl = $cf->Label(-text => 'Print command:',
		     -anchor => 'w',
		     -justify => 'right')->pack(-side => 'left');

  my $ce = $cf->Entry(-relief => 'sunken',
		     -width => 20,
		     -font => $font,
		     -textvariable => \$com)->pack(-side => 'left');
  my $defaultBg=$ce->cget('-background');
  my $disabledBg=$d->cget('-background');

  $ce->configure($toFile 
		? (-state => 'disabled',-background => $disabledBg)
		: (-state => 'normal', -background => $defaultBg));


  $cf->pack(-pady => '5m', -side=>'top');
  my $ff=$d->Frame();
  my $fl = $ff->Label(-text => 'File name:',
		     -anchor => 'w',
		     -justify => 'right')->pack(-side => 'left');

  my $fe = $ff->Entry(-relief => 'sunken',
		     -width => 20,
		     -font => $font,
		     -textvariable => \$fil)->pack(-side => 'left');

  $fe->configure($toFile 
		? (-state => 'normal', -background => $defaultBg)
		: (-state => 'disabled',-background => $disabledBg));
  my $of=$d->Frame();
  my $bf=$of->Frame();
  $bf->Checkbutton(-text     => 'Print to file',
		   -variable => \$toFile,
		   -command  => [sub {
				  my ($t,$c,$f)=@_;
				  if ($$t) {
				    $f->focus;
				    $c->configure(-state => 'disabled',
						  -background => $disabledBg);
				    $f->configure(-state => 'normal',
						  -background => $defaultBg);
				  } else {
				    $c->focus;
				    $f->configure(-state => 'disabled',
						  -background => $disabledBg);
				    $c->configure(-state => 'normal',
						  -background => $defaultBg);
				  }
				},\$toFile,$ce,$fe ],
		   -relief   => 'flat')->pack(-fill => 'y',-anchor => 'nw');

  $bf->Checkbutton(-text     => 'Create EPS',
			  -variable => \$toEPS,
			  -relief   => 'flat')->pack(-fill => 'y',-anchor => 'nw');

  $bf->Checkbutton(-text     => 'Use Type1 Postscript Font',
			  -state => $type1font ? 'normal' : 'disabled' ,
			  -variable => \$useType1Font,
			  -relief   => 'flat')->pack(-fill => 'y',-anchor => 'nw');

  $bf->Checkbutton(-text => 'Use colors',
		   -variable => \$printColors,
		   -relief   => 'flat')->pack(-fill => 'y',-anchor => 'nw');
  $bf->Checkbutton(-text => 'Print sentence',
		   -variable => \$snt,
		   -relief   => 'flat')->pack(-fill => 'y',-anchor => 'nw');
  
  $bf->pack(-side => 'right');
  $of->pack(-fill => 'x',-padx=>'1c');
  my $sf = $d->Frame();
  $sf->Label(-text => 'Page range:',
	     -anchor => 'w',
	     -justify => 'right')->pack(-side => 'left');
  $sf->Entry(-relief => 'sunken',
	     -width => 20,
	     -font => $font,
	     -textvariable => \$printRange)->pack(-side => 'left', -padx=>'2m');
  $sf->pack(-side => 'bottom', -pady => '5m');
  $ff->pack(-side => 'bottom', -pady => '5m');

#  $toFile ? $fe->focus : $ce->focus;
  my $result = ShowDialog($d,$toFile ? $fe : $ce,$grp->{top});
  $grp->{'printRange'}=$printRange;
#  $grp->{'printSelection'}= join(' ',grep { $lt->selectionIncludes($_) } (0 .. $lt->size-1));
  $grp->{'printToFile'}=$toFile;
  $grp->{'printToEPS'}=$toEPS;
  $grp->{'printPsFile'}=$fil;
  $grp->{'printSentenceInfo'}=$snt;
  $grp->{'printCommand'}=$com;
  $grp->{'printUseType1Font'}=$useType1Font;
  $d->destroy;
  undef $d;
  return ($result =~ /OK/);
}

sub printThis {
  my ($grp)=@_;
  my $i;
  my $c=$grp->{'canvas'};
  my $saveTreeNo=$grp->{treeNo};
  my $savefont=$font;
  my $pagewidth;
  my $pageheight;
  my $printMultiple;
  my @printList=();
  my %pso;

  if (not printDialog($grp)) {
    #print "Printing aborted!\n";
    return;
  }

  $backgroundColor=$grp->{canvas}->cget('-background');
  {
    local $outputenc='iso-88859-2';
    local ($lineColor, $nodeColor, $currentBoxColor, $boxColor, 
	   $currentNodeColor, $currentNodeWidth, $currentNodeHeight,
	   $nearestNodeColor,
	   $textColor , $textColorShadow, $textColorHilite,
	   $textColorXHilite, $activeTextColor, $noColor)=
	     ($lineColor, $nodeColor, $currentBoxColor, $boxColor, 
	      $nodeColor, $nodeWidth, $currentNodeHeight,
	      $nearestNodeColor,
	      $textColor , $textColorShadow, $textColorHilite, 
	      $textColorXHilite, $activeTextColor,$noColor);

    unless ($printColors) {
      $lineColor='black';
      $nodeColor='white';
      $currentBoxColor='white';
      $boxColor='white';
      $currentNodeColor = 'white';
      $nearestNodeColor= 'white';
      $textColor = 'black';
      $textColorShadow = 'black';
      $textColorHilite = 'black';
      $textColorXHilite = 'black';
      $activeTextColor='black';
      $noColor=1;
    }

    local $backgroundColor='white';
    local $lineWidth=1;
    local $font=$savefont;
    local $drawSentenceInfo=$grp->{printSentenceInfo};

    my $pbeg;
    my $pend;
    foreach (split /,/,$grp->{'printRange'}) {
      print "Parsing $_\n";
      if (/^\s*([0-9]+)\s*$/ and $1<=$grp->{FSFile}->lastTreeNo) {
	print "Prepairing $1\n";
	push @printList,$1;
	next;
      }
      if (/^\s*([0-9]*)\s*-\s*([0-9]*)\s*$/) {
	print "Prepairing $1-$2\n";
	($pbeg,$pend)=($1,$2);
	$pend=$grp->{FSFile}->lastTreeNo+1 if ($pend eq '');
	$pbeg=1 if ($pbeg eq '');
	$pend=min($grp->{FSFile}->lastTreeNo+1,$pend);
	next unless ($pbeg<=$pend);
	push @printList,$pbeg..$pend;
      }
    }
    #  @printList=split ' ',$grp->{'printSelection'};
    push @printList,$grp->{treeNo}+1 unless (@printList);

    unless (open(F,"<$psFontFile")) {
      print STDERR "Aborting: failed to open font file $psFontFile\n";
      return 0;
    }
    if ($grp->{'printToFile'}) {
      #print "Trying to print to ",$grp->{'printPsFile'},"\n";
      return 0 unless open(O,">".$grp->{'printPsFile'});
      #print "File successfully opend!\n";
    } else {
      #print "Trying to print via command ",$grp->{'printCommand'},"\n";
      $SIG{'PIPE'} = sub {};
      return 0 unless open(O, "| ".$grp->{'printCommand'});
      #print "Pipe successfully opend!\n";
    }

#    $grp->{top}->Busy(-recurse => 1);

    for (my $t=0;$t<=$#printList;$t++) {
      print "Printing $printList[$t]\n";
      $font=$type1font if ($grp->{printUseType1Font});      
      $printList[$t]!=$grp->{treeNo}+1 ? gotoTree($grp,$printList[$t]-1) : redraw_tree($grp);
      my $rotate = ( ! $grp->{printToEPS} 
	and $grp->{canvasHeight}<$grp->{canvasWidth});
      print $grp->{canvasHeight},"x",$grp->{canvasWidth}," $rotate\n";
      if (not $rotate) {
	$pagewidth=$c->fpixels($prtFmtWidth)-2*$c->fpixels($prtHMargin);
	$pageheight=$c->fpixels($prtFmtHeight)-2*$c->fpixels($prtVMargin);
      } else {
	$pagewidth=$c->fpixels($prtFmtHeight)-2*$c->fpixels($prtVMargin);
	$pageheight=$c->fpixels($prtFmtWidth)-2*$c->fpixels($prtHMargin);
      }

      %pso = (-colormode => $printColors ? 'color' : 'gray',
	      -x => 0, -y => 0,
	      -fontmap => { $font => [$psFontName, $psFontSize] },
	      -width => $grp->{canvasWidth},
	      -height => $grp->{canvasHeight},
	      -rotate => $rotate);

      unless ($grp->{printToEPS}) {
	#print "Maximizing: $maximizePrintSize\n";
	if ($maximizePrintSize or $c->fpixels($grp->{canvasWidth})>$pagewidth or
	    $c->fpixels($grp->{canvasHeight})>$pageheight) {
	  print "Adjusting print size\n";
	  if ($c->fpixels($grp->{canvasWidth})/$pagewidth*$pageheight>$c->fpixels($grp->{canvasHeight})) {
	    #print "Applying width\n";
	    $pso{-pagewidth} =
	      $pagewidth;
	    print "Scaling by tree width,\n";
	    print "forcing box width to $pagewidth\n";
	    #$c->fpixels($prtFmtWidth)-2*$c->fpixels($prtHMargin);
	  } else {
	    #print "Applying height\n";
	    $pso{-pageheight} =
	      $pageheight;
	    print "Scaling by tree height,\n";
	    print "forcing box height to $pageheight\n";
	    #$c->fpixels($prtFmtHeight)-2*$c->fpixels($prtVMargin);
	  }
	}
      }
 
#    $grp->{top}->Busy(-recurse => 1);

      my @ps = split /\n/,$c->postscript(%pso);
      $i=0;
      if ($t>0) {
	$i++  while ($i<=$#ps and $ps[$i]!~/^%%Page:/);
	print O '%%Page: ',$t+1," ",$t+1,"\n";
	my $now=localtime;
	unless ($grp->{printToEPS}) {
	  print O "gsave\n",
	    "/Arial-Medium findfont 8 scalefont setfont\n",
	      "0.000 0.000 0.000 setrgbcolor AdjustColor\n",
		"40 40 [\n",
		  "(".
#		    "File ",$grp->{FSFile}->filename,".    ".
		    "Printed by TrEd on $now.)\n",
		    "] 13 -0 0 0 false DrawText\ngrestore\n";
	}
	$i++;
      } else {
	$i=0;
	print "Lines:",$#ps,"\n";
	unless ($grp->{printToEPS}) {
	  print O $ps[$i++],"\n" while ($i<=$#ps and $ps[$i]!~/^%%BoundingBox:/);
	  #	print "Bounding Box:\n";
	  #	print $ps[$i],"\n";
	  print O $ps[$i++],"\n";
	  print O $psMedia,"\n";
	  print O '%%Pages: ',$#printList+1,"\n";
	  $i++;
	}
	print O $ps[$i++],"\n" while ($i<=$#ps and $ps[$i] !~ /^%%DocumentNeededResources: font Arial-Medium/);
	print O $ps[$i++],"\n" while ($i<=$#ps and $ps[$i]!~/^%%BeginProlog/);
	print O $ps[$i++],"\n";
	print O '%%BeginFont arialm',"\n";
	print O <F>;
	print O '%%EndFont',"\n\n";
	$i++ while ($i<=$#ps and $ps[$i]!~/% StrokeClip/);
	print O $ps[$i++],"\n" while ($i<=$#ps and $ps[$i]!~/^%%IncludeResource: font Arial-Medium/);
	$i++;
      }

      # replacing ISOEncode
      while ($i<=$#ps && $ps[$i]!~/^%%Trailer\w*$/) {
	$ps[$i]=~s/ISOEncode //g;
	print O $ps[$i++],"\n";
      }
    }
    print O '%%EOF',"\n";
    #print "$i: Done.\n";
    close (F);
    close (O);

    #print "$psFile written!\n";
  }

  if ($grp->{treeNo} eq $saveTreeNo) { redraw_tree($grp); }
  else { gotoTree($grp,$saveTreeNo); }
  $grp->{top}->Unbusy();

  return 1;
}


sub switchContext {
  my ($grp,$context)=@_;
  my $prevcontext=$grp->{macroContext};
  return 0 if (doEvalHook($grp,"pre_switch_context_hook",$prevcontext,$context) eq 'stop');
  $grp->{macroContext}=$context;
  doEvalHook($grp,"switch_context_hook",$prevcontext,$context);
  redraw_tree($grp);
}


sub gotoTree {
  my $grp=shift;
  return unless $grp->{'FSFile'};
  my $no = max(0,min(shift,$grp->{FSFile}->lastTreeNo));
  return $grp->{treeNo} if doEvalHook($grp,"goto_tree_hook") eq 'stop';
  return $no if ($no == $grp->{treeNo});
  $grp->{treeNo}=$no;
  getNodes($grp);
  centerToXY($grp,0,0);
  redraw_tree($grp);
  return $no;
}

sub nextTree {
  my ($grp)=@_;
  return unless $grp->{'FSFile'};
  return 0 if ($grp->{treeNo} >= $grp->{FSFile}->lastTreeNo);
  gotoTree($grp,$grp->{treeNo}+1);
  return 1;
}

sub prevTree {
  my ($grp)=@_;
  return 0 if ($grp->{treeNo} <= 0);
  gotoTree($grp,$grp->{treeNo}-1);
  return 1;
}

sub newTree {
  my ($grp)=@_;
  
  my $nr=FSNode->new(); # blessing new root

  splice(@{$grp->{FSFile}->treeList}, $grp->{treeNo}, 0, $nr);

  getNodes($grp);
  centerToXY($grp,0,0);
  redraw_tree($grp);
  return 1;
}

sub newTreeAfter {
  my ($grp)=@_;

  my $nr=FSNode->new(); # blessing new root

  splice(@{$grp->{FSFile}->treeList}, ++$grp->{treeNo}, 0, $nr);

  getNodes($grp);
  centerToXY($grp,0,0);
  redraw_tree($grp);
  return 1;
}

sub pruneTree {
  my ($grp)=@_;

  return unless ($grp->{'FSFile'} and $grp->{FSFile}->treeList->[$grp->{treeNo}]);
  $grp->{root}=$grp->{FSFile}->treeList->[$grp->{treeNo}];
  splice(@{$grp->{FSFile}->treeList}, $grp->{treeNo}, 1);
  DeleteTree($grp->{root});

  $grp->{treeNo}=max(0,min($grp->{treeNo},$grp->{FSFile}->lastTreeNo));
  $grp->{root} = undef;

  getNodes($grp);
  centerToXY($grp,0,0);
  redraw_tree($grp);
  return 1;
}


sub newNode {
  ## Adds new son to current node
  my ($grp)=@_;
  my $parent=$grp->{currentNode};
  return unless ($grp->{'FSFile'} and $parent);

  my $nd=FSNode->new();

  Paste($nd,$parent,$grp->{FSFile}->FS->defs);
  $node->{$grp->{FSFile}->FS->order}=$parent->{$grp->{FSFile}->FS->order};
  setCurrent($grp,$nd);

  getNodes($grp);
  redraw_tree($grp);

  return $nd;
}

sub pruneNode {
  ## Deletes given node
  my ($grp,$node)=@_;
  my $t;
  return undef unless ($grp->{'FSFile'} and $node and $node->parent);

  Paste(Cut($t),$node->parent,$grp->{FSFile}->FS->defs)
    while ($t=$node->firstson);

  setCurrent($grp,$node->parent) if ($node == $grp->{currentNode});
  $t=DeleteLeaf($node);
  getNodes($grp);
  redraw_tree($grp);
  return $t;
}

sub prepareFont {
  my ($grp,$font,$fn)=@_;
  print STDERR "Preparing fonts.\n" if $tredDebug;
  
  if ($$font!~/^-/) {
    my @a=split(/\s*,\s*/,$$font);
    my $option,$value;
    my @b;
    foreach (@a) {
      ($option, $value) = split(/\s*:\s*/, $_, 2);
      push @b, "-".$option, $value if ($option=~/^(?:size|weight|family|slant|underline|overstrike)$/);
    }
      # try
    eval { $grp->{top}->fontDelete($fn) }; 
      # error would be displayed otherwise if yet undefined
      # and I'm lazy to remember or find out how to check
      # :)
    $grp->{top}->fontCreate($fn,@b);
    $$font=$fn;
  }
  #
  # There were problems with the following lines, so I'm skipping them  
  #
  # else {
  #  $grp->{top}->fontCreate('C_normal',$grp->{top}->fontActual($$font));
  #  $$font='C_normal';
  # }
}

sub prepareFonts {
  my $grp=shift;
  prepareFont($grp,\$font,'C_normal');
  prepareFont($grp,\$vLineFont,'C_vline');
}

sub addBindTags {
  my $w=shift @_;
  $w->bindtags([@_,$w,ref($w),$w->toplevel,'all']);

}

sub cascadeMenus {
  my $uM=[ @_[0..min($maxMenuLines-1,$#_)] ];
  my $uuM=$uM;
  $i=$maxMenuLines;
  while ($i<=$#_) {
    $_=[@_[$i..min($i+$maxMenuLines-1,$#_)]];
    push @$uuM,[Cascade => 'More...', -menuitems => $_];
    $uuM=$_;
    $i+=$maxMenuLines;
  }
  return $uM;
}

sub saveFileStateUpdate {
  my ($grp)=@_;
  $grp->{'saveButton'}->
    configure(-image =>
	      ($grp->{FSFile} and $grp->{FSFile}->notSaved)
	      ? $grp->{'normalSavePixmap'} : $grp->{'savedSavePixmap'});
}


sub About {
  my ($grp)=@_;
  my $message="";
  my $fileinfo="";
  my $colinf="";
  print STDERR "=" x 60,"\n",join("\n",keys(%$grp)),"=" x 60,"\n";
  if ($grp->{FSFile}) {
    $fileinfo=
      "Current file:\n".
	$grp->{FSFile}->filename."\n".
	  "Format: ".$grp->{FSFile}->fileFormat.", ".$grp->{FSFile}->lastTreeNo." trees\n";
    my %colinf=(Shadow => [], Hilite =>, XHilite => []);
    foreach ($grp->{FSFile}->FS->attributes) {
      push @{$colinf{$grp->{FSFile}->FS->color($_)}},$_
	unless ($grp->{FSFile}->FS->color($_) eq 'normal');
    }
    $colinf="Coloured attributes:\n    Highlited: ".join(",",@{$colinf{Hilite}}).
      "\n    XHighlited: ".join(",",@{$colinf{XHilite}}).
	"\n    Shadow: ".join(",",@{$colinf{Shadow}})."\n";
  }

  doEvalHook($grp,"about_file_hook",\$message);
  $grp->{top}->messageBox(-icon => 'info',
			  -type => 'ok',
			  -message =>
			  "TrEd version $version\n\n$fileinfo$colinf$message\n$about\n\nLast update: $lastupdate",
			  -title => 'About');
}

sub keyBind {
  local $_=shift;
  s/-/+/g;
  s/Control/CTRL/g;
  return uc($_);
}

sub startMain {
  my $firstFile=shift;
  my $node;
  my $parent;
  my %group;

  $group{top}=MainWindow->new;

  if (defined($geometry)) {
    if ($geometry=~/^(.*)x(.*)\+([0-9]+)\+([0-9]+)/) {
        $geometry
	  = "$1x$2+".min($3,$group{top}->vrootwidth-$1).
	    "+".min($4,$group{top}->vrootheight-$2);
    }
    $group{top}->geometry($geometry);
  }


  $group{macroContext}='TredMacro';
  $group{templateMatchMethod}=$defaultTemplateMatchMethod;
  $group{macroListOrder}=$defaultMacroListOrder;
  print STDERR "Main window created.\n" if $tredDebug;

  if (-f $appIcon) {
    print STDERR "adding icon-image.\n" if $tredDebug;
    $group{top}->iconimage($group{top}->Pixmap(-file => "$appIcon"));
    print STDERR "done.\n" if $tredDebug;
  }

  addBindTags($group{'top'},'my');

  print STDERR "Asking wm for exit-hook.\n" if $tredDebug;

  $group{top}->
    protocol('WM_DELETE_WINDOW' => 
	     [sub { $grp=shift;
		    doEvalHook(\%group,"exit_hook");
		    # run user's exit_hook
		    askSaveFile($grp);
		    closeFile($grp);
		    $grp->{'top'}->destroy;
		    $grp->{'top'}=undef;
		  },\%group]);


  print STDERR "Exit hook created.\n" if $tredDebug;

  $group{Balloon}=$group{'top'}->Balloon(-initwait => 450, -balloonposition => 'mouse',
					-state => 'balloon', -background => '#fff3b0');
  $group{'frame'}=$group{'top'}->Frame;



  print STDERR "Creating menubar.\n" if $tredDebug;


  $group{Menubar}=$group{top}->Frame(-relief => $menubarRelief, -borderwidth => 2);
  $group{Menubar}->pack(qw/-fill x/);
  $group{top}->Frame(-relief => sunken, -height=>2, -borderwidth => 2)->pack(qw/-fill x/);
  addBindTags($group{Menubar},'my');

  $group{FileMenu} = $group{Menubar}->Menubutton(qw/-text File -underline 0/);
  $group{FileMenu}->command(-label=> 'Open ...', -underline => 0,   -command => [\&fileDialog, \%group]);
  $group{FileMenu}->command(-label=> 'Close', -underline => 0, 
			    -command => [ sub {
					    my ($grp)=@_;
					    removeFromFilelist($grp,undef,$grp->{currentFileNo});
					    closeFile($grp);
					  }
					 , \%group]);
  $group{FileMenu}->command(-label => 'File List...', -underline => 5, -command => [\&filelistDialog, \%group]);
#	 [Button => 'New',         -command => [\&menus_error2, 'New']],
  $group{FileMenu}->command(-label => 'Save', -underline => 0, -command => [\&saveFile,\%group]);
  $group{FileMenu}->command(-label => 'Save As ...', -underline => 5 ,-command => [\&saveFileAs, \%group]);
  $group{FileMenu}->separator();
  $group{RecentFileMenu}=$group{FileMenu}->cascade(-label => "Recent Files", -underline => 0);
  my $i=0;
  foreach (@recentFiles) {
    $group{RecentFileMenu}->command(-label  => "$i.  $_",
				    -underline => 0,
				    -command => [\&openFile,\%group,$_]);
    $i++;
  }
  $group{FileMenu}->separator();
  $group{FileMenu}->command(-label => 'Previous File', -underline => 3, -command => [\&prevFile,\%group]);
  $group{FileMenu}->command(-label => 'Next File', -underline => 0, -command => [\&nextFile,\%group]);
  $group{FileMenu}->separator();
  $group{FileMenu}->command(-label => 'Print ...', -underline => 0, -command => [\&printThis,\%group]);
  $group{FileMenu}->separator();
  $group{FileMenu}->command(-label =>'Edit config file ...', -underline => 0,  -command => [\&editConfig,\%group]);
  $group{FileMenu}->command(-label =>'Reload config ...', -underline => 3, -command => [sub {
							  readConfig();
							  redraw_tree(shift);
							},\%group]);
  $group{FileMenu}->separator();
  $group{FileMenu}->command(-label =>'Quit', -underline => 0, -command => [sub { $grp=shift;
						       askSaveFile($grp);
						       $grp->{'top'}->destroy;
						    },\%group]);
	
  $group{FileMenu}->pack(qw/-side left/);

  $group{ViewMenu}= $group{Menubar}->Menubutton(qw/-text View -underline 0 -menuitems/ =>
	[
	 [Button => 'Previous Tree',
	  -underline => 0,
	  -command => [\&prevTree,\%group]],
	 [Button => 'Next Tree', -underline => 0, -command => [\&nextTree,\%group]],
	 [Separator => ''],
	 [Checkbutton => 'Draw boxes', -underline => 0,
	   -variable => \$drawBoxes,
	   -command  => [\&redraw_tree,\%group]],
	 [Checkbutton => 'Show Hidden Nodes', -underline => 0,
	  -underline => 5,
	  -variable => \$showHidden,
	  -command  => [sub { getNodes(@_);
			      currentUnhiden(@_);
			      redraw_tree(@_) },\%group]],
	 [Checkbutton => 'Highlight Attributes', -underline => 1,
	  -variable => \$highlightAttributes,
	  -command  => [\&redraw_tree,\%group]],
	 [Checkbutton => 'Sort Attributes in Dialogs', -underline => 1,
	  -variable => \$sortAttrs],
	 [Separator => ''],
	 [Button => 'Customize Attributes ...', -underline => 0,
	  -command => [\&customAttrsDialog,\%group]],
	 [Separator => ''],
	 [Button => 'List of Named Macros ...', -underline => 0,
	  -command => [\&macrolistDialog,\%group]]
	])->pack(qw/-side left/);
  $group{NodeMenu}= $group{Menubar}->Menubutton(qw/-text Node -underline 0 -menuitems/ =>
	[
	 [Button => 'New Node', -underline => 0, -command => [sub {
					       my ($grp)=@_;
					       newNode($grp);
					     },\%group]],
	 [Button => 'Remove Active Node', -underline => 0, -command => [sub {
					       my ($grp)=@_;
					       pruneNode($grp,$grp->{currentNode});
					     },\%group]],
	 [Button => 'Insert New Tree', -underline => 0, -command => [sub {
						      my ($grp)=@_;
						      newTree($grp);
						    },\%group]],
	 [Button => 'Insert New Tree After', -underline => 16, -command => [sub {
						      my ($grp)=@_;
						      newTreeAfter($grp);
						    },\%group]],
	 [Button => 'Remove Whole Current Tree', -underline => 7, -command => [sub {
						      my ($grp)=@_;
						      pruneTree($grp);
						    },\%group]],
	 [Separator => ''],
	 [Button => 'Edit Attributes ...', -underline => 0, -command => [sub {
						      my ($grp)=@_;
						      editAttrsDialog($grp,$grp->{currentNode})
							if ($grp->{currentNode});
						    },\%group]],
	 [Separator => ''],
	 [Button => 'Find ...', -underline => 0,-command => [sub {
					      my ($grp,$template)=@_;
					      findNodeDialog($grp,$template)
						if ($grp->{currentNode});
					    },\%group,\%searchTemplate]],
	 [Button => 'Find Next', -underline => 7,
	  -command => [sub {
			 my ($grp,$template)=@_;
			 findFirstTemplated($grp,$template,1)
			   if ($grp->{currentNode});
		       },\%group,\%searchTemplate]],
	 [Button => 'Find Previous', -underline => 5,
	  -command => [sub {
			 my ($grp,$template)=@_;
			 findPrevTemplated($grp,$template,1)
			   if ($grp->{currentNode});
		       },\%group,\%searchTemplate]]

	])->pack(qw/-side left/);
  print STDERR "Creating user menu.\n" if $tredDebug;


  $group{ContextsMenu}=$group{Menubar}->
    Optionmenu(-textvariable => \$group{macroContext},
	       -command => [sub { my $grp=shift;
				  switchContext($grp,$grp->{macroContext}); },\%group],
	       -underline => 0,
	       -relief => 'groove', #$menubarRelief,
	       -borderwidth => 2,
	       -options => [sort(keys(%keyBindings))])->pack(qw/-side right/);
  my $cM=[];
  if ($createMacroMenu) {
    push @$cM, 
      @{cascadeMenus(map { $keyBindings{TredMacro}->{$_}=~/$context\-\>(.*)/;
			   [Button => $1,
			    -command => [\&doEvalMacro,\%group,$keyBindings{TredMacro}->{$_}],
			    -accelerator => "($_)"
			   ]
			 } sort(keys(%{$keyBindings{TredMacro}})))};

    foreach my $context (sort(keys(%keyBindings))) {
      if ($context ne "TredMacro") {
	push @$cM, 
	  [Cascade => $context,
	   -menuitems =>
	   cascadeMenus(map { $keyBindings{$context}->{$_}=~/(?:$context\-\>)?(.*)/;
			      [Button => $1,
			       -command => [\&doEvalMacro,\%group,$keyBindings{$context}->{$_}],
			       -accelerator => "($_)"
			      ]
			    } sort(keys(%{$keyBindings{$context}})))];
      }
    }

    $group{MacroMenu}=$group{Menubar}->
      Menubutton(qw/-text Key-Macros -underline 0 -menuitems/ =>
		 $cM)->pack(qw/-side left/);
  }

  $cM=[];
  push @$cM,
    @{cascadeMenus(map ([Button => $_,
			 -command => [\&doEvalMacro,\%group,$menuBindings{TredMacro}->{$_}->[0]],
			 ($menuBindings{TredMacro}->{$_}->[1]) ?
			 (-accelerator => "(".$menuBindings{TredMacro}->{$_}->[1].")") : ()],
			sort(keys(%{$menuBindings{TredMacro}}))))};

  foreach my $context (sort(keys(%menuBindings))) {
   if ($context eq "TredMacro") { 
   } else {
        push @$cM,
  	[Cascade => $context,
  	 -menuitems =>
  	 cascadeMenus(map ([Button => $_,
  			    -command => [\&doEvalMacro,\%group,$menuBindings{$context}->{$_}->[0]],
  			    ($menuBindings{$context}->{$_}->[1]) ?
  			    (-accelerator => "(".$menuBindings{$context}->{$_}->[1].")") : ()],
  			   sort(keys(%{$menuBindings{$context}}))))];
      }
  }
  $group{UserMenu}=$group{Menubar}->
    Menubutton(qw/-text User-defined -underline 0 -menuitems/ =>
	       $cM)->pack(qw/-side left/);




  addBindTags($group{'frame'},'my');
  my $canvas = $group{'top'}->Scrolled('Canvas', -width => $defCWidth,
				       -height => $defCHeight, 
				       qw /-relief sunken
			                   -borderwidth 2 -scrollbars se/, -scrollregion =>
				       [qw/0c 0c 100c 100c/],
				       $backgroundColor ? (-background => $backgroundColor) : ());


  $group{HelpMenu}= $group{Menubar}->Menubutton(qw/-text Help -menuitems/ =>
	[
	 [Button => 'About', -command => [\&About,\%group]]])->pack(qw/-side left/);

  addBindTags($canvas->Subwidget('scrolled'),'canvas');
  prepareFonts(\%group);

  print STDERR "Creating canvas.\n" if $tredDebug;

  $group{'valueLine'}=$group{'top'}->Scrolled(qw/Entry -state disabled -relief sunken
			   -borderwidth 2 -scrollbars s/, -font => $vLineFont, -textvariable => \$valueLine);

  $group{'canvas'}=$canvas;
  addBindTags($canvas,'my');

  # creating Canvas balloon
  $group{CanvasBalloon}=$group{top}->Balloon(-initwait => $canvasBalloonInitWait,
					     -state => 'balloon',
					     -background => '#fff3b0');
  $group{CanvasBalloon}->Subwidget('message')->configure(-justify => 'left',-font => $font);
  
  print STDERR "Creating buttons.\n" if $tredDebug;

  $group{'nextButton'}=$group{'frame'}->Button(-text => "Next",
					       -relief => $buttonsRelief,
					       -image => $group{top}->Pixmap(-file =>
									     "$libDir/right.xpm"),
					       -borderwidth => $buttonBorderWidth,

			    -command => [sub { nextTree(@_) },\%group]);
  $group{Balloon}->attach($group{'nextButton'},
		 -balloonmsg => "see the next tree");
  addBindTags($group{'nextButton'},'my');
  $group{'prevButton'}=$group{'frame'}->Button(-text => "Prev",
					       -relief => $buttonsRelief,
					       -image => $group{top}->Pixmap(-file =>
									     "$libDir/left.xpm"),
					       -borderwidth => $buttonBorderWidth,
					       -command => [sub { prevTree(@_) },\%group]);
  $group{Balloon}->attach($group{prevButton},
		 -balloonmsg => "see the previous tree");
  addBindTags($group{'prevButton'},'my');

  $group{'openButton'}=$group{'frame'}->Button(-text => "Open",
					       -relief => $buttonsRelief,
					       -image       => $group{top}->Pixmap(-file => "$libDir/fileopen.xpm"),
					       -borderwidth => $buttonBorderWidth,
			 -command => [sub { fileDialog(@_) },\%group])->pack(-side=>'left',-padx=>'1');
  $group{Balloon}->attach($group{openButton},
		 -balloonmsg => "open file");
  addBindTags($group{'openButton'},'my');
  $group{'normalSavePixmap'}=$group{top}->Pixmap(-file =>"$libDir/filefloppy.xpm");
  $group{'savedSavePixmap'}=$group{top}->Pixmap(-file =>"$libDir/filesaved.xpm");
  $group{'saveButton'}=
    $group{'frame'}->Button(-text => "Save",
			    -relief => $buttonsRelief,
			    -image => $group{'savedSavePixmap'},
			    -borderwidth => $buttonBorderWidth,
			    -command => [sub {
					   saveFile(@_)
					 },\%group])->pack(-side=>'left',-padx=>'1');

  $group{Balloon}->attach($group{saveButton},
			  -balloonmsg => "save current file");
  addBindTags($group{'saveButton'},'my');

  $group{'prevFileButton'}=
    $group{'frame'}->Button(-text => "Prev file",
			    -relief => $buttonsRelief,
			    -image => $group{top}->Pixmap(-file =>
							  "$libDir/start.xpm"),
			    -borderwidth => $buttonBorderWidth,
			    -command => [sub { prevFile(@_); },\%group])->pack(-side=>'left',
									       -padx=>'1');
  $group{Balloon}->attach($group{prevFileButton},
			  -balloonmsg => "visit the previous open file");
  addBindTags($group{'prevFileButton'},'my');

  $group{'nextFileButton'}=
    $group{'frame'}->Button(-text => "Next file",
			    -relief => $buttonsRelief,
			    -image => $group{top}->Pixmap(-file =>
							  "$libDir/finish.xpm"),
			    -borderwidth => $buttonBorderWidth,
			    -command => [sub { nextFile(@_); },\%group])->pack(-side=>'left',
									       -padx=>'1');
  $group{Balloon}->attach($group{nextFileButton},
		 -balloonmsg => "visit the next open file");
  addBindTags($group{'nextFileButton'},'my');


  $group{'printButton'}=
    $group{'frame'}->Button(-text => "Print",
			    -relief => $buttonsRelief,
			    -image       => $group{top}->Pixmap(-file =>
								"$libDir/fileprint.xpm"),
			    -borderwidth => $buttonBorderWidth,
			    -command => [sub { printThis(@_) },\%group])->pack(-side=>'left',
									       -padx=>'1');
  $group{Balloon}->attach($group{printButton},
		 -balloonmsg => "print ...");
  addBindTags($group{'printButton'},'my');

  $group{'findButton'}=
    $group{'frame'}->Button(-text => "Find",
			    -relief => $buttonsRelief,
			    -image       => $group{top}->Pixmap(-file =>
								"$libDir/find.xpm"),
			    -borderwidth => $buttonBorderWidth,
			    -command => [sub {
					   my ($grp,$template)=@_;
					   findNodeDialog($grp,$template)
					     if ($grp->{currentNode});
					 },\%group,\%searchTemplate])->pack(-side=>'left',
									    -padx=>'1');
  $group{Balloon}->attach($group{findButton},
		 -balloonmsg => "Find node ...");
  addBindTags($group{'findButton'},'my');

  $group{'findNextButton'}=
    $group{'frame'}->Button(-text => "Find Next",
			    -relief => $buttonsRelief,
			    -image       => $group{top}->Pixmap(-file =>
								"$libDir/findnext.xpm"),
			    -borderwidth => $buttonBorderWidth,
			    -command => [sub {
					   my ($grp,$template)=@_;
					   if ($grp->{currentNode}) {
					     $grp->{'top'}->toplevel->
					       messageBox(-icon => 'warning',
							  -message => "No matching node found!",
							  -title => 'Find Next',
							  -type => 'ok')
						 unless( findFirstTemplated($grp,$template,1));
					   }
					 },\%group,\%searchTemplate])->pack(-side=>'left',
									       -padx=>'1');
  $group{Balloon}->attach($group{findNextButton},
		 -balloonmsg => "Find next ...");
  addBindTags($group{'findNextButton'},'my');


  $group{'findPrevButton'}=
    $group{'frame'}->Button(-text => "Find Previous",
			    -relief => $buttonsRelief,
			    -image => $group{top}->Pixmap(-file =>
								"$libDir/findprev.xpm"),
			    -borderwidth => $buttonBorderWidth,
			    -command => [sub {
					   my ($grp,$template)=@_;
					   if ($grp->{currentNode}) {
					     $grp->{'top'}->toplevel->
					       messageBox(-icon => 'warning',
							  -message => "No matching node found!",
							  -title => 'Find Next',
							  -type => 'ok')
						 unless( findPrevTemplated($grp,$template,1));
					   }
					 },\%group,\%searchTemplate])->pack(-side=>'left',
									       -padx=>'1');
  $group{Balloon}->attach($group{findPrevButton},
		 -balloonmsg => "Find previous ...");
  addBindTags($group{'findPrevButton'},'my');


  $group{'frame'}->Frame()->pack(-side => 'left', -padx =>'10');
  $group{'prevButton'}->pack(-side => 'left', -padx =>'1');
  $group{'nextButton'}->pack(-side => 'left', -padx => '1');




  $group{'attrButton'}=
    $group{'frame'}->Button(-text => "Attributes",
			    -relief => $buttonsRelief,
			    -image => $group{top}->Pixmap(-file =>
							  "$libDir/tick.xpm"),
			    -borderwidth => $buttonBorderWidth,
			    -command => [sub { customAttrsDialog(@_) },\%group])->pack(-side=>'right',
										 -padx=>'1');
  $group{Balloon}->attach($group{attrButton},
		 -balloonmsg => "select visible attributes");

  print STDERR "Packing widgets.\n" if $tredDebug;


  $group{'frame'}->pack(-fill => 'x', -padx => '1', -pady => 1);
  $group{'valueLine'}->pack(qw/-fill x/);
  $group{'canvas'}->pack(qw/-expand yes -fill both/);
  addBindTags($group{'canvas'},'my');
  #  $group{'contextLed'}->pack(-side => 'bottom');
  
  print STDERR "Binding keystrokes...\n" if $tredDebug;
  #  $group{'frame'}->bind('my','<Control-x><KeyPress>' =>
  #			[sub { evalMacro(@_); Tk->break; }, \%group, 'CTRL-X+' ]);
  $group{'Menubar'}->bind('Menubutton','<Escape>', sub { shift->Leave(); } );
  $group{'frame'}->
    bind('my','<Alt-KeyPress>' =>
	 [sub { 
	    if (defined(evalMacro(@_))) {
	      Tk->break;
	    } else {
	      # Actually, this should work by it self. And it realy
	      # does, but not under windows :-) Well, do not laugh,
	      # too early, Linux users. With menu (not menubutton)
	      # this is the same there, only vice versa.
	      my ($w,$grp,$mod)=@_;
	      my $mbar=$grp->{Menubar};
	      foreach my $child ($mbar->children) {
		if ($child->class eq 'Menubutton' and $child->FindMenu($w->XEvent->K)) {
		  $child->ButtonUp() if ($^O eq "MSWin32"); 
		  # This ButtonUp is needed for some reason under
		  # Windows, otherwise the button remains active even
		  # when you leave the window! Window$ realy suck!!!!
		  last;
		}
	      }
	      Tk->break;
	    }
	  }, \%group,'ALT+']);

  $group{'frame'}->bind('my','<KeyPress>' =>
			[sub { evalMacro(@_); Tk->break; }, \%group, '' ]);

  foreach (qw(Shift Control Meta Control-Shift Control-Alt
              Control-Meta Alt-Shift Meta-Shift)) {
    foreach my $event (qw(KeyPress Right Left Up Down Return comma period Next Prior greater less)) {
      $group{'frame'}->bind('my',"<$_-$event>" =>
			    [sub { evalMacro(@_); Tk->break; }, \%group, keyBind($_)."+"]);
    }
  }
  #  $group{'frame'}->bind('all','<Tab>' => [sub {1;}]);
  #  $group{'top'}->bind('dialog','<Tab>' => [sub { shift->focusNext(); }] );
  #  $group{'top'}->bind('dialog','<Shift-Tab>' => [sub { shift->focusPrev(); }] );
  #  $group{'frame'}->bind('all','<Shift-Tab>' => [sub {1;}]);
  #  $group{'frame'}->bind('all','<Control-Tab>' => [sub {1;}]);
  
  $group{'frame'}->bind('my','<Tab>' => [sub { shift; currentNext(@_); Tk->break; },\%group]);
  $group{'frame'}->bind('my','<Shift-ISO_Left_Tab>' => [sub { shift; currentPrev(@_); Tk->break; },\%group]);
  $group{'frame'}->bind('my','<Shift-Tab>' => [sub { shift; currentPrev(@_); Tk->break; },\%group]);

  $group{'frame'}->bind('my','<period>' => [\&onIdleNextTree,\%group]);
  $group{'frame'}->bind('my','<comma>' => [\&onIdlePrevTree,\%group]);
  $group{'frame'}->bind('my','<Next>' => [\&onIdleNextTree,\%group]);
  $group{'frame'}->bind('my','<Prior>' => [\&onIdlePrevTree,\%group]);
  $group{'frame'}->bind('my','<greater>' => [sub { shift; my $grp=shift; gotoTree($grp,$grp->{FSFile}->lastTreeNo); Tk->break; },\%group]);
  $group{'frame'}->bind('my','<less>' => [sub { shift; my $grp=shift; gotoTree($grp,0); Tk->break; },\%group]);

  $group{'frame'}->bind('my','<KeyPress-Return>' => [sub {
					      my ($w,$grp)=@_;
					      editAttrsDialog($grp,$grp->{'currentNode'});
					      Tk->break;
					    },\%group]);
  $group{'frame'}->bind('my','<KeyPress-Left>' => [sub {
					   my ($w,$grp)=@_;
					   currentLeft($grp);
					   Tk->break;
					 },\%group]);
  $group{'frame'}->bind('my','<KeyPress-Right>' => [sub {
					    my ($w,$grp)=@_;
					    currentRight($grp);
					   Tk->break;
					  },\%group]);
  $group{'frame'}->bind('my','<KeyPress-Up>' => [sub {
					 my ($w,$grp)=@_;
					 currentUp($grp);
					 Tk->break;
				       },\%group]);
  $group{'frame'}->bind('my','<KeyPress-Down>' => [sub {
					   my ($w,$grp)=@_;
					   currentDown($grp);
					   Tk->break;
					 },\%group]);

  ## Canvas bindings  
  $group{'canvas'}->bind('text', '<Any-Enter>' => [sub{
			       my $c=shift;
			       my $grp=shift;
			       my $t=$c->find('withtag','current');
			       my $node=$grp->{'pinfo'}{$t};
			       $node->{_tkSaveColor_}=$c->itemcget($t,'-fill');
			       $c->itemconfigure($t,
						 -fill => $activeTextColor);

			     }, \%group]);

  $group{'canvas'}->bind('text',
			 '<Any-Leave>'
			 => [sub{
			       my $c=shift;
			       my $grp=shift;
			       my $t=$c->find('withtag','current');
			       my $node=$grp->{'pinfo'}{$t};
			       $c->itemconfigure('current',
						 -fill => $node->{_tkSaveColor_});
			     }, \%group]);

  $group{'canvas'}->bind('point', '<1>' => [sub {node_down(@_) },\%group,0]);
  $group{'canvas'}->bind('point', '<ButtonRelease-1>' => [sub {node_release(@_)},\%group,0]);
  $group{'canvas'}->bind('point', '<B1-Motion>' => [sub {node_move(@_)},\%group]);
  $group{'canvas'}->bind('point','<3>' => [sub {node_down(@_)},\%group,1]);
  $group{'canvas'}->bind('point', '<ButtonRelease-3>' => [sub {node_release(@_)},\%group]);
  $group{'canvas'}->bind('point','<B3-Motion>' => [sub {node_move(@_)},\%group,1]);
  $group{'canvas'}->CanvasBind('<2>' => [sub {follow_mouse_press(@_)},\%group]);
  $group{'canvas'}->CanvasBind('<B2-Motion>' => [sub {follow_mouse(@_)},\%group]);
  $group{'canvas'}->bind('point', '<Double-1>' => [sub { editAttrs(@_); Tk->break; },\%group]);
  $group{'canvas'}->bind('text', '<1>' => [sub {node_down(@_) },\%group,0]);
  $group{'canvas'}->bind('text', '<Double-1>' => [sub { editAttr(@_); Tk->break; },\%group]);
  $group{'canvas'}->bind('textbg', '<Double-1>' => [sub { editAttr(@_); Tk->break; },\%group]);

  $group{'canvas'}->focus;

  $group{'printToFile'}=0;
  $group{'printCommand'}='lpr';
  $group{'printPsFile'}=$psFile;

  print STDERR "Binding canvas destroy...\n" if $tredDebug;
  $group{'top'}->bind('canvas', '<Destroy>',
		      [ sub {
			  shift;
			  my $grp=shift;
			  my $canvas=$grp->{'canvas'}->Subwidget('scrolled');			  
			  $defCWidth=$canvas->width();
			  $defCHeight=$canvas->height();
			  print "$defCHeight x $defCWidth\n";
			  $geometry=$group{top}->geometry();
			  print "geometry is $geometry\n";
			  if ($^O eq "MSWin32" and $group{top}->state() eq 'zoomed') {
			    $geometry=~s/\+[-0-9]+\+[-0-9]+/+-3+-3/;
			  }
			  print "state is ",$group{top}->state(),"\n";
			},\%group ]);

  print STDERR "GUI prepared.\nOpenning first file ...." if $tredDebug;

  if ($firstFile) {
    openFile(\%group,$firstFile);
  }
  
  print STDERR "done.\nStarting main loop.\n" if $tredDebug;

  exit if doEvalHook(\%group,"start_hook") eq 'stop'; # run start_hook

  # Starting ------------------------------------------

  MainLoop;


  # Finished ------------------------------------------

  # Save configuration
  print STDERR "Saving some configuration options.\n" if $tredDebug;
  my @conf;
  my $ommit="canvasheight|canvaswidth|recentfile[0-9]+|geometry";
  if (open(F,"<$configFile")) {
    @conf= grep { !/^\s*(?:$ommit)\s*=/i } <F>;
    close(F);
  }
  #  $geometry=~s/^[0-9]+x[0-9]+//;
  push @conf,
    "Geometry\t=\t".$geometry."\n",
    "CanvasHeight\t=\t".$defCHeight."\n",
    "CanvasWidth\t=\t".$defCWidth."\n",
      map { 
	my $s=$recentFiles[$_];
	$s=~s/\\/\\\\/g;
	"RecentFile$_\t=\t$s\n"
      } 0..$#recentFiles;
  chomp $conf[$#conf];
  saveConfig(\%group,@conf);
  print STDERR "Done.\n" if $tredDebug;
}

sub onIdleNextTree {
  my ($w,$grp)=@_;
  return unless $grp->{'FSFile'};
  $grp->{treeNo}=max(0,min($grp->{treeNo}+1,$grp->{FSFile}->lastTreeNo));
  getValueLine($grp);
  $w->afterCancel($myIdle) if ($myIdle);
  $grp->{valueLine}->idletasks();
  $myIdle=$w->afterIdle([ sub {
			    my $g=shift;
			    my $no=$grp->{treeNo};
			    $grp->{treeNo}=-1; # this is to force getNodes & redraw
			    gotoTree($g,$no);
			    $myIdle=undef;
			  },$grp]);
  Tk->break;
}

sub onIdlePrevTree {
  if ($grp->{treeNo}>0) {
    my ($w,$grp)=@_;
    $grp->{treeNo}--;
    getValueLine($grp);
    $w->afterCancel($myIdle) if ($myIdle);
    $grp->{valueLine}->idletasks();
    $myIdle=$w->afterIdle([ sub {
			      my $g=shift;
			      my $no=$grp->{treeNo};
			      $grp->{treeNo}=-1; # this is to force getNodes & redraw
			      gotoTree($g,$no);
			      $myIdle=undef;
			    },$grp]);
  }
  Tk->break;
}


# This patches $dialog->Show which implicitly focuses the default button;
# here focus stays where it is.
# Usage: my $dlg=DialogBox(); ...; ShowDialog($dlg);
sub ShowDialog {
  my ($cw, $focus, $oldFocus) = @_;

  $oldFocus = $cw->focusCurrent unless $oldFocus;
  my $oldGrab = $cw->grabCurrent;
#  my $old_grab = $cw->grabSave;
#  my $old_focus = $cw->grabSave;
  my $grabStatus = $oldGrab->grabStatus if ($oldGrab);

#  $cw->grab;

  $cw->Popup();


  Tk::catch {
    $cw->grab;
  };
  $focus->focusForce if ($focus);
  
  $cw->Wait;

  eval {
    $oldFocus->focusForce;
  };
  #&$old_grab;
  #&$old_focus;
  

  $cw->withdraw;
  $cw->grabRelease;
  if ($oldGrab) {
    if ($grabStatus eq 'global') {
      $oldGrab->grabGlobal;
    } else {
      $oldGrab->grab;
    }
  }

  return $cw->{'selected_button'};
}

sub fileDialog {
  my $grp = shift;
  my $file;

#  use Tk::FileSelect;
#  my $FSref = $grp->{top}->FileSelect(-selectmode => extended);
#  print $FSref->Show;

  $file = $grp->{'top'}->getOpenFile(-filetypes => \@open_types);
  if (defined $file and $file ne '') {
    return openFile($grp,$file);
  }
  return 0;
}

sub saveFileAs {
  my $grp = shift;
  my $initdir;
  return unless $grp->{FSFile};
  my $file=$grp->{FSFile}->filename;

  $initdir=dirname($file);
  $initdir=cwd if ($initdir eq './');

  $file = $grp->{'top'}->getSaveFile(-filetypes => \@save_types,
				     -title => "Save As ...",
				     -initialdir => $initdir,
     				     -initialfile => filename($file));
  if (defined $file and $file ne '') {
    $grp->{FSFile}->changeFilename($file);
    $grp->{'top'}->title("$appName $file (".($grp->{currentFileNo}+1)."/".@files.")");
    return saveFile($grp);
  }
  return 0;
}

sub askSaveFile {
  my ($grp)=@_;
  return unless $FileNotSaved;
  saveFile($grp)
   if (
       $grp->{'top'}->toplevel->
       messageBox(-icon => 'question',
		  -message => "File may be changed!\nDo you want to save it?",
		  -title => 'File not saved',
		  -type => 'YesNo'
#		  , -default => 'Yes' # problem: Windows 'yes', UNIX 'Yes'
		 ) =~ /yes/i);
}

sub saveConfig {
 my $grp=shift;

 if (open(F,">$configFile")) {
   print F @_;
   close(F);
 } else {
   my $lasterr=$!;
   my ($trc)=<'~/.tredrc'>;
   my ($dc,$ic)=stat($configFile);
   my ($dh,$ih)=stat($trc);
   if ($configFile ne $trc and ($dc != $dh or $ic != $ih) and
       $grp->{'top'}->toplevel->
       messageBox(-icon => 'warning',
		  -message => "Cannot write configuration to $configFile\n($lasterr)\n\n".
		  "Shell I try to save it to ~/.tredrc?\n",
		  -title => 'Configuration cannot be saved',
		  -type => 'YesNo',
		  #			  -default => 'Yes' # problem: Windows 'yes', UNIX 'Yes'
		 ) =~ /yes/i) {
     if (open(F,">".$trc)) {
       print F @_;
       close(F);
     } else {
       $grp->{'top'}->toplevel->
	 messageBox(-icon => 'error',
		    -message => 'Cannot write to "'.$trc.'"!'."\n($!)\n".
		    "\nConfiguration could not be saved!\n",
		    -title => 'Configuration cannot be saved',
		    -type => 'Ok');
     }
   } else {
     $grp->{'top'}->toplevel->
       messageBox(-icon => 'error',
		  -message => "Cannot write to \"$configFile\"!"."\n($lasterr)\n".
		  "\nConfiguration could not be saved!",
		     -title => 'Configuration cannot be saved',
		  -type => 'Ok',
		  -default => 'Ok');
   }
 }
}

sub editConfig {
  my $grp=shift;
  return unless $grp;
  if ($grp->{configDialog}) {
    $grp->{configDialog}->deiconify;
    $grp->{configDialog}->focus;
    $grp->{configDialog}->raise;
    return;
  }
  $grp->{configDialog} = $grp->{'top'}->Toplevel(-title => "Edit Resource File ($configFile)" , 
						   -width => "10c");
  my $d=$grp->{configDialog};
  $d->withdraw;
#  $d->resizable(0,0);
  $d->bind('<Return>' => [sub {1;}]);
  my $t = $d->
    Scrolled(qw/Text -relief sunken -borderwidth 2 -setgrid true
		     -height 30 -scrollbars e/);
  $t->pack(qw/-expand yes -fill both/);
  my $bottom=$d->Frame()->pack(qw/-expand yes -fill both/);
  $bottom->
    Button(-text => "  Save and Apply  ",
	   -command => [sub {
			  my ($grp,$d,$t)=@_;
			  saveConfig($grp,$t->get("0.0","end"));
			  applyConfig(split(/\n/,$t->get("0.0","end")));
			  addToRecent($grp);
			  prepareFonts($grp);
			  $grp->{valueLine}->configure(-font => $vLineFont);
			  redraw_tree($grp);
#			  $d->destroy;
			},$grp,$d,$t])
      ->pack(-side => 'left', -expand => 1,  -padx => 1, -pady => 1);
  $bottom->Button(-text => "  Apply  ",
		  -command => [sub {
				 my $grp=shift;
				 applyConfig(split(/\n/,shift->get("0.0","end")));
				 addToRecent($grp);
				 prepareFonts($grp);
				 $grp->{valueLine}->configure(-font => $vLineFont);
				 redraw_tree($grp);
			       },$grp,$t])
    ->pack(-side => 'left', -expand => 1,  -padx => 1, -pady => 1);

  $bottom->Button(-text => "  Close  ", -command => [sub { shift->destroy; },$d])
    ->pack(-side => 'left', -expand => 1,  -padx => 1, -pady => 1);

  $d->bind('<Destroy>' => [sub { shift; shift->{configDialog}=undef; },$grp ]);
  $d->bind('all','<Escape>' => [sub { shift; shift->destroy(); },$d]);
  if (open(F,"<$configFile")) {
    $t->insert('0.0',join "",<F>);
    close(F);
  }
  $t->mark(qw/set insert 0.0/);
  $d->Popup;
}


sub QueryString {
  my $newvalue;
  my ($grp, $title, $label)=@_;

  my $d=$grp->{'top'}->DialogBox(-title => $title,
				 -buttons => ["OK", "Cancel"]);
  $d->bind('all','<Escape>' => [sub { shift; shift->{'selected_button'}='Cancel'; },$d ]);
  addBindTags($d,'dialog');
  my $e=$d->add(Entry,-relief => 'sunken',
		    -width => 40,
		    -takefocus => 1,
		    -font => $font,
		    -textvariable => \$newvalue);
  my $l = $d->Label(-text => encode($label),
		    -anchor => 'e',
		    -justify => 'right');
  $l->pack(-side=>'left');
  $e->pack(-side=>'right');
  $d->resizable(0,0);
#  $e->focus;
  my $result = ShowDialog($d,$e,$grp->{top});
  $d->destroy;
  undef $d;
  if ($result =~ /OK/) {
    return decode($newvalue);
  } else {
    return undef;
  }
}


sub selectValuesDialog {
 my ($grp, $attr, $vals, $selected, $may_add, $lastFocus,$force)=@_;
 my $a;
 my $multi=0;
 my @prevSelectionSet;

 $grp->{'top'}->Busy(-recurse => 1);
 my $enabled=($force or doEvalHook($grp,'enable_attr_hook',$attr,"ambiguous") ne 'stop');

 my $d=$grp->{'top'}->DialogBox(-title => "$attr: select values", -width => '8c',
				-buttons => $enabled ? ["OK", "Cancel"] : ["Cancel"]);
 $d->bind('all','<Escape>' => [sub { shift; shift->{'selected_button'}='Cancel'; },$d ]);
 $d->resizable(0,0);
 my $l=$d->Scrolled(qw/Listbox -relief sunken -takefocus 1 -scrollbars e/,
		    -height => min($maxDisplayedValues,scalar(@$vals)),
		    -font => $font)->pack(qw/-expand yes -fill both/);
 $l->insert('end',@$vals);

 if ($enabled) {
   $l->bind('<Double-ButtonPress-1>' =>
	    [sub { my $w=shift;
		   my $d=shift;
		   my $e = $w->XEvent;
		   $w->BeginSelect($w->index($e->xy));
		   $d->{'selected_button'}='OK';
		 },$d
	    ]);
 }
 my $act=0;
 for ($a=0;$a<@$vals;$a++)  {
   if (grep { $$vals[$a] eq $_ } @$selected) {
     $l->selectionSet($a);
     if (not $act) {
       $act=1;
       $l->activate($a);
       $l->see($a);
     }
   }
 }
 if ($enabled) {
   $d->Checkbutton(-text     => 'multiple select',
		   -variable => \$multi,
		   -command  => [sub {
				   shift->configure(-selectmode => $multi ? 'multiple' : 'browse');
				 },$l],
		   -relief   => 'flat')->pack();
   if ($may_add) {
     $d->Button(-text => 'Add',
		-command => [sub {
			       my ($grp,$l,$vals)=@_;
			       my $val=QueryString($grp,"Add new value","Value");
			       return unless defined $val;
			       push @$vals,$val;
			       $l->insert('end',$val);
			       $l->selectionClear(0,$l->size-1) unless $multi;
			       $l->selectionSet($l->size-1);
			     },$grp,$l,$vals])->pack();
   }
 }
 $grp->{'top'}->Unbusy();
# $l->focus;
 my $result = ShowDialog($d,$l,$lastFocus);
 if ($result =~ /OK/) {
   # Hajic wanted this (I wash my hands):
   # first we store the values, which were selected originaly and stayed selected
   foreach my $s (@$selected) { 
     push @prevSelectionSet, (grep { $$vals[$_] eq $s } (0 .. $l->size-1));
   }
   @$selected=();
   foreach (@prevSelectionSet) {
     if ($l->selectionIncludes($_)) {
       $l->selectionClear($_);
       push @$selected,$$vals[$_];
     }
   }
   foreach (0 .. $l->size-1) {
     push @$selected, $$vals[$_] if $l->selectionIncludes($_);
   }
   $d->destroy;
   undef $d;
   return 1;
 }
 $d->destroy;
 undef $d;
 return 0;
}

sub editListAttr {
  my ($grp, $value, $attr,$d) =@_;
  return unless $grp->{'FSFile'};
  my @vals = map { encode($_) } $grp->{FSFile}->FS->listValues($attr);
  #print "splitting ",$value{$attr},"\n";
  my @selected = map { encode($_) } split /\|/,$value;
  #print "splitted to ", join ('-',@selected),"\n";

  if (selectValuesDialog($grp,$attr,\@vals,\@selected,0,$d)) {
    return decode(join('|',@selected));
  }
  return undef;
}

sub editAmbiguousAttr {
  my ($grp, $value, $attr) =@_;
  my @vals = map { encode($_) }split /\|/,$value;
  my @selected = @vals;
  
  if (selectValuesDialog($grp,$attr,\@vals,\@selected,1,$grp->{top})) {
    return decode(join('|',@selected));
  }
  return undef;
}

sub editAttrsDialog {
  my ($grp,$node)=@_;
  return if (doEvalHook($grp,"do_edit_node_hook",$node) eq 'stop');
  return unless $grp->{'FSFile'};
  my @vals;
  my $rows=min(10,$grp->{FSFile}->FS->count);
  my @r=();
  my @atord = $sortAttrs ? (sort {uc($a) cmp uc($b)} $grp->{FSFile}->FS->attributes) : $grp->{FSFile}->FS->attributes;
  my ($a,$b,$r);

  $grp->{'top'}->Busy(-recurse =>1);
  my $d=$grp->{'top'}->DialogBox(-title => "Edit Node Attributes", -width => '10c',
				 -buttons => ["OK", "Cancel"]);
  $d->bind('all','<Escape>' => [sub { shift; shift->{'selected_button'}='Cancel'; },$d ]);
  $d->resizable(0,0);
  my $f = $d->Scrolled('Tiler',
		       -columns =>2,
		       -rows =>$rows,
		       -relief => 'groove',
		       -scrollbars => 'e');

  sub focusxDn {
    my ($w,$i,$e,$f,$rows,$cnt)=@_;
    if ($i+1>$#atord) {
      $w->focusNext if ($cnt);
    } else {
      $e->{$atord[$i+1]}->focus;
      $f->scroll(1,'pages')
	if ($i+1>=($f->{SubWidget}{tiler}{Start}+$rows));
      # D'ya like dirty tricks ? :)
    }
    Tk->break;
  };
  sub focusxUp {
    my ($w,$i,$e,$f,$cnt)=@_;
    if ($i<=0) {
      $w->focusPrev if ($cnt);
    } else {
      $e->{$atord[$i-1]}->focus;
      $f->scroll(-1,'pages')
	if ($i-1<($f->{SubWidget}{tiler}{Start}));
      # D'ya like dirty tricks ? :)
    }
    Tk->break;
  };

  $f->bind($f,'<Tab>',[sub {
			     if ($e{$atord[0]}) {
			       $e{$atord[0]}->focus;
			       $f->moveto(0);
			     } else {
			       shift->focusNext;
			     }
			     Tk->break;
			   }]);
  for (my $i=0;$i<=$#atord;$i++) {
    $_=$atord[$i];
    # Reliefs: raised, sunken, flat, ridge, and groove.
    push @r,$f->Label(-text => $_, -anchor => 'nw')->pack();

    if  ($grp->{FSFile}->FS->isList($_) or
	 $$node{$_}=~/^(?:[^\|\\]|\\.)*\|/) { # readonly entry and buttons for list
      $r = $f->Frame;
      $e{$_} = $r->Entry(-relief => 'sunken', -takefocus => 1,
			 -font => $font)->pack(qw/-expand yes -fill both -side left/);
#      unless (doEvalHook($grp,'enable_attr_hook',$_,"ambiguous") eq 'stop') {
	$b=$r->Button(-text => "...", -takefocus => 0,
		      -command => [sub {
				     my ($e,$grp,$node,$attr,$d)=@_;
				     my $result =
				       ($grp->{FSFile}->FS->isList($attr)
					? editListAttr($grp,$e->get,$attr)
					: editAmbiguousAttr($grp,$e->get,$attr,$d));
				     if (defined $result) {
				       $e->configure(-state => 'normal');
				       $e->delete(0,length($e->get));
				       $e->insert(0,$result);
				       $e->configure(-state => 'disabled');
				     }
				   },$e{$_},$grp,$node,$_,$d])->pack(-side => 'right');
	$e{$_}->bind($e{$_},'<Return>',[sub { shift; shift->invoke; Tk->break; },$b]);
	$e{$_}->bind($e{$_},'<Double-ButtonPress-1>',[sub { shift; shift->invoke; Tk->break; },$b]);
#      }
      $e{$_}->insert(0,encode($$node{$_}));
      $e{$_}->configure(-state => 'disabled');
      push @r, $r;
    } else {
      $e{$_} = $f->Entry(-relief => 'sunken', -takefocus => 1,
			 -font => $font)->pack(qw/-expand yes -fill both/);
      $e{$_}->insert(0,encode($$node{$_}));
      if (doEvalHook($grp,'enable_attr_hook',$_,"normal") eq 'stop') {
	$e{$_}->configure(-state => 'disabled');
      }

      push @r, $e{$_};
    }

    $e{$_}->bind($e{$_},'<Tab>',[\&focusxDn,$i,\%e,$f,$rows,1]);
    $e{$_}->bind($e{$_},'<Down>',[\&focusxDn,$i,\%e,$f,$rows]);
    $e{$_}->bind($e{$_},'<Shift-Tab>',[\&focusxUp,$i,\%e,$f,1]);
    $e{$_}->bind($e{$_},'<Up>',[\&focusxUp,$i,\%e,$f]);
  }
  $f->Manage(@r);
  $f->pack();
  $grp->{'top'}->Unbusy();

  my $result = ShowDialog($d,($atord[0] ? $e{$atord[0]}->focus : undef),$grp->{top});

  if ($result =~ /OK/) {
    $grp->{FSFile}->notSaved(1);
    foreach $a (@atord) {
      $$node{$a}=decode($e{$a}->get);
    }
    getNodes($grp);
    redraw_tree($grp);
  }
  undef %e;
  foreach $_ (@r) {$_->destroy;}
  @r=();
  $f->destroy;
  $d->destroy;
  undef $d;

}

sub customAttrsDialog {
  my ($grp)=@_;
  return if (doEvalHook($grp,"customize_attrs_hook",$node) eq 'stop');
  return unless $grp->{'FSFile'};
  my $e;

  $grp->{'top'}->Busy(-recurse =>1);
  my $d=$grp->{'top'}->
    DialogBox(-title => "Customize Visible Attributes",
	      -width => '10c',
	      -buttons => ["OK", "Cancel"]);

  my $f = $d->Frame();
  my $af = $f->Frame();
  $af->Label(-text => 'Attributes')->pack();
  my $al = $af->Scrolled(qw/Listbox -relief sunken 
                     -borderwidth 2 -setgrid true
		     -height 15 -scrollbars e
                     -exportselection 0/)->pack();
  $al->insert('end',$sortAttrs ? (sort {uc($a) cmp uc($b)} $grp->{FSFile}->FS->attributes) : $grp->{FSFile}->FS->attributes);
  $af->pack(qw/-padx 5 -side left -expand yes -fill both/);
  my $cf = $f->Frame();
  $cf->Label(-text => 'Display patterns')->pack();
  my $cl =
    $cf->Scrolled(qw/Listbox -relief sunken
                     -borderwidth 2 -setgrid true
		     -scrollbars se
                     -selectmode extended
                     -exportselection 0/
		 )->pack(qw/-side top -expand yes
                            -fill both
                            -padx 3 -pady 3/);
  $cl->insert('end',@displayAttrs,'   ');
  $cf->Label(-text => 'Hint pattern')->pack();
  my $t =
    $cf->Scrolled(qw/Text -relief sunken
                     -borderwidth 2 -setgrid true
		     -height 4 -scrollbars se
                     -width 50
                     -exportselection 1
                     -wrap none/
		 )->pack(qw/-side top -expand yes
                            -fill both
                            -padx 3 -pady 3/);
  $t->insert('0.0',$grp->{BalloonPattern});

  my $e = $d->Entry(qw/-relief sunken
                       -borderwidth 2/);

  my $bf = $f->Frame();
  $bf->Button(-text => "Add/Paste",
	      -command =>
	      sub {
		if ($e->get ne "") {
		  $cl->insert('active',$e->get);
		}
		$e->selectionRange(0,'end');
	      }
	     )->pack(-side => top, -expand => yes, -padx => 3, -pady => 3);

  $bf->Button(-text => "Cut",
	      -command =>
	      sub {
		$cl->selectionClear($cl->index('end')-1)
		  if ($cl->selectionIncludes($cl->index('end')-1));
		while (defined(($cl->curselection)[0])) {
		  $e->delete(0,'end');
		  $e->insert('insert',$cl->get(($cl->curselection)[0]));
		  $cl->delete(($cl->curselection)[0]);
		}
	      }
	     )->pack(-side => top, expand => yes, -padx => 3, -pady => 3);
  $bf->Button(-text => "Delete",
	      -command =>
	      sub {
		$cl->selectionClear($cl->index('end')-1)
		  if ($cl->selectionIncludes($cl->index('end')-1));
		while (defined(($cl->curselection)[0])) {
		  $cl->delete(($cl->curselection)[0]);
		}
	      }
	     )->pack(-side => top, expand => yes, -padx => 3, -pady => 3);


  $bf->Button(-text => "Add as hint",
	      -command =>
	      sub {
		if ($e->get ne "") {
		  Tk::catch { $t->delete('sel.first','sel.last') };
		  $t->insert('insert',$e->get);
		}
		$e->selectionRange(0,'end');
	      }
	     )->pack(-side => top, -expand => yes, -padx => 3, -pady => 3);


  $bf->pack(qw/-padx 5 -side left -expand yes -fill both/);
  $cf->pack(qw/-padx 5 -side left -expand yes -fill both/);


  $f->pack(qw/-side top -expand yes -fill x/);
  $e->pack(qw/-side bottom -expand yes -fill x/);

  $d->bind('all','<Escape>' =>
	   [sub { shift;
		  shift->{'selected_button'}='Cancel';
		},$d ]);
  $al->bind('<Double-1>' => 
	   sub {
	     $e->delete('sel.first','sel.last')
	       if ($e->selectionPresent);
	     $e->insert('insert','${'.$al->get('active').'}');
	   }
	  );
  $cl->bind('<Double-1>' => 
	   sub {
	     return if ($cl->index('active') == $cl->index('end')-1);
	     if ($e->selectionPresent) {
	       $e->delete('sel.first','sel.last')
	     }
	     $e->insert('insert',$cl->get('active'));
	   }
	  );
  $d->bind('<Return>' => [sub {1;}]);
  $d->resizable(0,0);
  $grp->{'top'}->Unbusy();

  my $result = ShowDialog($d,$e,$grp->{top});

  if ($result =~ /OK/) {
    $grp->{BalloonPattern}=$t->get('0.0','end - 1 chars');
    @displayAttrs=$cl->get(0,$cl->index('end')-2);
    redraw_tree($grp);
  }
  $d->destroy;
  undef $d;
}


sub findNodeDialog {
  my ($grp,$template)=@_;
  return unless $grp->{'FSFile'};
  my $r;
  my @vals;
  my @atord = $sortAttrs ? (sort {uc($a) cmp uc($b)} $grp->{FSFile}->FS->attributes) : $grp->{FSFile}->FS->attributes;

  my $b;
  my $a;
  my $rows=min(10,$#atord+1);
  my @r=();
  $grp->{'top'}->Busy(-recurse =>1);
  my $d=$grp->{'top'}->DialogBox(-title => "Find Node By Attributes", -width => '10c',
				 -buttons => ["Find", "Cancel"]);
  $d->bind('all','<Escape>' => [sub { shift; shift->{'selected_button'}='Cancel'; },$d ]);
  $d->resizable(0,0);
  my $f = $d->Scrolled('Tiler',
		       -columns =>2,
		       -rows =>$rows,
		       -relief => 'groove',
		       -scrollbars => 'e');
  sub focusxDn {
    my ($w,$i,$e,$f,$rows,$cnt)=@_;
    if ($i+1>$#atord) {
      $w->focusNext if ($cnt);
    } else {
      $e->{$atord[$i+1]}->focus;
      $f->scroll(1,'pages')
	if ($i+1>=($f->{SubWidget}{tiler}{Start}+$rows));
      # D'ya like dirty tricks ? :)
    }
    Tk->break;
  }
  ;
  sub focusxUp {
    my ($w,$i,$e,$f,$cnt)=@_;
    if ($i<=0) {
      $w->focusPrev if ($cnt);
    } else {
      $e->{$atord[$i-1]}->focus;
      $f->scroll(-1,'pages')
	if ($i-1<($f->{SubWidget}{tiler}{Start}));
      # D'ya like dirty tricks ? :)
    }
    Tk->break;
  }
  ;

  $f->bind($f,'<Tab>',[	sub {
			  if ($e{$atord[0]}) {
			    $e{$atord[0]}->focus;
			    $f->moveto(0);
			  } else {
			    shift->focusNext;
			  }
			  Tk->break;
			}]);

  for (my $i=0;$i<=$#atord;$i++) {
    $_=$atord[$i];
    # Reliefs: raised, sunken, flat, ridge, and groove.
    push @r,$f->Label(-text => $_, -anchor => 'nw')->pack();

    $e{$_} = $f->Entry(-relief => 'sunken', -takefocus => 1,
		       -font => $font)->pack(qw/-expand yes -fill both/);
    $e{$_}->insert(0,encode($template->{$_}));
    push @r, $e{$_};

    $e{$_}->bind($e{$_},'<Tab>',[\&focusxDn,$i,\%e,$f,$rows,1]);
    $e{$_}->bind($e{$_},'<Down>',[\&focusxDn,$i,\%e,$f,$rows]);
    $e{$_}->bind($e{$_},'<Shift-Tab>',[\&focusxUp,$i,\%e,$f,1]);
    $e{$_}->bind($e{$_},'<Up>',[\&focusxUp,$i,\%e,$f]);
  }
  $f->Manage(@r);
  $f->pack();

  foreach my $p ('Regular expression',
		 'Exhaustive regular expression',
		 'Wildcard pattern',
		 'Literal') {
    $d->Radiobutton(-anchor   => 'nw',
		    -text     => $p,
		    -variable => \$grp->{templateMatchMethod},
		    -relief   => 'flat',
		    -value    => substr($p,0,1),
		   )->pack(-fill => 'x');
  }

  $grp->{'top'}->Unbusy();
  my $result = ShowDialog($d,($atord[0] ? $e{$atord[0]}->focus : undef),$grp->{top});
  if ($result =~ /Find/) {
    #    $grp->{FSFile}->notSaved(1);
    foreach $a (@atord) {
      $template->{$a}=decode($e{$a}->get);
    }
    $grp->{'top'}->toplevel->
      messageBox(-icon => 'warning',
		 -message => "No matching node found!",
		 -title => 'Find',
		 -type => 'ok')
	unless (findFirstTemplated($grp,$template,0));
    #    getNodes($grp);
    #    redraw_tree($grp);
  }
  $d->destroy;
  undef $d;
}

sub cmpTemplateField {
  my ($grp,$val,$templ)=@_;
  return $val =~ /^$templ$/ if ($grp->{templateMatchMethod} eq 'E');
  return $val =~ /$templ/ if ($grp->{templateMatchMethod} eq 'R');
  return $val eq $templ if ($grp->{templateMatchMethod} eq 'L');
  if ($grp->{templateMatchMethod} eq 'W') {
    $templ=~s/[.^$(){}<>\\]/\\\&/g;
    $templ=~s/\*/.\*/g;
    $templ=~s/\?/./g;
    return $val =~ /^$templ$/;
  }
  return $val eq $templ;
}

sub findFirstTemplated {
  my ($grp,$template,$skipfirst)=@_;
  return unless $grp->{'FSFile'};
  my $node=$grp->{'currentNode'};
  my $tree=$grp->{treeNo};
  my $a;

  $node=(HNext($grp,$node) || $grp->{FSFile}->treeList->[(++$tree)]) if ($skipfirst);
  while ($node) {
    unless (grep ((exists($template->{$_}) and
		   $template->{$_} ne '' and
		   not cmpTemplateField($grp,$node->{$_},$template->{$_})
		  ), $grp->{FSFile}->FS->attributes))
      {
	gotoTree($grp,$tree);
	setCurrent($grp, $node);
	centerTo($grp,$node);
	return $node;
      }
    $node=(HNext($grp,$node) || $grp->{FSFile}->treeList->[(++$tree)]);
  }
  return undef;
}

sub lastSubtreeNode {
  my ($top)=@_;
  return undef unless $top;
  while ($top->firstson) {
    $top=$top->firstson;
    $top=$top->rbrother while ($top->rbrother);
  }
  return $top;
}

sub findPrevTemplated {
  my ($grp,$template,$skipfirst)=@_;
  return unless $grp->{'FSFile'};
  my $node=$grp->{'currentNode'};
  my $tree=$grp->{treeNo};
  my $a;

  if ($skipfirst) {
    $node=HPrev($grp,$node);
    unless ($node or $tree==0) {
      $node=lastSubtreeNode($grp->{FSFile}->treeList->[(--$tree)]);
      $node=HPrev($grp,$node) unless (isShown($grp,$node));
    }
  }
  while ($node) {
    unless (grep ((exists($template->{$_}) and
		   $template->{$_} ne '' and
		   not cmpTemplateField($grp,$node->{$_},$template->{$_})
		  ), $grp->{FSFile}->FS->attributes))
      {
	gotoTree($grp, $tree);
	setCurrent($grp, $node);
	centerTo($grp,$node);
	return $node;
      }
    $node=HPrev($grp,$node);
    unless ($node or $tree==0) {
      $node=lastSubtreeNode($grp->{FSFile}->treeList->[(--$tree)]);
      $node=HPrev($grp,$node) unless (isShown($grp,$node));
    }
  }
  return undef;
}


sub editAttrs {
  my ($w,$grp)=@_;
  my $node=$grp->{'pinfo'}{$w->find('withtag','current')};
  editAttrsDialog($grp,$node);
}

sub editAttr {
  my ($w,$grp)=@_;
  return unless $grp->{'FSFile'};
  my $attr;
  my $newvalue;

  my $t=$w->find('withtag','current');
  my $node=$grp->{'pinfo'}{$t};
  my $d;
  setCurrent($grp,$node);
  $attr= (grep {$$node{$_} eq $t} keys %$node)[0];
  return 0 unless ($attr=~/^_tkText\[([^]]+)\]/ or $1>$#displayAttrs);
  $attr=$1;
  my $result = doEvalHook($grp,'do_edit_attr_hook',$attr,$node);
  return 0 if $result eq 'stop';

  if ($grp->{FSFile}->FS->isList($attr)) {
    $newvalue = editListAttr($grp,$$node{$attr},$attr,$grp->{top});
    if (defined($newvalue)) {
      $grp->{'top'}->Busy(-recurse => 1);
      $grp->{FSFile}->notSaved(1);
      $$node{$attr}=$newvalue;
      getNodes($grp);
      redraw_tree($grp);
      $grp->{'top'}->Unbusy();
    }
    return;
  }

  if ($$node{$attr}=~/^(?:[^\|\\]|\\.)*\|/) {
    $newvalue = editAmbiguousAttr($grp,$$node{$attr},$attr);
    if (defined $newvalue) {
      $grp->{'top'}->Busy(-recurse => 1);
      $grp->{FSFile}->notSaved(1);
      $$node{$attr}=$newvalue;
      getNodes($grp);
      redraw_tree($grp);
      $grp->{'top'}->Unbusy();
    }
    return;
  }

  $grp->{'top'}->Busy(-recurse => 1);


  $newvalue=encode($$node{$attr});
  $d = $grp->{'top'}->DialogBox(-title => "Edit Node Attribute",
				-buttons => ["OK", "Cancel"]);
  $d->bind('all','<Escape>' => [sub { shift; shift->{'selected_button'}='Cancel'; },$d ]);
  $d->resizable(0,0);
  addBindTags($d,'dialog');
  my $l = $d->Label(-text => $attr,
		    -anchor => 'e',
		    -justify => 'right')->pack(-side=>'left');
  my $e = $d->Entry(-relief => 'sunken',
		    -width => 40,
		    -state => (doEvalHook($grp,'enable_attr_hook',$_) eq 'stop') ? 'disabled' : 'normal',
		    -takefocus => 1,
		    -font => $font,
		    -textvariable => \$newvalue)->pack();
  $e->icursor('end');
#  $e->focus;
  $grp->{'top'}->Unbusy();
  my $result = ShowDialog($d,$e,$grp->{top});
#  $grp->{'top'}->Busy(-recurse => 1);
  if ($result =~ /OK/) {
    $grp->{FSFile}->notSaved(1);
    $$node{$attr}=decode($newvalue);
    getNodes($grp);
    redraw_tree($grp);
  }
#  $grp->{'top'}->Unbusy();
  $d->destroy;
  undef $d;
}



sub whichTextColor {
  my ($grp,$arg)=@_;
  return undef unless $grp->{'FSFile'};

  return $textColor unless ($highlightAttributes);

  if ($grp->{FSFile}->FS->color($arg) eq 'Shadow') {
    return $textColorShadow;
  } elsif ($grp->{FSFile}->FS->color($arg) eq 'Hilite') {
    return $textColorHilite;
  } elsif ($grp->{FSFile}->FS->color($arg) eq 'XHilite') {
    return $textColorXHilite;
  } else {
    return $textColor;
  }
}

sub nodeOptions {
  my ($grp,$node)=@_;
  return (-outline => $nodeOutlineColor,
	  -fill =>
	  ($grp->{'currentNode'} eq $node) ?
	  $currentNodeColor :
	  (isShown($grp,$node,0) ?
	   $nodeColor :
	   $hiddenNodeColor)
	 );
}

sub nodeBoxOptions {
  my ($grp,$node)=@_;
  return (-fill =>
	  ($grp->{'currentNode'} eq $node) ?
	  $currentBoxColor :
	  (isShown($grp,$node,0) ?
	   $boxColor :
	   $hiddenBoxColor)
	 );
}


sub nodeCoords {
  my ($grp,$node)=@_;
  my ($nw,$nh)=
    (($grp->{'currentNode'} eq $node) ? $currentNodeWidth : $nodeWidth,
     ($grp->{'currentNode'} eq $node) ? $currentNodeHeight : $nodeHeight);

  return ($node->{"_tkXPOS_"}+($nodeWidth-$nw)/2,
	  $node->{"_tkYPOS_"}+($nodeHeight-$nh)/2,
	  $node->{"_tkXPOS_"}+$nh,
	  $node->{"_tkYPOS_"}+$nw);
}

sub wrappedLines {
  my ($grp,$font,$text,$width)=@_;
  use integer;
  return $grp->{'canvas'}->fontMeasure($font,$text)/$width + 1;
}


sub redraw_tree {
  my ($grp)=@_;
  my $node;
  my $parent;

  return if $insideEval;
  saveFileStateUpdate($grp);
  foreach $node (@{$grp->{Nodes}}) {
    foreach (keys(%$node)) {
      delete $node->{$_} if (/^_tk(?:X|Text)/);
    }
  }
  recalculate_positions($grp);

  $grp->{'canvas'}->configure(-scrollregion =>['0c', '0c', $grp->{canvasWidth}, $grp->{canvasHeight}]);
  $grp->{'canvas'}->configure(-background => $backgroundColor) if (defined $backgroundColor);
  $grp->{'canvas'}->addtag('delete','all');
  $grp->{'canvas'}->delete('delete');

  $grp->{'pinfo'}={lastX => 0, lastY => 0};

  if ($drawSentenceInfo) {
    return unless $grp->{'FSFile'};
    my $valtext=$valueLine;
    my $currentfile=filename($grp->{FSFile}->filename);
    my $fontHeight=$grp->{'canvas'}->fontMetrics($font, -linespace);
    $valtext=~s/ +([.,!:;])|(\() |(\)) /\1/g;

    if ($valtext=~/^(.*)\/([^:]*):\s*(.*)/) {
      my $ftext="File: $currentfile, tree $1 of $2";
      my $vtext=$3;
      $grp->{'canvas'}->createText(0,$grp->{canvasHeight},-font => $font,-text => $ftext,
				   -justify => left, -anchor => nw);
      $grp->{canvasHeight}+=$fontHeight;
      $grp->{canvasWidth}=max($grp->{canvasWidth},$grp->{'canvas'}->fontMeasure($font,$ftext));
      $grp->{'canvas'}->createLine(0,$grp->{canvasHeight},
				   $grp->{'canvas'}->fontMeasure($font,$ftext),
				   $grp->{canvasHeight});
      $grp->{canvasHeight}+=$fontHeight;
      $grp->{'canvas'}->createText(0,$grp->{canvasHeight},-font => $font,-text => $vtext,
				   -justify => left, -anchor => nw,
				   -width => $grp->{canvasWidth});
      $grp->{canvasHeight}+=$fontHeight*(wrappedLines($grp,$font,$vtext,$grp->{canvasWidth})+1);
#      $grp->{'canvas'}->createLine(0,$grp->{canvasHeight},$grp->{canvasWidth},$grp->{canvasHeight});

    }
  }

  foreach $node (@{$grp->{Nodes}}) {
    $parent=$node->parent;
    use integer;
    if ($parent) {
      $$node{"_tkLine_"}=$grp->{'canvas'}->createLine($$node{"_tkXPOS_"}+$nodeWidth/2,
					     $$node{"_tkYPOS_"}+$nodeHeight/2,
					     $$parent{"_tkXPOS_"}+$nodeWidth/2,
					     $$parent{"_tkYPOS_"}+$nodeHeight/2,
						      '-arrow' =>$lineArrow,
						     '-width' => $lineWidth,
						     '-fill' => $lineColor);
      $grp->{'pinfo'}{$$node{"_tkLine_"}}=$node;
    }
  }

  my $lineHeight=$grp->{'canvas'}->fontMetrics($font, -linespace);
  ## The Nodes ##
  foreach $node (@{$grp->{Nodes}}) {
    $$node{"_tkOval_"}=$grp->{'canvas'}->createOval(nodeCoords($grp,$node),
						    nodeOptions($grp,$node));
    $grp->{'canvas'}->addtag('point', 'withtag', $$node{"_tkOval_"});


    ## Boxes around attributes
    if ($drawBoxes) {
      ## get maximum width stored here by recalculate_positions
      my $textWidth=$node->{'_tkXWidth'};
      $$node{"_tkTextBox_"}=
	$grp->{'canvas'}->
	  createRectangle($$node{"_tkXPOS_"}-$xmargin,
			  $$node{"_tkYPOS_"}+$nodeHeight+$nodeYSkip-$ymargin,
			  $$node{"_tkXPOS_"}+
			  $textWidth+$xmargin,
			  $$node{"_tkYPOS_"}+
			  ($#displayAttrs+1)*$lineHeight+
			  $nodeHeight+$nodeYSkip+$ymargin,
			  nodeBoxOptions($grp,$node));
    }

    ## Texts of attributes
    for ($i=0;$i<=$#displayAttrs;$i++) {

      ## Clear background
      $$node{"_tkTextBg".$i."_"}=
	$grp->{'canvas'}->
	  createRectangle($$node{"_tkXPOS_"},
			  $$node{"_tkYPOS_"}+$nodeHeight+$nodeYSkip+$i*$lineHeight,
			  $$node{"_tkXPOS_"}+$node->{"_tkX_$i"}+1,
			  #$grp->{'canvas'}->fontMeasure($font,PrepareText($node,$i))+1,
			  $$node{"_tkYPOS_"}+$nodeHeight+$nodeYSkip+($i+1)*$lineHeight,
			  -fill => $grp->{'canvas'}->cget('-background'), -outline => undef)
	  unless ($drawBoxes);
      $grp->{'canvas'}->addtag('textbg', 'withtag', $$node{"_tkTextBg".$i."_"});
      $grp->{'pinfo'}{$$node{"_tkTextBg".$i."_"}}=$node;

      ## Draw attribute
      ## Custom version (the tredish)
      ##
      ## in this case we use the following syntax:
      ## #{color} changes color of all the following text
      ## ${attribute} is expanded to the value of attribute (and the
      ##              text is made active, so that modification is possible)
      ## <?code?>     expands to the return value of the imbedded perl-code
      ##              ($${attribute} may be used inside the code and is expanded
      ##               to 'value'. \${attribute} is not interpolated before <?code?>,
      ##               but may be used in retur value and is interpolated later)
      my $msg=encode(InterpolateTextField($node,$displayAttrs[$i]));
      $msg=~s/([\$\#]{[^}]+})/\#\#\#\1\#\#\#/g;
      my $xskip=0;
      my $txt;
      my $at_text;
      my $j=0;
      my $color=undef;
      foreach (split(/\#\#\#/,$msg)) {
	if (/^\${([^}]+)}$/) {
	  $j++;
	  $at_text=PrepareTextField($node,$1);
	  $txt=$grp->{'canvas'}->
	    createText($$node{"_tkXPOS_"}+$xskip,
		       $$node{"_tkYPOS_"}+
		       $nodeHeight+$nodeYSkip+$i*$lineHeight,
		       -anchor => 'nw',
		       -text => $at_text,
		       -fill => defined($color) ? $color : whichTextColor($grp,$1),
		       -font => $font);
	  $xskip+=$grp->{'canvas'}->fontMeasure($font,$at_text);
	  $grp->{'canvas'}->addtag('text', 'withtag', $txt);
	  $grp->{'pinfo'}{$txt}=$node;
	  $$node{"_tkText[$1][$i][$j]_"}=$txt;
	} elsif (/^\#{([^}]+)}$/) {
	  unless ($noColor) {
	    $color=$1;
	    $color=undef if ($color eq 'default');
	    $color=$customColors[$1] if ($color=~/^custom([0-9])$/);
	  }
	} else {
	  if ($_ ne "") {
	    $txt=$grp->{'canvas'}->
	      createText($$node{"_tkXPOS_"}+$xskip,
			 $$node{"_tkYPOS_"}+
			 $nodeHeight+$nodeYSkip+$i*$lineHeight,
			 -anchor => 'nw',
			 -text => $_,
			 -fill => defined($color) ? $color : $textColor,
			 -font => $font);
	    $xskip+=$grp->{'canvas'}->fontMeasure($font,$_);
	  }
	}
      }
    }

    $grp->{'pinfo'}{$$node{"_tkOval_"}}=$node;
    $grp->{'pinfo'}{$$node{"_tkTextBox_"}}=$node if exists $$node{"_tkTextBox_"};
  }

  ## Canvas Custom Balloons ##
  if ($grp->{CanvasBalloon}) {
    $grp->{CanvasBalloon}->
      attach($grp->{'canvas'}->Subwidget('scrolled'),
	     -balloonposition => 'mouse',
	     -msg => { map 
		       {
			 if (defined($_)) {
			   my $msg=InterpolateTextField($grp->{'pinfo'}{$_},
							$grp->{'BalloonPattern'});
			   $msg=~s/\${([^}]+)}/$grp->{'pinfo'}{$_}->{$1}/eg;
			   $_ => encode($msg);
			 }
		       } $grp->{'canvas'}->find('withtag','point')
		     });
  }
}


sub follow_mouse {
  my ($w, $grp) = @_;
  my $e = $w->XEvent;
  my($x, $y) = ($w->fpixels($e->x), $w->fpixels($e->y));
  scrollCanvasToXY($w, $grp, $x, $y);
}

sub follow_mouse_press {
  my ($w, $grp) = @_;
  my $e = $w->XEvent;
  my($x, $y) = ($w->fpixels($e->x), $w->fpixels($e->y));

  $grp->{'pinfo'}{'lastX'}=$x;
  $grp->{'pinfo'}{'lastY'}=$y;
  $grp->{'pinfo'}{'lastCanvasX'}=$w->canvasx($x);
  $grp->{'pinfo'}{'lastCanvasY'}=$w->canvasy($y);
}



sub scrollCanvasToXY {
  my ($w, $grp, $x, $y)=@_;
  my ($ax,$bx)=$w->xview;
  my ($ay,$by)=$w->yview;
  my $canvasX;

  my $sizeX=$w->fpixels($grp->{'canvasWidth'})*($bx-$ax);
  my $shiftX=($x-$grp->{'pinfo'}{'lastX'});
  if ($shiftX>0) {
    if ($grp->{'pinfo'}{'lastX'} == $sizeX) {
      $shiftX=0;
    } else {
      $shiftX/=$sizeX-$grp->{'pinfo'}{'lastX'}; # a fraction of our right move in window
    }
    $canvasX=$shiftX*
      ($w->fpixels($grp->{'canvasWidth'})-
	$grp->{'pinfo'}{'lastCanvasX'}); # this is where we should get on the canvas
  }
  else {
    if ($grp->{'pinfo'}{'lastX'} == 0) {
      $shiftX=0;
    } else{
      $shiftX/=$grp->{'pinfo'}{'lastX'}
    }
    $canvasX=$shiftX*
	$grp->{'pinfo'}{'lastCanvasX'}; # this is where we should get on the canvas
  }
  $canvasX+=$grp->{'pinfo'}{'lastCanvasX'};
  $w->xview(moveto =>
	    max(0,min(1,($canvasX-$x+1+$w->fpixels($w->cget('-borderwidth')))
		      /$grp->{'canvasWidth'})));

  # the same for Y
  my $sizeY=$w->fpixels($grp->{'canvasHeight'})*($by-$ay);
  my $shiftY=($y-$grp->{'pinfo'}{'lastY'});
  if ($shiftY>0) {
    if ($grp->{'pinfo'}{'lastY'} == $sizeY) {
      $shiftY=0;
    } else {
      $shiftY/=$sizeY-$grp->{'pinfo'}{'lastY'}; # a fraction of our right move in window
    }
    $canvasY=$shiftY*
      ($w->fpixels($grp->{'canvasHeight'})-
	$grp->{'pinfo'}{'lastCanvasY'}); # this is where we should get on the canvas
  }
  else {
    if ($grp->{'pinfo'}{'lastY'}==0) {
      $shiftY=0;
    } else {
      $shiftY/=$grp->{'pinfo'}{'lastY'};
    }
    $canvasY=$shiftY*
	$grp->{'pinfo'}{'lastCanvasY'}; # this is where we should get on the canvas
  }
  $canvasY+=$grp->{'pinfo'}{'lastCanvasY'};
  $w->yview(moveto =>
	    max(0,min(1,($canvasY-$y+1+$w->fpixels($w->cget('-borderwidth')))
		      /$grp->{'canvasHeight'})));


  $grp->{'pinfo'}{'lastX'}=$x;
  $grp->{'pinfo'}{'lastY'}=$y;
  $grp->{'pinfo'}{'lastCanvasX'}=$w->canvasx($x);
  $grp->{'pinfo'}{'lastCanvasY'}=$w->canvasy($y);
}

sub recalculate_positions {
  my ($grp)=@_;
  my $xpos=$baseXPos;
  my $ypos;
  my $minxpos; # used temporarily to place a node far enough from its left neighbour
  my $maxypos; # has different meaning from $minxpos; this one's used for canvasHeight
  my $canvasWidth=0;
  my $node;

  my $fontHeight=$grp->{'canvas'}->fontMetrics($font, -linespace);

  #print "Calculating positions ...\n";
  %prevnode=();
  $maxypos=0;
  foreach $node (@{$grp->{Nodes}}) {
    $ypos=0;
    $parent=$node->parent;
    while ($parent) {
      #print "!\n";
      $ypos++;
      $parent=$parent->parent;
    }
    $maxypos=max($maxypos,$ypos);
    $$node{"_tkYPOS_"}=$baseYPos+$ypos*(2*($nodeYSkip+$ymargin)+($#displayAttrs+1)*$fontHeight+$nodeHeight);

    #print "got y position for ",$$node{"form"},"\n";


    my $textWidth=0;
    my $m;
    for ($i=0;$i<=$#displayAttrs;$i++) {
      $m=$grp->{'canvas'}->fontMeasure($font,PrepareText($node,$i));
      $$node{"_tkX_$i"}=$m;
      $textWidth=$m if $m>$textWidth;
    }
    $$node{"_tkXWidth_"}=$textWidth;

    $minxpos=0;
    if ($prevnode{$ypos}) {
      $minxpos=$prevnode{$ypos}{"_tkXPOS_"}+$prevnode{$ypos}{"_tkXWidth_"}+
	$nodeXSkip+$nodeWidth+2*$xmargin;
    }
    $xpos=max($xpos,$minxpos);
    $$node{"_tkXPOS_"}=$xpos;
    $xpos+=$nodeXSkip+$nodeWidth;
    $canvasWidth=
      max($canvasWidth,
	  $$node{"_tkXPOS_"}+$$node{"_tkXWidth_"}+$baseXPos+$nodeWidth+2*$xmargin+$nodeXSkip);
    #print "got x position\n";

    $prevnode{$ypos}=$node;
    #print "$ypos ... ",$$node{"_tkYPOS_"},"\n";
  }
  #print "Width: $canvasWidth\n";
  $grp->{'canvasWidth'}=$canvasWidth;
  $grp->{'canvasHeight'}=$baseYPos+
    ($maxypos+1)*(2*($nodeYSkip+$ymargin)+($#displayAttrs+1)*$fontHeight+$nodeHeight);
  #print "Done.\n";
}

sub currentUnhiden {
  my $grp=shift;
  return unless $grp->{'FSFile'};
  unless ($showHidden) {
    my $node=$grp->{FSFile}->FS->isHidden($grp->{'currentNode'});
    setCurrent($grp,$node->parent) if ($node and $node->parent);
  }
}

sub currentLeft {
  my $grp=shift;
  return unless $grp->{'FSFile'};
  if ($showHidden) {
    if ($grp->{'currentNode'}->lbrother) {
      setCurrent($grp,$grp->{'currentNode'}->lbrother);
      centerTo($grp,$grp->{'currentNode'});
    }
  } else {
    my $n=$grp->{'currentNode'}->lbrother;
    $n=$n->lbrother while ($n and defined($grp->{FSFile}->FS->hide)
			   and ($n->{$grp->{FSFile}->FS->hide} eq 'hide'));
    if ($n) {
      setCurrent($grp,$n);
      centerTo($grp,$grp->{'currentNode'});
    }
  }
}

sub currentRight {
  my $grp=shift;
  return unless $grp->{'FSFile'};
  if ($showHidden) {
    if ($grp->{'currentNode'}->rbrother) {
      setCurrent($grp,$grp->{'currentNode'}->rbrother);
      centerTo($grp,$grp->{'currentNode'});
    }
  } else {
    my $n=$grp->{'currentNode'}->rbrother;

    $n=$n->rbrother while ($n and defined($n->{$grp->{FSFile}->FS->hide})
			   and ($n->{$grp->{FSFile}->FS->hide} eq 'hide'));
    if ($n) {
      setCurrent($grp,$n);
      centerTo($grp,$grp->{'currentNode'});
    }
  }
}

sub currentDown {
  my $grp=shift;
  return unless $grp->{'FSFile'};
  if ($showHidden) {
    if ($grp->{'currentNode'}->firstson) {
      setCurrent($grp,$grp->{'currentNode'}->firstson);
      centerTo($grp,$grp->{'currentNode'});
    }
  } else {
    my $n=$grp->{'currentNode'}->firstson;
    $n=$n->rbrother while ($n and defined($n->{$grp->{FSFile}->FS->hide})
			   and $n->{$grp->{FSFile}->FS->hide} eq 'hide');
    if ($n) {
      setCurrent($grp,$n);
      centerTo($grp,$grp->{'currentNode'});
    }
  }
}



sub currentUp {
  my $grp=shift;
  if ($grp->{'currentNode'}->parent) {
    setCurrent($grp,$grp->{'currentNode'}->parent);
    centerTo($grp,$grp->{'currentNode'});
  }
}

sub setCurrent {
  my ($grp,$node)=@_;
  my $prev=$grp->{currentNode};
  my $n;
  $grp->{'currentNode'}=$node;
  foreach $n ($prev,$node) { 
    $grp->{'canvas'}->itemconfigure($n->{'_tkOval_'}, nodeOptions($grp,$n));
    $grp->{'canvas'}->itemconfigure($n->{'_tkTextBox_'},nodeBoxOptions($grp,$n))
      if ($drawBoxes and $n->{'_tkTextBox_'});
    $grp->{'canvas'}->coords($n->{'_tkOval_'}, nodeCoords($grp,$n));
  }
}

sub centerToXY {
  ($grp, $x, $y) = @_;
  ($ax,$bx)=$grp->{'canvas'}->xview;
  ($ay,$by)=$grp->{'canvas'}->yview;

  $shiftx=($bx-$ax)/2;
  $shifty=($by-$ay)/2;

  $grp->{'canvas'}->xview(moveto => min(max(0,$x/$grp->{'canvasWidth'}-$shiftx),1))
    if ($grp->{'canvasWidth'}-$shiftx);
  $grp->{'canvas'}->yview(moveto => min(max(0,$y/$grp->{'canvasHeight'}-$shifty),1))
    if ($y/$grp->{'canvasHeight'}-$shifty);
}

sub centerTo {
  ($grp, $node) = @_;
  centerToXY($grp,$$node{'_tkXPOS_'},$$node{'_tkYPOS_'});
}

sub doEvalHook {
  my ($grp,$hook)=(shift,shift);
#  my $hookparams=join ",", map { "\"$_\"" } @_;
  my $context=$grp->{macroContext};
  return unless $hook;

  $this=$grp->{'currentNode'};
  return unless $this;
  $root=$grp->{'root'};

  my $result;
  $FileNotSaved=$grp->{FSFile}->notSaved; # Macro may want to override this :)
  $insideEval=1;

  unless ($macrosEvaluated) {
    eval ("@macros\n return 1;");
    $macrosEvaluated=1;
    if ($result or $@) {
      print STDERR "FirstEvaluation of macros\n" if $macroDebug;
      print STDERR "Returned with: $result\n$@\n" if $macroDebug;
    }
  }
  if ($context->can($hook)) {
    print STDERR "running hook $context\-\>$hook\n" if $hookDebug;
    $result=eval { return &{"$context\:\:$hook"}(@_); };
  } elsif ($context ne "TredMacro" and TredMacro->can($hook)) {
    print STDERR "running hook Tredmacro->$hook\n" if $hookDebug;
#    $result=eval("return TredMacro\:\:$hook($hookparams);\n");
    $result=eval { return &{"TredMacro\:\:$hook"}(@_); };
  }
  print "$@\n" if $@;
  $grp->{FSFile}->notSaved($grp->{FSFile}->notSaved or $FileNotSaved);
  saveFileStateUpdate($grp);
  $insideEval=0;

  # This may be important
  # (we do not want to leave references to non-existsing
  #  objects later)
  $this=undef;
  $root=undef;

  print STDERR "Hook resulted with $result\n" if $hookDebug;
  return $result;
}


sub doEvalMacro {
  my ($grp,$macro)=(shift,shift);
  return unless $macro;

  $this=$grp->{'currentNode'};
  return unless $this;
  $root=$grp->{'root'};

  my $result;
  $grp->{'top'}->Busy(-recurse => 1);
  $FileNotSaved=1; #$grp->{FSFile}->notSaved;  # Macro may want to override this :)
  $forceFileSaved=0; # Macro may want to override this :)
  $insideEval=1;

  unless ($macrosEvaluated) {
    eval ("@macros\n return 1;");
    $macrosEvaluated=1;
    if ($result or $@) {
      print STDERR "FirstEvaluation of macros\n";# if $macroDebug;
      print STDERR "Returned with: $result\n$@\n" if $macroDebug;
    }
  }
#  $result=eval("return ".$macro."();\n@macros\n");  # this consumes memory!!!!
  print "Running $macro\n" if $macroDebug;
  $result=eval("return $macro;\n");

  if ($result or $@) {
    print STDERR "Had run: ",$macro,"\n" if $macroDebug;
    print STDERR "Returned with: $result\n$@\n" if $macroDebug;
  }
  unless ($forceFileSaved) {
    print STDERR "Macro claims file untouched\n"
      unless ($FileNotSaved);
    $grp->{FSFile}->notSaved($grp->{FSFile}->notSaved or $FileNotSaved);
  } else {
    print STDERR "Macro forsly claims file saved.\n";
    # using value of $FileNotSaved
    $grp->{FSFile}->notSaved($FileNotSaved);
  }
  $insideEval=0;

  getNodes($grp);     # memory ok, speed ok


  #------------------------------------------------------------
  #use Benchmark;
  #my $t0 = new Benchmark;
  #for (my $i=0;$i<=50;$i++) {
  #------------------------------------------------------------

  redraw_tree($grp);  # ??? 4kb/50 runs memory leaks???, speed ok
 
  #------------------------------------------------------------
  #}
  #my $t1 = new Benchmark;
  #my $td = timediff($t1, $t0);
  #print "$FileNotSaved the code took:",timestr($td),"\n";
  #------------------------------------------------------------


  # the rest of this routine is:
  # memory ok, speed ok
  setCurrent($grp,$this) if ($this);
  currentUnhiden($grp);

  # This may be important
  # (we do not want to leave references to non-existsing
  #  objects later)
  $this=undef;
  $root=undef;

  centerTo($grp,$grp->{currentNode});


  $grp->{'top'}->Unbusy;
  return $result;
}

sub evalMacro {
  my ($w,$grp,$prefix)=@_;
  my $key;
  my $e = $w->XEvent;
  my $A = uc($e->A);
  my @possib=();
  my $context;
  my $macro=undef;

  if ($keyboardDebug) {
    print STDERR "Pressed: (".ord($A)."), prefix $prefix, keysym ",$e->K,"/",$e->N,"\n";
    print STDERR "Maybe: ",$prefix.$pckey_shift_translates{$e->K},"\n";
  }

  push @possib,
    ($prefix.$A,
      ($prefix =~/SHIFT/ and exists($pckey_shift_translates{$e->K})) ?
	$prefix.$pckey_shift_translates{$e->K} : ()),
	$prefix.uc($e->K);
 context:
  foreach $context ($grp->{macroContext},$grp->{macroContext} eq "TredMacro" ? () : "TredMacro") {
    foreach $key (@possib) {
      if (exists ($keyBindings{$context}->{$key})) {
	$macro=$keyBindings{$context}->{$key};
	last context;
      }
    }
  }
  if (defined $macro) {
#    use Benchmark;
#    my $t0 = new Benchmark;
#    # ... your code here ...
#    for (my $i=0;$i<=50;$i++) {
      doEvalMacro($grp,$macro);
#    }
#    my $t1 = new Benchmark;
#    my $td = timediff($t1, $t0);
#    print "the code took:",timestr($td),"\n";

    return 1;
  }
  return undef;
}

sub currentNext {
  my ($grp)=@_;
  my $next=HNext($grp,$grp->{'currentNode'});
  if ($next) {
    setCurrent($grp,$next);
    centerTo($grp,$grp->{'currentNode'});
  }
}


sub currentPrev {
  my ($grp)=@_;
  my $prev=HPrev($grp,$grp->{'currentNode'});
  if ($prev) {
    setCurrent($grp,$prev);
    centerTo($grp,$grp->{'currentNode'});
  }
}


sub node_down {

    my($w,$grp) = @_;

    my $e = $w->XEvent;
    my($x, $y) = ($e->x, $e->y);
    my $node=$grp->{'pinfo'}{$w->find('withtag','current')};

    setCurrent($grp,$node);
    $w->dtag('selected');
    $w->addtag('selected', 'withtag', 'current');
    $w->raise('current');
    $grp->{'pinfo'}{'lastX'} = $x;
    $grp->{'pinfo'}{'lastY'} = $y;
    $grp->{'pinfo'}{'lastCanvasX'}=$w->canvasx($x);
    $grp->{'pinfo'}{'lastCanvasY'}=$w->canvasy($y);
} # end plot_down

sub node_move {

    my($w,$grp,$scroll) = @_;

    my $e = $w->XEvent;
    my($x, $y) = ($e->x, $e->y);
    my $node=$grp->{'pinfo'}->{$w->find('withtag','selected')};

    my $lcx=$grp->{'pinfo'}{'lastCanvasX'};
    my $lcy=$grp->{'pinfo'}{'lastCanvasY'};
    my $ncolor,$ocolor;

    if ($scroll) {
      $ncolor=$w->itemcget('selected','-fill');
      $ocolor=$w->itemcget('selected','-outline');
      $w->itemconfigure('selected',
			-fill => $grp->{'canvas'}->cget('-background'),
			-outline => $grp->{'canvas'}->cget('-background')
		       );
      scrollCanvasToXY($w, $grp, $x, $y);
    } else {
      $grp->{'pinfo'}{'lastCanvasX'}=$w->canvasx($x);
      $grp->{'pinfo'}{'lastCanvasY'}=$w->canvasy($y);
    }
    my($cx, $cy) = ($w->canvasx($x),$w->canvasy($y));
    $w->move('selected',  $cx-$lcx, $cy-$lcy);
    $w->itemconfigure('selected', -fill => $ncolor, -outline => $ocolor ) if $scroll;
    $w->itemconfigure('nearest', -fill => (isShown($grp,$node,0) ?
						     $nodeColor :
						     $hiddenNodeColor));
    $w->dtag('nearest');

    my @dots= $w->find('withtag','point');
    my $nearestNode=0;
    my $bestDist=10000;
    my $dist;
    foreach $p (@dots) {
      if ($grp->{'pinfo'}{$p} and $grp->{'pinfo'}{$p}!=$node) {
	$dist=
	  ($cx-$grp->{'pinfo'}{$p}{'_tkXPOS_'})*
	    ($cx-$grp->{'pinfo'}{$p}{'_tkXPOS_'})+
	      ($cy-$grp->{'pinfo'}{$p}{'_tkYPOS_'})*
		($cy-$grp->{'pinfo'}{$p}{'_tkYPOS_'});
	if ($bestDist>$dist) {
	  $bestDist=$dist;
	  $nearestNode=$grp->{'pinfo'}{$p};
	}
      }
    }
    if ($bestDist<800) {
      $w->addtag('nearest','withtag',$$nearestNode{"_tkOval_"});
      $w->itemconfigure($$nearestNode{"_tkOval_"}, -fill => $nearestNodeColor);
    }
} # end plot_move

sub node_release {
  my($w,$grp) = @_;
  return unless $grp->{'FSFile'};
  my $e = $w->XEvent;
  my($x, $y) = ($e->x, $e->y);
  my $parent;
  my $node;
  my $center=0;
  my $sel=$w->find('withtag','selected');
  $node=$grp->{'pinfo'}{$sel} if (defined ($sel));

  if ($node) {
    $p=$w->find('withtag','nearest');
    $w->dtag('selected');
    if (defined $p) {
      $parent=$grp->{'pinfo'}{$p};
      $w->itemconfigure($parent->{"_tkOval_"}, 
			  nodeOptions($grp,$parent));
      while ($parent) {
	$p=0, last if ($node eq $parent);
	$parent=$parent->parent;
      }
      if ($p and $grp->{'pinfo'}{$p} 
	  and $node->parent!=$grp->{'pinfo'}{$p}) {
	Paste(Cut($node),$grp->{'pinfo'}{$p},$grp->{FSFile}->FS->defs);
	$grp->{FSFile}->notSaved(1);
	redraw_tree($grp);
	centerTo($grp,$grp->{currentNode});
	return;
      }
    }
    # returning node to its position
    $w->coords($sel, nodeCoords($grp,$node));
  } else { redraw_tree($grp); }
}

sub PrepareTextField {
  my ($node,$atr)=@_;
  $text=$node->{$atr};
  $text=$1."*" if ($text =~/^([^\|]*)\|/);
  return encode($text);
}

sub InterpolateTextField {
  my ($node,$text)=@_;
  $text=~s/\<\?((?:[^?]|\?[^>])+)\?\>/eval InterpolateRefs($node,$1)/eg;
  return $text;
}

sub InterpolateRefs {
  my ($node,$text)=@_;
  $text=~s/\$\${([^}]+)}/"'".$node->{$1}."'"/eg;
  return $text;
}

sub PrepareText {
  my ($node,$str)=@_;
    my $msg=InterpolateTextField($node,$displayAttrs[$str]);
    $msg=~s/\#{[^}]+}//g;
    $msg=~s/\${([^}]+)}/PrepareTextField($node,$1)/eg;
    return encode($msg);
}
