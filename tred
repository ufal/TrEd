#!/usr/bin/perl
#
# Tred ver. 0.3 - Copyright (C) 2000 by Petr Pajas
# This software is covered by GPL - The General Public Licence
# Full text of the GPL can be found at http://www.gnu.org/copyleft/gpl.html.
#
# This is "Tred" - a simple viewer/editor of tree graphs in fs
# file-format used in Graph - program developed by M. Kren. Tred is
# written entirely in Perl and for graphical output it uses PerlTk
# library as a frontend to Tk toolkit
#
################################################################################
#
# Usage:
# tred [-c <config-file>] [-m <macro-file>] file1[##N|#N] [file2[##N|#N] [...]]
#
# or
#
# tred -u  for usage
#
# or
#
# tred -h  for help
#
################################################################################


# Once we got rid of them we call getopt to read all the other options
use Tk;
use Tk::Xrm;
# process the standard arguments for X resources
Tk::CmdLine::SetArguments();


use Getopt::Std;
getopts('m:c:hu');

if ($opt_u) {

  print <<EOH;
Usage:
  tred [-c config-file] [-m macro-file] files...
or
  btred -u          to show usage
or
  btred -h          to show help
EOH
  exit;
}

if ($opt_h) {
  print <<EOF;
Usage:
tred [-c <config-file>] [-m <macro-file>] file1[##N|#N] [file2[##N|#N] [...]]

or

tred -u|-h    for usage/help

This is `TRED' - a simple viewer/editor of tree graphs in FS-format
used in `GRAPH' - a program developed by M. Kren. TRED (which stands
for The TRee EDitor) is written entirely in Perl and it uses PerlTk
module for GUI.

Files file1, etc. given on the command-line must be in fs-format (for
not a little bit obsolete description see:
	http://ufal.ms.mff.cuni.cz/local/doc/trees/format_fs.html)

The name of each file may be followed by a suffices of the following
forms:

#N      where N is a number possibly followed by one or more
	upper-case letters. In this case, #N tells tred to skip to the
	first tree the root of which has `#N' as a value of attribute
	called `form' (this feature is optimized for specific
	instances of fs-format used while working on The Prague
	Dependency Treebank)

##N     where N is a number. This makes tred to go to the N-th tree in
	the given file after the file is opened.

-m      may be used to specify a macro file different from the one
	given in ~/.tredrc (or whatsoever) configuration file

-c      may be used to specify a config-file to be used (overrides
	~/.tredrc and all the other files Tred would otherwise try to
	search for).

EOF
  exit;
}


# this variable is used when searching for rc-file (i.e. the inicialisation file)
my @configFileSearchList=($ENV{HOME}.'/.tredrc',
			  (exists $ENV{TREDHOME}) ? $ENV{TREDHOME}.'/tredrc' : (),
			  dirname(<$0>).'tredrc',
			  dirname(<$0>).'../lib/tredlib/tredrc',
			  dirname(<$0>).'tredlib/tredrc',
			  dirname(<$0>).'../lib/tred/tredrc',
			  '/usr/X11R6/lib/X11/app-defaults');
my $configFile;
# other configuration should be given in that file


my $libDir;
# Default values of $libDir used to search for macro-file (tred.mac)
# and default-macro file (tred.def) are specified here. They may be
# overriden by value of LibDir in tred resource file (tredrc or ~/.tredrc - see above).

if (exists $ENV{TREDHOME}) {
  $libDir=$ENV{TREDHOME};
} elsif (-d dirname($0).'tredlib') {
  $libDir=dirname($0).'tredlib';
} elsif (-d dirname($0).'../lib/tredlib') {
  $libDir=dirname($0).'../lib/tredlib';
} elsif (-d dirname($0).'../lib/tred') {
  $libDir=dirname($0).'../lib/tred';
}
print "Trying $libDir\n" if ($libDir);


$macroFile=undef;

if (defined $opt_c) {
  @configFileSearchList=($opt_c); # override any other possible config files
}

readConfig();

$macroFile="$libDir/tred.mac" unless (defined $macroFile);

if (defined $opt_m) {
  $macroFile=$opt_m;
}



unless (-d $libDir) {
  print <<'EOL';
 Tred couldn't find a tredlib directory. You may need to point
 to its location by the TREDHOME variable or add a correct LibDir
 field to your .tredrc.

EOL
    die "Error: Couldn't find lib-directory.";
}


##################### character encoding functions ########################

%encodings = (
	      'iso-8859-2' => "ì¹èø¾ýáíéìúùóò»ïµà¶å¼æñÌ©ÈØ®ÝÁÍÉÌÚÙÓÒ«Ï¥À¦Å¬ÆÑ",
	      'ascii' => "escrzyaieeuuontdlrslzcnESCRZYAIEEUUONTDLRSLZCN",
	      'iso-8859-1' => "escrzýáíéeúuóntdlrslzcnESCRZÝÁÍÉEÚUÓNTDLRSLZCN",
	      'windows-1250' => "ìšèøžýáíéìúùóòï¾àœåŸæñÌŠÈØŽÝÁÍÉÌÚÙÓÒÏ¼ÀŒÅÆÑ"
	     );

sub encode {
  return join("",@_) if ($inputenc eq $outputenc);

  local $_=join "",@_;
  eval " tr/$encodings{$inputenc}/$encodings{$outputenc}/";
  return $_;
}

sub decode {
  return join("",@_) if ($inputenc eq $outputenc);

  local $_=join "",@_;
  eval " tr/$encodings{$outputenc}/$encodings{$inputenc}/";
  return $_;
}

$inputenc="iso-8859-2";
if ($^O =~ /^MS/) {
  $outputenc="windows-1250";
} else {
  $outputenc="iso-8859-2";
}

################ end of character encoding functions ########################

use Tk;
use Tk::LabFrame;
use Tk::Listbox;
use Tk::Balloon;
use Tk::DialogBox;
use Tk::Tiler;

push @INC,$libDir;
require Fslib;
import Fslib;
import Fslib qw(&Ord &Value &Hide &SentOrd &AOrd &AValue &AHide &ASentOrd);


my @macros=();

if ($useCzechLocales) {
  use locale;
  use POSIX qw(locale_h);
  setlocale(LC_COLLATE,"cs_CZ");
  setlocale(LC_NUMERIC,"us_EN");
  setlocale(LANG,"czech");
}

my %attribs = ();
my @atord = ();

my @files=@ARGV;
my @trees=();
my @header=();
my @nodes=();
my @rest=();

my $root, $this;
my $_NoSuchTree; # for compatibility with Graph2Tred
my $NodeClipboard;


my $insideEval=0;
my $FileNotSaved=0;
my $fileNo=0;
my $filecount=$#files+1;

my %searchTemplate;

%pckey_shift_translates = (exclam => 1, at => 2, numbersign => 3,
			   dollar => 4, percent => 5, asciicircum => 6,
			   ampersand => 7, asterisk => 8, parenleft => 9,
			   parenright => 0, plus => 'equal',
			   underscore => 'minus',
			   less => 'comma', greater => 'period', 
			   question => 'slash',
			   colon => 'semicolon', quotedbl => 'apostroph',
			   braceleft => 'bracketleft', 
			   braceright => 'bracketright',
			   bar => 'backslash', asciitilde => 'grave'
			  );

sub dirname {
  $_=shift;
  return (m!/!)? (substr($_,0,rindex($_,"/")+1)) : "./";
}

print STDERR "Reading macros from $macroFile...";
readMacros($macroFile);		# read macros
print STDERR "done.\n";
startMain($files[$fileNo]);	# display first tree

closeFile();

exit;

############################
############################
############################

sub min {
  my ($a,$b)=@_;
  return ($a<$b)?$a:$b;
}

sub max {
  my ($a,$b)=@_;
  return ($a<$b)?$b:$a;
}


sub parseConfigLine {
  local $_=shift;
  my $confs=shift;
  my $key;
  unless (/^[;#]/ or /^$/) {
    chomp;
    if (/^\s*([a-zA-Z_]+[a-zA-Z_0-9]*)\s*=\s*('(?:[^\\']|\\.)*'|"(?:[^\\"]|\\.)*"|(?:\s*(?:[^;\\\s]|\\.)+)*)/) {
      $confs->{$1}=$2;
      $key=$1;
      $confs->{$key}=~s/\\//g;
      $confs->{$key}=$1 if ($confs->{$key}=~/^'(.*)'$/ or $confs->{$key}=~/^"(.*)"$/);
      #print "$key=$confs->{$key};\n";
    }
  }
}

sub readConfig {
  #
  # Simple configuration file handling
  #
  my %confs;
  my $key, $f;
  local *F;
  my $openOk=0;

  foreach $f (@_,@configFileSearchList) {
    if (defined($f), open(F,"<$f")) {
      print "Using resource file $f\n";
      while (<F>) {
	parseConfigLine($_,\%confs);
      }
      close F;
      $openOk=1;
      $configFile=$f;
      last;
    }
  }
  unless ($openOk) {
    print
      "Warning: Cannot open any file in:\n",
      join(":",@configFileSearchList),"\n" .
      "         Using configuration defaults!\n";
  }
  setConfig(\%confs);
}

sub applyConfig {
  my %confs;
  foreach (@_) {
    parseConfigLine($_,\%confs);
  }
  setConfig(\%confs);
}

sub setConfig {
  my $confs=shift;

  $appName=(exists $confs->{AppName}) ? $confs->{AppName} : "Tred ver. 0.3";
  $baseXPos=(exists $confs->{BaseXPos}) ? $confs->{BaseXPos} : 15;
  $baseYPos=(exists $confs->{BaseYPos}) ? $confs->{BaseYPos} : 15;
  $nodeWidth=(exists $confs->{NodeWidth}) ? $confs->{NodeWidth} : 5;
  $nodeHeight=(exists $confs->{NodeHeight}) ? $confs->{NodeHeight} : 5;
  $nodeXSkip=(exists $confs->{NodeXSkip}) ? $confs->{NodeXSkip} : 5;
  $nodeYSkip=(exists $confs->{NodeYSkip}) ? $confs->{NodeYSkip} : 10;
  $xmargin=(exists $confs->{Xmargin}) ? $confs->{Xmargin} : 2;
  $ymargin=(exists $confs->{Ymargin}) ? $confs->{Ymargin} : 2;
  $buttonsRelief=(exists $confs->{ButtonsRelief}) ? $confs->{ButtonsRelief} : 'raised';
  $menubarRelief=(exists $confs->{MenubarRelief}) ? $confs->{MenubarRelief} : 'raised';
  $buttonBorderWidth=(exists $confs->{ButtonsBorder}) ? $confs->{ButtonsBorder} : 2;
  $lineWidth=(exists $confs->{LineWidth}) ? $confs->{LineWidth} : 1;
  $lineColor=(exists $confs->{LineColor}) ? $confs->{LineColor} : 'black';
  $lineArrow=(exists $confs->{LineArrow}) ? $confs->{LineArrow} : 'none';
  $nodeColor=(exists $confs->{NodeColor}) ? $confs->{NodeColor} : 'yellow';
  $hiddenNodeColor=(exists $confs->{HiddenNodeColor}) ? $confs->{HiddenNodeColor} : 'black';
  # $activeNodeColor=(exists $confs->{ActiveNodeColor}) ? $confs->{ActiveNodeColor} : 'blue';
  $currentNodeColor=(exists $confs->{CurrentNodeColor}) ? $confs->{CurrentNodeColor} : 'red';
  $nearestNodeColor=(exists $confs->{NearestNodeColor}) ? $confs->{NearestNodeColor} : 'green';
  $textColor=(exists $confs->{TextColor}) ? $confs->{TextColor} : 'black';
  $textColorShadow=(exists $confs->{TextColorShadow}) ? $confs->{TextColorShadow} : 'darkgrey';
  $textColorHilite=(exists $confs->{TextColorHilite}) ? $confs->{TextColorHilite} : 'darkgreen';
  $textColorXHilite=(exists $confs->{TextColorXHilite}) ? $confs->{TextColorXHilite} : 'darkred';
  $activeTextColor=(exists $confs->{ActiveTextColor}) ? $confs->{ActiveTextColor} : 'blue';
  $boxColor=(exists $confs->{BoxColor}) ? $confs->{BoxColor} : 'wheat';
  $currentBoxColor=(exists $confs->{CurrentBoxColor}) ? $confs->{CurrentBoxColor} : 'white';
  $backgroundColor=(exists $confs->{BackgroundColor}) ? $confs->{BackgroundColor} : undef;
  $font=(exists $confs->{Font}) ? $confs->{Font} :
    (($^O=~/^MS/) ? 'family:Helvetica,size:10' : '-*-helvetica-medium-r-normal-*-12-*-*-*-*-*-*-2');
  $type1font=(exists $confs->{Type1Font}) ? $confs->{Type1Font} :
    (($^O=~/^MS/) ? $font : '-ult1mo-arial-medium-r-*-*-*-*-*-*-*-*-*-2');
  $libDir=(exists $confs->{LibDir}) ? <$$confs{LibDir}> : $libDir;
  $appIcon=(exists $confs->{AppIcon}) ? <$$confs{AppIcon}> : "$libDir/tred.xpm";
  $psFontFile=(exists $$confs{PsFontFile}) ?
    ((-d <$$confs{PsFontFile}>) ? <$$confs{PsFontFile}> : "$libDir/".$$confs{PsFontFile}) :
      "$libDir/csarialm.pfa";
  $psFontName=(exists $$confs{PsFontName}) ? <$$confs{PsFontName}> : "Arial-Medium";
  $psFontSize=(exists $$confs{PsFontSize}) ? <$$confs{PsFontSize}> : "12";
  $macroFile=(exists $$confs{MacroFile}) ? <$$confs{MacroFile}> : $macroFile;
  $defaultMacroFile=(exists $confs->{DefaultMacroFile}) ? <$$confs{DefaultMacroFile}> : "$libDir/tred.def";
  $prtFmtWidth=(exists $confs->{PrtFmtWidth}) ? $confs->{PrtFmtWidth} : '21c';
  $prtFmtHeight=(exists $confs->{PrtFmtHeight}) ? $confs->{PrtFmtHeight} : '297m';
  $prtVMargin=(exists $confs->{PrtVMargin}) ? $confs->{PrtVMargin} : '3c';
  $prtHMargin=(exists $confs->{PrtHMargin}) ? $confs->{PrtHMargin} : '1c';
  $psMedia=(exists $confs->{PsMedia}) ? $confs->{PsMedia} : '%%DocumentMedia: A4 595 842 white()';
  $psFile=(exists $confs->{PsFile}) ? <$$confs{PsFile}> : 'tred.ps';
  $drawBoxes=(exists $confs->{DrawBoxes}) ? $confs->{DrawBoxes} : 0;
  $highlightAttributes=(exists $confs->{HighlightAttributes}) ? $confs->{HighlightAttributes} : 1;
  $maximizePrintSize=(exists $confs->{MaximizePrintSize}) ? $confs->{MaximizePrintSize} : 0;
  $showHidden=exists ($confs->{ShowHidden}) ? $confs->{ShowHidden} : 0;
  $createMacroMenu=(exists $confs->{CreateMacroMenu}) ? $confs->{CreateMacroMenu} : 0;
  $maxMenuLines=(exists $confs->{MaxMenuLines}) ? $confs->{MaxMenuLines} : 30;
  $useCzechLocales=(exists $confs->{UseCzechLocales}) ? $confs->{UseCzechLocales} : 1;
  $Tk::strictMotif=(exists $confs->{StrictMotif}) ? $confs->{StrictMotif} : 0;
  $printColors=(exists $confs->{PrintColors}) ? $confs->{PrintColors} : 0;
  $anyToFs=(exists $confs->{AnyToFs}) ? $confs->{AnyToFs} : undef;
  print "finished reading ini-file\n";
}


sub readMacros {
  # This subroutine reads macro file. Macros are usual perl
  # subroutines and may use this program's namespace. They are also
  # provided some special names for certain variables which override
  # the original namespace.

  # Macros may be bound to a keysym with a special form of a comment.
  # The synax is:
  #
  # # bind MacroName to key [[Modifyer+]*]KeySym
  #
  # which causes subroutine MacroName to be bound to keyboard event of
  # simoultaneous pressing the optionally specified Modifyer(s) (which
  # should be some of Shift, Ctrl and Alt) and the specified KeySym
  # (this probabbly depends on platform too :( ).


  my ($file)=@_;
  my $nextBind=undef;
  my $macro;
  my $key;
  local *F;

  %keyBindings=();
  %menuBindings=();
  @macros=();

  print "ERROR: Cannot open macros!\n", return
    unless open(F,"<$defaultMacroFile");
  push @macros, <F>;
  close F;

  print "ERROR: Cannot open macros!\n", return
    unless open(F,"<$file");

  while (<F>) {
    push @macros,$_;
    if (/\#[ \t]*bind[ \t]+(\w*)[ \t]+(?:to[ \t]+)?(?:key(?:sym)?[ \t]+)?([^ \t\r\n]+)(?:[ \t]+menu[ \t]+(.+))?/) {
      $macro=$1;
      $key=uc($2);
      $menu=$3;
      #print "binding $key [$menu] => $macro\n";
      $keyBindings{$key}=$macro;
      $menuBindings{$menu}=[$macro,$key] if ($menu);
    } elsif (/\#[ \t]*insert[ \t]+(\w*)[ \t]+(?:as[ \t]+)?(?:menu[ \t]+)?(.+)/) {
      $macro=$1;
      $menu=$2;
      #print "binding [$menu] => $macro\n";
      $menuBindings{$menu}=[$macro,undef];
    }
  }
  close(F);
}

sub nextFile {
  return 0 if ($fileNo >= $#files);
  my ($grp)=@_;
  askSaveFile($grp);
  $fileNo++;
  openFile($files[$fileNo],$grp);
  return 1;
}
sub prevFile {
  return 0 unless ($fileNo > 0);
  my ($grp)=@_;
  askSaveFile($grp);
  $fileNo--;
  openFile($files[$fileNo],$grp);
  return 1;
}

sub closeFile {
  my $grp=shift;
  my $key;

  @nodes=();
  undef $NodeClipboard;
  undef $root;
  delete $grp->{'currentNode'} if (exists $grp->{'currentNode'});
  undef %{$grp->{pinfo}} if ($grp->{pinfo});
  foreach (@trees) { DeleteTree($_); }
  undef @trees;
  undef @header;
  undef @rest;

  @trees = ();
  @header = ();
  @rest = ();
  @atord=();
  %attribs=();
}

sub openFile {
  my $f = shift;
  my $grp = shift;
  my $goto = undef;
  my $fs;
  my @d=();

  $grp->{'top'}->Busy(-recurse => 1);

  closeFile($grp);

  if ($f=~/(##?[0-9A-Z]+)$/) {
    $f=~s/(##?[0-9A-Z]+)$//;
      $goto=$1
  }

  # opening file
  unless (open(F,"<$f")) {
    print STDERR "cannot open $f!\n";
    return 0;
  }

  # peep on the first character
  $fs =($_=<F> and /^\@/); close(F);

  print STDERR "file is fs: $fs\n";

  if ($fs) {
    # opening file again, know it is fs
    unless (open(F,"<$f")) {
      if ($grp->{top}) {
	$grp->{top}->
	  messageBox(-icon => 'error',
		     -message => "Cannot open $f!\n",
		     -title => 'Error', -type => 'Ok');
      } else {
	print STDERR "Error: cannot open $f!\n";
      }
      $grp->{'top'}->Unbusy();
      return 0;
    }
  } elsif (defined($anyToFs) and -x $anyToFs) {
    print STDERR "trying to run \`$anyToFs\'\n";
    unless (open(F,"$anyToFs $f |")) {
      print STDERR "ok.\n";
      if ($grp->{top}) {
	$grp->{top}->
	  messageBox(-icon => 'error',
		     -message => "Cannot run filter \`$anyToFs\' on $f!\n",
		     -title => 'Error', -type => 'Ok');
      } else {
	print STDERR "Error: cannot run $anyToFs on $f!\n";
      }
      $grp->{'top'}->Unbusy();
      return 0;
    }
    $f.=".fs";
  } else {   
    if ($grp->{top}) {
      $grp->{top}->
	messageBox(-icon => 'error',
		   -message => 
		   "Cannot open $f (bad $anyToFs or unknown format?)!\n",
		   -title => 'Error', -type => 'Ok');
    } else {
      print STDERR "cannot open $f (bad $anyToFs or unknown format?)!\n";
    }
    $grp->{'top'}->Unbusy();
    return 0;
  }

  #reading attribs
  %attribs=ReadAttribs(\*F,\@atord,2,\@header);

  # reading trees
  while ($_=ReadTree(\*F)) {
    if (/^\[/) {
      $root=GetTree($_,\@atord,\%attribs);
      push(@trees, $root) if $root;
    } else { push(@rest, $_); }
  }
  close (F);

  #parse Rest
  #print "@rest\n";
  @d= $rest[0]=~/[,\(]([0-9]+)/g;
  #print "Displaying:\n@d\n";
  @displayAttrs = map { $atord[$_] } @d;
  #print "That is:\n@displayAttrs\n";

  print STDERR "empty file!\n" if ($#trees<0);

  $treeNo=0;

  # -- smells like proprietary code, at least the second case
  if (defined $goto) {
    if ($goto=~/^##([0-9]+)$/) {
      $treeNo=min(max(0,$1),$#trees);
    }
    for (my $i=0;$i<=$#trees;$i++) {
      $treeNo=$i,last if ($trees[$i]->{'form'} eq $goto);
    }
  }
  # --
  $grp->{'currentFile'}=$f;
  $grp->{'top'}->title("$appName $f");
  getNodes($grp);
  $FileNotSaved=0;
  redraw_tree($grp);
  $grp->{'top'}->Unbusy();
  return 1;
}

sub saveFile {
  my $grp=shift;
  my $f=$grp->{'currentFile'};
  my @atrIds=();

  return unless $grp->{'currentFile'};

  rename $f,$f."~";
  die "cannot open $f for writing!\n" unless open(FO,">$f");
  print FO @header;
  PrintFS(\*FO,\@header,\@trees,\@atord,\%attribs);
  my $atrLine=shift @rest;

  for (my $i=0;$i<=$#atord;$i++) {
    push @atrIds, $i if (grep {$_ eq $atord[$i]} @displayAttrs);
  }
  print FO "(";
  print FO join ",",@atrIds;
  print FO ")\n";
  #print "Saving with", join ",",@atrIds;
  #print "\n";
  print FO @rest;
  close(FO);
  $FileNotSaved=0;
  #print STDERR "wrote $f, $f~ is a backup.\n";
}

sub isShown { # test if node is shown (always 1 if $showHidden)
  my $node=shift;
  my $show=shift;
  $show=$showHidden unless defined $show;

  return 0 unless $node;
  return 1 if $show or not defined(AHide(\%attribs));
  while ($node and (Hide($node,\%attribs) ne 'hide')) {
    $node=Parent($node);
  }
  return ($node ? 0 : 1)
}

sub HNext { # same as Next but obey $showHidden
  my ($node,$top) = (shift, shift);
  $node=Next($node,$top);
  while ($node) {
    return $node if (isShown($node));
    $node=Next($node,$top);
  }
  return 0;
}


sub getNodes {
# prepare value line and @nodes list with deleted/saved hidden
# and ordered by real Ord

  my ($grp)=@_;
  my @unsorted=();
  $treeNo=0 if ($treeNo<0);
  $treeNo=$#trees if ($treeNo>$#trees);
  @nodes=();
  my @sent=();
  $root=$trees[$treeNo];
  my $node=$root;
  my $current=$root;

  $valueLine="";

  while ($node) {
    push @sent,$node;
    $node=Next($node);
  }
  my $defs = join ",", values %attribs;

  # this is a workaround for TR vs. ATS (ATS trees use only @N to sort
  # @V to a sentence while on TR there is @W defined for this purpose)

  if ($defs=~/W/) {
    @sent = sort { SentOrd($a,\%attribs) <=> SentOrd($b,\%attribs) } @sent;
  } else {
    @sent = sort { Ord($a,\%attribs) <=> Ord($b,\%attribs) } @sent;
  }
  $valueLine = encode(join(" ", map { Value($_,\%attribs) } @sent));

  $node=$root;
  loop: while($node)
  {
    #skip hidden subtrees
    if (not $showHidden and
	defined(Hide($node,\%attribs)) and
	(Hide($node,\%attribs) eq 'hide')) {
      while ($node) {
	if (RBrother($node)) {
	  $node=RBrother($node);
	  next loop;
	}
	$node = Parent($node);
      }
      next loop;
    }
    push @unsorted, $node;
    $node=Next($node);

    $current=$node if (exists $grp->{'currentNode'} and
		       $grp->{'currentNode'} eq $node);
  }
  $grp->{'currentNode'}=$current;
  @nodes=sort { Ord($a,\%attribs) <=> Ord($b,\%attribs)} @unsorted;

  # jus for sure
  undef @sent;
  undef @unsorted;

  # this is actually a workaround for TR, where two different nodes
  # may have the same Ord
}

sub printDialog {
  my $grp=shift;

  return unless $grp->{currentFile};

  my $com=$grp->{'printCommand'};
  my $fil=$grp->{'printPsFile'};
  my $toFile=$grp->{'printToFile'};
  my $toEPS=$grp->{'printToEPS'};
  my $useType1Font=$grp->{'printUseType1Font'};
  my $printRange=$grp->{'printRange'};

  my $d = $grp->{'top'}->DialogBox(-title => "Print current tree",
				-buttons => ["OK", "Cancel"]);
  $d->resizable(0,0);
  addBindTags($d,'dialog');
  $d->bind('all','<Tab>',[sub { shift->focusNext; }]);
  $d->bind('all','<Shift-Tab>',[sub { shift->focusPrev; }]);
  my $cf = $d->Frame();
  my $cl = $cf->Label(-text => 'Print command:',
		     -anchor => 'w',
		     -justify => 'right')->pack(-side => 'left');

  my $ce = $cf->Entry(-relief => 'sunken',
		     -width => 20,
		     -font => $font,
		     -state => $toFile ? 'disabled' : 'normal',
		     -textvariable => \$com)->pack(-side => 'left');

  $cf->pack(-pady => '5m', -side=>'top');
  my $ff=$d->Frame();
  my $fl = $ff->Label(-text => 'File name:',
		     -anchor => 'w',
		     -justify => 'right')->pack(-side => 'left');

  my $fe = $ff->Entry(-relief => 'sunken',
		     -width => 20,
		     -state => $toFile ? 'normal' : 'disabled' ,
		     -font => $font,
		     -textvariable => \$fil)->pack(-side => 'left');

  my $of=$d->Frame();
  my $bf=$of->Frame();
  $bf->Checkbutton(-text     => 'Print to file',
		   -variable => \$toFile,
		   -command  => [sub {
				  my ($t,$c,$f)=@_;
				  if ($$t) {
				    $f->focus;
				    $c->configure(-state => 'disabled');
				    $f->configure(-state => 'normal');
				  } else {
				    $c->focus;
				    $f->configure(-state => 'disabled');
				    $c->configure(-state => 'normal');
				  }
				},\$toFile,$ce,$fe ],
		   -relief   => 'flat')->pack(-fill => 'y',-anchor => 'nw');

  $bf->Checkbutton(-text     => 'Create EPS',
			  -variable => \$toEPS,
			  -relief   => 'flat')->pack(-fill => 'y',-anchor => 'nw');

  $bf->Checkbutton(-text     => 'Use Type1 Postscript Font',
			  -state => $type1font ? 'normal' : 'disabled' ,
			  -variable => \$useType1Font,
			  -relief   => 'flat')->pack(-fill => 'y',-anchor => 'nw');

  $bf->Checkbutton(-text => 'Use colors',
		   -variable => \$printColors,
		   -relief   => 'flat')->pack(-fill => 'y',-anchor => 'nw');
  

  $bf->pack(-side => 'right');
  $of->pack(-fill => 'x',-padx=>'1c');
  my $sf = $d->Frame();
  $sf->Label(-text => 'Page range:',
	     -anchor => 'w',
	     -justify => 'right')->pack(-side => 'left');
  $sf->Entry(-relief => 'sunken',
	     -width => 20,
	     -font => $font,
	     -textvariable => \$printRange)->pack(-side => 'left', -padx=>'2m');
  $sf->pack(-side => 'bottom', -pady => '5m');
  $ff->pack(-side => 'bottom', -pady => '5m');

#  $toFile ? $fe->focus : $ce->focus;
  my $result = ShowDialog($d,$toFile ? $fe : $ce);
  $grp->{'printRange'}=$printRange;
#  $grp->{'printSelection'}= join(' ',grep { $lt->selectionIncludes($_) } (0 .. $lt->size-1));
  $grp->{'printToFile'}=$toFile;
  $grp->{'printToEPS'}=$toEPS;
  $grp->{'printPsFile'}=$fil;
  $grp->{'printCommand'}=$com;
  $grp->{'printUseType1Font'}=$useType1Font;
  undef $d;
  return ($result =~ /OK/);
}

sub printThis {
  my ($grp)=@_;
  my $i;
  my $c=$grp->{'canvas'};
  my $saveTreeNo=$treeNo;
  my $savefont=$font;
  my $pagewidth;
  my $pageheight;
  my $printMultiple;
  my @printList=();
  my %pso;

  if (not printDialog($grp)) {
    #print "Printing aborted!\n";
    return;
  }

  $backgroundColor=$grp->{canvas}->cget('-background');
  {
    local $outputenc='iso-88859-2';
    local ($lineColor, $nodeColor, $currentBoxColor, $boxColor, 
	   $currentNodeColor, $nearestNodeColor, 
	   $textColor , $textColorShadow, $textColorHilite, 
	   $textColorXHilite, $activeTextColor)=
	     ($lineColor, $nodeColor, $currentBoxColor, $boxColor, 
	      $currentNodeColor, $nearestNodeColor, 
	      $textColor , $textColorShadow, $textColorHilite, 
	      $textColorXHilite, $activeTextColor);

    unless ($printColors) {
      $lineColor='black';
      $nodeColor='white';
      $currentBoxColor='white';
      $boxColor='white';
      $currentNodeColor = 'white';
      $nearestNodeColor= 'white';
      $textColor = 'black';
      $textColorShadow = 'black';
      $textColorHilite = 'black';
      $textColorXHilite = 'black';
      $activeTextColor='black';
    }

    local $backgroundColor='white';
    local $lineWidth=1;
    local $font=$savefont;

    my $pbeg;
    my $pend;
    foreach (split /,/,$grp->{'printRange'}) {
      print "Parsing $_\n";
      if (/^\s*([0-9]+)\s*$/ and $1<=$#trees) {
	print "Prepairing $1\n";
	push @printList,$1;
	next;
      }
      if (/^\s*([0-9]*)\s*-\s*([0-9]*)\s*$/) {
	print "Prepairing $1-$2\n";
	($pbeg,$pend)=($1,$2);
	$pend=$#trees if ($pend eq '');
	$pbeg=0 if ($pbeg eq '');
	$pend=min($#trees,$pend);
	next unless ($pbeg<=$pend);
	push @printList,$pbeg..$pend;
      }
    }
    #  @printList=split ' ',$grp->{'printSelection'};
    push @printList,$treeNo+1 unless (@printList);

    unless (open(F,"<$psFontFile")) {
      print STDERR "Aborting: failed to open font file $psFontFile\n";
      return 0;
    }
    if ($grp->{'printToFile'}) {
      #print "Trying to print to ",$grp->{'printPsFile'},"\n";
      return 0 unless open(O,">".$grp->{'printPsFile'});
      #print "File successfully opend!\n";
    } else {
      #print "Trying to print via command ",$grp->{'printCommand'},"\n";
      $SIG{'PIPE'} = sub {};
      return 0 unless open(O, "| ".$grp->{'printCommand'});
      #print "Pipe successfully opend!\n";
    }

    $grp->{top}->Busy(-recurse => 1);

    for (my $t=0;$t<=$#printList;$t++) {
      print "Printing $printList[$t]\n";
      $font=$type1font if ($grp->{printUseType1Font});
      $printList[$t]!=$treeNo+1 ? gotoTree($printList[$t]-1,$grp) : redraw_tree($grp);
      my $rotate =  !$grp->{printToEPS} and ($grp->{canvasHeight}<$grp->{canvasWidth});
      print $grp->{canvasHeight},"x",$grp->{canvasWidth}," $rotate\n";
      if (not $rotate) {
	$pagewidth=$c->fpixels($prtFmtWidth)-2*$c->fpixels($prtHMargin);
	$pageheight=$c->fpixels($prtFmtHeight)-2*$c->fpixels($prtVMargin);
      } else {
	$pagewidth=$c->fpixels($prtFmtHeight)-2*$c->fpixels($prtVMargin);
	$pageheight=$c->fpixels($prtFmtWidth)-2*$c->fpixels($prtHMargin);
      }

      %pso = (-colormode => $printColors ? 'color' : 'gray',
	      -x => 0, -y => 0,
	      -fontmap => { $font => [$psFontName, $psFontSize] },
	      -width => $grp->{canvasWidth},
	      -height => $grp->{canvasHeight},
	      -rotate => $rotate);

      unless ($grp->{printToEPS}) {
	#print "Maximizing: $maximizePrintSize\n";
	if ($maximizePrintSize or $c->fpixels($grp->{canvasWidth})>$pagewidth or
	    $c->fpixels($grp->{canvasHeight})>$pageheight) {
	  print "Adjusting print size\n";
	  if ($c->fpixels($grp->{canvasWidth})/$pagewidth*$pageheight>$c->fpixels($grp->{canvasHeight})) {
	    #print "Applying width\n";
	    $pso{-pagewidth} =
	      $pagewidth;
	    print "Scaling by tree width,\n";
	    print "forcing box width to $pagewidth\n";
	    #$c->fpixels($prtFmtWidth)-2*$c->fpixels($prtHMargin);
	  } else {
	    #print "Applying height\n";
	    $pso{-pageheight} =
	      $pageheight;
	    print "Scaling by tree height,\n";
	    print "forcing box height to $pageheight\n";
	    #$c->fpixels($prtFmtHeight)-2*$c->fpixels($prtVMargin);
	  }
	}
      }

#    $grp->{top}->Busy(-recurse => 1);

      my @ps = split /\n/,$c->postscript(%pso);
      $i=0;
      if ($t>0) {
	$i++  while ($i<=$#ps and $ps[$i]!~/^%%Page:/);
	print O '%%Page: ',$t+1," ",$t+1,"\n";
	my $now=localtime;
	unless ($grp->{printToEPS}) {
	  print O "gsave\n",
	    "/Arial-Medium findfont 8 scalefont setfont\n",
	      "0.000 0.000 0.000 setrgbcolor AdjustColor\n",
		"40 40 [\n",
		  "(File ",$grp->{currentFile},".    Printed by Tred on $now.)\n",
		    "] 13 -0 0 0 false DrawText\ngrestore\n";
	}
	$i++;
      } else {
	$i=0;
	print "Lines:",$#ps,"\n";
	unless ($grp->{printToEPS}) {
	  print O $ps[$i++],"\n" while ($i<=$#ps and $ps[$i]!~/^%%BoundingBox:/);
	  #	print "Bounding Box:\n";
	  #	print $ps[$i],"\n";
	  print O $ps[$i++],"\n";
	  print O $psMedia,"\n";
	  print O '%%Pages: ',$#printList+1,"\n";
	  $i++;
	}
	print O $ps[$i++],"\n" while ($i<=$#ps and $ps[$i] !~ /^%%DocumentNeededResources: font Arial-Medium/);
	print O $ps[$i++],"\n" while ($i<=$#ps and $ps[$i]!~/^%%BeginProlog/);
	print O $ps[$i++],"\n";
	print O '%%beginFont arialm',"\n";
	print O <F>;
	print O '%%EndFont',"\n\n";
	$i++ while ($i<=$#ps and $ps[$i]!~/% StrokeClip/);
	print O $ps[$i++],"\n" while ($i<=$#ps and $ps[$i]!~/^%%IncludeResource: font Arial-Medium/);
	$i++;
      }

      # replacing ISOEncode
      while ($i<=$#ps && $ps[$i]!~/^%%Trailer\w*$/) {
	$ps[$i]=~s/ISOEncode //g;
	print O $ps[$i++],"\n";
      }
    }
    print O '%%EOF',"\n";
    #print "$i: Done.\n";
    close (F);
    close (O);

    #print "$psFile written!\n";
  }

  if ($treeNo eq $saveTreeNo) { redraw_tree($grp); }
  else { gotoTree($saveTreeNo,$grp); }
  $grp->{top}->Unbusy();

  return 1;
}

sub gotoTree {
  my $no = max(0,min(shift,$#trees));
  return $no if ($no == $treeNo);
  my ($grp)=@_;
  @nodes=();
  $treeNo=$no;
  getNodes($grp);
  redraw_tree($grp);
  return $no;
}

sub nextTree {
  return 0 if ($treeNo >= $#trees);
  my ($grp)=@_;
  @nodes=();
  $treeNo++;
  getNodes($grp);
  redraw_tree($grp);
  return 1;
}

sub prevTree {
  return 0 if ($treeNo <= 0);
  my ($grp)=@_;
  @nodes=();
  $treeNo--;
  getNodes($grp);
  redraw_tree($grp);
  return 1;
}

sub newTree {
  my ($grp)=@_;
  my $nr={};
  NewNode($nr); # blessing new root

  splice(@trees, $treeNo, 0, $nr);

  @nodes=();
  getNodes($grp);
  redraw_tree($grp);
  return 1;
}

sub newTreeAfter {
  my ($grp)=@_;
  my $nr={};
  NewNode($nr); # blessing new root

  splice(@trees, ++$treeNo, 0, $nr);

  @nodes=();
  getNodes($grp);
  redraw_tree($grp);
  return 1;
}

sub pruneTree {
  my ($grp)=@_;

  return unless $trees[$treeNo];
  $root=$trees[$treeNo];
  splice(@trees, $treeNo, 1);
  DeleteTree($root);

  $treeNo=max(0,min($treeNo,$#trees));
  undef $root;
  @nodes=();
  getNodes($grp);
  redraw_tree($grp);
  return 1;
}


sub newNode {
  ## Adds new son to current node
  my ($grp)=@_;
  my $parent=$grp->{currentNode};
  return unless $parent;
  my $nd={};
  NewNode($nd);            # initializing new node
  Paste($nd,$parent,\%attribs);
  $node->{AOrd(\%attribs)}=Ord($parent,\%attribs);
  setCurrent($grp,$nd);

  getNodes($grp);
  redraw_tree($grp);

  return $nd;
}


sub addBindTags {
  my $w=shift @_;
  $w->bindtags([@_,$w,ref($w),$w->toplevel,'all']);

}

sub startMain {
  my $firstFile=shift;
  my $node;
  my $parent;
  my %group;

  $group{top}=MainWindow->new;

  print STDERR "Main window created.\n";

  if (-f $appIcon) {
    print STDERR "adding icon-image.\n";
    $group{top}->iconimage($group{top}->Pixmap(-file => "$appIcon"));
    print STDERR "done.\n";
  }

  addBindTags($group{'top'},'my');

  print STDERR "Asking wm for exit-hook.\n";

  $group{top}->protocol('WM_DELETE_WINDOW' => [sub { $grp=shift;
						       askSaveFile($grp);
						       $grp->{'top'}->destroy; },\%group]);


  print STDERR "Exit hook created.\n";

  $group{Balloon}=$group{'top'}->Balloon(-initwait => 450, -balloonposition => 'mouse',
					-state => 'balloon', -background => '#fff3b0');
  $group{'frame'}=$group{'top'}->Frame;



  print STDERR "Creating menubar.\n";


  $group{Menubar}=$group{top}->Frame(-relief => $menubarRelief, -borderwidth => 2);
  $group{Menubar}->pack(qw/-fill x/);
  addBindTags($group{Menubar},'my');

  $group{FileMenu} = $group{Menubar}->Menubutton(qw/-text File -underline 0 -menuitems/ =>
	[
	 [Button => 'Open ...',    -command => [\&fileDialog, \%group]],
#	 [Button => 'New',         -command => [\&menus_error2, 'New']],
	 [Button => 'Save',        -command => [\&saveFile,\%group]],
	 [Button => 'Save As ...', -command => [\&saveFileAs, \%group]],
	 [Separator => ''],
#	 [Button => 'Setup ...',   -command => [\&menus_error2, 'Setup']],
	 [Button => 'Print ...',   -command => [\&printThis,\%group]],
	 [Separator => ''],
	 [Button => 'Edit config file ...',   -command => [\&editConfig,\%group]],
	 [Button => 'Reload config ...',   -command => [sub {
							  readConfig();
							  redraw_tree(shift);
							},\%group]],
	 [Separator => ''],
	 [Button => 'Quit',        -command => [$group{top} => 'destroy']],
	])->pack(qw/-side left/);

  $group{ViewMenu}= $group{Menubar}->Menubutton(qw/-text View -underline 0 -menuitems/ =>
	[
	 [Button => 'Previous File', -command => [\&prevFile,\%group]],
	 [Button => 'Next File', -command => [\&nextFile,\%group]],
	 [Separator => ''],
	 [Checkbutton => 'Draw boxes',
	   -variable => \$drawBoxes,
	   -command  => [\&redraw_tree,\%group]],
	 [Checkbutton => 'Show Hidden',
	  -variable => \$showHidden,
	  -command  => [sub { getNodes(@_);
			      currentUnhiden(@_);
			      redraw_tree(@_) },\%group]],
	 [Checkbutton => 'Highlight Attributes',
	  -variable => \$highlightAttributes,
	  -command  => [\&redraw_tree,\%group]],
	 [Separator => ''],
	 [Button => 'Visible Attributes', -command => [\&selectAttrs,\%group]]
	])->pack(qw/-side left/);
  $group{NodeMenu}= $group{Menubar}->Menubutton(qw/-text Node -underline 0 -menuitems/ =>
	[
	 [Button => 'New Node', -command => [sub {
					       my ($grp)=@_;
					       newNode($grp);
					     },\%group]],
	 [Button => 'Insert New Tree', -command => [sub {
						      my ($grp)=@_;
						      newTree($grp);
						    },\%group]],
	 [Button => 'Insert New Tree After', -command => [sub {
						      my ($grp)=@_;
						      newTreeAfter($grp);
						    },\%group]],
	 [Button => 'Prune Current Tree', -command => [sub {
						      my ($grp)=@_;
						      pruneTree($grp);
						    },\%group]],
	 [Button => 'Edit Attributes', -command => [sub {
						      my ($grp)=@_;
						      editAttrsDialog($grp,$grp->{currentNode})
							if ($grp->{currentNode});
						    },\%group]],
	 [Separator => ''],
	 [Button => 'Find...', -command => [sub {
					      my ($grp,$template)=@_;
					      findNodeDialog($grp,$template)
						if ($grp->{currentNode});
					    },\%group,\%searchTemplate]],
	 [Button => 'Find Next...', 
	  -command => [sub {
			 my ($grp,$template)=@_;
			 findFirstTemplated($grp,$template,1)
			   if ($grp->{currentNode});
		       },\%group,\%searchTemplate]],
	])->pack(qw/-side left/);

  print STDERR "Creating user menubar.\n";

  my @umenus = map (
		    [Button => $_,
		   -command => [\&doEvalMacro,\%group,$menuBindings{$_}->[0]],
		     ($menuBindings{$_}->[1]) ?
		     (-accelerator => "(".$menuBindings{$_}->[1].")") : ()],
		    sort(keys(%menuBindings)));
  my $uM,$uuM;
  $uM=[ @umenus[0..min($maxMenuLines-1,$#umenus)] ];
  $uuM=$uM;
  my $i=$maxMenuLines;
  while ($i<=$#umenus) {
    $_=[@umenus[$i..min($i+$maxMenuLines-1,$#umenus)]];
    push @$uuM,[Cascade => 'More...', -menuitems => $_];
    $uuM=$_;
    $i+=$maxMenuLines;
  }


  $group{UserMenu}=$group{Menubar}->Menubutton(qw/-text User-defined -underline 0 -menuitems/ =>
					       $uM)->pack(qw/-side left/);
  $group{MacroMenu}=$group{Menubar}->Menubutton(qw/-text Key-Macros -underline 0 -menuitems/ =>
					       [ map ([Button => $keyBindings{$_}, -accelerator => "($_)",
						       -command => [\&doEvalMacro,\%group,$keyBindings{$_}]],
						 keys(%keyBindings))
					       ])->pack(qw/-side left/) if ($createMacroMenu);

  addBindTags($group{'frame'},'my');
  my $canvas = $group{'top'}->Scrolled(qw/Canvas -width 20c -height 20c -relief sunken
			   -borderwidth 2 -scrollbars se -scrollregion/ =>
				       [qw/0c 0c 100c 100c/],
				       $backgroundColor ? (-background => $backgroundColor) : ());

  print STDERR "Preparing fonts.\n";

  if ($font!~/^-/) {
    my @a=split(/\s*,\s*/,$font);
    my $option,$value;
    my @b;
    foreach (@a) {
      ($option, $value) = split(/\s*:\s*/, $_, 2);
      push @b, "-".$option, $value if ($option=~/^(?:size|weight|family|slant|underline|overstrike)$/);
    }
    $group{top}->fontCreate('C_normal',@b);
    $font='C_normal';
  } else {
    $group{top}->fontCreate('C_normal',$group{top}->fontActual($font));
    $font='C_normal';
  }


    print STDERR "Creating canvas.\n";

  $group{'valueLine'}=$group{'top'}->Scrolled(qw/Entry -state disabled -relief sunken
			   -borderwidth 2 -scrollbars s/, -font => $font,-textvariable => \$valueLine);
  $group{'canvas'}=$canvas;
  addBindTags($canvas,'my');

  print STDERR "Creating buttons.\n";

  $group{'nextButton'}=$group{'frame'}->Button(-text => "Next",
					       -relief => $buttonsRelief,
					       -image => $group{top}->Pixmap(-file =>
									     "$libDir/right.xpm"),
					       -borderwidth => $buttonBorderWidth,

			    -command => [sub { nextTree(@_) },\%group]);
  $group{Balloon}->attach($group{'nextButton'},
		 -balloonmsg => "see the next tree");
  addBindTags($group{'nextButton'},'my');
  $group{'prevButton'}=$group{'frame'}->Button(-text => "Prev",
					       -relief => $buttonsRelief,
					       -image => $group{top}->Pixmap(-file =>
									     "$libDir/left.xpm"),
					       -borderwidth => $buttonBorderWidth,
					       -command => [sub { prevTree(@_) },\%group]);
  $group{Balloon}->attach($group{prevButton},
		 -balloonmsg => "see the previous tree");
  addBindTags($group{'prevButton'},'my');
  $group{'attrDialog'}=undef;

  $group{'openButton'}=$group{'frame'}->Button(-text => "Open",
					       -relief => $buttonsRelief,
					       -image       => $group{top}->Pixmap(-file => "$libDir/fileopen.xpm"),
					       -borderwidth => $buttonBorderWidth,
			 -command => [sub { fileDialog(@_) },\%group])->pack(-side=>'left',-padx=>'1');
  $group{Balloon}->attach($group{openButton},
		 -balloonmsg => "open file");
  addBindTags($group{'openButton'},'my');
  $group{'saveButton'}=
    $group{'frame'}->Button(-text => "Save",
			    -relief => $buttonsRelief,
			    -image => $group{top}->Pixmap(-file =>
							  "$libDir/filefloppy.xpm"),
			    -borderwidth => $buttonBorderWidth,
			    -command => [sub {
					   saveFile(@_)
					 },\%group])->pack(-side=>'left',-padx=>'1');

  $group{Balloon}->attach($group{saveButton},
			  -balloonmsg => "save current file");
  addBindTags($group{'saveButton'},'my');
  $group{'printButton'}=
    $group{'frame'}->Button(-text => "Print",
			    -relief => $buttonsRelief,
			    -image       => $group{top}->Pixmap(-file =>
								"$libDir/fileprint.xpm"),
			    -borderwidth => $buttonBorderWidth,
			    -command => [sub { printThis(@_) },\%group])->pack(-side=>'left',
									       -padx=>'1');
  $group{Balloon}->attach($group{printButton},
		 -balloonmsg => "print ...");
  addBindTags($group{'printButton'},'my');

  $group{'findButton'}=
    $group{'frame'}->Button(-text => "Find",
			    -relief => $buttonsRelief,
			    -image       => $group{top}->Pixmap(-file =>
								"$libDir/find.xpm"),
			    -borderwidth => $buttonBorderWidth,
			    -command => [sub {
					   my ($grp,$template)=@_;
					   findNodeDialog($grp,$template)
					     if ($grp->{currentNode});
					 },\%group,\%searchTemplate])->pack(-side=>'left',
									    -padx=>'1');
  $group{Balloon}->attach($group{findButton},
		 -balloonmsg => "Find node ...");
  addBindTags($group{'findButton'},'my');

  $group{'findNextButton'}=
    $group{'frame'}->Button(-text => "Find Next",
			    -relief => $buttonsRelief,
			    -image       => $group{top}->Pixmap(-file =>
								"$libDir/findnext.xpm"),
			    -borderwidth => $buttonBorderWidth,
			    -command => [sub {
					   my ($grp,$template)=@_;
					   findFirstTemplated($grp,$template,1)
					     if ($grp->{currentNode});
					 },\%group,\%searchTemplate])->pack(-side=>'left',
									       -padx=>'1');
  $group{Balloon}->attach($group{findNextButton},
		 -balloonmsg => "Find next ...");
  addBindTags($group{'findNextButton'},'my');


  $group{'prevFileButton'}=
    $group{'frame'}->Button(-text => "Prev file",
			    -relief => $buttonsRelief,
			    -image => $group{top}->Pixmap(-file =>
							  "$libDir/start.xpm"),
			    -borderwidth => $buttonBorderWidth,
			    -command => [sub { prevFile(@_); },\%group])->pack(-side=>'left',
									       -padx=>'1');
  $group{Balloon}->attach($group{prevFileButton},
			  -balloonmsg => "visit the previous open file");
  addBindTags($group{'prevFileButton'},'my');

  $group{'nextFileButton'}=
    $group{'frame'}->Button(-text => "Next file",
			    -relief => $buttonsRelief,
			    -image => $group{top}->Pixmap(-file =>
							  "$libDir/finish.xpm"),
			    -borderwidth => $buttonBorderWidth,
			    -command => [sub { nextFile(@_); },\%group])->pack(-side=>'left',
									       -padx=>'1');
  $group{Balloon}->attach($group{nextFileButton},
		 -balloonmsg => "visit the next open file");
  addBindTags($group{'nextFileButton'},'my');



  $group{'attrButton'}=
    $group{'frame'}->Button(-text => "Attributes",
			    -relief => $buttonsRelief,
			    -image => $group{top}->Pixmap(-file =>
							  "$libDir/tick.xpm"),
			    -borderwidth => $buttonBorderWidth,
			    -command => [sub { selectAttrs(@_) },\%group])->pack(-side=>'right',
										 -padx=>'1');
  $group{Balloon}->attach($group{attrButton},
		 -balloonmsg => "select visible attributes");
  $group{'nextButton'}->pack(-side => 'right', -padx => '1');
  $group{'prevButton'}->pack(-side => 'right', -padx =>'1');

  print STDERR "Packing widgets.\n";


  $group{'frame'}->pack(-fill => 'x', -padx => '1', -pady => 1);
  $group{'valueLine'}->pack(qw/-fill x/);
  $group{'canvas'}->pack(qw/-expand yes -fill both/);
  addBindTags($group{'canvas'},'my');

  $group{'canvas'}->focus;

  $group{'printToFile'}=0;
  $group{'printCommand'}='lpr';
  $group{'printPsFile'}=$psFile;

  print STDERR "GUI prepared.\nOpenning first file ....";

  if ($firstFile) {
    openFile($firstFile,\%group);
  }
  
  print STDERR "done.\nStarting main loop.\n";

  MainLoop;
    
}


# This patches $dialog->Show which implicitly focuses the default button;
# here focus stays where it is.
# Usage: my $dlg=DialogBox(); ...; ShowDialog($dlg);
sub ShowDialog {
  my ($cw, $focus) = @_;

  my $oldFocus = $cw->focusCurrent;
  my $oldGrab = $cw->grabCurrent;
  my $grabStatus = $oldGrab->grabStatus if ($oldGrab);

  $cw->grab;
  $focus->focus if ($focus);

  $cw->Popup();

  $cw->Wait;

  eval {
    $oldFocus->focus if $oldFocus;
  };
  $cw->grabRelease;
  $cw->withdraw;
  if ($oldGrab) {
    if ($grabStatus eq 'global') {
      $oldGrab->grabGlobal;
    } else {
      $oldGrab->grab;
    }
  }

  return $cw->{'selected_button'};
}

sub fileDialog {
  my $grp = shift;
  my $types;
  my $file;

#  use Tk::FileSelect;
#  my $FSref = $grp->{top}->FileSelect(-selectmode => extended);
#  print $FSref->Show;
  @types =
    (["Fs files",           [qw/.fs .FS .Fs/]],
     ["CSTS files",           [qw/.am .cst .csts/]],
     ["Backup Fs files",           [qw/.fs~ .fb .FB .Fb/]],     
     ["All files",        '*']
    );
  $file = $grp->{'top'}->getOpenFile(-filetypes => \@types);
  if (defined $file and $file ne '') {
    return openFile($file,$grp);
  }
  return 0;
}

sub saveFileAs {
  my $grp = shift;
  my $types;
  my $file=$grp->{currentFile};

  @types =
    (["Fs files",           [qw/.fs .FS .Fs/]],
     ["All files",        '*']
    );

  $file = $grp->{'top'}->getSaveFile(-filetypes => \@types, -initialfile => $file);
  if (defined $file and $file ne '') {
    $grp->{currentFile}=$file;
    $grp->{'top'}->title("$appName $file");
    return saveFile($grp);
  }
  return 0;
}

sub askSaveFile {
  my ($grp)=@_;
  return unless $FileNotSaved;
  saveFile($grp)
   if (
       $grp->{'top'}->toplevel->
       messageBox(-icon => 'questhead',
		  -message => "File may be changed!\nDo you want to save it?",
		  -title => 'File not saved',
		  -type => 'YesNo',
		  -default => 'Yes') eq 'Yes');
}

sub editConfig {
  my $grp=shift;
  my $d = $grp->{'top'}->DialogBox(-title => "Edit Resource File ($configFile)" , -width => "10c",
				   -buttons => ["Save and Apply"]);
  $d->resizable(0,0);
  $d->bind('<Return>' => [sub {1;}]);
  my $t = $d->
    Scrolled(qw/Text -relief sunken -borderwidth 2 -setgrid true
		     -height 30 -scrollbars e/);
  $t->pack(qw/-expand yes -fill both/);
  my $b = $d->Subwidget('bottom')->Button(-text => "Apply",
		     -command => [sub {
				    applyConfig(split(/\n/,shift->get("0.0","end")));
				    redraw_tree(shift);
				  },$t,$grp]);
  $b->pack(-side => 'left', -expand => 1,  -padx => 1, -pady => 1);
  $b = $d->Subwidget('bottom')->
    Button(-text => "Cancel",
	   -command => sub { $d->{'selected_button'} = "Cancel" } );
  $b->pack(-side => 'left', -expand => 1,  -padx => 1, -pady => 1);
  if (open(F,"<$configFile")) {
    $t->insert('0.0',join "",<F>);
    close(F);
  }
  $t->mark(qw/set insert 0.0/);
  my $result=ShowDialog($d);
  if ($result eq 'Save and Apply') {
    if (open(F,">$configFile")) {
      print F $t->get("0.0","end");
      close(F);
    } else {
      my $lasterr=$!;
      my ($dc,$ic)=stat($configFile);
      my ($dh,$ih)=stat(<'~/.tredrc'>);
      if ($configFile ne <'~/.tredrc'> and ($dc != $dh or $ic != $ih) and
	     $grp->{'top'}->toplevel->
	       messageBox(-icon => 'warning',
			  -message => "Cannot write configuration to $configFile\n($lasterr)\n\n".
			  "Shell I try to save it to ~/.tredrc?\n",
			  -title => 'Configuration cannot be saved',
			  -type => 'YesNo',
			  -default => 'Yes') eq 'Yes') {
	if (open(F,">".<'~/.tredrc'>)) {
	  print F $t->get("0.0","end");
	  close(F);
	} else {
	  $grp->{'top'}->toplevel->
	    messageBox(-icon => 'error',
		       -message => 'Cannot write to "'.<'~/.tredrc'>.'"!'."\n($!)\n".
		       "\nConfiguration could not be saved!\n",
		       -title => 'Configuration cannot be saved',
		       -type => 'Ok',
		       -default => 'Ok');
	}
      } else {
      	$grp->{'top'}->toplevel->
	  messageBox(-icon => 'error',
		     -message => "Cannot write to \"$configFile\"!"."\n($lasterr)\n".
		     "\nConfiguration could not be saved!",
		     -title => 'Configuration cannot be saved',
		     -type => 'Ok',
		     -default => 'Ok');
      }
    }
    applyConfig(split(/\n/,$t->get("0.0","end")));
    redraw_tree($grp);
  }
  undef $d;
}


sub selectAttrs {
  my ($grp)=@_;
  my %datr;
  my $a;
  my $d;
  my %e=();
  my @r=();
  my $rows=min(10,$#atord+1);
  return unless $grp->{currentFile};
  $grp->{'top'}->Busy(-recurse => 1);
  foreach $a (@atord) {
    $datr{$a} = grep {$a eq $_} @displayAttrs;
  }
  $d = $grp->{'top'}->DialogBox(-title => "Select", -width => "10c",
			     -buttons => ["OK", "Cancel"]);
  $d->resizable(0,0);
  my $f = $d->Scrolled('Tiler',
		       -columns =>1,
		       -rows =>$rows,
		       -relief => 'groove',
		       -borderwidth => 0,
		       -highlightthickness =>0,
		       -scrollbars => 'e');
  $f->bind($f,'<Tab>',
	   [sub {
	      if ($e{$atord[0]}) {
		$e{$atord[0]}->focus;
		$f->moveto(0);
	      } else {
		shift->focusNext;
	      }
	      Tk->break;
	    }]);
  foreach (@atord) {
    $e{$_}=$f->Checkbutton(-text     => $_."              ",
			   -command  => [
					 sub {
					   my $da=shift;
					   my $ka=shift;
					   $$da{$ka}=!$$da{$ka}
					 },
						 \%datr,$_],
			   -anchor => 'nw',
			   -justify => 'left',
			   -relief   => 'flat')->pack();
    $e{$_}->bind($e{$_},'<Tab>',[sub {
				   my ($w,$t)=@_;
				   my $i=0;
				   $i++ while ($i<=$#atord and $atord[$i] ne $t);
				   if ($i+1>$#atord) {
				     $w->focusNext;
				   } else {
				     $f->scroll(1,'pages')
				       if (($i+1)/$f->cget('-columns')>=
					   ($f->{SubWidget}{tiler}{Start}+$f->cget('-rows')));
				     $e{$atord[$i+1]}->focus;
				     # D'ya like dirty tricks ? :)
				   }
				   Tk->break;
				 },$_]);
    push @r, $e{$_};
    $e{$_}->select if ($datr{$_});
  }
  $f->Manage(@r);
  $f->pack();
  $grp->{'top'}->Unbusy();
#  $e{$atord[0]}->focus if $atord[0];
  my $result = ShowDialog($d, ($atord[0]) ? $e{$atord[0]}->focus : undef);
#  $grp->{'top'}->Busy(-recurse => 1);
  if ($result =~ /OK/) {
    @displayAttrs = grep { $datr{$_} } @atord;
    redraw_tree($grp);
  }
  $d=undef;
#  $grp->{'top'}->Unbusy();
}

sub QueryString {
  my $newvalue;
  my ($grp, $title, $label)=@_;

  my $d=$grp->{'top'}->DialogBox(-title => $title,
				 -buttons => ["OK", "Cancel"]);
  addBindTags($d,'dialog');
  my $e=$d->add(Entry,-relief => 'sunken',
		    -width => 40,
		    -takefocus => 1,
		    -font => $font,
		    -textvariable => \$newvalue);
  my $l = $d->Label(-text => encode($label),
		    -anchor => 'e',
		    -justify => 'right');
  $l->pack(-side=>'left');
  $e->pack(-side=>'right');
  $d->resizable(0,0);
#  $e->focus;
  my $result = ShowDialog($d,$e);
  if ($result =~ /OK/) {
    return decode($newvalue);
  } else {
    return undef;
  }
}


sub selectValuesDialog {
 my ($grp, $vals, $selected, $may_add)=@_;
 my $a;
 my $multi=0;

 $grp->{'top'}->Busy(-recurse => 1);
 my $d=$grp->{'top'}->DialogBox(-title => "Select Values", -width => '8c',
				-buttons => ["OK", "Cancel"]);
 $d->resizable(0,0);
 my $l=$d->Scrolled(qw/Listbox -relief sunken -takefocus 1/,
		    -font => $font)->pack(qw/-expand yes -fill both/);
 $l->insert('end',@$vals);

 my $act=0;
 for ($a=0;$a<@$vals;$a++)  {
   if (grep { $$vals[$a] eq $_ } @$selected) {
     $l->selectionSet($a);
     if (not $act) {
       $act=1;
       $l->activate($a);
       $l->see($a);
     }
   }
 }
 $d->Checkbutton(-text     => 'multiple select',
		 -variable => \$multi,
		 -command  => [sub {
				 shift->configure(-selectmode => $multi ? 'multiple' : 'single');
				 },$l],
		 -relief   => 'flat')->pack();
 if ($may_add) {
   $d->Button(-text => 'Add',
	      -command => [sub {
			     my ($grp,$l,$vals)=@_;
			     my $val=QueryString($grp,"Add new value","Value");
			     return unless defined $val;
			     push @$vals,$val;
			     $l->insert('end',$val);
			   $l->selectionClear(0,$l->size-1) unless $multi;
			     $l->selectionSet($l->size-1);
			   },$grp,$l,$vals])->pack();
 }
 $grp->{'top'}->Unbusy();
# $l->focus;
 my $result = ShowDialog($d,$l);
 undef $d;
 if ($result =~ /OK/) {
   @$selected = (map { $$vals[$_] } ( grep { $l->selectionIncludes($_) } (0 .. $l->size-1) ));
   return 1;
 }
 return 0;
}

sub editListAttr {
  my ($grp, $value, $attr) =@_;
  my @vals = map { encode($_) } ListValues($attr,\%attribs);
  #print "splitting ",$value{$attr},"\n";
  my @selected = map { encode($_) } split /\|/,$value;
  #print "splitted to ", join ('-',@selected),"\n";

  if (selectValuesDialog($grp,\@vals,\@selected,0)) {
    return decode(join('|',@selected));
  }
  return undef;
}

sub editAmbiguousAttr {
  my ($grp, $value, $attr) =@_;
  my @vals = map { encode($_) }split /\|/,$value;
  my @selected = @vals;
  if (selectValuesDialog($grp,\@vals,\@selected,1)) {
    return decode(join('|',@selected));
  }
  return undef;
}

sub editAttrsDialog {
  my ($grp,$node)=@_;
  my $r;
  my $b;
  my $a;
  my @vals;
  my $rows=min(10,$#atord+1);
  my @r=();
  $grp->{'top'}->Busy(-recurse =>1);
  my $d=$grp->{'top'}->DialogBox(-title => "Edit Node Attributes", -width => '10c',
				 -buttons => ["OK", "Cancel"]);
  $d->resizable(0,0);
  my $f = $d->Scrolled('Tiler',
		       -columns =>2,
		       -rows =>$rows,
		       -relief => 'groove',
		       -scrollbars => 'e');
  sub focusxDn {
    my ($w,$i,$e,$f,$rows,$cnt)=@_;
    if ($i+1>$#atord) {
      $w->focusNext if ($cnt);
    } else {
      $e->{$atord[$i+1]}->focus;
      $f->scroll(1,'pages')
	if ($i+1>=($f->{SubWidget}{tiler}{Start}+$rows));
      # D'ya like dirty tricks ? :)
    }
    Tk->break;
  };
  sub focusxUp {
    my ($w,$i,$e,$f,$cnt)=@_;
    if ($i<=0) {
      $w->focusPrev if ($cnt);
    } else {
      $e->{$atord[$i-1]}->focus;
      $f->scroll(-1,'pages')
	if ($i-1<($f->{SubWidget}{tiler}{Start}));
      # D'ya like dirty tricks ? :)
    }
    Tk->break;
  };

  $f->bind($f,'<Tab>',[sub {
			     if ($e{$atord[0]}) {
			       $e{$atord[0]}->focus;
			       $f->moveto(0);
			     } else {
			       shift->focusNext;
			     }
			     Tk->break;
			   }]);
  for (my $i=0;$i<=$#atord;$i++) {
    $_=$atord[$i];
    # Reliefs: raised, sunken, flat, ridge, and groove.
    push @r,$f->Label(-text => $_, -anchor => 'nw')->pack();

    if  (IsList($_,\%attribs) or
	 $$node{$_}=~/^(?:[^\|\\]|\\.)*\|/) { # readonly entry and buttons for list
      $r = $f->Frame;
      $e{$_} = $r->Entry(-relief => 'sunken', -takefocus => 1,
			 -font => $font)->pack(qw/-expand yes -fill both -side left/);
      $b=$r->Button(-text => "...", -takefocus => 0,
		    -command => [sub {
				my ($e,$grp,$node,$attr)=@_;
				my $result =
				  (IsList($attr,\%attribs)
				   ? editListAttr($grp,$e->get,$attr)
				   : editAmbiguousAttr($grp,$e->get,$attr));
				if (defined $result) {
				  $e->configure(-state => 'normal');
				  $e->delete(0,length($e->get));
				  $e->insert(0,$result);
				  $e->configure(-state => 'disabled');
				}
			      },$e{$_},$grp,$node,$_])->pack(-side => 'right');
      $e{$_}->bind($e{$_},'<Return>',[sub { shift; shift->invoke; Tk->break; },$b]);
      $e{$_}->bind($e{$_},'<Double-ButtonPress-1>',[sub { shift; shift->invoke; Tk->break; },$b]);
      $e{$_}->insert(0,encode($$node{$_}));
      $e{$_}->configure(-state => 'disabled');
      push @r, $r;
    } else {
      $e{$_} = $f->Entry(-relief => 'sunken', -takefocus => 1,
			 -font => $font)->pack(qw/-expand yes -fill both/);
      $e{$_}->insert(0,encode($$node{$_}));
      push @r, $e{$_};
    }

    $e{$_}->bind($e{$_},'<Tab>',[\&focusxDn,$i,\%e,$f,$rows,1]);
    $e{$_}->bind($e{$_},'<Down>',[\&focusxDn,$i,\%e,$f,$rows]);
    $e{$_}->bind($e{$_},'<Shift-Tab>',[\&focusxUp,$i,\%e,$f,1]);
    $e{$_}->bind($e{$_},'<Up>',[\&focusxUp,$i,\%e,$f]);
  }
  $f->Manage(@r);
  $f->pack();
  $grp->{'top'}->Unbusy();
#  $e{$atord[0]}->focus if $atord[0];
  my $result = ShowDialog($d,($atord[0] ? $e{$atord[0]}->focus : undef));
#  $grp->{'top'}->Busy(-recurse =>1);
  if ($result =~ /OK/) {
    $FileNotSaved=1;
    foreach $a (@atord) {
      $$node{$a}=decode($e{$a}->get);
    }
    getNodes($grp);
    redraw_tree($grp);
  }
  $d=undef;
#  $grp->{'top'}->Unbusy();
}

sub findNodeDialog {
  my ($grp,$template)=@_;
  my $r;
  my $b;
  my $a;
  my @vals;
  my $rows=min(10,$#atord+1);
  my @r=();
  $grp->{'top'}->Busy(-recurse =>1);
  my $d=$grp->{'top'}->DialogBox(-title => "Find Node By Attributes", -width => '10c',
				 -buttons => ["Find", "Cancel"]);
  $d->resizable(0,0);
  my $f = $d->Scrolled('Tiler',
		       -columns =>2,
		       -rows =>$rows,
		       -relief => 'groove',
		       -scrollbars => 'e');
  sub focusxDn {
    my ($w,$i,$e,$f,$rows,$cnt)=@_;
    if ($i+1>$#atord) {
      $w->focusNext if ($cnt);
    } else {
      $e->{$atord[$i+1]}->focus;
      $f->scroll(1,'pages')
	if ($i+1>=($f->{SubWidget}{tiler}{Start}+$rows));
      # D'ya like dirty tricks ? :)
    }
    Tk->break;
  }
  ;
  sub focusxUp {
    my ($w,$i,$e,$f,$cnt)=@_;
    if ($i<=0) {
      $w->focusPrev if ($cnt);
    } else {
      $e->{$atord[$i-1]}->focus;
      $f->scroll(-1,'pages')
	if ($i-1<($f->{SubWidget}{tiler}{Start}));
      # D'ya like dirty tricks ? :)
    }
    Tk->break;
  }
  ;

  $f->bind($f,'<Tab>',[	sub {
			  if ($e{$atord[0]}) {
			    $e{$atord[0]}->focus;
			    $f->moveto(0);
			  } else {
			    shift->focusNext;
			  }
			  Tk->break;
			}]);

  for (my $i=0;$i<=$#atord;$i++) {
    $_=$atord[$i];
    # Reliefs: raised, sunken, flat, ridge, and groove.
    push @r,$f->Label(-text => $_, -anchor => 'nw')->pack();

    $e{$_} = $f->Entry(-relief => 'sunken', -takefocus => 1,
		       -font => $font)->pack(qw/-expand yes -fill both/);
    $e{$_}->insert(0,encode($template->{$_}));
    push @r, $e{$_};

    $e{$_}->bind($e{$_},'<Tab>',[\&focusxDn,$i,\%e,$f,$rows,1]);
    $e{$_}->bind($e{$_},'<Down>',[\&focusxDn,$i,\%e,$f,$rows]);
    $e{$_}->bind($e{$_},'<Shift-Tab>',[\&focusxUp,$i,\%e,$f,1]);
    $e{$_}->bind($e{$_},'<Up>',[\&focusxUp,$i,\%e,$f]);
  }
  $f->Manage(@r);
  $f->pack();
  $grp->{'top'}->Unbusy();
  my $result = ShowDialog($d,($atord[0] ? $e{$atord[0]}->focus : undef));
  if ($result =~ /Find/) {
    #    $FileNotSaved=1;
    foreach $a (@atord) {
      $template->{$a}=decode($e{$a}->get);
    }
    $grp->{'top'}->toplevel->
      messageBox(-icon => 'warning',
		 -message => "No matching node found!",
		 -title => 'Find',
		 -type => 'ok')
	unless (findFirstTemplated($grp,$template,0));
    #    getNodes($grp);
    #    redraw_tree($grp);
  }
  $d=undef;
}

sub findFirstTemplated {
  my ($grp,$template,$skipfirst)=@_;
  my $node=$grp->{'currentNode'};
  my $tree=$treeNo;
  my $a;

  $node=(HNext($node) || $trees[(++$tree)]) if ($skipfirst);
  while ($node) {
    unless (grep ((exists($template->{$_}) and
		   $template->{$_} ne '' and
		   $node->{$_} !~ /$template->{$_}/ ), @atord))
      {
	gotoTree($tree, $grp);
	setCurrent($grp, $node);
	centerTo($grp,$node);
	return $node;
      }
    $node=(HNext($node) || $trees[(++$tree)]);
  }
  return undef;
}


sub editAttrs {
  my ($w,$grp)=@_;
  my $node=$grp->{'pinfo'}{$w->find('withtag','current')};
  editAttrsDialog($grp,$node);
}

sub editAttr {
  my ($w,$grp)=@_;
  my $attr;
  my $newvalue;

  my $t=$w->find('withtag','current');
  my $node=$grp->{'pinfo'}{$t};
  my $d;
  $attr= (grep {$$node{$_} eq $t} keys %$node)[0];

  return unless ($attr=~/^_tkText(?:Bg)*(\d+)_$/ or $1>$#displayAttrs);
  $attr=$displayAttrs[$1];

  if (IsList($attr,\%attribs)) {
    $newvalue = editListAttr($grp,$$node{$attr},$attr);
    if (defined $newvalue) {
      $grp->{'top'}->Busy(-recurse => 1);
      $FileNotSaved=1;
      $$node{$attr}=$newvalue;
      getNodes($grp);
      redraw_tree($grp);
      $grp->{'top'}->Unbusy();
    }
    return;
  }

  if ($$node{$attr}=~/^(?:[^\|\\]|\\.)*\|/) {
    $newvalue = editAmbiguousAttr($grp,$$node{$attr},$attr);
    if (defined $newvalue) {
      $grp->{'top'}->Busy(-recurse => 1);
      $FileNotSaved=1;
      $$node{$attr}=$newvalue;
      getNodes($grp);
      redraw_tree($grp);
      $grp->{'top'}->Unbusy();
    }
    return;
  }

  $grp->{'top'}->Busy(-recurse => 1);


  $newvalue=encode($$node{$attr});
  $d = $grp->{'top'}->DialogBox(-title => "Edit Node Attribute",
				-buttons => ["OK", "Cancel"]);
  $d->resizable(0,0);
  addBindTags($d,'dialog');
  my $l = $d->Label(-text => $attr,
		    -anchor => 'e',
		    -justify => 'right')->pack(-side=>'left');
  my $e = $d->Entry(-relief => 'sunken',
		    -width => 40,
		    -takefocus => 1,
		    -font => $font,
		    -textvariable => \$newvalue)->pack();
  $e->icursor('end');
#  $e->focus;
  $grp->{'top'}->Unbusy();
  my $result = ShowDialog($d,$e);
#  $grp->{'top'}->Busy(-recurse => 1);
  if ($result =~ /OK/) {
    $FileNotSaved=1;
    $$node{$attr}=decode($newvalue);
    getNodes($grp);
    redraw_tree($grp);
  }
#  $grp->{'top'}->Unbusy();
  $d=undef;
}


sub PrepareText {
  my $text=shift;
  $text=$1."*" if ($text =~/^([^\|]*)\|/);

  return encode($text);
}


sub whichTextColor {
  my $i=shift;

  return $textColor unless ($highlightAttributes);

  if (index($attribs{$displayAttrs[$i]}," 1")>=0) {
    return $textColorShadow;
  } elsif (index($attribs{$displayAttrs[$i]}," 2")>=0) {
    return $textColorHilite;
  } elsif (index($attribs{$displayAttrs[$i]}," 3")>=0) {
    return $textColorXHilite;
  } else {
    return $textColor;
  }
}

sub redraw_tree {
  my ($grp)=@_;
  my $node;
  my $parent;

  return if $insideEval;
  recalculate_positions($grp);
  #print $grp->{'canvasWidth'},'x',$grp->{'canvasHeight'},"\n";
  $grp->{'canvas'}->configure(-scrollregion =>['0c', '0c', $grp->{canvasWidth}, $grp->{canvasHeight}]);
  $grp->{'canvas'}->configure(-background => $backgroundColor) if (defined $backgroundColor);
  $grp->{'canvas'}->addtag('delete','all');
  $grp->{'canvas'}->delete('delete');

#  undef %{$grp->{pinfo}} if (exists $grp->{pinfo});
#  print keys(%{$grp->{pinfo}}),"---\n";
  $grp->{'pinfo'}={lastX => 0, lastY => 0};
#  $grp->{'pinfo'}{'lastX'}=0;
#  $grp->{'pinfo'}{'lastY'}=0;
  foreach $node (@nodes) {
    foreach (keys(%$node)) {
      delete $node->{$_}
	if (/^_tkText/);
    }
    $parent=Parent($node);
    use integer;
    if ($parent) {
      $$node{"_tkLine_"}=$grp->{'canvas'}->createLine($$node{"_tkXPOS_"}+$nodeWidth/2,
					     $$node{"_tkYPOS_"}+$nodeHeight/2,
					     $$parent{"_tkXPOS_"}+$nodeWidth/2,
					     $$parent{"_tkYPOS_"}+$nodeHeight/2,
						      '-arrow' =>$lineArrow,
						     '-width' => $lineWidth,
						     '-fill' => $lineColor);
      $grp->{'pinfo'}{$$node{"_tkLine_"}}=$node;
    }
  }
#  print "drawing ovals and texts...\n";
  foreach $node (@nodes) {
    $$node{"_tkOval_"}=$grp->{'canvas'}->createOval($$node{"_tkXPOS_"},$$node{"_tkYPOS_"},
					   $$node{"_tkXPOS_"}+$nodeWidth,
					   $$node{"_tkYPOS_"}+$nodeHeight,
						    -fill =>
						    ($grp->{'currentNode'} eq $node) ?
						    $currentNodeColor : 
						    (isShown($node,0) ?
						     $nodeColor :
						     $hiddenNodeColor));
    $grp->{'canvas'}->addtag('point', 'withtag', $$node{"_tkOval_"});

    my $lineHeight=$grp->{'canvas'}->fontMetrics($font, -linespace);
    my $textWidth=0;
    my $i;
    foreach (@displayAttrs) {
      $i=$grp->{'canvas'}->fontMeasure($font,PrepareText($$node{$_}));
      $textWidth=$i if ($i>$textWidth);
    }
    if ($drawBoxes) {
      $$node{"_tkTextBox_"}=$grp->{'canvas'}->createRectangle($$node{"_tkXPOS_"}-$xmargin,
						     $$node{"_tkYPOS_"}+$nodeHeight+$nodeYSkip-$ymargin,
						     $$node{"_tkXPOS_"}+
						     $textWidth+$xmargin,
						     $$node{"_tkYPOS_"}+
						     ($#displayAttrs+1)*$lineHeight+
						     $nodeHeight+$nodeYSkip+$ymargin,
						     -fill => ($grp->{'currentNode'} eq $node) ?
						    $currentBoxColor : $boxColor);
    }
    for ($i=0;$i<=$#displayAttrs;$i++) {
      $$node{"_tkTextBg".$i."_"}=
	$grp->{'canvas'}->createRectangle($$node{"_tkXPOS_"},
				 $$node{"_tkYPOS_"}+$nodeHeight+$nodeYSkip+$i*$lineHeight,
				 $$node{"_tkXPOS_"}+
				 $grp->{'canvas'}->fontMeasure($font,PrepareText($$node{$displayAttrs[$i]}))+1,
				 $$node{"_tkYPOS_"}+$nodeHeight+$nodeYSkip+($i+1)*$lineHeight,
				 -fill => $grp->{'canvas'}->cget('-background'), -outline => undef)
	unless ($drawBoxes);
      $grp->{'canvas'}->addtag('textbg', 'withtag', $$node{"_tkTextBg".$i."_"});
      $grp->{'pinfo'}{$$node{"_tkTextBg".$i."_"}}=$node;
      $$node{"_tkText".$i."_"}=
	$grp->{'canvas'}->createText($$node{"_tkXPOS_"},$$node{"_tkYPOS_"}+
				     $nodeHeight+$nodeYSkip+$i*$lineHeight,
				     -anchor => 'nw',
				     -text => PrepareText($$node{$displayAttrs[$i]}),
				     -fill => whichTextColor($i),
				     -font => $font);
      $grp->{'canvas'}->addtag('text', 'withtag', $$node{"_tkText".$i."_"});
      $grp->{'pinfo'}{$$node{"_tkText".$i."_"}}=$node;
    }
#    print "done\n";
    $grp->{'pinfo'}{$$node{"_tkOval_"}}=$node;
    $grp->{'pinfo'}{$$node{"_tkTextBox_"}}=$node
      if exists $$node{"_tkTextBox_"};
  }

#  $grp->{'canvas'}->bind('point', '<Any-Enter>' => [sub{shift->itemconfigure(@_)},
#				      'current', -fill => $activeNodeColor]);
#  $grp->{'canvas'}->bind('point', '<Any-Leave>' => [sub{ shift->itemconfigure(@_)},
#				      'current', -fill => $nodeColor]);
  $grp->{'canvas'}->bind('text', '<Any-Enter>' => [sub{shift->itemconfigure(@_)},
				      'current', -fill => $activeTextColor]);
  $grp->{'canvas'}->bind('text',
			 '<Any-Leave>'
			 => [sub{
			       my $c=shift;
			       my $grp=shift;
			       my $t=$c->find('withtag','current');
			       my $node=$grp->{'pinfo'}{$t};
			       my $attr= (grep {$node->{$_} eq $t} keys %$node)[0];

			       return unless ($attr=~/^_tkText(?:Bg)*(\d+)_$/
					      or $1>$#displayAttrs);
			       $c->itemconfigure('current',
						 -fill => whichTextColor($1));
			     }, $grp]);

  $grp->{'frame'}->bind('my','<KeyPress>' =>
			[sub { evalMacro(@_); Tk->break; }, $grp, '' ]);
#  $grp->{'frame'}->bind('my','<Control-x><KeyPress>' =>
#			[sub { evalMacro(@_); Tk->break; }, $grp, 'CTRL-X+' ]);
  $grp->{'frame'}->bind('my','<Shift-KeyPress>' =>
			[sub { evalMacro(@_); Tk->break; }, $grp,'SHIFT+']);
  $grp->{'frame'}->bind('my','<Control-KeyPress>' =>
			[sub { evalMacro(@_); Tk->break; }, $grp,'CTRL+']);
  $grp->{'frame'}->bind('my','<Alt-KeyPress>' =>
			[sub { evalMacro(@_); Tk->break; }, $grp,'ALT+']);
  $grp->{'frame'}->bind('my','<Meta-KeyPress>' =>
			[sub { evalMacro(@_); Tk->break; }, $grp,'META+']);
  $grp->{'frame'}->bind('my','<Control-Shift-KeyPress>' =>
			[sub { evalMacro(@_); Tk->break; }, $grp,'CTRL+SHIFT+']);
  $grp->{'frame'}->bind('my','<Control-Alt-KeyPress>' =>
			[sub { evalMacro(@_); Tk->break; }, $grp,'CTRL+ALT+']);
  $grp->{'frame'}->bind('my','<Control-Meta-KeyPress>' =>
			[sub { evalMacro(@_); Tk->break; }, $grp,'CTRL+META+']);
  $grp->{'frame'}->bind('my','<Alt-Shift-KeyPress>' =>
			[sub { evalMacro(@_); Tk->break; }, $grp,'ALT+SHIFT+']);
  $grp->{'frame'}->bind('my','<Meta-Shift-KeyPress>' =>
			[sub { evalMacro(@_); Tk->break; }, $grp,'META+SHIFT+']);


#  $grp->{'frame'}->bind('all','<Tab>' => [sub {1;}]);
#  $grp->{'top'}->bind('dialog','<Tab>' => [sub { shift->focusNext(); }] );
#  $grp->{'top'}->bind('dialog','<Shift-Tab>' => [sub { shift->focusPrev(); }] );
#  $grp->{'frame'}->bind('all','<Shift-Tab>' => [sub {1;}]);
#  $grp->{'frame'}->bind('all','<Control-Tab>' => [sub {1;}]);

  $grp->{'frame'}->bind('my','<Tab>' => [sub { currentNext(@_); Tk->break; },$grp]);
  $grp->{'frame'}->bind('my','<Control-Tab>' => [sub { currentPrev(@_); Tk->break; },$grp]);
  $grp->{'frame'}->bind('my','<Return>' => [sub {
					      my ($w,$grp)=@_;
					      editAttrsDialog($grp,$grp->{'currentNode'});
					      Tk->break;
					    },$grp]);
  $grp->{'frame'}->bind('my','<Left>' => [sub {
					   my ($w,$grp)=@_;
					   currentLeft($grp);
					   Tk->break;
					 },$grp]);
  $grp->{'frame'}->bind('my','<Right>' => [sub {
					    my ($w,$grp)=@_;
					    currentRight($grp);
					   Tk->break;
					  },$grp]);
  $grp->{'frame'}->bind('my','<Up>' => [sub {
					 my ($w,$grp)=@_;
					 currentUp($grp);
					 Tk->break;
				       },$grp]);
  $grp->{'frame'}->bind('my','<Down>' => [sub {
					   my ($w,$grp)=@_;
					   currentDown($grp);
					   Tk->break;
					 },$grp]);

  $grp->{'canvas'}->bind('point', '<1>' => [sub {node_down(@_) },$grp,0]);
  $grp->{'canvas'}->bind('point', '<ButtonRelease-1>' => [sub {node_release(@_)},$grp,0]);
  $grp->{'canvas'}->bind('point', '<B1-Motion>' => [sub {node_move(@_)},$grp]);
  $grp->{'canvas'}->bind('point','<3>' => [sub {node_down(@_)},$grp,1]);
  $grp->{'canvas'}->bind('point', '<ButtonRelease-3>' => [sub {node_release(@_)},$grp]);
  $grp->{'canvas'}->bind('point','<B3-Motion>' => [sub {node_move(@_)},$grp,1]);
  $grp->{'canvas'}->CanvasBind('<2>' => [sub {follow_mouse_press(@_)},$grp]);
  $grp->{'canvas'}->CanvasBind('<B2-Motion>' => [sub {follow_mouse(@_)},$grp]);
  $grp->{'canvas'}->bind('point', '<Double-ButtonPress-1>' => [sub { editAttrs(@_) },$grp]);
  $grp->{'canvas'}->bind('text', '<Double-ButtonPress-1>' => [sub { editAttr(@_) },$grp]);
  $grp->{'canvas'}->bind('textbg', '<Double-ButtonPress-1>' => [sub { editAttr(@_) },$grp]);
}


sub follow_mouse {
  my ($w, $grp) = @_;
  my $e = $w->XEvent;
  my($x, $y) = ($w->fpixels($e->x), $w->fpixels($e->y));
  scrollCanvasToXY($w, $grp, $x, $y);
}

sub follow_mouse_press {
  my ($w, $grp) = @_;
  my $e = $w->XEvent;
  my($x, $y) = ($w->fpixels($e->x), $w->fpixels($e->y));

  $grp->{'pinfo'}{'lastX'}=$x;
  $grp->{'pinfo'}{'lastY'}=$y;
  $grp->{'pinfo'}{'lastCanvasX'}=$w->canvasx($x);
  $grp->{'pinfo'}{'lastCanvasY'}=$w->canvasy($y);
}



sub scrollCanvasToXY {
  my ($w, $grp, $x, $y)=@_;
  my ($ax,$bx)=$w->xview;
  my ($ay,$by)=$w->yview;
  my $canvasX;

  my $sizeX=$w->fpixels($grp->{'canvasWidth'})*($bx-$ax);
  my $shiftX=($x-$grp->{'pinfo'}{'lastX'});
  if ($shiftX>0) {
    if ($grp->{'pinfo'}{'lastX'} == $sizeX) {
      $shiftX=0;
    } else {
      $shiftX/=$sizeX-$grp->{'pinfo'}{'lastX'}; # a fraction of our right move in window
    }
    $canvasX=$shiftX*
      ($w->fpixels($grp->{'canvasWidth'})-
	$grp->{'pinfo'}{'lastCanvasX'}); # this is where we should get on the canvas
  }
  else {
    if ($grp->{'pinfo'}{'lastX'} == 0) {
      $shiftX=0;
    } else{
      $shiftX/=$grp->{'pinfo'}{'lastX'}
    }
    $canvasX=$shiftX*
	$grp->{'pinfo'}{'lastCanvasX'}; # this is where we should get on the canvas
  }
  $canvasX+=$grp->{'pinfo'}{'lastCanvasX'};
  $w->xview(moveto =>
	    max(0,min(1,($canvasX-$x+1+$w->fpixels($w->cget('-borderwidth')))
		      /$grp->{'canvasWidth'})));

  # the same for Y
  my $sizeY=$w->fpixels($grp->{'canvasHeight'})*($by-$ay);
  my $shiftY=($y-$grp->{'pinfo'}{'lastY'});
  if ($shiftY>0) {
    if ($grp->{'pinfo'}{'lastY'} == $sizeY) {
      $shiftY=0;
    } else {
      $shiftY/=$sizeY-$grp->{'pinfo'}{'lastY'}; # a fraction of our right move in window
    }
    $canvasY=$shiftY*
      ($w->fpixels($grp->{'canvasHeight'})-
	$grp->{'pinfo'}{'lastCanvasY'}); # this is where we should get on the canvas
  }
  else {
    if ($grp->{'pinfo'}{'lastY'}==0) {
      $shiftY=0;
    } else {
      $shiftY/=$grp->{'pinfo'}{'lastY'};
    }
    $canvasY=$shiftY*
	$grp->{'pinfo'}{'lastCanvasY'}; # this is where we should get on the canvas
  }
  $canvasY+=$grp->{'pinfo'}{'lastCanvasY'};
  $w->yview(moveto =>
	    max(0,min(1,($canvasY-$y+1+$w->fpixels($w->cget('-borderwidth')))
		      /$grp->{'canvasHeight'})));


  $grp->{'pinfo'}{'lastX'}=$x;
  $grp->{'pinfo'}{'lastY'}=$y;
  $grp->{'pinfo'}{'lastCanvasX'}=$w->canvasx($x);
  $grp->{'pinfo'}{'lastCanvasY'}=$w->canvasy($y);
}

sub recalculate_positions {
  my ($grp)=@_;
  my $xpos=$baseXPos;
  my $ypos;
  my $minxpos; # used temporarily to place a node far enough from its left neighbour
  my $maxypos; # has different meaning from $minxpos; this one's used for canvasHeight
  my $canvasWidth=0;
  my $node;

  my $fontHeight=$grp->{'canvas'}->fontMetrics($font, -linespace);

  #print "Calculating positions ...\n";
  %prevnode=();
  $maxypos=0;
  foreach $node (@nodes) {
    $ypos=0;
    $parent=Parent($node);
    while ($parent) {
      #print "!\n";
      $ypos++;
      $parent=Parent($parent);
    }
    $maxypos=max($maxypos,$ypos);
    $$node{"_tkYPOS_"}=$baseYPos+$ypos*(2*($nodeYSkip+$ymargin)+($#displayAttrs+1)*$fontHeight+$nodeHeight);

    #print "got y position for ",$$node{"form"},"\n";


    my $textWidth=0;
    my $i;
    foreach (@displayAttrs) {
      $i=$grp->{'canvas'}->fontMeasure($font,PrepareText($$node{$_}));
      $textWidth=max($i,$textWidth);
    }
    $$node{"_tkXWidth_"}=$textWidth;

    $minxpos=0;
    if ($prevnode{$ypos}) {
      $minxpos=$prevnode{$ypos}{"_tkXPOS_"}+$prevnode{$ypos}{"_tkXWidth_"}+
	$nodeXSkip+$nodeWidth+2*$xmargin;
    }
    $xpos=max($xpos,$minxpos);
    $$node{"_tkXPOS_"}=$xpos;
    $xpos+=$nodeXSkip+$nodeWidth;
    $canvasWidth=
      max($canvasWidth,
	  $$node{"_tkXPOS_"}+$$node{"_tkXWidth_"}+$baseXPos+$nodeWidth+2*$xmargin+$nodeXSkip);
    #print "got x position\n";

    $prevnode{$ypos}=$node;
    #print "$ypos ... ",$$node{"_tkYPOS_"},"\n";
  }
  #print "Width: $canvasWidth\n";
  $grp->{'canvasWidth'}=$canvasWidth;
  $grp->{'canvasHeight'}=$baseYPos+
    ($maxypos+1)*(2*($nodeYSkip+$ymargin)+($#displayAttrs+1)*$fontHeight+$nodeHeight);
  #print "Done.\n";
}

sub IsHidden {
  # Tests if given node is hidden or not
  # Returns the ancesor that hides it or undef
  my $node=shift;
  $node=Parent($node) while ($node and (Hide($node,\%attribs) ne 'hide'));
  return ($node ? $node : undef);
}

sub currentUnhiden {
  my $grp=shift;
  unless ($showHidden) {
    my $node=IsHidden($grp->{'currentNode'});
    setCurrent($grp,Parent($node)) if ($node and Parent($node));
  }
}

sub currentLeft {
  my $grp=shift;
  if ($showHidden) {
    if (LBrother($grp->{'currentNode'})) {
      setCurrent($grp,LBrother($grp->{'currentNode'}));
      centerTo($grp,$grp->{'currentNode'});
    }
  } else {
    my $n=LBrother($grp->{'currentNode'});
    $n=LBrother($n) while ($n and defined(Hide($n,\%attribs))
			   and (Hide($n,\%attribs) eq 'hide'));
    if ($n) {
      setCurrent($grp,$n);
      centerTo($grp,$grp->{'currentNode'});
    }
  }
}

sub currentRight {
  my $grp=shift;
  if ($showHidden) {
    if (RBrother($grp->{'currentNode'})) {
      setCurrent($grp,RBrother($grp->{'currentNode'}));
      centerTo($grp,$grp->{'currentNode'});
    }
  } else {
    my $n=RBrother($grp->{'currentNode'});

    $n=RBrother($n) while ($n and defined(Hide($n,\%attribs))
			   and (Hide($n,\%attribs) eq 'hide'));
    if ($n) {
      setCurrent($grp,$n);
      centerTo($grp,$grp->{'currentNode'});
    }
  }
}

sub currentDown {
  my $grp=shift;
  if ($showHidden) {
    if (FirstSon($grp->{'currentNode'})) {
      setCurrent($grp,FirstSon($grp->{'currentNode'}));
      centerTo($grp,$grp->{'currentNode'});
    }
  } else {
    my $n=FirstSon($grp->{'currentNode'});
    $n=RBrother($n) while ($n and defined(Hide($n,\%attribs))
			   and Hide($n,\%attribs) eq 'hide');
    if ($n) {
      setCurrent($grp,$n);
      centerTo($grp,$grp->{'currentNode'});
    }
  }
}



sub currentUp {
  my $grp=shift;
  if (Parent($grp->{'currentNode'})) {
    setCurrent($grp,Parent($grp->{'currentNode'}));
    centerTo($grp,$grp->{'currentNode'});
  }
}

sub setCurrent {
  my ($grp,$node)=@_;
  $grp->{'canvas'}->itemconfigure($grp->{'currentNode'}->{'_tkOval_'},
				  -fill => (isShown($grp->{'currentNode'},0) ?
						     $nodeColor :
						     $hiddenNodeColor));
  $grp->{'canvas'}->itemconfigure($grp->{'currentNode'}->{'_tkTextBox_'},
				  -fill => $boxColor)
    if ($drawBoxes and $grp->{'currentNode'}->{'_tkTextBox_'});

  $grp->{'currentNode'}=$node;
  $grp->{'canvas'}->itemconfigure($grp->{'currentNode'}->{'_tkOval_'},
				  -fill => $currentNodeColor);
  $grp->{'canvas'}->itemconfigure($grp->{'currentNode'}->{'_tkTextBox_'},
				  -fill => $currentBoxColor)
    if ($drawBoxes and $grp->{'currentNode'}->{'_tkTextBox_'});
}

sub centerToXY {
  ($grp, $x, $y) = @_;
  ($ax,$bx)=$grp->{'canvas'}->xview;
  ($ay,$by)=$grp->{'canvas'}->yview;

  $shiftx=($bx-$ax)/2;
  $shifty=($by-$ay)/2;

  $grp->{'canvas'}->xview(moveto => min(max(0,$x/$grp->{'canvasWidth'}-$shiftx),1));
  $grp->{'canvas'}->yview(moveto => min(max(0,$y/$grp->{'canvasHeight'}-$shifty),1));
}

sub centerTo {
  ($grp, $node) = @_;
  centerToXY($grp,$$node{'_tkXPOS_'},$$node{'_tkYPOS_'});
}

sub doEvalMacro {
  my ($grp,$macro)=@_;
  print "$macro\n";
  local $this;
  $this=$grp->{'currentNode'};
  my $result;
  my $FileNotSavedOrig=$FileNotSaved;

  return unless $this;
  $grp->{'top'}->Busy(-recurse => 1);
  $FileNotSaved=1; # Macro may want to override this :)
  $insideEval=1;

  unless ($macrosEvaluated) {
    eval ("@macros\n return 1;");
    $macrosEvaluated=1;
  }
#  $result=eval("return ".$macro."();\n@macros\n");  # this consumes memory!!!!
    $result=eval("return ".$macro."();\n");
  if (!$result or $@) {
    print STDERR "Had run: ",$macro,"\n";
    print STDERR "Returned with: $result\n$@\n";
  }
  print "Macro claims file untouched\n"
    unless ($FileNotSaved);
  $FileNotSaved=($FileNotSavedOrig or $FileNotSaved);
  $insideEval=0;
  $grp->{'top'}->Unbusy;
  setCurrent($grp,$this);
  getNodes($grp);
  redraw_tree($grp);
  centerTo($grp,$this);
}

sub evalMacro {
  my ($w,$grp,$prefix)=@_;
  my $key;
  my $e = $w->XEvent;
  my $A = uc($e->A);

#  print STDERR "Pressed: ($A), prefix $prefix, keysym ",$e->K,"/",$e->N,"\n";
#  print STDERR "Maybe: ",$prefix.$pckey_shift_translates{$e->K},"\n";

  if (defined $keyBindings{$prefix.$A}) {
    $key=$prefix.$A;
  } elsif ($prefix =~/SHIFT/ and exists($pckey_shift_translates{$e->K})
	  and defined $keyBindings{$prefix.$pckey_shift_translates{$e->K}}) {
    $key=$prefix.$pckey_shift_translates{$e->K};
    print STDERR "Trying: ",$prefix.$pckey_shift_translates{$e->K},"\n";
  } else {
    $key=$prefix.uc($e->K);
  }
  #print "Got $prefix$A (",ord($e->A),",",ord($A),",",ord($e->B),") looking for macro\n";
  if (defined $keyBindings{$key}) {
    doEvalMacro($grp,$keyBindings{$key});
  }
}

sub currentNext {
  my ($w,$grp)=@_;
  if (Next($grp->{'currentNode'})) {
    setCurrent($grp,Next($grp->{'currentNode'}));
    centerTo($grp,$grp->{'currentNode'});
  }
}


sub currentPrev {
  my ($w,$grp)=@_;
  if (Prev($grp->{'currentNode'})) {
    setCurrent($grp,Prev($grp->{'currentNode'}));
    centerTo($grp,$grp->{'currentNode'});
  }
}


sub node_down {

    my($w,$grp) = @_;

    my $e = $w->XEvent;
    my($x, $y) = ($e->x, $e->y);
    my $node=$grp->{'pinfo'}{$w->find('withtag','current')};

    setCurrent($grp,$node);
    $w->dtag('selected');
    $w->addtag('selected', 'withtag', 'current');
    $w->raise('current');
    $grp->{'pinfo'}{'lastX'} = $x;
    $grp->{'pinfo'}{'lastY'} = $y;
    $grp->{'pinfo'}{'lastCanvasX'}=$w->canvasx($x);
    $grp->{'pinfo'}{'lastCanvasY'}=$w->canvasy($y);
} # end plot_down

sub node_move {

    my($w,$grp,$scroll) = @_;

    my $e = $w->XEvent;
    my($x, $y) = ($e->x, $e->y);
    my $node=$grp->{'pinfo'}->{$w->find('withtag','selected')};

    my $lcx=$grp->{'pinfo'}{'lastCanvasX'};
    my $lcy=$grp->{'pinfo'}{'lastCanvasY'};

    if ($scroll) {
      scrollCanvasToXY($w, $grp, $x, $y);
    } else {
      $grp->{'pinfo'}{'lastCanvasX'}=$w->canvasx($x);
      $grp->{'pinfo'}{'lastCanvasY'}=$w->canvasy($y);
    }
    my($cx, $cy) = ($w->canvasx($x),$w->canvasy($y));
    $w->move('selected',  $cx-$lcx, $cy-$lcy);

    $w->itemconfigure('nearest', -fill => (isShown($node,0) ?
						     $nodeColor :
						     $hiddenNodeColor));
    $w->dtag('nearest');

    my @dots= $w->find('withtag','point');
    my $nearestNode=0;
    my $bestDist=10000;
    my $dist;
    foreach $p (@dots) {
      if ($grp->{'pinfo'}{$p} and $grp->{'pinfo'}{$p}!=$node) {
	$dist=
	  ($cx-$grp->{'pinfo'}{$p}{'_tkXPOS_'})*
	    ($cx-$grp->{'pinfo'}{$p}{'_tkXPOS_'})+
	      ($cy-$grp->{'pinfo'}{$p}{'_tkYPOS_'})*
		($cy-$grp->{'pinfo'}{$p}{'_tkYPOS_'});
	if ($bestDist>$dist) {
	  $bestDist=$dist;
	  $nearestNode=$grp->{'pinfo'}{$p};
	}
      }
    }
    if ($bestDist<800) {
      $w->addtag('nearest','withtag',$$nearestNode{"_tkOval_"});
      $w->itemconfigure($$nearestNode{"_tkOval_"}, -fill => $nearestNodeColor);
    }
} # end plot_move

sub node_release {
  my($w,$grp) = @_;
  my $e = $w->XEvent;
  my($x, $y) = ($e->x, $e->y);
  my $parent;
  my $node;
  my $center=0;
  my $sel=$w->find('withtag','selected');
  $node=$grp->{'pinfo'}{$sel} if (defined ($sel));

  if ($node) {
    $p=$w->find('withtag','nearest');
    $w->dtag('selected');
    if (defined $p) {
      $parent=$grp->{'pinfo'}{$p};
      while ($parent) {
	$p=0, last if ($node eq $parent);
	$parent=Parent($parent);
      }
      if ($p and $grp->{'pinfo'}{$p} 
	  and Parent($node)!=$grp->{'pinfo'}{$p}) {
	Paste(Cut($node),$grp->{'pinfo'}{$p},\%attribs);
	redraw_tree($grp);
	centerTo($grp,$grp->{currentNode});
	$FileNotSaved=1;
	return;
      } 
    }
    # returning node to its position
    $w->coords($sel, $node->{"_tkXPOS_"}, $node->{"_tkYPOS_"},
	       $node->{"_tkXPOS_"}+$nodeWidth,
	       $node->{"_tkYPOS_"}+$nodeHeight);
  } else { redraw_tree($grp); }
}

### Local Variables:
### mode:cperl
### End:
