#!/usr/bin/perl
# -*- cperl -*-
#
################################################################################
$version='$Revision$ ';
$timestamp="Time-stamp: <2001-03-29 17:58:21 pajas>";
$about=
  "Copyright (c) 2001 by Petr Pajas\n".
  "This software is distributed under GPL - The General Public Licence\n".
  "Full text of the GPL can be found at http://www.gnu.org/copyleft/gpl.html";
$lastupdate=$1 if ($timestamp=~/\<([0-9-: ]+) /);
################################################################################
#
# This is "TrEd" - a simple viewer/editor of tree graphs in fs
# file-format used in Graph - program developed by M. Kren. TrEd is
# written entirely in Perl and for graphical output it uses PerlTk
# library as a frontend to Tk toolkit
#
################################################################################
#
# Usage:
# tred [-c <config-file>] [-m <macro-file>] [-l <filelist>] file1[##N|#N] [file2[##N|#N] [...]]
#
# or
#
# tred -u  for usage
#
# or
#
# tred -h  for help
#
################################################################################


# Once we got rid of them we call getopt to read all the other options
use Tk;
use Tk::Wm;

package Tk::Wm;
# overwriting the original Tk::Wm::Post:
sub Post
{
 my ($w,$X,$Y) = @_;
 $X = int($X);
 $Y = int($Y);
 $w->positionfrom('user');
# $w->geometry("+$X+$Y");
 $w->MoveToplevelWindow($X,$Y);
 $w->deiconify;
## This causes the "slowness":
# $w->raise;
}

package main;


use Tk::Xrm;
# process the standard arguments for X resources
Tk::CmdLine::SetArguments();


use Getopt::Std;
getopts('m:c:l:hu');

if ($opt_u) {
  print <<EOH;
Usage:
  tred [-c config-file] [-m macro-file] [-l file-list] files...
or
  tred -u          to show usage
or
  tred -h          to show help
EOH
  exit;
}

if ($opt_h) {
  print <<EOF;
Usage:
tred [-c <config-file>] [-m <macro-file>] [-l <filelist>] file1[##N|#N] [file2[##N|#N] [...]]

or

tred -u|-h    for usage/help

This is `TrEd' - a simple viewer/editor of tree graphs in FS-format
used in `GRAPH' - a program developed by M. Kren. TrEd (which stands
for The TRee EDitor) is written entirely in Perl and it uses PerlTk
module for GUI.

Files file1, etc. given on the command-line must be in fs-format (for
not a little bit obsolete description see:
	http://ufal.ms.mff.cuni.cz/local/doc/trees/format_fs.html)

The name of each file may be followed by a suffices of the following
forms:

#N      where N is a number possibly followed by one or more
	upper-case letters. In this case, #N tells TrEd to skip to the
	first tree the root of which has `#N' as a value of attribute
	called `form' (this feature is optimized for specific
	instances of fs-format used while working on The Prague
	Dependency Treebank)

##N     where N is a number. This makes TrEd to go to the N-th tree in
	the given file after the file is opened.

-m      may be used to specify a macro file different from the one
	given in ~/.tredrc (or whatsoever) configuration file

-c      may be used to specify a config-file to be used (overrides
	~/.tredrc and all the other files TrEd would otherwise try to
	search for).

EOF
  exit;
}

# platform specific stuff
$inputenc="iso-8859-2";
if ($^O eq "MSWin32") {
  $outputenc="windows-1250";
  $Ds="\\"; # how filenames and directories are separated
} else {
  $Ds='/';
  $outputenc="iso-8859-2";
}

use FindBin;

# in Windows, if HOME not defined, use user's AppData folder instaed
if ($^O eq "MSWin32" and !exists $ENV{HOME}) {
  require Win32::Registry;
  my %shf;
  my $ShellFolders;

  my $shfolders="Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders";
  $::HKEY_CURRENT_USER->Open($shfolders,$ShellFolders) or die "Cannot read $shfolders $^E\n";
  $ShellFolders->GetValues(\%shf);
  $ENV{HOME} = $shf{AppData}[2];
}

# this variable is used when searching for rc-file (i.e. the inicialisation file)
my @configFileSearchList=($ENV{HOME}.'/.tredrc',
			  (exists $ENV{TREDHOME}) ? $ENV{TREDHOME}.'/tredrc' : (),
			  "$FindBin::RealBin/tredrc",
			  "$FindBin::RealBin/../lib/tredlib/tredrc",
			  "$FindBin::RealBin/tredlib/tredrc",
			  "$FindBin::RealBin/../lib/tred/tredrc",
			  '/usr/usr/share/config/tredrc');

my $configFile;
# other configuration should be given in that file


my $libDir;
# Default values of $libDir used to search for macro-file (tred.mac)
# and default-macro file (tred.def) are specified here. They may be
# overriden by value of LibDir in tred resource file (tredrc or ~/.tredrc - see above).

if (exists $ENV{TREDHOME}) {
  $libDir=$ENV{TREDHOME};
} elsif (-d "$FindBin::RealBin/tredlib") {
  $libDir="$FindBin::RealBin/tredlib";
} elsif (-d "$FindBin::RealBin/../lib/tredlib") {
  $libDir="$FindBin::RealBin/../lib/tredlib";
} elsif (-d "$FindBin::RealBin/../lib/tred") {
  $libDir="$FindBin::RealBin/../lib/tred";
}
print "Trying $libDir\n" if ($libDir);


$macroFile=undef;

if (defined $opt_c) {
  @configFileSearchList=($opt_c); # override any other possible config files
}

# this must be done before readconfig is first used
@filelists=();
@openfiles=();

my $configfile=readConfig();

print "Resource file parsed\n";

$macroFile="$libDir/tred.mac" unless (defined $macroFile);

if (defined $opt_m) {
  $macroFile=$opt_m;
}

unless (-d $libDir) {
  print <<'EOL';
 TrEd couldn't find a tredlib directory. You may need to point
 to its location by the TREDHOME variable or add a correct LibDir
 field to your ~/.tredrc.

EOL
    die "Error: Couldn't find lib-directory.";
}


use Cwd;

use Tk::LabFrame;
use Tk::Listbox;
use Tk::HList;
use Tk::ItemStyle;
use Tk::Balloon;
use Tk::DialogBox;
use Tk::Tiler;
use Tk::BrowseEntry;

push @INC,$libDir unless (grep($_ eq $libDir, @INC));
require Fslib;
import Fslib;
import Fslib qw(&Ord &Value &Hide &SentOrd &AOrd &AValue &AHide &ASentOrd &Index);

require Filelist;

require Tk::MyFileSelect;

use Exporter;
use File::Spec;

# This is default export to macros
@EXPORT = qw($root $this $_NoSuchTree $NodeClipboard
	     $forceFileSaved $insideEval $FileNotSaved
             @openfiles @filelists &min &max);

my @macros=();

my @customColors=('darkgreen','darkblue','darkmagenta',,'orange','darkred','green1',
		  'slategray1','gold','cyan','midnightblue');


@open_types =
  (["Fs files",           [qw/.fs .FS .Fs/]],
   ["Gzipped Fs files",   [qw/.fgz .fs.gz .FGZ .FS.gz .FS.GZ/]],
   ["CSTS files",           [qw/.am .cst .csg .csts/]],
   ["Gzipped CSTS files",           [qw/.am.gz .cst.gz .csg.gz .csts.gz/]],
   ["Backup Fs files",           [qw/.fs~ .fb .FB .Fb/]],
   ["Backup gzipped Fs files",           [qw/.fgz~ .fs.gz~ .FGZ~ .FS.gz~ .FS.GZ~/]],
   ["All files",        '*']
  );

@save_types =
  (["Fs files",           [qw/.fs .FS .Fs/]],
   ["Gzipped Fs files",   [qw/.fgz .fs.gz .FGZ .FS.gz .FS.GZ/]],
   ["CSTS files",           [qw/.cst .csts/]],
   ["Gzipped CSTS files",           [qw/.cst.gz .csts.gz/]],
   ["All files",        '*']
  );

# it seems, that under Windoze setting LC_NUMERIC back to us does not
# work, so I recommend not to use czech locales there, unless you
# really want the decimal points to be replaced by commas in
# postscript:)

if ($useCzechLocales) {
  use locale;
  use POSIX qw(locale_h);
  setlocale(LC_COLLATE,"cs_CZ");
  setlocale(LC_NUMERIC,"us_EN");
  setlocale(LANG,"czech");
}

$fsF=undef;

sub bookmarkFilelist {
  foreach (@filelists) {
    return $_ if ref and $_->name eq 'Bookmarks';
  }
  return undef;
}

{
  my $default = new Filelist('Default');
  my @files;

  if ($opt_l and -f $opt_l) {
    if (open(F,"<$opt_l")) {
      @files=<F>;
      close(F);
      chomp @files;
    }
  }
  push(@files, @ARGV);

  use File::Spec::Functions (rel2abs);
  @files = map { rel2abs($_) } @files;

  $default->add(0,@files);
  addNewFilelist(undef,$default);
  unless (bookmarkFilelist) {
    my $bookmarks = new Filelist('Bookmarks',$ENV{HOME}.'/.tred_bookmarks');
    addNewFilelist(undef,$bookmarks);
  }
}

# These are used only in macros and hooks!!!
$root=undef;
$this=undef;
$FileNotSaved=0;
$forceFileSaved=0;

$_NoSuchTree; # for compatibility with Graph2Tred
$NodeClipboard;

$drawSentenceInfo=0;
$insideEval=0;

my %searchTemplate;

%pckey_shift_translates = (exclam => 1, at => 2, numbersign => 3,
			   dollar => 4, percent => 5, asciicircum => 6,
			   ampersand => 7, asterisk => 8, parenleft => 9,
			   parenright => 0, plus => 'equal',
			   underscore => 'minus',
			   less => 'comma', greater => 'period', 
			   question => 'slash',
			   colon => 'semicolon', quotedbl => 'apostroph',
			   braceleft => 'bracketleft', 
			   braceright => 'bracketright',
			   bar => 'backslash', asciitilde => 'grave'
			  );

sub dirname {
  my $a=shift;  
  return (index($a,$Ds)>=0)? substr($a,0,rindex($a,$Ds)+1) : ".$Ds";
}

sub filename {
  my $a=shift;
  return (index($a,$Ds)>=0)? substr($a,rindex($a,$Ds)+1) : $a;
}


##################### character encoding functions ########################

%encodings = (
    'iso-8859-2' => "ÏπË¯æ˝·ÌÈÏ˙˘ÛÚªÔµ‡∂ÂºÊÒÃ©»ÿÆ›¡Õ…Ã⁄Ÿ”“´œ•¿¶≈¨∆—",
	      'ascii' => "escrzyaieeuuontdlrslzcnESCRZYAIEEUUONTDLRSLZCN",
	      'iso-8859-1' => "escrz˝·ÌÈe˙uÛntdlrslzcnESCRZ›¡Õ…E⁄U”NTDLRSLZCN",
	      'windows-1250' => "ÏöË¯û˝·ÌÈÏ˙˘ÛÚùÔæ‡úÂüÊÒÃä»ÿé›¡Õ…Ã⁄Ÿ”“çœº¿å≈è∆—"
	     );

sub encode {
  return join("",@_) if ($inputenc eq $outputenc);

  local $_=join "",@_;
  eval " tr/$encodings{$inputenc}/$encodings{$outputenc}/";
  return $_;
}

sub decode {
  return join("",@_) if ($inputenc eq $outputenc);

  local $_=join "",@_;
  eval " tr/$encodings{$outputenc}/$encodings{$inputenc}/";
  return $_;
}

################ end of character encoding functions ########################


print STDERR "Reading macros from $macroFile...\n";
readMacros($macroFile);		# read macros
print STDERR "done.\n";

startMain();	# display first tree

print STDERR "TrEd ended.\n";

exit;

############################
############################
############################

sub min {
  my ($a,$b)=@_;
  return ($a<$b)?$a:$b;
}

sub max {
  my ($a,$b)=@_;
  return ($a<$b)?$b:$a;
}


sub parseConfigLine {
  local $_=shift;
  my $confs=shift;
  my $key;
  unless (/^[;#]/ or /^$/) {
    chomp;
    if (/^\s*([a-zA-Z_]+[a-zA-Z_0-9]*)\s*=\s*('(?:[^\\']|\\.)*'|"(?:[^\\"]|\\.)*"|(?:\s*(?:[^;\\\s]|\\.)+)*)/) {
      $key=lc($1);
      $confs->{$key}=$2;
      $confs->{$key}=~s/\\(.)/\1/g;
      $confs->{$key}=$1 if ($confs->{$key}=~/^'(.*)'$/ or $confs->{$key}=~/^"(.*)"$/);
      #print "$key=$confs->{$key};\n";
    }
  }
}

sub readConfig {
  #
  # Simple configuration file handling
  #
  my %confs;
  my $key, $f;
  local *F;
  my $openOk=0;

  foreach $f (@_,@configFileSearchList) {
    if (defined($f), open(F,"<$f")) {
      print "Using resource file $f\n";
      while (<F>) {
	parseConfigLine($_,\%confs);
      }
      close F;
      $openOk=1;
      $configFile=$f;
      last;
    }
  }
  unless ($openOk) {
    print
      "Warning: Cannot open any file in:\n",
      join(":",@configFileSearchList),"\n" .
      "         Using configuration defaults!\n";
  }
  setConfig(\%confs);
  return $f;
}

sub applyConfig {
  my %confs;
  foreach (@_) {
    parseConfigLine($_,\%confs);
  }
  setConfig(\%confs);
}

sub setConfig {
  my $confs=shift;

  $appName=(exists $confs->{appname}) ? $confs->{appname} : "TrEd ver. 0.5";
  $baseXPos=(exists $confs->{basexpos}) ? $confs->{basexpos} : 15;
  $baseYPos=(exists $confs->{baseypos}) ? $confs->{baseypos} : 15;
  $nodeWidth=(exists $confs->{nodewidth}) ? $confs->{nodewidth} : 7;
  $nodeHeight=(exists $confs->{nodeheight}) ? $confs->{nodeheight} : 7;
  $currentNodeWidth=(exists $confs->{currentnodewidth}) ? $confs->{currentnodewidth} : $nodeWidth;
  $currentNodeHeight=(exists $confs->{currentnodeheight}) ? $confs->{currentnodeheight} : $nodeHeight;
  $nodeXSkip=(exists $confs->{nodexskip}) ? $confs->{nodexskip} : 5;
  $nodeYSkip=(exists $confs->{nodeyskip}) ? $confs->{nodeyskip} : 10;
  $xmargin=(exists $confs->{xmargin}) ? $confs->{xmargin} : 2;
  $ymargin=(exists $confs->{ymargin}) ? $confs->{ymargin} : 2;
  $buttonsRelief=(exists $confs->{buttonsrelief}) ? $confs->{buttonsrelief} : 'flat';
  $menubarRelief=(exists $confs->{menubarrelief}) ? $confs->{menubarrelief} : 'flat';
  $buttonBorderWidth=(exists $confs->{buttonsborder}) ? $confs->{buttonsborder} : 2;
  $lineWidth=(exists $confs->{linewidth}) ? $confs->{linewidth} : 1;
  $lineColor=(exists $confs->{linecolor}) ? $confs->{linecolor} : 'black';
  $lineArrow=(exists $confs->{linearrow}) ? $confs->{linearrow} : 'none';
  $nodeColor=(exists $confs->{nodecolor}) ? $confs->{nodecolor} : 'yellow';
  $nodeOutlineColor=(exists $confs->{nodeoutlinecolor}) ? $confs->{nodeoutlinecolor} : 'black';
  $hiddenNodeColor=(exists $confs->{hiddennodecolor}) ? $confs->{hiddennodecolor} : 'black';
  # $activeNodeColor=(exists $confs->{activenodecolor}) ? $confs->{activenodecolor} : 'blue';
  $currentNodeColor=(exists $confs->{currentnodecolor}) ? $confs->{currentnodecolor} : 'red';
  $nearestNodeColor=(exists $confs->{nearestnodecolor}) ? $confs->{nearestnodecolor} : 'green';
  $textColor=(exists $confs->{textcolor}) ? $confs->{textcolor} : 'black';
  $textColorShadow=(exists $confs->{textcolorshadow}) ? $confs->{textcolorshadow} : 'darkgrey';
  $textColorHilite=(exists $confs->{textcolorhilite}) ? $confs->{textcolorhilite} : 'darkgreen';
  $textColorXHilite=(exists $confs->{textcolorxhilite}) ? $confs->{textcolorxhilite} : 'darkred';

  foreach (0..9) {
    $customColors[$_]=$confs->{"customcolor$_"} if $confs->{"customcolor$_"};
  }

  $canvasBalloonInitWait=(exists $confs->{hintwait}) ? $confs->{hintwait} : 1000;
  $activeTextColor=(exists $confs->{activetextcolor}) ? $confs->{activetextcolor} : 'blue';
  $boxColor=(exists $confs->{boxcolor}) ? $confs->{boxcolor} : 'wheat';
  $currentBoxColor=(exists $confs->{currentboxcolor}) ? $confs->{currentboxcolor} : 'white';
  $hiddenBoxColor=(exists $confs->{hiddenboxcolor}) ? $confs->{hiddenboxcolor} : 'gray';
  $backgroundColor=(exists $confs->{backgroundcolor}) ? $confs->{backgroundcolor} : undef;
  $noColor=(exists $confs->{allowcustomcolors}) ? $confs->{allowcustomcolors} : 0;
  $font=(exists $confs->{font}) ? $confs->{font} :
    (($^O=~/^MS/) ? 'family:Helvetica,size:10' : '-*-helvetica-medium-r-normal-*-12-*-*-*-*-*-iso8859-2');
  $vLineFont=(exists $confs->{vlinefont}) ? $confs->{vlinefont} : $font;
  $type1font=(exists $confs->{type1font}) ? $confs->{type1font} :
    (($^O=~/^MS/) ? $font : '-ult1mo-arial-medium-r-*-*-*-*-*-*-*-*-iso8859-2');

  ($libDir)=<$$confs{libdir}>
    if (exists $confs->{libdir});
  unshift @INC,$libDir unless (grep($_ eq $libDir, @INC));
  if (exists $$confs{psfontfile}) {
    ($psFontFile)=<$$confs{psfontfile}>;
    $psFontFile="$libDir/".$psFontFile if (not -f $psFontFile and -f 
					   "$libDir/".$psFontFile);
  } else {
    $psFontFile="$libDir/csarialm.pfa";
  }
  ($appIcon)=(exists $confs->{appicon}) ? <$$confs{appicon}> : ("$libDir/tred.xpm");
  $sortAttrs=(exists $$confs{sortAttributes}) ? $$confs{sortAttributes} : 1;
  $psFontName=(exists $$confs{psfontname}) ? $$confs{psfontname} : "Arial-Medium";
  $psFontSize=(exists $$confs{psfontsize}) ? $$confs{psfontsize} : "12";
  ($macroFile)=<$$confs{macrofile}> if (exists $$confs{macrofile});
  ($defaultMacroFile)=(exists $confs->{defaultmacrofile}) ? <$$confs{defaultmacrofile}> : ("$libDir/tred.def");
  $prtFmtWidth=(exists $confs->{prtfmtwidth}) ? $confs->{prtfmtwidth} : '21c';
  $prtFmtHeight=(exists $confs->{prtfmtheight}) ? $confs->{prtfmtheight} : '297m';
  $prtVMargin=(exists $confs->{prtvmargin}) ? $confs->{prtvmargin} : '3c';
  $prtHMargin=(exists $confs->{prthmargin}) ? $confs->{prthmargin} : '1c';
  $psMedia=(exists $confs->{psmedia}) ? $confs->{psmedia} : '%%DocumentMedia: A4 595 842 white()';
  ($psFile)=(exists $confs->{psfile}) ? <$$confs{psfile}> : ('tred.ps');
  $drawBoxes=(exists $confs->{drawboxes}) ? $confs->{drawboxes} : 0;
  $highlightAttributes=(exists $confs->{highlightattributes}) ? $confs->{highlightattributes} : 1;
  $maximizePrintSize=(exists $confs->{maximizeprintsize}) ? $confs->{maximizeprintsize} : 0;
  $showHidden=exists ($confs->{showhidden}) ? $confs->{showhidden} : 0;
  $createMacroMenu=(exists $confs->{createmacromenu}) ? $confs->{createmacromenu} : 0;
  $maxMenuLines=(exists $confs->{maxmenulines}) ? $confs->{maxmenulines} : 20;
  $useCzechLocales=(exists $confs->{useczechlocales}) ? $confs->{useczechlocales} : ($^O !~ /^MS/);
  $Tk::strictMotif=(exists $confs->{strictmotif}) ? $confs->{strictmotif} : 0;
  $printColors=(exists $confs->{printcolors}) ? $confs->{printcolors} : 0;
  $cstsToFs=(exists $confs->{cststofs}) ? $confs->{cststofs} : undef;
  $fsToCsts=(exists $confs->{fstocsts}) ? $confs->{fstocsts} : undef;
  $gzip=(exists $confs->{gzip}) ? $confs->{gzip} : (-x "/bin/gzip" ? "/bin/gzip -c" : undef);
  $zcat=(exists $confs->{zcat}) ? $confs->{zcat} : (-x "/bin/zcat" ? "/bin/zcat" : $gzip." -c");
  $keyboardDebug=(exists $confs->{keyboarddebug}) ? $confs->{keyboarddebug} : 0;
  $hookDebug=(exists $confs->{hookdebug}) ? $confs->{hookdebug} : 0;
  $macroDebug=(exists $confs->{macrodebug}) ? $confs->{macrodebug} : 0;
  $tredDebug=(exists $confs->{treddebug}) ? $confs->{treddebug} : 0;
  
  $defaultTemplateMatchMethod=(exists $confs->{searchmethod}) ? $confs->{searchmethod} : 'E';
  $defaultMacroListOrder=(exists $confs->{macrolistorder}) ? $confs->{macrolistorder} : 'M';

  $defCWidth=(exists $confs->{canvaswidth}) ? $confs->{canvaswidth} : '18c';
  $defCHeight=(exists $confs->{canvasheight}) ? $confs->{canvasheight} : '12c';

  $geometry=(exists $confs->{geometry}) ? $confs->{geometry} : undef;
  $maxDisplayedValues=(exists $confs->{maxdisplayedvalues}) ? $confs->{maxdisplayedvalues} : 30;
  $maxDisplayedAttributes=(exists $confs->{maxdisplayedattributes}) ? $confs->{maxdisplayedattributes} : 20;

  $lastAction=(exists $confs->{lastaction}) ? $confs->{lastaction} : undef;

  foreach (0..9) {
    @recentFiles[$_]=$confs->{"recentfile$_"};
  }
  @recentFiles=grep {$_} @recentFiles;

  require Filelist;
  my $fl;
  foreach (grep /^filelist[0-9]+/, keys %$confs) {
    print "Reading $_\n";
    $fl=Filelist->new(undef,$confs->{$_});
    next unless $fl;
    $fl->load();
    print STDERR "Reading filelist ".$fl->name." from ".$fl->filename."\n" if $tredDebug;
    addNewFilelist(undef,$fl);
  }

  print STDERR "Applying configuration.\n" if $tredDebug;
}


sub readMacros {
  # This subroutine reads macro file. Macros are usual perl
  # subroutines and may use this program's namespace. They are also
  # provided some special names for certain variables which override
  # the original namespace.

  # Macros may be bound to a keysym with a special form of a comment.
  # The synax is:
  #
  # # bind MacroName to key [[Modifyer+]*]KeySym
  #
  # which causes subroutine MacroName to be bound to keyboard event of
  # simoultaneous pressing the optionally specified Modifyer(s) (which
  # should be some of Shift, Ctrl and Alt) and the specified KeySym
  # (this probabbly depends on platform too :( ).


  my ($file,$keep)=(shift,shift);
  my $macro;
  my $key;
  local *F;
  my @contexts=@_;

  @contexts=("TredMacro") unless (@contexts);
  unless ($keep) {
    %keyBindings=();
    %menuBindings=();
    @macros=();
    print "ERROR: Cannot open macros!\n", return
      unless open(F,"<$defaultMacroFile");
    push @macros, <F>;
  }
  close F;

  print "ERROR: Cannot open macros!\n", return
    unless open(F,"<$file");

#
# new "pragmas":
#
# include <file>
# include "file"
#
# binding-context <context> [<context> [...]]
#
# key-binding-adopt <contexts>
# menu-binding-adopt <contexts>
#
# bind <method> [to] [key[sym]] <key> [menu <menu>[/submenu[/...]]]
#
# insert <method> [as] [menu] <menu>[/submenu[/...]]
#


  while (<F>) {
    push @macros,$_;
    if (/\#[ \t]*binding-context[ \t]+(.*)/) {
      @contexts=(split /[ \t]+/,$1);
    } elsif (/\#[ \t]*key-binding-adopt[ \t]+(.*)/) {
      my @toadopt=(split /[ \t]+/,$1);
      my $context;
      my $toadopt;
      foreach $context (@contexts) {
	$keyBindings{$context}={} unless exists($keyBindings{$context});
	foreach $toadopt (@toadopt) {
	  foreach (keys %{$keyBindings{$toadopt}}) {
	    $keyBindings{$context}->{$_}=$keyBindings{$toadopt}->{$_};
	  }
	}
      }
    } elsif (/\#[ \t]*menu-binding-adopt[ \t]+(.*)/) {
      my @toadopt=(split /[ \t]+/,$1);
      my $context;
      my $toadopt;
      foreach $context (@contexts) {
	$menuBindings{$context}={} unless exists($menuBindings{$context});
	foreach $toadopt (@toadopt) {
	  foreach (keys %{$menuBindings{$toadopt}}) {
	    $menuBindings{$context}->{$_}=$menuBindings{$toadopt}->{$_};
	  }
	}
      }
    } elsif (/\#[ \t]*bind[ \t]+(\w*)[ \t]+(?:to[ \t]+)?(?:key(?:sym)?[ \t]+)?([^ \t\r\n]+)(?:[ \t]+menu[ \t]+(.+))?/)
      {
	$macro=$1;
	$key=uc($2);
	$menu=encode($3);
	#print "binding $key [$menu] => $macro\n";
	foreach (@contexts) {
	  $keyBindings{$_}={} unless exists($keyBindings{$_});
	  $keyBindings{$_}->{$key}="$_"."->"."$macro";
	  if ($menu) {
	    $menuBindings{$_}={} unless exists($menuBindings{$_});
	    $menuBindings{$_}->{$menu}=["$_"."->"."$macro",$key] if ($menu);
	  }
	}
      } elsif (/\#[ \t]*insert[ \t]+(\w*)[ \t]+(?:as[ \t]+)?(?:menu[ \t]+)?(.+)/) {
	$macro=$1;
	$menu=encode($2);
	foreach (@contexts) {
	  $menuBindings{$_}={} unless exists($menuBindings{$_});
	  $menuBindings{$_}->{$menu}=["$_"."->"."$macro",$key] if ($menu);
	}
      } elsif (/\#[[ \t]*include[ \t]+(.+)/) {
	my $mf=$1;
	print STDERR "including $mf\n";
	unless (-f $mf) {
	  $mf=dirname($file).$m1;
	  print STDERR "trying $mf\n";
	  unless (-f $mf) {
	    $mf="$libDir/$1";
	    print STDERR "not found, trying $mf\n";
	  }
	}
	if (-f $mf) {
	  readMacros($mf,1,@contexts);
	} else {
	  print STDERR "Cannot include macros $1: file not found!\n";
	}
      }
  }
  close(F);
}

sub gotoFile {
  my ($grp,$fn,$no_recent)=@_;
  return 0 if doEvalHook($grp,"goto_file_hook") eq 'stop';
  return 0 if ($fn >= $grp->{currentFilelist}->file_count or $fn<0);
#  askSaveFile($grp);
  $grp->{currentFileNo}=$fn;
  openFile($grp,$grp->{currentFilelist}->file_at($grp->{currentFileNo}),$no_recent);
  if ($grp->{Filelist} and
	$grp->{filelistCurrentFilelist} eq $grp->{currentFilelist}) {
    my $path=filelistEntryPath($grp->{currentFilelist},$grp->{currentFileNo});
    $grp->{Filelist}->anchorSet($path);
    $grp->{Filelist}->selectionClear();
    $grp->{Filelist}->selectionSet($path);
  }
  return 1;
}

sub nextFile {
  my ($grp,$no_recent)=@_;
  return gotoFile($grp,$grp->{currentFileNo}+1,$no_recent);
}
sub prevFile {
  my ($grp,$no_recent)=@_;
  return gotoFile($grp,$grp->{currentFileNo}-1,$no_recent);
}

sub resumeFile {
  my ($grp,$fsfile)=@_;
  return unless ref($grp) and ref($fsfile);
  print "Resuming file ".$fsfile->filename."\n";
  closeFile($grp);

  $grp->{FSFile}=$fsfile;
  $grp->{treeNo}=$fsfile->currentTreeNo;
  $grp->{'currentNode'}=$fsfile->currentNode;
  @openfiles=grep { $_ ne $fsfile } @openfiles;
  updatePostponed($grp);
  saveFileStateUpdate($grp);
}

sub closeFile {
  my ($grp,$no_update)=@_;

  $grp->{Nodes}=undef;
  undef $NodeClipboard;
  $grp->{root}=undef;
  $grp->{FSFile}=undef;
  $grp->{treeNo}=undef;
  delete $grp->{'currentNode'} if (exists $grp->{'currentNode'});
  undef %{$grp->{pinfo}} if ($grp->{pinfo});
  $valueLine="";
  unless ($no_update) {
    updateTitle($grp);
    redraw_tree($grp);
  }
}

sub ErrorMessage {
  my ($grp,$msg)=@_;
  if ($grp->{top}) {
    $grp->{top}->toplevel->
      messageBox(-icon => 'error',
		 -message => $msg,
		 -title => 'Error', -type => 'ok');
  } else {
    print STDERR "$msg\n";
  }
}

sub addToRecent {
  my ($grp,$f)=@_;

  if ($f) {
    @recentFiles=grep { $_ ne $f } @recentFiles;
    unshift @recentFiles,rel2abs($f);
  }
  @recentFiles=@recentFiles[0..min($#recentFiles,9)];

  if ($grp->{RecentFileMenu}) {
    my $menu = $grp->{RecentFileMenu}->cget(-menu);
    $menu->delete(0,'end');
    my $i=0;
    foreach (@recentFiles) {
      $grp->{RecentFileMenu}->command(-label  => "$i.  $_",
				      -underline => 0,
				      -command => [\&openFile,$grp,$_]);
      $i++;
    }
  }
}

sub bookmarkThis {
  my ($grp)=@_;
  my $f=undef;
  if (ref($grp->{FSFile})) {
    $f=$grp->{FSFile}->filename()."##".($grp->{treeNo}+1);
    if ($grp->{currentNode}) {
      my $root;
      my $i=0;
      $root=$grp->{FSFile}->treeList->[$grp->{treeNo}];
      while ($root and $root ne $grp->{currentNode}) {
	$i++;
	$root=$root->following();
      }
      $f.=".$i" if ($root);
    }
  }
  return $f;
}

sub addBookmark {
  my ($grp)=@_;
  my $bl=bookmarkFilelist();
  return unless ref($bl);
  my $f=bookmarkThis($grp);
  if (defined($f)) {
    insertToFilelist($grp,$bl,$bl->count,$f);
    updateBookmarks($grp);
  }
}

sub lastActionBookmark {
  my ($grp,$bmk)=@_;
  my $f=defined($bmk) ? $bmk : bookmarkThis($grp);
  if (defined($f)) {
    print STDERR "Bookmarking last action at: $f\n";
    $grp->{lastActionBookmark}=$f;
    updateBookmarks($grp);
  }
}

sub updateBookmarks {
  my ($grp)=@_;

  if ($grp->{BookmarksFileMenu}) {
    print STDERR "Updating bookmark menu\n";
    my $menu = $grp->{BookmarksFileMenu}->menu;
    $menu->delete(0,'end');
    $grp->{BookmarksFileMenu}->command(-label => 'Add to bookmarks',
				       -underline => 0,
				       -command => [ \&addBookmark,$grp ]);
    $grp->{BookmarksFileMenu}->separator();
    if (defined($grp->{lastActionBookmark})) {
      $grp->{BookmarksFileMenu}->command(-label  => "Last action",
					 -underline => 0,
					 -command => [ \&openFile,$grp,$grp->{lastActionBookmark} ]);
    }
    $grp->{BookmarksFileMenu}->separator();
    my $i=0;
    my $bl=bookmarkFilelist();
    return unless ref ($bl);
    foreach (bookmarkFilelist->files()) {
      print STDERR "$_\n";
      $grp->{BookmarksFileMenu}->command(-label  => "$i.  ".$_,
				      -underline => 0,
				      -command => [ \&openFile,$grp,$_ ]);
      $i++;
    }
  }
}

sub updatePostponed {
  my ($grp)=@_;

  if ($grp->{PostponedFileMenu}) {
    print STDERR "Updating session menu\n";
    my $menu = $grp->{PostponedFileMenu}->menu;
    $menu->delete(0,'end');
    $grp->{PostponedFileMenu}->command(-label => 'Kept files',
				       -state => 'disabled',
				       -background => '#444444'
				      );
    my $i=0;
    foreach (@openfiles) {
      $grp->{PostponedFileMenu}->command(-label  => "$i.  ".$_->filename(),
				      -underline => 0,
				      -command => [\&openFile,$grp,$_->filename()]);
      $i++;
    }
    $grp->{PostponedFileMenu}->command(-label => 'none',
				       -state => 'disabled'
				      ) unless (@openfiles);
    $grp->{PostponedFileMenu}->command(-label => 'File lists',
				       -state => 'disabled',
				       -background => '#444444'
				      );

    $i='A';
    foreach (@filelists) { 
      $grp->{PostponedFileMenu}->command(-label  => "$i.  ".$_->name(),
					 -underline => 0,
					 -command => [\&selectFilelist,$grp,$_->name()]);
      $i++;
    }
  }
}

sub updateTitle {
  my ($grp)=@_;
  return unless ref($grp);
  if (defined($grp->{currentFileNo}) and 
      ref($grp->{FSFile}) and
      defined($grp->{currentFilelist})) {
    $grp->{'top'}->title("$appName    ".
			 $grp->{currentFilelist}->name()."(".($grp->{currentFileNo}+1)."/".
			 $grp->{currentFilelist}->file_count()."): ".$grp->{FSFile}->filename()
			);
  } else {
    $grp->{'top'}->title("$appName");
  }
}

sub openFile {
  my ($grp,$f,$no_recent) = @_;
  my $goto = undef;
  my $fs;
  my $gz='';
  my $in1='<';
  my $in2='';
  my %fs=(fs => 'FS format', 
	  fgz => 'gzipped FS format', 
	  any => 'any non-specific format (csts?), using CstsToFs');

  print STDERR "Got openFile $f\n";
  if ($f=~/(##?[0-9A-Z]+(?:\.[0-9]+)?)$/) {
    $f=~s/(##?[0-9A-Z]+(?:\.[0-9]+)?)$//;
      $goto=$1
  }

  askSaveFile($grp,1)
    unless (ref($grp->{FSFile}) and $grp->{FSFile}->filename() eq $f);

  $grp->{top}->Busy(-recurse => 1) unless $insideEval;
  foreach ($grp->{FSFile},@openfiles) {
    if (ref($_) and $_->filename() eq $f) {
      print "Opening postponed file\n";
      resumeFile($grp,$_);

      $grp->{currentFileNo} = max(0,$grp->{currentFileNo});
      insertToFilelist($grp,$grp->{currentFilelist},$grp->{currentFileNo},$f.$goto);
      updateTitle($grp);
      applyFileSuffix($grp,$goto);
      getNodes($grp);
      redraw_tree($grp);
      if ($grp->{currentNode}) {
	centerToXY($grp,0,0);
      }
      doEvalHook($grp,"file_resumed_hook");
      addToRecent($grp,$f) unless $no_recent;
      $grp->{'top'}->Unbusy() unless $insideEval;
      return 2;
    }
  }

  #########################################
  # opening file to find out the file type
  #

  if ($f=~/\.f?gz$/i) {
    $gz='gzipped ';
    $in1="$zcat ";
    $in2=" |";
  }
  unless (open(F,"$in1$f$in2")) {
    ErrorMessage($grp, "Cannot read from $in1$f$in2\n($!)\n");
    $grp->{top}->Unbusy() unless $insideEval;
    return 0;
  } else {
    # peep on the first character
    $fs=($_=<F> and /^\@/) ? 'fs' : 'any';
  }
  close(F);
  #
  ##########################################


  print STDERR "File \'$f\' is in $gz", $fs{$fs},"\n" if $tredDebug;

  if ($fs eq 'any') {
    if ($in1 eq '<') {
      $in1=$cstsToFs." ";
      $in2=" |";
    } else {
      $in2.=$cstsToFs." |";
    }
  }
  print STDERR "Reading from $in1$f$in2\n" if $tredDebug;
  # opening file again, know it is fs
  unless (open(F,"$in1$f$in2")) {
    ErrorMessage($grp,"Cannot read from $in1$f$in2\n($!)\n");
    $grp->{top}->Unbusy() unless $insideEval;
    return 0;
  }

  closeFile($grp,1);

  $grp->{'FSFile'} = FSFile->newFSFile(\*F);
  $grp->{'FSFile'}->changeFilename($f);
  $grp->{'FSFile'}->changeFileFormat($gz.$fs);
  print STDERR "empty or corrupt file!\n" if ($grp->{FSFile}->lastTreeNo<0);


  close (F);

  $grp->{treeNo}=0;

  # add file to filelist
  $grp->{currentFileNo} = max(0,$grp->{currentFileNo});
  insertToFilelist($grp,$grp->{currentFilelist},$grp->{currentFileNo},$f.$goto);
  updateTitle($grp);

  applyFileSuffix($grp,$goto);
  getNodes($grp);
  doEvalHook($grp,"file_opened_hook");
  redraw_tree($grp);
  if ($grp->{currentNode}) {
    centerToXY($grp,0,0);
  }
  $grp->{'top'}->Unbusy() unless $insideEval;

  addToRecent($grp,$f);
  return 1;
}

sub applyFileSuffix {
  my ($grp,$goto) = @_;
  return unless ref($grp) and defined($goto) and $goto ne "";

  # -- smells like PDT-specific code, at least the second case
  # but we want it, dont we:)

  if ($goto=~/^##([0-9]+)/) {
    $grp->{treeNo}=min(max(0,$1-1),$grp->{FSFile}->lastTreeNo);
  } elsif ($goto=~/^#([0-9]+)/) {
    for (my $i=0;$i<=$grp->{FSFile}->lastTreeNo;$i++) {
      $grp->{treeNo}=$i,last if ($grp->{FSFile}->treeList->[$i]->{'form'} eq $1);
    }
  }
  # new: we're the dot in .[0-9]+ (TM)
  my $root;
  if ($goto=~/\.([0-9]+)$/) {
    $root=$grp->{FSFile}->treeList->[$grp->{treeNo}];
    my $i=$1;
    while ($root and $i>0) {
      $i--;
      $root=$root->following();
    }
    $grp->{currentNode}=$root if ($root);
  }
  # hey, caller, you should redraw after this!
}

sub saveFile {
  my $grp=shift;

  return unless $grp->{'FSFile'};

  my $f=$grp->{'FSFile'}->filename;
  my $out="";
  my $of;
  my $gz;

  rename $f,$f."~" if (-f $f);

  if ($grp->{'FSFile'}->fileFormat =~/gzipped/ or $f=~/\.f?gz$/i) {
    if ($gzip) {
      $gz='gzipped ';
      $out.="| $gzip ";
    } else {
      ErrorMessage($grp,"Cannot write gzipped file (No gzip utility defined)\n".
		   "Use file name without the gz suffix to save the file\n".
		   "in a non-gzipped format.\n"
		  );
      return 0;
    }
  }
  if ($grp->{'FSFile'}->fileFormat =~/any/ or $f=~/csts?$|csts?.gz$/i) {
    if ($fsToCsts) {
      $out="| $fsToCsts ".$out;
    } else {
      ErrorMessage($grp,"Cannot export to CSTS file (No option FsToCsts defined)\n".
		   "Use file name without the csts suffix to save the file\n".
		   "in a FS or gzipped FS format.\n"
		  );
      return 0;
    }
  }
  unless (open(FO,"$out> $f")) {
    ErrorMessage($grp,"Cannot write to '$out > $f'\n($!)\n");
    return 0;
  }

  print STDERR "Writing to $out> $f\n" if $tredDebug;

  $grp->{FSFile}->writeTo(\*FO);

  close(FO);
  saveFileStateUpdate($grp);
  #print STDERR "wrote $f, $f~ is a backup.\n";
}

sub isShown { # test if node is shown (always 1 if $showHidden)
  my ($grp,$node,$show)=@_;
  $show=$showHidden unless defined $show;

  return 0 unless ($node and $grp->{'FSFile'});
  return 1 if $show or not defined($grp->{FSFile}->FS->hide());
  while ($node and ($node->{$grp->{FSFile}->FS->hide()} ne 'hide')) {
    $node=$node->parent;
  }
  return ($node ? 0 : 1)
}

sub HNext { # same as Next but obey $showHidden
  my ($grp,$node,$top) = @_;
  $node=Next($node,$top);
  while ($node) {
    return $node if (isShown($grp,$node));
    $node=Next($node,$top);
  }
  return 0;
}

sub HPrev { # same as Next but obey $showHidden
  my ($grp,$node,$top) = @_;
  $node=Prev($node,$top);
  while ($node) {
    return $node if (isShown($grp,$node));
    $node=Prev($node,$top);
  }
  return 0;
}

sub getValueLine {
  my ($grp)=@_;
  return unless $grp->{'FSFile'};

  my $node=$grp->{root};
  my @sent=();

  #$valueLine="";

  my $attr=$grp->{FSFile}->FS->sentord;
  while ($node) {
    push @sent,$node unless $node->{$attr}>=999; # this is TR specific
    $node=Next($node);
  }
  my $defs = join ",", values %{$grp->{FSFile}->FS->defs};

  # this is a workaround for TR vs. ATS (ATS trees use only @N to sort
  # @V to a sentence while on TR there is @W defined for this purpose)
  $attr=$grp->{FSFile}->FS->order unless ($defs=~/W/);

  @sent = sort { $a->{$attr} <=> $b->{$attr} } @sent;

  $attr=$grp->{FSFile}->FS->value;
  $valueLine = 
    ($grp->{treeNo}+1)."/".($grp->{FSFile}->lastTreeNo+1).": ".
    encode(join(" ", map { $_->{$attr} } @sent));
  undef @sent;
}


sub getNodes {
# prepare value line and @nodes list with deleted/saved hidden
# and ordered by real Ord

  my ($grp)=@_;
  return unless $grp->{FSFile};
  $grp->{Nodes}=[];
  my @unsorted=();
  $grp->{treeNo}=0 if ($grp->{treeNo}<0);
  $grp->{treeNo}=$grp->{FSFile}->lastTreeNo if ($grp->{treeNo}>$grp->{FSFile}->lastTreeNo);
  $grp->{root}=$grp->{FSFile}->treeList->[$grp->{treeNo}];
  my $node=$grp->{root};
  my $current=$grp->{root};
  my $prevcurrent=$grp->{currentNode};

#  use Benchmark;
#  my $t=timeit(100, 'getValueLine($grp);');
#  print "$count loops of getNodes took: ",timestr($t),"\n";
  getValueLine($grp);

  while($node)
  {
    push @unsorted, $node;
    $current=$node if ($prevcurrent eq $node);
    $node=HNext($grp,$node);  #skip also hidden subtrees unless showHidden

  }
  $grp->{'currentNode'}=$current;
  my $ord=$grp->{FSFile}->FS->order;
  @{$grp->{Nodes}}=
    sort { $a->{$ord} <=> $b->{$ord} } 
      @unsorted;

  # just for sure
  undef @unsorted;

  # this is actually a workaround for TR, where two different nodes
  # may have the same Ord
}

############################################################
############################################################
############################################################
# Filelists
############################################################

sub selectFilelist {
  my ($grp,$list_name)=@_;
  my $fl=switchFilelist($grp,$list_name);
  print "Switching filelist to $list_name\n";
  return unless defined($fl);

  if ($fl ne $grp->{currentFilelist}) {
    # save file position in the current file-list
    # before switching
    if (ref($grp->{FSFile}) and
	$grp->{currentFilelist}->position($grp->{FSFile}->filename())>=0) {
      $grp->{currentFilelist}->set_current($grp->{FSFile}->filename());
    }
    $grp->{currentFilelist}=$fl;
  }

  # find current file
  $grp->{currentFileNo}=max(0,$fl->position());
  my $file=$fl->file_at($grp->{currentFileNo});

  print "Setting up file $file, no. $grp->{currentFileNo}\n";

  if (defined($file)) {
    openFile($grp,$file);
  } else {
    askSaveFile($grp,1);
    closeFile($grp);  #emtpy filelist
  }
}

# Find named filelist. Return undef if no such filelist exists
sub findFilelist {
  my ($name)=@_;
  for (@filelists) {
    return $_ if ($_->name eq $name);
  }
  return undef;
}


# this is only a local switch inside the file list dialog window,
# but returns filelist of a given name as a by-product
sub switchFilelist {
  my ($grp,$list_name)=@_;
  return undef unless ref($grp);
  my $fl=undef;
  if (ref($list_name)) {
    $fl=$list_name;
    $list_name=$fl->name();
  }
  return $grp->{filelistCurrentFilelist} 
    if (ref($grp->{filelistCurrentFilelist}) and 
	$list_name eq $grp->{filelistCurrentFilelist}->name);
  $fl=findFilelist($list_name) unless ($fl);
  return undef unless $fl;
  if ($grp->{Filelist}) {
    $grp->{filelistCurrentFilelist}=$fl;
    $fl->expand();
    feedHListWithFilelist($grp,$grp->{Filelist},$fl);
    my $activate=0;
    if (defined($fl->current)) {
      $activate=max(0,$fl->position);
    }
    my $path=filelistEntryPath($fl,$activate);
    $grp->{Filelist}->selectionClear();
    if (defined($path) and $path ne "") {
      $grp->{Filelist}->anchorSet($path);
      $grp->{Filelist}->see($path);
      $grp->{Filelist}->selectionSet($path);
    }
    $grp->{Filelist}->update();
  }
  return $fl;
}


sub createFilelistBrowseEntry {
  my ($grp,$w,$filelistref)=@_;
  my $ll = $w->BrowseEntry
    (
     -label => 'File lists:',
     -variable => $filelistref,
     -browsecmd =>
     [
      sub {
	my ($grp,$list,$l)=@_;
	switchFilelist($grp,$$list);
      },$grp,$filelistref
     ],
     -listcmd =>
     [ sub {
	 my $l=shift;
	 $l->delete(0,'end');
	 foreach (@filelists) {
	   $l->insert(0,$_->name);
	 }
       }]
    );
  $ll->Subwidget('entry')->bind
    ('<Return>',
     [ sub {
	 my ($w, $grp, $fl)=@_;
	 my $text=$w->get;
	 if (defined Index(\@filelists, $text)) {
	   switchFilelist($grp,$text);
	 } else {
	   return unless $text ne "";
	   print "Continuing...$text\n";
	   my $d=$w->toplevel->
	     Dialog(-text => "File-list named $text does not exist.\n".
		    "Do you want to create new filelist or rename current?",
		    -bitmap => 'question',
		    -title => 'Create/Rename?',
		    -buttons => ['Create', 'Rename', 'Cancel']);
	   $d->bind('<Return>', sub { my $w=shift; my $f=$w->focusCurrent;
				      $f->Invoke if ($f and $f->isa('Tk::Button')) } );
	   my $answer=$d->Show();
	   if ($answer eq 'Create') {
	     push @filelists, Filelist->new($text);
	     switchFilelist($grp,$text);
	     updatePostponed($grp);
	   } elsif ($answer eq 'Rename') {
	     my $oldn=$grp->{filelistCurrentFilelist}->name();
	     $grp->{filelistCurrentFilelist}->rename($text);
	     updateBookmarks($grp)
	       if ($oldn eq 'Bookmarks');
	     $$fl=$text;
	     updatePostponed($grp);
	   } else {
	     $$fl=$grp->{filelistCurrentFilelist}->name
	       if ($grp->{filelistCurrentFilelist});
	   }
	 }
       },$grp,$filelistref ]);
  $ll->Subwidget('entry')->Subwidget('entry')->configure(qw/-background white -foreground black/);
  $ll->Subwidget('slistbox')->configure(qw/-background white -foreground black/);
  return $ll;
}

sub getFilelistLinePosition {
  my ($fl,$line)=@_;
  return undef unless ref($fl);
  my ($p,$f)=split /\t/,$line;
  return Index($fl->list_ref,$p);
}

sub insertToFilelist {
  print "Parameters: @_\n";  

  my ($grp,$filelist,$position)=(shift,shift,shift);
  $filelist=$grp->{currentFilelist} unless defined($filelist);
  $position=$grp->{currentFileNo} unless defined($position);
  return unless ref($filelist);


  print "Insert: ",$#_," ",$_[0]," is at position ",$filelist->position($_[0]),"\n";
  return if ($#_==0 and $filelist->position($_[0])>=0);
  # this is the case when we add a file which is actually already there

  my @list=map { rel2abs($_) } @_;
  my $tmp;
  my $toplevel = $grp->{Filelist} ? $grp->{Filelist}->toplevel : $grp->{top};
  @list = map {
    if (-d $_) {
      $tmp=Query($toplevel,"Selection Pattern","Insert pattern for directory $_","*.*");
      $_ = defined($tmp) ? File::Spec->catfile($_,$tmp) : undef;
    }
    $_;
  } @list;
  print "Inserting @list\n";
  $filelist->add($position+1,@list);

  if ($grp->{Filelist} and 
      $grp->{filelistCurrentFilelist} eq $filelist) {
    feedHListWithFilelist($grp,$grp->{Filelist},$filelist);
      $position=max(0,$filelist->position(@_[0]));
    my $path=filelistEntryPath($filelist,$position);

    $grp->{Filelist}->selectionClear();
    print "path is $path";
    if ($grp->{Filelist}->info('exists',$path)) {
      $grp->{Filelist}->anchorSet($path);
      $grp->{Filelist}->selectionSet($path);
      $grp->{Filelist}->see($path);
    }
    # select all files resulting from added patterns
    for (my $i=0 ; $i<$filelist->file_count ; $i++) {
      if (defined(Index(\@_,$filelist->file_pattern($i)))) {
	$grp->{Filelist}->selectionSet(filelistEntryPath($filelist,$i));
      }
    }
  }
}

sub removeFromFilelist {
  my ($grp,$filelist,$position)=(shift,shift,shift);
  $filelist=$grp->{currentFilelist} if not defined($filelist);
  $position=$grp->{currentFileNo} if not defined($position);
  return unless ref($filelist);

  $filelist->remove(@_);
  if ($filelist eq $grp->{currentFilelist}) {
    $grp->{currentFileNo} = min($grp->{currentFileNo},
				$filelist->file_count-1);
  }

  if ($grp->{Filelist} and 
      $grp->{filelistCurrentFilelist} eq $filelist) {
    $position=min($position,$filelist->file_count-1);
    feedHListWithFilelist($grp,$grp->{Filelist},$filelist);
      $grp->{Filelist}->selectionClear();
    my $path;
    $path=$grp->{filelistCurrentFilelist}->list_ref->[$position];
    if ($grp->{Filelist}->info('exists',$path)) {
      $grp->{Filelist}->anchorSet($path);
      $grp->{Filelist}->selectionSet($path);
      $grp->{Filelist}->see($grp->{Filelist}->info('anchor'));
    }
  }
}

sub addNewFilelist {
  my ($grp,$fl)=@_;
  for (@filelists) {
    if ($_->name eq $fl->name) {
      print STDERR "Filelist ",$fl->name," already exists, replacing!\n"
	if $tredDebug;
      @{ $_->list_ref } = $fl->list;
      $_->expand;
      if ($grp) {
	$grp->{filelistCurrentFilelist}=undef;
	switchFilelist($grp,$_);
      }
      undef $fl;
      return;
    }
  }
  push @filelists, $fl;
  if ($grp) {
    switchFilelist($grp,$fl);
    updatePostponed($grp);
  }
}

sub filelistEntryPath {
  my ($fl,$index) = @_;
  return undef unless ref($fl);

  my $f = $fl->file_at($index);
  my $p = $fl->file_pattern($index);
  return $f eq $p ? $f : "$p\t$f";
}

sub feedHListWithFilelist {
  my ($grp,$hl,$fl)=@_;
  return unless ref($hl) and ref($fl);
  $hl->delete('all');
  my $pat;
  my $f;
  for(my $i=0;$i<$fl->file_count;$i++) {
    $pat=$fl->file_pattern($i);
    $f=$fl->file_at($i);
    next unless defined($pat) and defined($f);
    if ($pat eq $f) {
      $hl->add($f,
	       -itemtype => 'imagetext',
	       -image => $grp->{fileImage},
	       -data => $f,
	       -text => $f);
      next;
    }
    unless ( $hl->info('exists', $pat) ) {
      $hl->add("$pat",
	       -itemtype => 'imagetext',
	       -image => $grp->{folderImage},
	       -data => $pat,
	       -text => $pat);
    }
    $hl->add("$pat\t$f",
	     -itemtype => 'imagetext',
	     -image => $grp->{fileImage},
	     -data => $f,
	     -text => $f);
  }
}

sub filelistDialog {

  use Tk::LabFrame;

  my ($grp,$modal)=@_;
  if (defined($grp->{Filelist})) {
    if ($modal) {
      ShowDialog($grp->{Filelist}->toplevel);
    } else {
      $grp->{Filelist}->toplevel->deiconify;
      $grp->{Filelist}->toplevel->focus;
      $grp->{Filelist}->toplevel->raise;
    }
    return;
  }
  return if ($grp->{Filelist});
  my $filelist;
  $grp->{filelistCurrentFilelist}=$filelist=$grp->{currentFilelist};
  $filelist=$grp->{filelistCurrentFilelist}->name;
  my $d = $grp->{'top'}->Toplevel(-title => "Filelist");
  $d->withdraw;
  $grp->{'filelistDialog'}=$d;

  my $frame=$d->Frame();
  my $labframe=$frame->LabFrame(-label => 'Files to add',
				-labelside => 'acrosstop'
			       )->pack(qw/-expand yes -fill both -side left/);
  my $fl = $labframe->MyFileSelect(-selectmode => extended,
				   -filetypes => \@open_types)
    ->pack(qw/-expand yes -fill both -side left -padx 5 -pady 5/);

  $fl->Subwidget('filelist')->configure(qw/-background white -foreground black/);

  my $midframe=$frame->Frame()->pack(qw/-side left/);

  my $lframe=$frame->Frame()->pack(qw/-expand yes -fill both -side left -padx 5 -pady 5/);
  my $ll = createFilelistBrowseEntry($grp,$lframe,\$filelist);

  $ll->pack(qw/-expand yes -fill both -side top/);
  my $t = $lframe->Scrolled(qw/HList -relief sunken 
                     -selectmode extended
                     -width 60
                     -background white
		     -height 15 -scrollbars e/,
			    -separator => "\t"
			   )
    ->pack(qw/-expand yes -fill both -side top/);
  $grp->{Filelist}=$t;
  feedHListWithFilelist($grp,$t,$grp->{currentFilelist});

  $frame->pack(qw/-expand yes -fill both -side top/);

  my $addbutton=
    $midframe->Button(-text => 'Add -->',
	       -command=>[
			  sub {
				my ($grp,$t,$l)=@_;
				insertToFilelist($grp,
						 $grp->{filelistCurrentFilelist},
						 getFilelistLinePosition($grp->{filelistCurrentFilelist},
									 $t->info('anchor')),
						 $l->getSelectedFiles
						 );
				updateBookmarks($grp)
				  if (ref($grp->{filelistCurrentFilelist}) and
				      $grp->{filelistCurrentFilelist}->name eq 'Bookmarks');
			      },$grp,$t,$fl])->pack(-side => top);
  my $addbutton=
    $midframe->Button(-text => 'Remove',
	       -command=>[
			  sub { 
				my ($grp,$t)=@_;
				removeFromFilelist($grp,
						   $grp->{filelistCurrentFilelist},
						   getFilelistLinePosition($grp->{filelistCurrentFilelist},
									   $t->info('anchor')),
						   $t->info('selection'));
				updateBookmarks($grp)
				  if (ref($grp->{filelistCurrentFilelist}) and
				      $grp->{filelistCurrentFilelist}->name eq 'Bookmarks');
			      },$grp,$t])->pack(-side => top);

  unless ($modal) {
    $t->bind('<Return>' => [
			    sub {
			      my ($w,$grp)=@_;
			      my $anchor=$grp->{Filelist}->info('anchor');
			      my $nextentry=$grp->{Filelist}->info('next',$anchor);
			      unless ($nextentry and
					$grp->{Filelist}->info('parent',$nextentry) eq $anchor) {
				$grp->{filelistCurrentFilelist}->
				  set_current($grp->{Filelist}->
					      info('data',$grp->{Filelist}->info('anchor')));
				selectFilelist($grp,$grp->{filelistCurrentFilelist});
			      }
			    },$grp]);
    $t->bind('<Double-1>' => [
			      sub {
				my ($w,$grp)=@_;
				my $anchor=$grp->{Filelist}->info('anchor');
				my $nextentry=$grp->{Filelist}->info('next',$anchor);
				my $data=$grp->{Filelist}->info('data',$anchor);
				if ($nextentry and
					$grp->{Filelist}->info('parent',$nextentry) eq $anchor) {
				  # pattern -> edit
				  my $position=
				    $grp->{filelistCurrentFilelist}->find_pattern($data);
				  $data=Query($grp->{Filelist}->toplevel,"Selection Pattern",
					"Edit directory pattern for $data",$data);
				  if (defined($data)) {
				    print "Removing ",$grp->{Filelist}->info('data',$anchor),"\n";
				    $grp->{filelistCurrentFilelist}->remove($grp->{Filelist}->info('data',$anchor));
				    print "Adding $data\n";
				    $grp->{filelistCurrentFilelist}->add($position,$data);
				    feedHListWithFilelist($grp,$grp->{Filelist},$grp->{filelistCurrentFilelist});
				  }
				} else {
				  # file -> go to
				  $grp->{filelistCurrentFilelist}->set_current($data);
				  selectFilelist($grp,$grp->{filelistCurrentFilelist});
				}
			      },$grp ]);
    $d->Button(-text => 'Go',
	     -command => [ sub {
			     my ($grp)=@_;
			     $grp->{filelistCurrentFilelist}->
			       set_current($grp->{Filelist}->
					   info('data',$grp->{Filelist}->info('anchor')));
			     selectFilelist($grp,$grp->{filelistCurrentFilelist});
			   },$grp ])->pack(-padx=>'0.5c',-pady=>'0.2c',-side=>left);
  }
  $d->bind('<Destroy>' => [sub { shift;
				 my $grp=shift;
				 $grp->{Filelist}=undef;
				 $grp->{filelistCurrentFilelist}=undef;
			       },$grp ]);
  $d->bind('all','<Escape>' =>
	   [sub { shift;
		  $modal ?
		    shift->{'selected_button'} = "Cancel" :
		      shift->destroy();
		},$d ]);

  $d->Button(-text => 'Close',
	     -command => [sub {
			    $modal ?
			      shift->{'selected_button'} = "Cancel" :
				shift->destroy();
			  },$d ])
    ->pack(-padx=>'0.5c',-pady=>'0.2c',-side=>right);

  $d->Button(-text => 'Save',
	     -command => [sub {
			    my ($grp,$d)=@_;
			    my $file=$grp->{filelistCurrentFilelist}->filename;
			    unless (defined ($file)  and $file ne "") {
			      my $initdir=dirname($file);
			      $initdir=cwd if ($initdir eq './');
			      $file = $d->getSaveFile(-filetypes => 
								 [["Filelists",           ['.fl']]],
								 -title => "Save filelist as ...",
								 -initialdir => $initdir,
								 -initialfile => filename($file));
			      $d->deiconify;
			      $d->focus;
			      $d->raise;
			      return unless (defined $file and $file ne "");
			      $grp->{filelistCurrentFilelist}->filename($file);
			    }
			    $grp->{filelistCurrentFilelist}->save;
			  },$grp,$d ])
    ->pack(-padx=>'0.5c',-pady=>'0.2c',-side=>right);

  $d->Button(-text => 'Load',
	     -command => [sub {
			    my ($grp,$d)=@_;
			    $file = $d->getOpenFile(-filetypes => 
						    [["Filelists",           ['.fl']]],
						    -title => "Load filelist ...");
			    $d->deiconify;
			    $d->focus;
			    $d->raise;
			    return unless (defined $file and $file ne "");
			    my $fl=Filelist->new(undef,$file);
			    return unless $fl;
			    $fl->load();
			    addNewFilelist($grp,$fl);
			  },$grp,$d ])
    ->pack(-padx=>'0.5c',-pady=>'0.2c',-side=>right);

  if ($grp->{currentFileNo}) {
    my $path=filelistEntryPath($grp->{filelistCurrentFilelist},$grp->{currentFileNo});
    $t->anchorSet($path);
    $t->selectionClear();
    $t->selectionSet($path);
    $t->see($path);
  }
  $t->focus;
  if ($modal) {
    ShowDialog($d);
    $d->destroy();
    return $filelist;
  } else {
    $d->Popup;
    return $filelist;
  }

}

sub generateSortedMacroTable {
  my ($grp)=@_;
  @macroTable = map { [ 
		       $_,
		       $menuBindings{$grp->{macroContext}}->{$_}->[1],
		      ] } keys %{$menuBindings{$grp->{macroContext}}};
  if ($grp->{macroListOrder} eq 'K') {
    return sort {
      my @a= split '\+',$a->[1];
      my @b= split '\+',$b->[1];
      return $#a <=> $#b if ($#a != $#b);
      return length($a[0]) cmp length($b[0]) if (length($a[0]) ne length($b[0]));
      return $a[0] cmp $b[0] if ($a[0] ne $b[0]);
      return length($a[1]) cmp length($b[1]) if (length($a[1]) ne length($b[1]));
      return $a[1] cmp $b[1] if ($a[1] ne $b[1]);
      return length($a[2]) cmp length($b[2]) if (length($a[2]) ne length($b[2]));
      return $a[2] cmp $b[2] if ($a[2] ne $b[2]);
      return length($a[3]) cmp length($b[3]) if (length($a[3]) ne length($b[3]));
      return $a[3] cmp $b[3] if ($a[2] ne $b[3]);
      return $a cmp $b;
    } @macroTable;
  } else {
    return sort { $a->[0] cmp $b->[0] } @macroTable;
  }
}

sub macrolistCreateItems {
  my ($grp,$t)=@_;
  $t->delete('all');
  foreach my $entry (generateSortedMacroTable($grp)) {
    $e = $t->addchild("");
    $t->itemCreate($e, 0, -itemtype=>'text', -text=>$entry->[0]);
    $t->itemCreate($e, 1, -itemtype=>'text', -text=>$entry->[1]);
  }
}

sub macrolistDialog {
  my $grp=shift;
  my $context=$grp->{macroContext};
  if ($grp->{Macrolist}) {
    $grp->{Macrolist}->deiconify;
    $grp->{Macrolist}->focus;
    $grp->{Macrolist}->raise;
    return;
  }
  unless (scalar(keys %{$menuBindings{$context}})) {
    ErrorMessage($grp,"No named macros in current context ($context)");
    return;
  }
  my $d = $grp->{'top'}->Toplevel(-title => "List of available named macros");
  $d->withdraw;
  $d->resizable(0,1);
  my $t = $d->Scrolled(qw/HList -columns 2 -background white 
           -selectmode browse
           -height 25 -relief sunken -scrollbars e/);
  $grp->{Macrolist}=$d;
  my $e;
  my $maxw=0;
  macrolistCreateItems($grp,$t);

  $t->columnWidth(0,'');
  $t->columnWidth(1,'');
  $t->anchorSet('0');

  $t->configure(-width => 0);
  $t->pack(qw/-expand yes -fill both/);
  $d->bind('<Return>' =>
	   [
	    sub {
	      my ($w,$grp,$t)=@_;
	      doEvalMacro($grp,
			  $menuBindings{$context}->
			  {$t->itemCget($t->info('anchor'),0,'-text')}->[0]);
	    },$grp,$t ]);
  $d->bind('<Double-1>' => 
	   [
	    sub {
	      my ($w,$grp,$t)=@_;
	      doEvalMacro($grp,
			  $menuBindings{$context}->
			  {$t->itemCget($t->info('anchor'),0,'-text')}->[0]);
	    },$grp,$t ]);

  my $f=$d->Frame()->pack();
  $f->Radiobutton( -anchor   => 'nw',
		   -text     => 'Sort by name',
		   -variable => \$grp->{macroListOrder},
		   -relief   => 'flat',
		   -command  => [sub { #shift;
				       my ($grp,$t)=@_;
				       macrolistCreateItems($grp,$t);
				     },$grp,$t],
		   -value    => 'M'
		 )->pack(-side => 'left',-padx => 20);
  $f->Radiobutton( -anchor   => 'nw',
		   -text     => 'Sort by keyboard shortcut',
		   -variable => \$grp->{macroListOrder},
		   -relief   => 'flat',
		   -command  => [sub { #shift;
				       my ($grp,$t)=@_;
				       macrolistCreateItems($grp,$t);
				     },$grp,$t],
		   -value    => 'K'
		 )->pack(-side => 'right',-padx => 20);

  $d->Button(-text => 'Run and Close',
	     -command => [ sub {
			     my ($w,$grp,$t)=@_;
			     doEvalMacro($grp,
			       $menuBindings{$context}->
				 {$t->itemCget($t->info('anchor'),0,'-text')}->[0]);
			     $w->destroy();
			   },$d,$grp,$t ])->pack(-padx=>'0.5c',-pady=>'0.2c',-side=>left);
  $d->bind('<Destroy>' => [sub { shift; shift->{Macrolist}=undef; },$grp ]);
  $d->bind('all','<Escape>' =>
	   [sub {
	      shift; shift->destroy();
	    },$d ]);

  $d->Button(-text => 'Close',
		     -command => [ sub {
				     shift->destroy();
				   },$d ])->pack(-padx=>'0.5c',-pady=>'0.2c',-side=>right);
  $t->focus;
  $d->Popup;
}

sub printDialog {
  my $grp=shift;

  return unless $grp->{FSFile};

  my $com=$grp->{'printCommand'};
  my $fil=$grp->{'printPsFile'};
  my $toFile=$grp->{'printToFile'};
  my $toEPS=$grp->{'printToEPS'};
  my $useType1Font=$grp->{'printUseType1Font'};
  my $printRange=$grp->{'printRange'};
  my $snt=$grp->{'printSentenceInfo'};

  my $d = $grp->{'top'}->DialogBox(-title => "Print",
				-buttons => ["OK", "Cancel"]);
  $d->resizable(0,0);
  addBindTags($d,'dialog');
  $d->bind('all','<Escape>' => [sub { shift; shift->{'selected_button'}='Cancel'; },$d ]);
  $d->bind('all','<Tab>',[sub { shift->focusNext; }]);
  $d->bind('all','<Shift-Tab>',[sub { shift->focusPrev; }]);
  my $cf = $d->Frame();
  my $cl = $cf->Label(-text => 'Print command:',
		     -anchor => 'w',
		     -justify => 'right')->pack(-side => 'left');

  my $ce = $cf->Entry(-relief => 'sunken',
		     -width => 20,
		     -font => $font,
		     -textvariable => \$com)->pack(-side => 'left');
  my $defaultBg=$ce->cget('-background');
  my $disabledBg=$d->cget('-background');

  $ce->configure($toFile 
		? (-state => 'disabled',-background => $disabledBg)
		: (-state => 'normal', -background => $defaultBg));


  $cf->pack(-pady => '5m', -side=>'top');
  my $ff=$d->Frame();
  my $fl = $ff->Label(-text => 'File name:',
		     -anchor => 'w',
		     -justify => 'right')->pack(-side => 'left');

  my $fe = $ff->Entry(-relief => 'sunken',
		     -width => 20,
		     -font => $font,
		     -textvariable => \$fil)->pack(-side => 'left');

  $fe->configure($toFile 
		? (-state => 'normal', -background => $defaultBg)
		: (-state => 'disabled',-background => $disabledBg));
  my $of=$d->Frame();
  my $bf=$of->Frame();
  $bf->Checkbutton(-text     => 'Print to file',
		   -variable => \$toFile,
		   -command  => [sub {
				  my ($t,$c,$f)=@_;
				  if ($$t) {
				    $f->focus;
				    $c->configure(-state => 'disabled',
						  -background => $disabledBg);
				    $f->configure(-state => 'normal',
						  -background => $defaultBg);
				  } else {
				    $c->focus;
				    $f->configure(-state => 'disabled',
						  -background => $disabledBg);
				    $c->configure(-state => 'normal',
						  -background => $defaultBg);
				  }
				},\$toFile,$ce,$fe ],
		   -relief   => 'flat')->pack(-fill => 'y',-anchor => 'nw');

  $bf->Checkbutton(-text     => 'Create EPS',
			  -variable => \$toEPS,
			  -relief   => 'flat')->pack(-fill => 'y',-anchor => 'nw');

  $bf->Checkbutton(-text     => 'Use Type1 Postscript Font',
			  -state => $type1font ? 'normal' : 'disabled' ,
			  -variable => \$useType1Font,
			  -relief   => 'flat')->pack(-fill => 'y',-anchor => 'nw');

  $bf->Checkbutton(-text => 'Use colors',
		   -variable => \$printColors,
		   -relief   => 'flat')->pack(-fill => 'y',-anchor => 'nw');
  $bf->Checkbutton(-text => 'Print sentence',
		   -variable => \$snt,
		   -relief   => 'flat')->pack(-fill => 'y',-anchor => 'nw');
  
  $bf->pack(-side => 'right');
  $of->pack(-fill => 'x',-padx=>'1c');
  my $sf = $d->Frame();
  $sf->Label(-text => 'Page range:',
	     -anchor => 'w',
	     -justify => 'right')->pack(-side => 'left');
  $sf->Entry(-relief => 'sunken',
	     -width => 20,
	     -font => $font,
	     -textvariable => \$printRange)->pack(-side => 'left', -padx=>'2m');
  $sf->pack(-side => 'bottom', -pady => '5m');
  $ff->pack(-side => 'bottom', -pady => '5m');

#  $toFile ? $fe->focus : $ce->focus;
  my $result = ShowDialog($d,$toFile ? $fe : $ce,$grp->{top});
  $grp->{'printRange'}=$printRange;
#  $grp->{'printSelection'}= join(' ',grep { $lt->selectionIncludes($_) } (0 .. $lt->size-1));
  $grp->{'printToFile'}=$toFile;
  $grp->{'printToEPS'}=$toEPS;
  $grp->{'printPsFile'}=$fil;
  $grp->{'printSentenceInfo'}=$snt;
  $grp->{'printCommand'}=$com;
  $grp->{'printUseType1Font'}=$useType1Font;
  $d->destroy;
  undef $d;
  return ($result =~ /OK/);
}

sub printThis {
  my ($grp)=@_;
  my $i;
  my $c=$grp->{'canvas'};
  my $saveTreeNo=$grp->{treeNo};
  my $savefont=$font;
  my $pagewidth;
  my $pageheight;
  my $printMultiple;
  my @printList=();
  my %pso;

  if (not printDialog($grp)) {
    #print "Printing aborted!\n";
    return;
  }

  $backgroundColor=$grp->{canvas}->cget('-background');
  {
    local $outputenc='iso-88859-2';
    local ($lineColor, $nodeColor, $currentBoxColor, $boxColor, 
	   $currentNodeColor, $currentNodeWidth, $currentNodeHeight,
	   $nearestNodeColor,
	   $textColor , $textColorShadow, $textColorHilite,
	   $textColorXHilite, $activeTextColor, $noColor)=
	     ($lineColor, $nodeColor, $currentBoxColor, $boxColor, 
	      $nodeColor, $nodeWidth, $currentNodeHeight,
	      $nearestNodeColor,
	      $textColor , $textColorShadow, $textColorHilite, 
	      $textColorXHilite, $activeTextColor,$noColor);

    unless ($printColors) {
      $lineColor='black';
      $nodeColor='white';
      $currentBoxColor='white';
      $boxColor='white';
      $currentNodeColor = 'white';
      $nearestNodeColor= 'white';
      $textColor = 'black';
      $textColorShadow = 'black';
      $textColorHilite = 'black';
      $textColorXHilite = 'black';
      $activeTextColor='black';
      $noColor=1;
    }

    local $backgroundColor='white';
    local $lineWidth=1;
    local $font=$savefont;
    local $drawSentenceInfo=$grp->{printSentenceInfo};

    my $pbeg;
    my $pend;
    foreach (split /,/,$grp->{'printRange'}) {
      print "Parsing $_\n";
      if (/^\s*([0-9]+)\s*$/ and $1<=$grp->{FSFile}->lastTreeNo) {
	print "Prepairing $1\n";
	push @printList,$1;
	next;
      }
      if (/^\s*([0-9]*)\s*-\s*([0-9]*)\s*$/) {
	print "Prepairing $1-$2\n";
	($pbeg,$pend)=($1,$2);
	$pend=$grp->{FSFile}->lastTreeNo+1 if ($pend eq '');
	$pbeg=1 if ($pbeg eq '');
	$pend=min($grp->{FSFile}->lastTreeNo+1,$pend);
	next unless ($pbeg<=$pend);
	push @printList,$pbeg..$pend;
      }
    }
    #  @printList=split ' ',$grp->{'printSelection'};
    push @printList,$grp->{treeNo}+1 unless (@printList);

    unless (open(F,"<$psFontFile")) {
      print STDERR "Aborting: failed to open font file $psFontFile\n";
      return 0;
    }
    if ($grp->{'printToFile'}) {
      #print "Trying to print to ",$grp->{'printPsFile'},"\n";
      return 0 unless open(O,">".$grp->{'printPsFile'});
      #print "File successfully opend!\n";
    } else {
      #print "Trying to print via command ",$grp->{'printCommand'},"\n";
      $SIG{'PIPE'} = sub {};
      return 0 unless open(O, "| ".$grp->{'printCommand'});
      #print "Pipe successfully opend!\n";
    }

    $grp->{top}->Busy(-recurse => 1);

    for (my $t=0;$t<=$#printList;$t++) {
      print "Printing $printList[$t]\n";
      $font=$type1font if ($grp->{printUseType1Font});      
      $printList[$t]!=$grp->{treeNo}+1 ? gotoTree($grp,$printList[$t]-1) : redraw_tree($grp);
      my $rotate = ( ! $grp->{printToEPS} 
	and $grp->{canvasHeight}<$grp->{canvasWidth});
      print $grp->{canvasHeight},"x",$grp->{canvasWidth}," $rotate\n";
      if (not $rotate) {
	$pagewidth=$c->fpixels($prtFmtWidth)-2*$c->fpixels($prtHMargin);
	$pageheight=$c->fpixels($prtFmtHeight)-2*$c->fpixels($prtVMargin);
      } else {
	$pagewidth=$c->fpixels($prtFmtHeight)-2*$c->fpixels($prtVMargin);
	$pageheight=$c->fpixels($prtFmtWidth)-2*$c->fpixels($prtHMargin);
      }

      %pso = (-colormode => $printColors ? 'color' : 'gray',
	      -x => 0, -y => 0,
	      -fontmap => { $font => [$psFontName, $psFontSize] },
	      -width => $grp->{canvasWidth},
	      -height => $grp->{canvasHeight},
	      -rotate => $rotate);

      unless ($grp->{printToEPS}) {
	#print "Maximizing: $maximizePrintSize\n";
	if ($maximizePrintSize or $c->fpixels($grp->{canvasWidth})>$pagewidth or
	    $c->fpixels($grp->{canvasHeight})>$pageheight) {
	  print "Adjusting print size\n";
	  if ($c->fpixels($grp->{canvasWidth})/$pagewidth*$pageheight>$c->fpixels($grp->{canvasHeight})) {
	    #print "Applying width\n";
	    $pso{-pagewidth} =
	      $pagewidth;
	    print "Scaling by tree width,\n";
	    print "forcing box width to $pagewidth\n";
	    #$c->fpixels($prtFmtWidth)-2*$c->fpixels($prtHMargin);
	  } else {
	    #print "Applying height\n";
	    $pso{-pageheight} =
	      $pageheight;
	    print "Scaling by tree height,\n";
	    print "forcing box height to $pageheight\n";
	    #$c->fpixels($prtFmtHeight)-2*$c->fpixels($prtVMargin);
	  }
	}
      }
 
#    $grp->{top}->Busy(-recurse => 1);

      my @ps = split /\n/,$c->postscript(%pso);
      $i=0;
      if ($t>0) {
	$i++  while ($i<=$#ps and $ps[$i]!~/^%%Page:/);
	print O '%%Page: ',$t+1," ",$t+1,"\n";
	my $now=localtime;
	unless ($grp->{printToEPS}) {
	  print O "gsave\n",
	    "/Arial-Medium findfont 8 scalefont setfont\n",
	      "0.000 0.000 0.000 setrgbcolor AdjustColor\n",
		"40 40 [\n",
		  "(".
#		    "File ",$grp->{FSFile}->filename,".    ".
		    "Printed by TrEd on $now.)\n",
		    "] 13 -0 0 0 false DrawText\ngrestore\n";
	}
	$i++;
      } else {
	$i=0;
	print "Lines:",$#ps,"\n";
	unless ($grp->{printToEPS}) {
	  print O $ps[$i++],"\n" while ($i<=$#ps and $ps[$i]!~/^%%BoundingBox:/);
	  #	print "Bounding Box:\n";
	  #	print $ps[$i],"\n";
	  print O $ps[$i++],"\n";
	  print O $psMedia,"\n";
	  print O '%%Pages: ',$#printList+1,"\n";
	  $i++;
	}
	print O $ps[$i++],"\n" while ($i<=$#ps and $ps[$i] !~ /^%%DocumentNeededResources: font Arial-Medium/);
	print O $ps[$i++],"\n" while ($i<=$#ps and $ps[$i]!~/^%%BeginProlog/);
	print O $ps[$i++],"\n";
	print O '%%BeginFont arialm',"\n";
	print O <F>;
	print O '%%EndFont',"\n\n";
	$i++ while ($i<=$#ps and $ps[$i]!~/% StrokeClip/);
	print O $ps[$i++],"\n" while ($i<=$#ps and $ps[$i]!~/^%%IncludeResource: font Arial-Medium/);
	$i++;
      }

      # replacing ISOEncode
      while ($i<=$#ps && $ps[$i]!~/^%%Trailer\w*$/) {
	$ps[$i]=~s/ISOEncode //g;
	print O $ps[$i++],"\n";
      }
    }
    print O '%%EOF',"\n";
    #print "$i: Done.\n";
    close (F);
    close (O);

    #print "$psFile written!\n";
  }

  if ($grp->{treeNo} eq $saveTreeNo) { redraw_tree($grp); }
  else { gotoTree($grp,$saveTreeNo); }
  $grp->{top}->Unbusy();

  return 1;
}


sub switchContext {
  my ($grp,$context)=@_;
  my $prevcontext=$grp->{macroContext};
  return 0 if (doEvalHook($grp,"pre_switch_context_hook",$prevcontext,$context) eq 'stop');
  $grp->{macroContext}=$context;
  doEvalHook($grp,"switch_context_hook",$prevcontext,$context);
  redraw_tree($grp);
}


sub gotoTree {
  my $grp=shift;
  return unless $grp->{'FSFile'};
  my $no = max(0,min(shift,$grp->{FSFile}->lastTreeNo));
  return $grp->{treeNo} if doEvalHook($grp,"goto_tree_hook") eq 'stop';
  return $no if ($no == $grp->{treeNo});
  $grp->{treeNo}=$no;
  getNodes($grp);
  centerToXY($grp,0,0);
  redraw_tree($grp);
  return $no;
}

sub nextTree {
  my ($grp)=@_;
  return unless $grp->{'FSFile'};
  return 0 if ($grp->{treeNo} >= $grp->{FSFile}->lastTreeNo);
  gotoTree($grp,$grp->{treeNo}+1);
  return 1;
}

sub prevTree {
  my ($grp)=@_;
  return 0 if ($grp->{treeNo} <= 0);
  gotoTree($grp,$grp->{treeNo}-1);
  return 1;
}

sub newTree {
  my ($grp)=@_;
  
  my $nr=FSNode->new(); # blessing new root

  splice(@{$grp->{FSFile}->treeList}, $grp->{treeNo}, 0, $nr);

  getNodes($grp);
  centerToXY($grp,0,0);
  redraw_tree($grp);
  return 1;
}

sub newTreeAfter {
  my ($grp)=@_;

  my $nr=FSNode->new(); # blessing new root

  splice(@{$grp->{FSFile}->treeList}, ++$grp->{treeNo}, 0, $nr);

  getNodes($grp);
  centerToXY($grp,0,0);
  redraw_tree($grp);
  return 1;
}

sub pruneTree {
  my ($grp)=@_;

  return unless ($grp->{'FSFile'} and $grp->{FSFile}->treeList->[$grp->{treeNo}]);
  $grp->{root}=$grp->{FSFile}->treeList->[$grp->{treeNo}];
  splice(@{$grp->{FSFile}->treeList}, $grp->{treeNo}, 1);
  DeleteTree($grp->{root});

  $grp->{treeNo}=max(0,min($grp->{treeNo},$grp->{FSFile}->lastTreeNo));
  $grp->{root} = undef;

  getNodes($grp);
  centerToXY($grp,0,0);
  redraw_tree($grp);
  return 1;
}


sub newNode {
  ## Adds new son to current node
  my ($grp)=@_;
  my $parent=$grp->{currentNode};
  return unless ($grp->{'FSFile'} and $parent);

  my $nd=FSNode->new();

  Paste($nd,$parent,$grp->{FSFile}->FS->defs);
  $node->{$grp->{FSFile}->FS->order}=$parent->{$grp->{FSFile}->FS->order};
  setCurrent($grp,$nd);

  getNodes($grp);
  redraw_tree($grp);

  return $nd;
}

sub pruneNode {
  ## Deletes given node
  my ($grp,$node)=@_;
  my $t;
  return undef unless ($grp->{'FSFile'} and $node and $node->parent);

  Paste(Cut($t),$node->parent,$grp->{FSFile}->FS->defs)
    while ($t=$node->firstson);

  setCurrent($grp,$node->parent) if ($node == $grp->{currentNode});
  $t=DeleteLeaf($node);
  getNodes($grp);
  redraw_tree($grp);
  return $t;
}

sub prepareFont {
  my ($grp,$font,$fn)=@_;
  print STDERR "Preparing fonts.\n" if $tredDebug;
  
  if ($$font!~/^-/) {
    my @a=split(/\s*,\s*/,$$font);
    my $option,$value;
    my @b;
    foreach (@a) {
      ($option, $value) = split(/\s*:\s*/, $_, 2);
      push @b, "-".$option, $value if ($option=~/^(?:size|weight|family|slant|underline|overstrike)$/);
    }
      # try
    eval { $grp->{top}->fontDelete($fn) }; 
      # error would be displayed otherwise if yet undefined
      # and I'm lazy to remember or find out how to check
      # :)
    $grp->{top}->fontCreate($fn,@b);
    $$font=$fn;
  }
  #
  # There were problems with the following lines, so I'm skipping them  
  #
  # else {
  #  $grp->{top}->fontCreate('C_normal',$grp->{top}->fontActual($$font));
  #  $$font='C_normal';
  # }
}

sub prepareFonts {
  my $grp=shift;
  prepareFont($grp,\$font,'C_normal');
  prepareFont($grp,\$vLineFont,'C_vline');
}

sub addBindTags {
  my $w=shift @_;
  $w->bindtags([@_,$w,ref($w),$w->toplevel,'all']);

}

sub cascadeMenus {
  my $uM=[ @_[0..min($maxMenuLines-1,$#_)] ];
  my $uuM=$uM;
  $i=$maxMenuLines;
  while ($i<=$#_) {
    $_=[@_[$i..min($i+$maxMenuLines-1,$#_)]];
    push @$uuM,[Cascade => 'More...', -menuitems => $_];
    $uuM=$_;
    $i+=$maxMenuLines;
  }
  return $uM;
}

sub saveFileStateUpdate {
  my ($grp)=@_;
  $grp->{'saveButton'}->
    configure(-image =>
	      ($grp->{FSFile} and $grp->{FSFile}->notSaved)
	      ? $grp->{'normalSavePixmap'} : $grp->{'savedSavePixmap'});
}


sub About {
  my ($grp)=@_;
  my $message="";
  my $fileinfo="";
  my $colinf="";
  if ($grp->{FSFile}) {
    $fileinfo=
      "Current file:\n".
	$grp->{FSFile}->filename."\n".
	  "Format: ".$grp->{FSFile}->fileFormat.", ".$grp->{FSFile}->lastTreeNo." trees\n";
    my %colinf=(Shadow => [], Hilite =>, XHilite => []);
    foreach ($grp->{FSFile}->FS->attributes) {
      push @{$colinf{$grp->{FSFile}->FS->color($_)}},$_
	unless ($grp->{FSFile}->FS->color($_) eq 'normal');
    }
    $colinf="Coloured attributes:\n    Highlited: ".join(",",@{$colinf{Hilite}}).
      "\n    XHighlited: ".join(",",@{$colinf{XHilite}}).
	"\n    Shadow: ".join(",",@{$colinf{Shadow}})."\n";
  }

  doEvalHook($grp,"about_file_hook",\$message);
  my $ver=$version;
  $ver=~s/\$//g;
  $grp->{top}->toplevel->
    messageBox(-icon => 'info',
			  -type => 'ok',
			  -message =>
			  "TrEd $ver\n\n$fileinfo$colinf$message\n$about\n\nLast update: $lastupdate",
			  -title => 'About');
}

sub keyBind {
  local $_=shift;
  s/-/+/g;
  s/Control/CTRL/g;
  return uc($_);
}

sub startMain {
  my $firstFile=shift;
  my $node;
  my $parent;
  my %group;

  $group{top}=MainWindow->new;

  $group{folderImage} = $group{top}->Pixmap(-file => Tk->findINC('folder.xpm'));
  $group{fileImage}   = $group{top}->Pixmap(-file => Tk->findINC('file.xpm'));
  $group{lastActionBookmark} = $lastAction;

  if (defined($geometry)) {
    if ($geometry=~/^(.*)x(.*)\+([0-9]+)\+([0-9]+)/) {
        $geometry
	  = "$1x$2+".min($3,$group{top}->vrootwidth-$1).
	    "+".min($4,$group{top}->vrootheight-$2);
    }
    $group{top}->geometry($geometry);
  }

  $group{macroContext}='TredMacro';
  $group{templateMatchMethod}=$defaultTemplateMatchMethod;
  $group{macroListOrder}=$defaultMacroListOrder;
  print STDERR "Main window created.\n" if $tredDebug;

  if (-f $appIcon) {
    print STDERR "adding icon-image.\n" if $tredDebug;
    $group{top}->iconimage($group{top}->Pixmap(-file => "$appIcon"));
    print STDERR "done.\n" if $tredDebug;
  }

  addBindTags($group{'top'},'my');

  print STDERR "Asking wm for exit-hook.\n" if $tredDebug;

  $group{top}->
    protocol('WM_DELETE_WINDOW' => 
	     [sub { $grp=shift;
		    doEvalHook($grp,"exit_hook");
		    # run user's exit_hook
		    askSaveFiles($grp);
		    closeFile($grp);
		    $grp->{'top'}->destroy;
		    $grp->{'top'}=undef;
		  },\%group]);


  print STDERR "Exit hook created.\n" if $tredDebug;

  $group{Balloon}=$group{'top'}->Balloon(-initwait => 450, -balloonposition => 'mouse',
					-state => 'balloon', -background => '#fff3b0');
  $group{'frame'}=$group{'top'}->Frame;



  print STDERR "Creating menubar.\n" if $tredDebug;


  $group{Menubar}=$group{top}->Frame(-relief => $menubarRelief, -borderwidth => 2);
  $group{Menubar}->pack(qw/-fill x/);
  $group{top}->Frame(-relief => sunken, -height=>2, -borderwidth => 2)->pack(qw/-fill x/);
  addBindTags($group{Menubar},'my');

  $group{FileMenu} = $group{Menubar}->Menubutton(qw/-text File -underline 0/);
  $group{FileMenu}->command(-label=> 'Open ...', -underline => 0,   -command => [\&fileDialog, \%group]);
  $group{FileMenu}->command(-label=> 'Close', -underline => 0, 
			    -command => [ sub {
					    my ($grp)=@_;
					    removeFromFilelist($grp,
							       undef,
							       undef,
							       $grp->{currentFilelist}->list_ref->[$grp->{currentFileNo}]);
					    closeFile($grp);
					  }
					 , \%group]);
  $group{FileMenu}->command(-label => 'File List...', -underline => 5, -command => [\&filelistDialog, \%group]);
#	 [Button => 'New',         -command => [\&menus_error2, 'New']],
  $group{FileMenu}->command(-label => 'Save', -underline => 0, -command => [\&saveFile,\%group]);
  $group{FileMenu}->command(-label => 'Save As ...', -underline => 5 ,-command => [\&saveFileAs, \%group]);
  $group{FileMenu}->separator();
  $group{RecentFileMenu}=$group{FileMenu}->cascade(-label => "Recent Files", -underline => 0);
  my $i=0;
  foreach (@recentFiles) {
    $group{RecentFileMenu}->command(-label  => "$i.  $_",
				    -underline => 0,
				    -command => [\&openFile,\%group,$_]);
    $i++;
  }
#  $group{PostponedFileMenu}=$group{FileMenu}->cascade(-label => "Postponed Files", -underline => 0);

  $group{FileMenu}->separator();
  $group{FileMenu}->command(-label => 'Previous File', -underline => 3, -command => [\&prevFile,\%group]);
  $group{FileMenu}->command(-label => 'Next File', -underline => 0, -command => [\&nextFile,\%group]);
  $group{FileMenu}->separator();
  $group{FileMenu}->command(-label => 'Print ...', -underline => 0, -command => [\&printThis,\%group]);
  $group{FileMenu}->separator();
  $group{FileMenu}->command(-label =>'Edit config file ...', -underline => 0,  -command => [\&editConfig,\%group]);
  $group{FileMenu}->command(-label =>'Reload config ...', -underline => 3, -command => [sub {
							  readConfig();
							  redraw_tree(shift);
							},\%group]);
  $group{FileMenu}->separator();
  $group{FileMenu}->command(-label =>'Quit', -underline => 0, -command => [sub { $grp=shift;
						       askSaveFiles($grp);
						       $grp->{'top'}->destroy;
						    },\%group]);
	
  $group{FileMenu}->pack(qw/-side left/);

  $group{ViewMenu}= $group{Menubar}->Menubutton(qw/-text View -underline 0 -menuitems/ =>
	[
	 [Button => 'Previous Tree',
	  -underline => 0,
	  -command => [\&prevTree,\%group]],
	 [Button => 'Next Tree', -underline => 0, -command => [\&nextTree,\%group]],
	 [Separator => ''],
	 [Checkbutton => 'Draw boxes', -underline => 0,
	   -variable => \$drawBoxes,
	   -command  => [\&redraw_tree,\%group]],
	 [Checkbutton => 'Show Hidden Nodes', -underline => 0,
	  -underline => 5,
	  -variable => \$showHidden,
	  -command  => [sub { getNodes(@_);
			      currentUnhiden(@_);
			      redraw_tree(@_) },\%group]],
	 [Checkbutton => 'Highlight Attributes', -underline => 1,
	  -variable => \$highlightAttributes,
	  -command  => [\&redraw_tree,\%group]],
	 [Checkbutton => 'Sort Attributes in Dialogs', -underline => 1,
	  -variable => \$sortAttrs],
	 [Separator => ''],
	 [Button => 'Customize Attributes ...', -underline => 0,
	  -command => [\&customAttrsDialog,\%group]],
	 [Separator => ''],
	 [Button => 'List of Named Macros ...', -underline => 0,
	  -command => [\&macrolistDialog,\%group]]
	])->pack(qw/-side left/);
  $group{NodeMenu}= $group{Menubar}->Menubutton(qw/-text Node -underline 0 -menuitems/ =>
	[
	 [Button => 'New Node', -underline => 0, -command => [sub {
					       my ($grp)=@_;
					       newNode($grp);
					     },\%group]],
	 [Button => 'Remove Active Node', -underline => 0, -command => [sub {
					       my ($grp)=@_;
					       pruneNode($grp,$grp->{currentNode});
					     },\%group]],
	 [Button => 'Insert New Tree', -underline => 0, -command => [sub {
						      my ($grp)=@_;
						      newTree($grp);
						    },\%group]],
	 [Button => 'Insert New Tree After', -underline => 16, -command => [sub {
						      my ($grp)=@_;
						      newTreeAfter($grp);
						    },\%group]],
	 [Button => 'Remove Whole Current Tree', -underline => 7, -command => [sub {
						      my ($grp)=@_;
						      pruneTree($grp);
						    },\%group]],
	 [Separator => ''],
	 [Button => 'Edit Attributes ...', -underline => 0, -command => [sub {
						      my ($grp)=@_;
						      editAttrsDialog($grp,$grp->{currentNode})
							if ($grp->{currentNode});
						    },\%group]],
	 [Separator => ''],
	 [Button => 'Find ...', -underline => 0,-command => [sub {
					      my ($grp,$template)=@_;
					      findNodeDialog($grp,$template)
						if ($grp->{currentNode});
					    },\%group,\%searchTemplate]],
	 [Button => 'Find Next', -underline => 7,
	  -command => [\&doFindFirstTemplated,\%group,\%searchTemplate,1]],
	 [Button => 'Find Previous', -underline => 5,
	  -command => [\&doFindPrevTemplated,\%group,\%searchTemplate,1]]

	])->pack(qw/-side left/);
  print STDERR "Creating user menu.\n" if $tredDebug;


  $group{PostponedFileMenu} = $group{Menubar}->Menubutton(qw/-text Session -underline 0/)
    ->pack(qw/-side left/);
  updatePostponed(\%group);

  $group{BookmarksFileMenu} = $group{Menubar}->Menubutton(qw/-text Bookmarks -underline 0/)
    ->pack(qw/-side left/);
  updateBookmarks(\%group);


  $group{ContextsMenu}=$group{Menubar}->
    Optionmenu(-textvariable => \$group{macroContext},
	       -command => [sub { my $grp=shift;
				  switchContext($grp,$grp->{macroContext}); },\%group],
	       -relief => 'groove', #$menubarRelief,
	       -borderwidth => 2,
	       -options => [sort(keys(%keyBindings))])->pack(qw/-side right/);
  my $cM=[];
  if ($createMacroMenu) {
    push @$cM, 
      @{cascadeMenus(map { $keyBindings{TredMacro}->{$_}=~/$context\-\>(.*)/;
			   [Button => $1,
			    -command => [\&doEvalMacro,\%group,$keyBindings{TredMacro}->{$_}],
			    -accelerator => "($_)"
			   ]
			 } sort(keys(%{$keyBindings{TredMacro}})))};

    foreach my $context (sort(keys(%keyBindings))) {
      if ($context ne "TredMacro") {
	push @$cM, 
	  [Cascade => $context,
	   -menuitems =>
	   cascadeMenus(map { $keyBindings{$context}->{$_}=~/(?:$context\-\>)?(.*)/;
			      [Button => $1,
			       -command => [\&doEvalMacro,\%group,$keyBindings{$context}->{$_}],
			       -accelerator => "($_)"
			      ]
			    } sort(keys(%{$keyBindings{$context}})))];
      }
    }

    $group{MacroMenu}=$group{Menubar}->
      Menubutton(qw/-text Shortcuts -underline 0 -menuitems/ =>
		 $cM)->pack(qw/-side left/);
  }

  $cM=[];
  push @$cM,
    @{cascadeMenus(map ([Button => $_,
			 -command => [\&doEvalMacro,\%group,$menuBindings{TredMacro}->{$_}->[0]],
			 ($menuBindings{TredMacro}->{$_}->[1]) ?
			 (-accelerator => "(".$menuBindings{TredMacro}->{$_}->[1].")") : ()],
			sort(keys(%{$menuBindings{TredMacro}}))))};

  foreach my $context (sort(keys(%menuBindings))) {
   if ($context eq "TredMacro") { 
   } else {
        push @$cM,
  	[Cascade => $context,
  	 -menuitems =>
  	 cascadeMenus(map ([Button => $_,
  			    -command => [\&doEvalMacro,\%group,$menuBindings{$context}->{$_}->[0]],
  			    ($menuBindings{$context}->{$_}->[1]) ?
  			    (-accelerator => "(".$menuBindings{$context}->{$_}->[1].")") : ()],
  			   sort(keys(%{$menuBindings{$context}}))))];
      }
  }
  $group{UserMenu}=$group{Menubar}->
    Menubutton(qw/-text User-defined -underline 0 -menuitems/ =>
	       $cM)->pack(qw/-side left/);




  addBindTags($group{'frame'},'my');
  my $canvas = $group{'top'}->Scrolled('Canvas', -width => $defCWidth,
				       -height => $defCHeight, 
				       qw /-relief sunken
			                   -borderwidth 2 -scrollbars se/, -scrollregion =>
				       [qw/0c 0c 100c 100c/],
				       $backgroundColor ? (-background => $backgroundColor) : ());


  $group{HelpMenu}= $group{Menubar}->Menubutton(qw/-text Help -underline 0 -menuitems/ =>
	[
	 [Button => 'About', -underline => 0, -command => [\&About,\%group]]])->pack(qw/-side left/);

  addBindTags($canvas->Subwidget('scrolled'),'canvas');
  prepareFonts(\%group);

  print STDERR "Creating canvas.\n" if $tredDebug;

  $group{'valueLine'}=$group{'top'}->Scrolled(qw/Entry -state disabled -relief sunken
			   -borderwidth 2 -scrollbars s/, -font => $vLineFont, -textvariable => \$valueLine);

  $group{'canvas'}=$canvas;
  addBindTags($canvas,'my');

  # creating Canvas balloon
  $group{CanvasBalloon}=$group{top}->Balloon(-initwait => $canvasBalloonInitWait,
					     -state => 'balloon',
					     -background => '#fff3b0');
  $group{CanvasBalloon}->Subwidget('message')->configure(-justify => 'left',-font => $font);
  
  print STDERR "Creating buttons.\n" if $tredDebug;

  $group{'nextButton'}=$group{'frame'}->Button(-text => "Next",
					       -relief => $buttonsRelief,
					       -image => $group{top}->Pixmap(-file =>
									     "$libDir/right.xpm"),
					       -borderwidth => $buttonBorderWidth,

			    -command => [sub { nextTree(@_) },\%group]);
  $group{Balloon}->attach($group{'nextButton'},
		 -balloonmsg => "see the next tree");
  addBindTags($group{'nextButton'},'my');
  $group{'prevButton'}=$group{'frame'}->Button(-text => "Prev",
					       -relief => $buttonsRelief,
					       -image => $group{top}->Pixmap(-file =>
									     "$libDir/left.xpm"),
					       -borderwidth => $buttonBorderWidth,
					       -command => [sub { prevTree(@_) },\%group]);
  $group{Balloon}->attach($group{prevButton},
		 -balloonmsg => "see the previous tree");
  addBindTags($group{'prevButton'},'my');

  $group{'openButton'}=$group{'frame'}->Button(-text => "Open",
					       -relief => $buttonsRelief,
					       -image       => $group{top}->Pixmap(-file => "$libDir/fileopen.xpm"),
					       -borderwidth => $buttonBorderWidth,
			 -command => [sub { fileDialog(@_) },\%group])->pack(-side=>'left',-padx=>'1');
  $group{Balloon}->attach($group{openButton},
		 -balloonmsg => "open file");
  addBindTags($group{'openButton'},'my');
  $group{'normalSavePixmap'}=$group{top}->Pixmap(-file =>"$libDir/filefloppy.xpm");
  $group{'savedSavePixmap'}=$group{top}->Pixmap(-file =>"$libDir/filesaved.xpm");
  $group{'saveButton'}=
    $group{'frame'}->Button(-text => "Save",
			    -relief => $buttonsRelief,
			    -image => $group{'savedSavePixmap'},
			    -borderwidth => $buttonBorderWidth,
			    -command => [sub {
					   saveFile(@_)
					 },\%group])->pack(-side=>'left',-padx=>'1');

  $group{Balloon}->attach($group{saveButton},
			  -balloonmsg => "save current file");
  addBindTags($group{'saveButton'},'my');

  $group{'prevFileButton'}=
    $group{'frame'}->Button(-text => "Prev file",
			    -relief => $buttonsRelief,
			    -image => $group{top}->Pixmap(-file =>
							  "$libDir/start.xpm"),
			    -borderwidth => $buttonBorderWidth,
			    -command => [sub { prevFile(@_); },\%group])->pack(-side=>'left',
									       -padx=>'1');
  $group{Balloon}->attach($group{prevFileButton},
			  -balloonmsg => "visit the previous open file");
  addBindTags($group{'prevFileButton'},'my');

  $group{'nextFileButton'}=
    $group{'frame'}->Button(-text => "Next file",
			    -relief => $buttonsRelief,
			    -image => $group{top}->Pixmap(-file =>
							  "$libDir/finish.xpm"),
			    -borderwidth => $buttonBorderWidth,
			    -command => [sub { nextFile(@_); },\%group])->pack(-side=>'left',
									       -padx=>'1');
  $group{Balloon}->attach($group{nextFileButton},
		 -balloonmsg => "visit the next open file");
  addBindTags($group{'nextFileButton'},'my');


  $group{'printButton'}=
    $group{'frame'}->Button(-text => "Print",
			    -relief => $buttonsRelief,
			    -image       => $group{top}->Pixmap(-file =>
								"$libDir/fileprint.xpm"),
			    -borderwidth => $buttonBorderWidth,
			    -command => [sub { printThis(@_) },\%group])->pack(-side=>'left',
									       -padx=>'1');
  $group{Balloon}->attach($group{printButton},
		 -balloonmsg => "print ...");
  addBindTags($group{'printButton'},'my');

  $group{'findButton'}=
    $group{'frame'}->Button(-text => "Find",
			    -relief => $buttonsRelief,
			    -image       => $group{top}->Pixmap(-file =>
								"$libDir/find.xpm"),
			    -borderwidth => $buttonBorderWidth,
			    -command => [sub {
					   my ($grp,$template)=@_;
					   findNodeDialog($grp,$template)
					     if ($grp->{currentNode});
					 },\%group,\%searchTemplate])->pack(-side=>'left',
									    -padx=>'1');
  $group{Balloon}->attach($group{findButton},
		 -balloonmsg => "Find node ...");
  addBindTags($group{'findButton'},'my');

  $group{'findNextButton'}=
    $group{'frame'}->Button(-text => "Find Next",
			    -relief => $buttonsRelief,
			    -image       => $group{top}->Pixmap(-file =>
								"$libDir/findnext.xpm"),
			    -borderwidth => $buttonBorderWidth,
			    -command => [\&doFindFirstTemplated,\%group,\%searchTemplate,1])
      ->pack(-side=>'left', -padx=>'1');
  $group{Balloon}->attach($group{findNextButton},
		 -balloonmsg => "Find next ...");
  addBindTags($group{'findNextButton'},'my');


  $group{'findPrevButton'}=
    $group{'frame'}->Button(-text => "Find Previous",
			    -relief => $buttonsRelief,
			    -image => $group{top}->Pixmap(-file =>
								"$libDir/findprev.xpm"),
			    -borderwidth => $buttonBorderWidth,
			    -command => [\&doFindPrevTemplated,\%group,\%searchTemplate,1])
      ->pack(-side=>'left', -padx=>'1');
  $group{Balloon}->attach($group{findPrevButton},
		 -balloonmsg => "Find previous ...");
  addBindTags($group{'findPrevButton'},'my');


  $group{'frame'}->Frame()->pack(-side => 'left', -padx =>'10');
  $group{'prevButton'}->pack(-side => 'left', -padx =>'1');
  $group{'nextButton'}->pack(-side => 'left', -padx => '1');




  $group{'attrButton'}=
    $group{'frame'}->Button(-text => "Attributes",
			    -relief => $buttonsRelief,
			    -image => $group{top}->Pixmap(-file =>
							  "$libDir/tick.xpm"),
			    -borderwidth => $buttonBorderWidth,
			    -command => [sub { customAttrsDialog(@_) },\%group])->pack(-side=>'right',
										 -padx=>'1');
  $group{Balloon}->attach($group{attrButton},
		 -balloonmsg => "select visible attributes");

  print STDERR "Packing widgets.\n" if $tredDebug;


  $group{'frame'}->pack(-fill => 'x', -padx => '1', -pady => 1);
  $group{'valueLine'}->pack(qw/-fill x/);
  $group{'canvas'}->pack(qw/-expand yes -fill both/);
  addBindTags($group{'canvas'},'my');
  #  $group{'contextLed'}->pack(-side => 'bottom');
  
  print STDERR "Binding keystrokes...\n" if $tredDebug;
  #  $group{'frame'}->bind('my','<Control-x><KeyPress>' =>
  #			[sub { evalMacro(@_); Tk->break; }, \%group, 'CTRL-X+' ]);
  $group{'Menubar'}->bind('Menubutton','<Escape>', sub { shift->Leave(); } );
  $group{'frame'}->
    bind('my','<Alt-KeyPress>' =>
	 [sub { 
	    if (defined(evalMacro(@_))) {
	      Tk->break;
	    } else {
	      # Actually, this should work by it self. And it realy
	      # does, but not under windows :-) Well, do not laugh,
	      # too early, Linux users. With menu (not menubutton)
	      # this is the same there, only vice versa.
	      my ($w,$grp,$mod)=@_;
	      my $mbar=$grp->{Menubar};
	      foreach my $child ($mbar->children) {
		if ($child->class eq 'Menubutton' and $child->FindMenu($w->XEvent->K)) {
		  $child->ButtonUp() if ($^O eq "MSWin32"); 
		  # This ButtonUp is needed for some reason under
		  # Windows, otherwise the button remains active even
		  # when you leave the window! Window$ realy suck!!!!
		  last;
		}
	      }
	      Tk->break;
	    }
	  }, \%group,'ALT+']);

  $group{'frame'}->bind('my','<KeyPress>' =>
			[sub { evalMacro(@_); Tk->break; }, \%group, '' ]);

  foreach (qw(Shift Control Meta Control-Shift Control-Alt
              Control-Meta Alt-Shift Meta-Shift)) {
    foreach my $event (qw(KeyPress Right Left Up Down Return comma period Next Prior greater less)) {
      $group{'frame'}->bind('my',"<$_-$event>" =>
			    [sub { evalMacro(@_); Tk->break; }, \%group, keyBind($_)."+"]);
    }
  }
  #  $group{'frame'}->bind('all','<Tab>' => [sub {1;}]);
  #  $group{'top'}->bind('dialog','<Tab>' => [sub { shift->focusNext(); }] );
  #  $group{'top'}->bind('dialog','<Shift-Tab>' => [sub { shift->focusPrev(); }] );
  #  $group{'frame'}->bind('all','<Shift-Tab>' => [sub {1;}]);
  #  $group{'frame'}->bind('all','<Control-Tab>' => [sub {1;}]);

  $group{'frame'}->Tk::bind('Busy','<Escape>',[\&_search_busy, \%group]);
  $group{'top'}->Tk::bind('Busy','<Escape>',[\&_search_busy, \%group]);

  $group{'frame'}->bind('my','<Tab>' => [sub { shift; currentNext(@_); Tk->break; },\%group]);
  $group{'frame'}->bind('my','<Shift-ISO_Left_Tab>' => [sub { shift; currentPrev(@_); Tk->break; },\%group]);
  $group{'frame'}->bind('my','<Shift-Tab>' => [sub { shift; currentPrev(@_); Tk->break; },\%group]);

  $group{'frame'}->bind('my','<period>' => [\&onIdleNextTree,\%group]);
  $group{'frame'}->bind('my','<comma>' => [\&onIdlePrevTree,\%group]);
  $group{'frame'}->bind('my','<Next>' => [\&onIdleNextTree,\%group]);
  $group{'frame'}->bind('my','<Prior>' => [\&onIdlePrevTree,\%group]);
  $group{'frame'}->bind('my','<greater>' => [sub { shift; my $grp=shift; gotoTree($grp,$grp->{FSFile}->lastTreeNo); Tk->break; },\%group]);
  $group{'frame'}->bind('my','<less>' => [sub { shift; my $grp=shift; gotoTree($grp,0); Tk->break; },\%group]);

  $group{'frame'}->bind('my','<KeyPress-Return>' => [sub {
					      my ($w,$grp)=@_;
					      editAttrsDialog($grp,$grp->{'currentNode'});
					      Tk->break;
					    },\%group]);
  $group{'frame'}->bind('my','<KeyPress-Left>' => [sub {
					   my ($w,$grp)=@_;
					   currentLeft($grp);
					   Tk->break;
					 },\%group]);
  $group{'frame'}->bind('my','<KeyPress-Right>' => [sub {
					    my ($w,$grp)=@_;
					    currentRight($grp);
					   Tk->break;
					  },\%group]);
  $group{'frame'}->bind('my','<KeyPress-Up>' => [sub {
					 my ($w,$grp)=@_;
					 currentUp($grp);
					 Tk->break;
				       },\%group]);
  $group{'frame'}->bind('my','<KeyPress-Down>' => [sub {
					   my ($w,$grp)=@_;
					   currentDown($grp);
					   Tk->break;
					 },\%group]);

  ## Canvas bindings  
  $group{'canvas'}->bind('text', '<Any-Enter>' => [sub{
			       my $c=shift;
			       my $grp=shift;
			       my $t=$c->find('withtag','current');
			       my $node=$grp->{'pinfo'}{$t};
			       $node->{_tkSaveColor_}=$c->itemcget($t,'-fill');
			       $c->itemconfigure($t,
						 -fill => $activeTextColor);

			     }, \%group]);

  $group{'canvas'}->bind('text',
			 '<Any-Leave>'
			 => [sub{
			       my $c=shift;
			       my $grp=shift;
			       my $t=$c->find('withtag','current');
			       my $node=$grp->{'pinfo'}{$t};
			       $c->itemconfigure('current',
						 -fill => $node->{_tkSaveColor_});
			     }, \%group]);

  $group{'canvas'}->bind('point', '<1>' => [sub {node_down(@_) },\%group,0]);
  $group{'canvas'}->bind('point', '<ButtonRelease-1>' => [sub {node_release(@_)},\%group,0]);
  $group{'canvas'}->bind('point', '<B1-Motion>' => [sub {node_move(@_)},\%group]);
  $group{'canvas'}->bind('point','<3>' => [sub {node_down(@_)},\%group,1]);
  $group{'canvas'}->bind('point', '<ButtonRelease-3>' => [sub {node_release(@_)},\%group]);
  $group{'canvas'}->bind('point','<B3-Motion>' => [sub {node_move(@_)},\%group,1]);
  $group{'canvas'}->CanvasBind('<2>' => [sub {follow_mouse_press(@_)},\%group]);
  $group{'canvas'}->CanvasBind('<B2-Motion>' => [sub {follow_mouse(@_)},\%group]);
  $group{'canvas'}->bind('point', '<Double-1>' => [sub { editAttrs(@_); Tk->break; },\%group]);
  $group{'canvas'}->bind('text', '<1>' => [sub {node_down(@_) },\%group,0]);
  $group{'canvas'}->bind('text', '<Double-1>' => [sub { editAttr(@_); Tk->break; },\%group]);
  $group{'canvas'}->bind('textbg', '<Double-1>' => [sub { editAttr(@_); Tk->break; },\%group]);

  $group{'canvas'}->focus;

  $group{'printToFile'}=0;
  $group{'printCommand'}='lpr';
  $group{'printPsFile'}=$psFile;

  print STDERR "Binding canvas destroy...\n" if $tredDebug;
  $group{'top'}->bind('canvas', '<Destroy>',
		      [ sub {
			  shift;
			  my $grp=shift;
			  my $canvas=$grp->{'canvas'}->Subwidget('scrolled');			  
			  $defCWidth=$canvas->width();
			  $defCHeight=$canvas->height();
			  print "$defCHeight x $defCWidth\n";
			  $geometry=$group{top}->geometry();
			  print "geometry is $geometry\n";
			  if ($^O eq "MSWin32" and $group{top}->state() eq 'zoomed') {
			    $geometry=~s/\+[-0-9]+\+[-0-9]+/+-3+-3/;
			  }
			  print "state is ",$group{top}->state(),"\n";
			},\%group ]);

  print STDERR "GUI prepared.\nOpenning first file ...." if $tredDebug;

  selectFilelist(\%group,'Default');
#    $group{currentFilelist}=$filelists[0];
#    if ($group{currentFilelist}->file_at(0)) {
#      openFile(\%group,$group{currentFilelist}->file_at(0));
#    }
  
  print STDERR "done.\nStarting main loop.\n" if $tredDebug;

  exit if doEvalHook(\%group,"start_hook") eq 'stop'; # run start_hook

  # Starting ------------------------------------------

  MainLoop;


  # Finished ------------------------------------------

  # Save configuration
  print STDERR "Saving some configuration options.\n" if $tredDebug;
  my @conf;
  my $ommit="canvasheight|canvaswidth|recentfile[0-9]+|geometry|filelist[0-9]+";
  if (open(F,"<$configFile")) {
    @conf= grep { !/^\s*(?:$ommit)\s*=/i } <F>;
    close(F);
  }
  #  $geometry=~s/^[0-9]+x[0-9]+//;
  push @conf,"LastAction\t=\t".$group{lastActionBookmark}."\n" if $group{lastActionBookmark};
  push @conf,
    "Geometry\t=\t".$geometry."\n",
    "CanvasHeight\t=\t".$defCHeight."\n",
    "CanvasWidth\t=\t".$defCWidth."\n",
    map { 
      my $s=$recentFiles[$_];
      $s=~s/\\/\\\\/g;
      "RecentFile$_\t=\t$s\n"
    } 0..$#recentFiles;
  my $i=0;
  foreach (@filelists) {
    if (ref($_) and defined($_->filename) and $_->filename ne "") {
      $_->save;
      push @conf,"filelist".$i++."\t=\t".$_->filename."\n";
    }
  }
  chomp $conf[$#conf];
  saveConfig(\%group,@conf);
  print STDERR "Done.\n" if $tredDebug;
}

sub onIdleNextTree {
  my ($w,$grp)=@_;
  return unless $grp->{'FSFile'};
  $grp->{treeNo}=max(0,min($grp->{treeNo}+1,$grp->{FSFile}->lastTreeNo));
  getValueLine($grp);
  $w->afterCancel($myIdle) if ($myIdle);
  $grp->{valueLine}->idletasks();
  $myIdle=$w->afterIdle([ sub {
			    my $g=shift;
			    my $no=$grp->{treeNo};
			    $grp->{treeNo}=-1; # this is to force getNodes & redraw
			    gotoTree($g,$no);
			    $myIdle=undef;
			  },$grp]);
  Tk->break;
}

sub onIdlePrevTree {
  if ($grp->{treeNo}>0) {
    my ($w,$grp)=@_;
    $grp->{treeNo}--;
    getValueLine($grp);
    $w->afterCancel($myIdle) if ($myIdle);
    $grp->{valueLine}->idletasks();
    $myIdle=$w->afterIdle([ sub {
			      my $g=shift;
			      my $no=$grp->{treeNo};
			      $grp->{treeNo}=-1; # this is to force getNodes & redraw
			      gotoTree($g,$no);
			      $myIdle=undef;
			    },$grp]);
  }
  Tk->break;
}


# This patches $dialog->Show which implicitly focuses the default button;
# here focus stays where it is.
# Usage: my $dlg=DialogBox(); ...; ShowDialog($dlg);
sub ShowDialog {
  my ($cw, $focus, $oldFocus) = @_;

  $oldFocus = $cw->focusCurrent unless $oldFocus;
  my $oldGrab = $cw->grabCurrent;
#  my $old_grab = $cw->grabSave;
#  my $old_focus = $cw->grabSave;
  my $grabStatus = $oldGrab->grabStatus if ($oldGrab);

#  $cw->grab;

  $cw->Popup();


  Tk::catch {
    $cw->grab;
  };
  $focus->focusForce if ($focus);
  Tk::DialogBox::Wait($cw);

  eval {
    $oldFocus->focusForce;
  };
  #&$old_grab;
  #&$old_focus;
  

  $cw->withdraw;
  $cw->grabRelease;
  if ($oldGrab) {
    if ($grabStatus eq 'global') {
      $oldGrab->grabGlobal;
    } else {
      $oldGrab->grab;
    }
  }

  return $cw->{'selected_button'};
}

sub fileDialog {
  my $grp = shift;
  my $file;

#  use Tk::FileSelect;
#  my $FSref = $grp->{top}->FileSelect(-selectmode => extended);
#  print $FSref->Show;

  $file = $grp->{'top'}->getOpenFile(-filetypes => \@open_types);
  if (defined $file and $file ne '') {
    return openFile($grp,$file);
  }
  return 0;
}

sub saveFileAs {
  my $grp = shift;
  my $initdir;
  return unless $grp->{FSFile};
  my $file=$grp->{FSFile}->filename;

  $initdir=dirname($file);
  $initdir=cwd if ($initdir eq './');


  $file = $grp->{'top'}->getSaveFile(-filetypes => \@save_types,
				     -title => "Save As ...",
				     -d $initdir ? (-initialdir => $initdir) : (),
     				     -initialfile => filename($file));
  if (defined $file and $file ne '') {
    $grp->{FSFile}->changeFilename($file);
    updateTitle($grp);
    return saveFile($grp);
  }
  return 0;
}

sub askSaveFiles {
  my ($grp) = @_;

  askSaveFile($grp,0);
  while (@openfiles) {
    resumeFile($grp,shift @openfiles);

    # let user see what he saves or leaves
    updateTitle($grp);
    getNodes($grp);
    redraw_tree($grp);
    if ($grp->{currentNode}) {
      centerToXY($grp,0,0);
    }
    $grp->{top}->update();

    askSaveFile($grp,0);
  }
}

sub askSaveFile {
  my ($grp,$keep)=@_;
  return unless ref($grp) and ref($grp->{FSFile}) and $grp->{FSFile}->notSaved;

  my $d=$grp->{top}->Dialog(-text => $grp->{FSFile}->filename()."\n\nFile may be changed!\nDo you want to save it?",
				 -bitmap => 'question', 
				 -title => 'Save File Dialog',
				 -buttons => ['Yes','No', $keep ? 'Keep' : ()]);
  $d->bind('<Return>', sub { my $w=shift; my $f=$w->focusCurrent;
			     $f->Invoke if ($f and $f->isa('Tk::Button')) } );
  my $answer=$d->Show();
  if ($answer eq 'Yes') {
    saveFile($grp);
  } elsif ($answer eq 'Keep') {
    print STDERR "Postponing ".$grp->{FSFile}->filename()."\n";
    $grp->{FSFile}->currentTreeNo($grp->{treeNo});
    $grp->{FSFile}->currentNode($grp->{currentNode});
    push @openfiles, $grp->{FSFile};
    updatePostponed($grp);
  }
}

sub saveConfig {
 my $grp=shift;

 if (open(F,">$configFile")) {
   print F @_;
   close(F);
 } else {
   my $lasterr=$!;
   my ($trc)=<'~/.tredrc'>;
   my ($dc,$ic)=stat($configFile);
   my ($dh,$ih)=stat($trc);
   if ($configFile ne $trc and ($dc != $dh or $ic != $ih) and
       $grp->{'top'}->toplevel->
       messageBox(-icon => 'warning',
		  -message => "Cannot write configuration to $configFile\n($lasterr)\n\n".
		  "Shell I try to save it to ~/.tredrc?\n",
		  -title => 'Configuration cannot be saved',
		  -type => 'YesNo',
		  #			  -default => 'Yes' # problem: Windows 'yes', UNIX 'Yes'
		 ) =~ /yes/i) {
     if (open(F,">".$trc)) {
       print F @_;
       close(F);
     } else {
       $grp->{'top'}->toplevel->
	 messageBox(-icon => 'error',
		    -message => 'Cannot write to "'.$trc.'"!'."\n($!)\n".
		    "\nConfiguration could not be saved!\n",
		    -title => 'Configuration cannot be saved',
		    -type => 'Ok');
     }
   } else {
     $grp->{'top'}->toplevel->
       messageBox(-icon => 'error',
		  -message => "Cannot write to \"$configFile\"!"."\n($lasterr)\n".
		  "\nConfiguration could not be saved!",
		     -title => 'Configuration cannot be saved',
		  -type => 'Ok',
		  -default => 'Ok');
   }
 }
}

sub editConfig {
  my $grp=shift;
  return unless $grp;
  if ($grp->{configDialog}) {
    $grp->{configDialog}->deiconify;
    $grp->{configDialog}->focus;
    $grp->{configDialog}->raise;
    return;
  }
  $grp->{configDialog} = $grp->{'top'}->Toplevel(-title => "Edit Resource File ($configFile)" , 
						   -width => "10c");
  my $d=$grp->{configDialog};
  $d->withdraw;
#  $d->resizable(0,0);
  $d->bind('<Return>' => [sub {1;}]);
  my $t = $d->
    Scrolled(qw/Text -relief sunken -borderwidth 2 -setgrid true
		     -height 30 -scrollbars e/);
  $t->pack(qw/-expand yes -fill both/);
  my $bottom=$d->Frame()->pack(qw/-expand yes -fill both/);
  $bottom->
    Button(-text => "  Save and Apply  ",
	   -command => [sub {
			  my ($grp,$d,$t)=@_;
			  saveConfig($grp,$t->get("0.0","end"));
			  applyConfig(split(/\n/,$t->get("0.0","end")));
			  addToRecent($grp);
			  prepareFonts($grp);
			  updateTitle($grp);
			  $grp->{valueLine}->configure(-font => $vLineFont);
			  redraw_tree($grp);
#			  $d->destroy;
			},$grp,$d,$t])
      ->pack(-side => 'left', -expand => 1,  -padx => 1, -pady => 1);
  $bottom->Button(-text => "  Apply  ",
		  -command => [sub {
				 my $grp=shift;
				 applyConfig(split(/\n/,shift->get("0.0","end")));
				 addToRecent($grp);
				 prepareFonts($grp);
				 updateTitle($grp);
				 $grp->{valueLine}->configure(-font => $vLineFont);
				 redraw_tree($grp);
			       },$grp,$t])
    ->pack(-side => 'left', -expand => 1,  -padx => 1, -pady => 1);

  $bottom->Button(-text => "  Close  ", -command => [sub { shift->destroy; },$d])
    ->pack(-side => 'left', -expand => 1,  -padx => 1, -pady => 1);

  $d->bind('<Destroy>' => [sub { shift; shift->{configDialog}=undef; },$grp ]);
  $d->bind('all','<Escape>' => [sub { shift; shift->destroy(); },$d]);
  if (open(F,"<$configFile")) {
    $t->insert('0.0',join "",<F>);
    close(F);
  }
  $t->mark(qw/set insert 0.0/);
  $d->Popup;
}


sub QueryString {
  my ($grp, $title, $label,$default_text)=@_;
  my $newvalue=encode($default_text);
  my $d=$grp->{'top'}->DialogBox(-title => $title,
				 -buttons => ["OK", "Cancel"]);
  $d->bind('all','<Escape>' => [sub { shift; shift->{'selected_button'}='Cancel'; },$d ]);
  addBindTags($d,'dialog');
  my $e=$d->add(Entry,-relief => 'sunken',
		    -width => 40,
		    -takefocus => 1,
		    -font => $font,
		    -textvariable => \$newvalue);
  my $l = $d->Label(-text => encode($label),
		    -anchor => 'e',
		    -justify => 'right');
  $l->pack(-side=>'left');
  $e->pack(-side=>'right');
  $d->resizable(0,0);
#  $e->focus;
  my $result = ShowDialog($d,$e,$grp->{top});
  $d->destroy;
  undef $d;
  if ($result =~ /OK/) {
    return decode($newvalue);
  } else {
    return undef;
  }
}

sub Query {
  my ($w, $title, $label,$default_text)=@_;
  my $newvalue=encode($default_text);
  my $d=$w->DialogBox(-title => $title,
				 -buttons => ["OK", "Cancel"]);
  $d->bind('all','<Escape>' => [sub { shift; shift->{'selected_button'}='Cancel'; },$d ]);
  addBindTags($d,'dialog');
  my $e=$d->add(Entry,-relief => 'sunken',
		    -width => 40,
		    -takefocus => 1,
		    -font => $font,
		    -textvariable => \$newvalue);
  my $l = $d->Label(-text => encode($label),
		    -anchor => 'e',
		    -justify => 'right');
  $l->pack(-side=>'top');
  $e->pack(-side=>'left');
  $d->resizable(0,0);
#  $e->focus;
  my $result = ShowDialog($d,$e,$w);
  $d->destroy;
  undef $d;
  if ($result =~ /OK/) {
    return decode($newvalue);
  } else {
    return undef;
  }
}

sub selectValuesDialog {
 my ($grp, $attr, $vals, $selected, $may_add, $lastFocus,$force)=@_;
 my $a;
 my $multi=0;
 my @prevSelectionSet;

 $grp->{'top'}->Busy(-recurse => 1);
 my $enabled=($force or doEvalHook($grp,'enable_attr_hook',$attr,"ambiguous") ne 'stop');

 my $d=$grp->{'top'}->DialogBox(-title => "$attr: select values", -width => '8c',
				-buttons => $enabled ? ["OK", "Cancel"] : ["Cancel"]);
 $d->bind('all','<Escape>' => [sub { shift; shift->{'selected_button'}='Cancel'; },$d ]);
 $d->resizable(0,0);
 my $l=$d->Scrolled(qw/Listbox -relief sunken -takefocus 1 -scrollbars e/,
		    -height => min($maxDisplayedValues,scalar(@$vals)),
		    -font => $font)->pack(qw/-expand yes -fill both/);
 $l->insert('end',@$vals);

 if ($enabled) {
   $l->bind('<Double-ButtonPress-1>' =>
	    [sub { my $w=shift;
		   my $d=shift;
		   my $e = $w->XEvent;
		   $w->BeginSelect($w->index($e->xy));
		   $d->{'selected_button'}='OK';
		 },$d
	    ]);
 }
 my $act=0;
 for ($a=0;$a<@$vals;$a++)  {
   if (grep { $$vals[$a] eq $_ } @$selected) {
     $l->selectionSet($a);
     if (not $act) {
       print "Activating $a\n";
       $act=1;
       $l->activate($a);
       $l->see($a);
     }
   }
 }
 if ($enabled) {
   $d->Checkbutton(-text     => 'multiple select',
		   -variable => \$multi,
		   -command  => [sub {
				   shift->configure(-selectmode => $multi ? 'multiple' : 'browse');
				 },$l],
		   -relief   => 'flat')->pack();
   if ($may_add) {
     $d->Button(-text => 'Add',
		-command => [sub {
			       my ($grp,$l,$vals)=@_;
			       my $val=QueryString($grp,"Add new value","Value");
			       return unless defined $val;
			       push @$vals,$val;
			       $l->insert('end',$val);
			       $l->selectionClear(0,$l->size-1) unless $multi;
			       $l->selectionSet($l->size-1);
			     },$grp,$l,$vals])->pack();
   }
 }
 $grp->{'top'}->Unbusy();
 $l->focus;
 my $result = ShowDialog($d,$l,$lastFocus);
 if ($result =~ /OK/) {
   # Hajic wanted this (I wash my hands):
   # first we store the values, which were selected originaly and stayed selected
   foreach my $s (@$selected) { 
     push @prevSelectionSet, (grep { $$vals[$_] eq $s } (0 .. $l->size-1));
   }
   @$selected=();
   foreach (@prevSelectionSet) {
     if ($l->selectionIncludes($_)) {
       $l->selectionClear($_);
       push @$selected,$$vals[$_];
     }
   }
   foreach (0 .. $l->size-1) {
     push @$selected, $$vals[$_] if $l->selectionIncludes($_);
   }
   $d->destroy;
   undef $d;
   return 1;
 }
 $d->destroy;
 undef $d;
 return 0;
}

sub editListAttr {
  my ($grp, $value, $attr,$d) =@_;
  return unless $grp->{'FSFile'};
  my @vals = map { encode($_) } $grp->{FSFile}->FS->listValues($attr);
  #print "splitting ",$value{$attr},"\n";
  my @selected = map { encode($_) } split /\|/,$value;
  #print "splitted to ", join ('-',@selected),"\n";

  if (selectValuesDialog($grp,$attr,\@vals,\@selected,0,$d)) {
    return decode(join('|',@selected));
  }
  return undef;
}

sub editAmbiguousAttr {
  my ($grp, $value, $attr) =@_;
  my @vals = map { encode($_) }split /\|/,$value;
  my @selected = @vals;
  
  if (selectValuesDialog($grp,$attr,\@vals,\@selected,1,$grp->{top})) {
    return decode(join('|',@selected));
  }
  return undef;
}

sub editAttrsDialog {
  my ($grp,$node)=@_;
  return if (doEvalHook($grp,"do_edit_node_hook",$node) eq 'stop');
  return unless $grp->{'FSFile'};
  my @vals;
  my @r=();
  my @atord=$grp->{FSFile}->FS->attributes;
  if ($sortAttrs) {
    @atord=sort {uc($a) cmp uc($b)} $grp->{FSFile}->FS->attributes
      unless (doEvalHook($grp,"sort_attrs_hook",\@atord));
  }
  my $rows=min($maxDisplayedAttributes,$#atord+1);
  my ($a,$b,$r);

  $grp->{'top'}->Busy(-recurse =>1);
  my $d=$grp->{'top'}->DialogBox(-title => "Edit Node Attributes", -width => '10c',
				 -buttons => ["OK", "Cancel"]);
  $d->bind('all','<Escape>' => [sub { shift; shift->{'selected_button'}='Cancel'; },$d ]);
  $d->resizable(0,0);
  my $f = $d->Scrolled('Tiler',
		       -columns =>2,
		       -rows =>$rows,
		       -relief => 'groove',
		       -scrollbars => 'e');

  sub focusxDn {
    my ($w,$i,$e,$f,$rows,$cnt)=@_;
    if ($i+1>$#atord) {
      $w->focusNext if ($cnt);
    } else {
      $e->{$atord[$i+1]}->focus;
      $f->scroll(1,'pages')
	if ($i+1>=($f->{SubWidget}{tiler}{Start}+$rows));
      # D'ya like dirty tricks ? :)
    }
    Tk->break;
  };
  sub focusxUp {
    my ($w,$i,$e,$f,$cnt)=@_;
    if ($i<=0) {
      $w->focusPrev if ($cnt);
    } else {
      $e->{$atord[$i-1]}->focus;
      $f->scroll(-1,'pages')
	if ($i-1<($f->{SubWidget}{tiler}{Start}));
      # D'ya like dirty tricks ? :)
    }
    Tk->break;
  };

  $f->bind($f,'<Tab>',[sub {
			     if ($e{$atord[0]}) {
			       $e{$atord[0]}->focus;
			       $f->moveto(0);
			     } else {
			       shift->focusNext;
			     }
			     Tk->break;
			   }]);
  for (my $i=0;$i<=$#atord;$i++) {
    $_=$atord[$i];
    # Reliefs: raised, sunken, flat, ridge, and groove.
    push @r,$f->Label(-text => $_, -anchor => 'nw')->pack();

    if  ($grp->{FSFile}->FS->isList($_) or
	 $$node{$_}=~/^(?:[^\|\\]|\\.)*\|/) { # readonly entry and buttons for list
      $r = $f->Frame;
      $e{$_} = $r->Entry(-relief => 'sunken', -takefocus => 1,
			 -font => $font)->pack(qw/-expand yes -fill both -side left/);
#      unless (doEvalHook($grp,'enable_attr_hook',$_,"ambiguous") eq 'stop') {
	$b=$r->Button(-text => "...", -takefocus => 0,
		      -command => [sub {
				     my ($e,$grp,$node,$attr,$d)=@_;
				     my $result =
				       ($grp->{FSFile}->FS->isList($attr)
					? editListAttr($grp,$e->get,$attr)
					: editAmbiguousAttr($grp,$e->get,$attr,$d));
				     if (defined $result) {
				       $e->configure(-state => 'normal');
				       $e->delete(0,length($e->get));
				       $e->insert(0,$result);
				       $e->configure(-state => 'disabled');
				     }
				   },$e{$_},$grp,$node,$_,$d])->pack(-side => 'right');
	$e{$_}->bind($e{$_},'<Return>',[sub { shift; shift->invoke; Tk->break; },$b]);
	$e{$_}->bind($e{$_},'<Double-ButtonPress-1>',[sub { shift; shift->invoke; Tk->break; },$b]);
#      }
      $e{$_}->insert(0,encode($$node{$_}));
      $e{$_}->configure(-state => 'disabled');
      push @r, $r;
    } else {
      $e{$_} = $f->Entry(-relief => 'sunken', -takefocus => 1,
			 -font => $font)->pack(qw/-expand yes -fill both/);
      $e{$_}->insert(0,encode($$node{$_}));
      if (doEvalHook($grp,'enable_attr_hook',$_,"normal") eq 'stop') {
	$e{$_}->configure(-state => 'disabled');
      }

      push @r, $e{$_};
    }

    $e{$_}->bind($e{$_},'<Tab>',[\&focusxDn,$i,\%e,$f,$rows,1]);
    $e{$_}->bind($e{$_},'<Down>',[\&focusxDn,$i,\%e,$f,$rows]);
    $e{$_}->bind($e{$_},'<Shift-Tab>',[\&focusxUp,$i,\%e,$f,1]);
    $e{$_}->bind($e{$_},'<Up>',[\&focusxUp,$i,\%e,$f]);
  }
  $f->Manage(@r);
  $f->pack();
  $grp->{'top'}->Unbusy();

  my $result = ShowDialog($d,($atord[0] ? $e{$atord[0]}->focus : undef),$grp->{top});

  if ($result =~ /OK/) {
    $grp->{FSFile}->notSaved(1);
    lastActionBookmark($grp);
    foreach $a (@atord) {
      $$node{$a}=decode($e{$a}->get);
    }
    getNodes($grp);
    redraw_tree($grp);
  }
  undef %e;
  foreach $_ (@r) {$_->destroy;}
  @r=();
  $f->destroy;
  $d->destroy;
  undef $d;

}

sub customAttrsDialog {
  my ($grp)=@_;
  return if (doEvalHook($grp,"customize_attrs_hook",$node) eq 'stop');
  return unless $grp->{'FSFile'};
  my $e;

  $grp->{'top'}->Busy(-recurse =>1);
  my $d=$grp->{'top'}->
    DialogBox(-title => "Customize Visible Attributes",
	      -width => '10c',
	      -buttons => ["OK", "Cancel"]);

  my $f = $d->Frame();
  my $af = $f->Frame();
  $af->Label(-text => 'Attributes')->pack();
  my $al = $af->Scrolled(qw/Listbox -relief sunken 
                     -borderwidth 2 -setgrid true
		     -height 15 -scrollbars e
                     -exportselection 0/)->pack();

  my @atord=$grp->{FSFile}->FS->attributes;
  if ($sortAttrs) {
    @atord=sort {uc($a) cmp uc($b)} $grp->{FSFile}->FS->attributes
      unless (doEvalHook($grp,"sort_attrs_hook",\@atord));
  }
  $al->insert('end',@atord);
  $af->pack(qw/-padx 5 -side left -expand yes -fill both/);
  my $cf = $f->Frame();
  $cf->Label(-text => 'Display patterns')->pack();
  my $cl =
    $cf->Scrolled(qw/Listbox -relief sunken
                     -borderwidth 2 -setgrid true
		     -scrollbars se
                     -selectmode extended
                     -exportselection 0/
		 )->pack(qw/-side top -expand yes
                            -fill both
                            -padx 3 -pady 3/);
  $cl->insert('end',$grp->{FSFile}->patterns,'   ');
  $cf->Label(-text => 'Hint pattern')->pack();
  my $t =
    $cf->Scrolled(qw/Text -relief sunken
                     -borderwidth 2 -setgrid true
		     -height 4 -scrollbars se
                     -width 50
                     -exportselection 1
                     -wrap none/
		 )->pack(qw/-side top -expand yes
                            -fill both
                            -padx 3 -pady 3/);
  $t->insert('0.0',$grp->{FSFile}->hint);

  my $e = $d->Entry(qw/-relief sunken
                       -borderwidth 2/);

  my $bf = $f->Frame();
  $bf->Button(-text => "Add/Paste",
	      -command =>
	      sub {
		if ($e->get ne "") {
		  $cl->insert('active',$e->get);
		}
		$e->selectionRange(0,'end');
	      }
	     )->pack(-side => top, -expand => yes, -padx => 3, -pady => 3);

  $bf->Button(-text => "Cut",
	      -command =>
	      sub {
		$cl->selectionClear($cl->index('end')-1)
		  if ($cl->selectionIncludes($cl->index('end')-1));
		while (defined(($cl->curselection)[0])) {
		  $e->delete(0,'end');
		  $e->insert('insert',$cl->get(($cl->curselection)[0]));
		  $cl->delete(($cl->curselection)[0]);
		}
	      }
	     )->pack(-side => top, expand => yes, -padx => 3, -pady => 3);
  $bf->Button(-text => "Delete",
	      -command =>
	      sub {
		$cl->selectionClear($cl->index('end')-1)
		  if ($cl->selectionIncludes($cl->index('end')-1));
		while (defined(($cl->curselection)[0])) {
		  $cl->delete(($cl->curselection)[0]);
		}
	      }
	     )->pack(-side => top, expand => yes, -padx => 3, -pady => 3);


  $bf->Button(-text => "Add as hint",
	      -command =>
	      sub {
		if ($e->get ne "") {
		  Tk::catch { $t->delete('sel.first','sel.last') };
		  $t->insert('insert',$e->get);
		}
		$e->selectionRange(0,'end');
	      }
	     )->pack(-side => top, -expand => yes, -padx => 3, -pady => 3);


  $bf->pack(qw/-padx 5 -side left -expand yes -fill both/);
  $cf->pack(qw/-padx 5 -side left -expand yes -fill both/);


  $f->pack(qw/-side top -expand yes -fill x/);
  $e->pack(qw/-side bottom -expand yes -fill x/);

  $d->bind('all','<Escape>' =>
	   [sub { shift;
		  shift->{'selected_button'}='Cancel';
		},$d ]);
  $al->bind('<Double-1>' => 
	   sub {
	     $e->delete('sel.first','sel.last')
	       if ($e->selectionPresent);
	     $e->insert('insert','${'.$al->get('active').'}');
	   }
	  );
  $cl->bind('<Double-1>' => 
	   sub {
	     return if ($cl->index('active') == $cl->index('end')-1);
	     if ($e->selectionPresent) {
	       $e->delete('sel.first','sel.last')
	     }
	     $e->insert('insert',$cl->get('active'));
	   }
	  );
  $d->bind('<Return>' => [sub {1;}]);
  $d->resizable(0,0);
  $grp->{'top'}->Unbusy();

  my $result = ShowDialog($d,$e,$grp->{top});

  if ($result =~ /OK/) {
    $grp->{FSFile}->changeHint($t->get('0.0','end - 1 chars'));
    $grp->{FSFile}->changePatterns($cl->get(0,$cl->index('end')-2));
    redraw_tree($grp);
  }
  $d->destroy;
  undef $d;
}


#####################################################
#####################################################
#####################################################
# Node searching
#####################################################

sub findNodeDialog {
  my ($grp,$template)=@_;
  return unless $grp->{'FSFile'};
  my $r;
  my @vals;
  my @atord=$grp->{FSFile}->FS->attributes;
  if ($sortAttrs) {
    @atord=sort {uc($a) cmp uc($b)} $grp->{FSFile}->FS->attributes
      unless (doEvalHook($grp,"sort_attrs_hook",\@atord));
  }

  my $b;
  my $a;
  my $rows=min($maxDisplayedAttributes,$#atord+1);
  my @r=();
  my %e=();
  $grp->{'top'}->Busy(-recurse =>1);
  my $d=$grp->{'top'}->DialogBox(-title => "Find Node By Attributes", -width => '10c',
				 -buttons => ["Find"]);
  my $bcl=$d->Subwidget('bottom')->Button(-text => "Clear",
				  -command => [sub { my $e=shift;
						     foreach (keys %$e) {
						       $e->{$_}->delete(0,'end');
						     }
						   },\%e] );
  my $bca=$d->Subwidget('bottom')->Button(-text => "Cancel", 
				  -command => [sub { shift->{'selected_button'} = "Cancel"},$d] );
  foreach ($bcl,$bca) {
    $_->configure(-width => 10, -pady => 0) if ($Tk::platform eq 'MSWin32');
    $_->pack(-side => 'left', -expand => 1,  -padx => 1, -pady => 1);
  }

  $d->bind('all','<Escape>' => [sub { shift; shift->{'selected_button'}='Cancel'; },$d ]);
  $d->resizable(0,0);
  my $f = $d->Scrolled('Tiler',
		       -columns =>2,
		       -rows =>$rows,
		       -relief => 'groove',
		       -scrollbars => 'e');
  sub focusxDn {
    my ($w,$i,$e,$f,$rows,$cnt)=@_;
    if ($i+1>$#atord) {
      $w->focusNext if ($cnt);
    } else {
      $e->{$atord[$i+1]}->focus;
      $f->scroll(1,'pages')
	if ($i+1>=($f->{SubWidget}{tiler}{Start}+$rows));
      # D'ya like dirty tricks ? :)
    }
    Tk->break;
  }
  ;
  sub focusxUp {
    my ($w,$i,$e,$f,$cnt)=@_;
    if ($i<=0) {
      $w->focusPrev if ($cnt);
    } else {
      $e->{$atord[$i-1]}->focus;
      $f->scroll(-1,'pages')
	if ($i-1<($f->{SubWidget}{tiler}{Start}));
      # D'ya like dirty tricks ? :)
    }
    Tk->break;
  }
  ;

  $f->bind($f,'<Tab>',[	sub {
			  if ($e{$atord[0]}) {
			    $e{$atord[0]}->focus;
			    $f->moveto(0);
			  } else {
			    shift->focusNext;
			  }
			  Tk->break;
			}]);

  for (my $i=0;$i<=$#atord;$i++) {
    $_=$atord[$i];
    # Reliefs: raised, sunken, flat, ridge, and groove.
    push @r,$f->Label(-text => $_, -anchor => 'nw')->pack();

    $e{$_} = $f->Entry(-relief => 'sunken', -takefocus => 1,
		       -font => $font)->pack(qw/-expand yes -fill both/);
    $e{$_}->insert(0,encode($template->{$_}));
    push @r, $e{$_};

    $e{$_}->bind($e{$_},'<Tab>',[\&focusxDn,$i,\%e,$f,$rows,1]);
    $e{$_}->bind($e{$_},'<Down>',[\&focusxDn,$i,\%e,$f,$rows]);
    $e{$_}->bind($e{$_},'<Shift-Tab>',[\&focusxUp,$i,\%e,$f,1]);
    $e{$_}->bind($e{$_},'<Up>',[\&focusxUp,$i,\%e,$f]);
  }
  $f->Manage(@r);
  $f->pack();  # or shoud it be pack(qw/-expand yes -fill x/)?
               # one may choose, but both have their plus and minus

  my $of=$d->Frame()->pack(qw/-expand yes -fill x/);
  $of->Label(-text => 'Search method: ')->pack(qw/-side left/);

  $of->Optionmenu(-variable => \$grp->{templateMatchMethod},
		  -options => ['Regular expression',
			       'Exhaustive regular expression',
			       'Wildcard pattern',
			       'Literal'])->pack(qw/-side left/);

  my $of=$d->Frame()->pack(qw/-expand yes -fill x/);
  $of->Label(-text => 'Search file-list: ')->pack(qw/-side left/);
  my $om=$of->Optionmenu(-textvariable => \$grp->{searchFilelist},
		  -options => [ '<<Current file only>>', 
				map { $_->name } @filelists ])->pack(qw/-side left/);

  $of->Button(-text => 'Edit',
	      -command => [ sub {
			      my ($grp)=@_;
			      my $name=filelistDialog($grp,1);
			      $om->options([map { $_->name } @filelists]);
			      $grp->{searchFilelist}=$name if (ref(findFilelist($name)));
			    },$grp,$om])->pack(qw/-side left/);
  $grp->{'top'}->Unbusy();
  my $result = ShowDialog($d,($atord[0] ? $e{$atord[0]}->focus : undef),$grp->{top});
  if ($result =~ /Find/) {
    foreach $a (@atord) {
      $template->{$a}=decode($e{$a}->get);
    }
    # Clear all empty rules
    foreach (keys %$template) {
      delete $template->{$_} unless defined($template->{$_}) and $template->{$_} ne '';
    }
    if ($grp->{searchFilelist} ne '<<Current file only>>') {
      my $fl=findFilelist($grp->{searchFilelist});
      if (ref($fl) and $fl->file_count>0 ) {
	local $insideEval=1;                 # no redraw
	$fl->set_current($fl->file_at(0));
	selectFilelist($grp,$fl);
      }
    } else { 
      $grp->{searchFilelist}=undef;
    }
    doFindFirstTemplated($grp,$template,0);
    #    getNodes($grp);
    #    redraw_tree($grp);
  }
  $d->destroy;
  undef $d;
}

#####################################
# bound to Escape for busy widgets
#####################################
sub _search_busy {
  my ($w,$grp)=@_;
  print STDERR $grp->{currentFileNo}."stopped by user\n" if ($tredDebug);
  $grp->{stopSearch}=1;
  Tk->break;
}

#####################################
# called after file open to process
# event queue and let user interrupt
# the search process
#####################################
sub _quick_update {
  my $grp=shift;
  $grp->{top}->Unbusy();
  $grp->{top}->update();
  $grp->{top}->Busy(-recurse => 1);
}

######################################
# start searching for a next node
# and display result unless succeeded
######################################
sub doFindFirstTemplated {
  my ($grp,$template,$cont)=@_;
  return undef unless ($grp->{currentNode});
  my $result;
  $grp->{'top'}->Busy(-recurse => 1);

  print "Starting search!\n";
  unless ($result=findFirstTemplated($grp,$template,$cont)) {
    redraw_tree($grp);
    $grp->{'top'}->toplevel->
      messageBox(-icon => 'warning',
		 -message => $grp->{stopSearch} ? "Interrupted by user!" : "No matching node found!",
		 -title => 'Find',
		 -type => 'ok');
  }
  $grp->{'top'}->Unbusy();
  return $result;
}

######################################
# start searching for a prev node
# and display result unless succeeded
######################################
sub doFindPrevTemplated {
  my ($grp,$template,$cont)=@_;
  return undef unless ($grp->{currentNode});
  my $result;
  $grp->{'top'}->Busy(-recurse => 1);

  unless ($result=findPrevTemplated($grp,$template,$cont)) {
    redraw_tree($grp);
    $grp->{'top'}->toplevel->
      messageBox(-icon => 'warning',
		 -message => $grp->{stopSearch} ? "Interrupted by user!" : "No matching node found!",
		 -title => 'Find',
		 -type => 'ok');
  }
  $grp->{'top'}->Unbusy();
  return $result;
}

######################################
# compare nodes with template
######################################
sub cmpTemplateField {
  my ($grp,$val,$templ)=@_;
  my $method=substr($grp->{templateMatchMethod},0,1);
  return $val =~ /^$templ$/ if ($method eq 'E');
  return $val =~ /$templ/ if ($method eq 'R');
  return $val eq $templ if ($method eq 'L');
  if ($method eq 'W') {
    $templ=~s/[.^$(){}<>\\]/\\\&/g;
    $templ=~s/\*/.\*/g;
    $templ=~s/\?/./g;
    return $val =~ /^$templ$/;
  }
  return $val eq $templ;
}

######################################
# go to next node in searchlist
######################################
sub nextNodeInSearchFilelist {
  my ($grp,$node,$tree)=@_;
  $node=(HNext($grp,$node) || $grp->{FSFile}->treeList->[(++$$tree)]);
  return $node if ($node or !defined($grp->{searchFilelist}));

  # this realises filelist search
  local $insideEval=1;
  my $result=nextFile($grp,1);
  $grp->{treeNo}=-1; # force redraw in gotoTree
  $$tree=0;
  # we especially wait for Escape
  _quick_update($grp);
  while (!$grp->{stopSearch} and $result and !$grp->{currentNode}) {
    $result=nextFile($grp,1);
    # we especially wait for Escape
    _quick_update($grp);
    $grp->{treeNo}=-1; # force redraw in gotoTree
  }
  return (!$grp->{stopSearch} and $result) ? $grp->{currentNode} : undef;
}

######################################
# find next matching node
######################################
sub findFirstTemplated {
  my ($grp,$template,$skipfirst)=@_;
  return unless $grp->{'FSFile'};
  my $node=$grp->{'currentNode'};
  my $tree=$grp->{treeNo};
  my $a;
  $grp->{stopSearch}=0;

  $node=nextNodeInSearchFilelist($grp,$node,\$tree) if ($skipfirst);
  while ($node) {
    unless (grep (!cmpTemplateField($grp,$node->{$_},$template->{$_}), keys (%$template)))
      {
	gotoTree($grp,$tree);
	setCurrent($grp, $node);
	centerTo($grp,$node);
	return $node;
      }
    $node=nextNodeInSearchFilelist($grp,$node,\$tree);
  }
  return undef;
}

######################################
# go to the last node of a tree
######################################
sub lastSubtreeNode {
  my ($top)=@_;
  return undef unless $top;
  while ($top->firstson) {
    $top=$top->firstson;
    $top=$top->rbrother while ($top->rbrother);
  }
  return $top;
}

######################################
# go to previous node in search list
######################################
sub prevNodeInSearchFilelist {
  my ($grp,$node,$tree)=@_;
  $node=HPrev($grp,$node);
  unless ($node or $$tree==0) {
    $node=lastSubtreeNode($grp->{FSFile}->treeList->[(--$$tree)]);
    $node=HPrev($grp,$node) unless (isShown($grp,$node));
  }
  return $node if $node or !defined($grp->{searchFilelist});

  # this realises filelist search
  local $insideEval=1;
  my $result=prevFile($grp,1);
  # we especially wait for Escape
  _quick_update($grp);
  $grp->{treeNo}=-1; # force redraw in gotoTree
  while ($result and !$grp->{stopSearch}
	 and !$grp->{FSFile} || $grp->{FSFile}->lastTreeNo<0) {
    $result=prevFile($grp,1);
    # we especially wait for Escape
    _quick_update($grp);
    $grp->{treeNo}=-1; # force redraw in gotoTree
  }
  if ($result and !$grp->{stopSearch}) {
    $$tree=$grp->{FSFile}->lastTreeNo;
    $node=lastSubtreeNode($grp->{FSFile}->treeList->[$$tree]);
    return $node;
  }
  return undef;
}

######################################
# find previous matching node
######################################
sub findPrevTemplated {
  my ($grp,$template,$skipfirst)=@_;
  return unless $grp->{'FSFile'};
  my $node=$grp->{'currentNode'};
  my $tree=$grp->{treeNo};
  my $a;
  $grp->{stopSearch}=0;

  $node=prevNodeInSearchFilelist($grp,$node,\$tree) if ($skipfirst);

  while ($node) {
    unless (grep (!cmpTemplateField($grp,$node->{$_},$template->{$_}), keys (%$template)))
      {
	gotoTree($grp, $tree);
	setCurrent($grp, $node);
	centerTo($grp,$node);
	return $node;
      }
    $node=prevNodeInSearchFilelist($grp,$node,\$tree);
  }
  return undef;
}

#############################################
#End of Searching functions
#############################################
#############################################
#############################################



sub editAttrs {
  my ($w,$grp)=@_;
  my $node=$grp->{'pinfo'}{$w->find('withtag','current')};
  editAttrsDialog($grp,$node);
}

sub editAttr {
  my ($w,$grp)=@_;
  return unless $grp->{'FSFile'};
  my $attr;
  my $newvalue;

  my $t=$w->find('withtag','current');
  my $node=$grp->{'pinfo'}{$t};
  my $d;
  setCurrent($grp,$node);
  $attr= (grep {$$node{$_} eq $t} keys %$node)[0];
  return 0 unless ($attr=~/^_tkText\[([^]]+)\]/);
  $attr=$1;
  my $result = doEvalHook($grp,'do_edit_attr_hook',$attr,$node);
  return 0 if $result eq 'stop';

  if ($grp->{FSFile}->FS->isList($attr)) {
    $newvalue = editListAttr($grp,$$node{$attr},$attr,$grp->{top});
    if (defined($newvalue)) {
      $grp->{'top'}->Busy(-recurse => 1);
      $grp->{FSFile}->notSaved(1);
      lastActionBookmark($grp);
      $$node{$attr}=$newvalue;
      getNodes($grp);
      redraw_tree($grp);
      $grp->{'top'}->Unbusy();
    }
    return;
  }

  if ($$node{$attr}=~/^(?:[^\|\\]|\\.)*\|/) {
    $newvalue = editAmbiguousAttr($grp,$$node{$attr},$attr);
    if (defined $newvalue) {
      $grp->{'top'}->Busy(-recurse => 1);
      $grp->{FSFile}->notSaved(1);
      lastActionBookmark($grp);
      $$node{$attr}=$newvalue;
      getNodes($grp);
      redraw_tree($grp);
      $grp->{'top'}->Unbusy();
    }
    return;
  }

  $grp->{'top'}->Busy(-recurse => 1);


  $newvalue=encode($$node{$attr});
  $d = $grp->{'top'}->DialogBox(-title => "Edit Node Attribute",
				-buttons => ["OK", "Cancel"]);
  $d->bind('all','<Escape>' => [sub { shift; shift->{'selected_button'}='Cancel'; },$d ]);
  $d->resizable(0,0);
  addBindTags($d,'dialog');
  my $l = $d->Label(-text => $attr,
		    -anchor => 'e',
		    -justify => 'right')->pack(-side=>'left');
  my $e = $d->Entry(-relief => 'sunken',
		    -width => 40,
		    -state => (doEvalHook($grp,'enable_attr_hook',$_) eq 'stop') ? 'disabled' : 'normal',
		    -takefocus => 1,
		    -font => $font,
		    -textvariable => \$newvalue)->pack();
  $e->icursor('end');
#  $e->focus;
  $grp->{'top'}->Unbusy();
  my $result = ShowDialog($d,$e,$grp->{top});
#  $grp->{'top'}->Busy(-recurse => 1);
  if ($result =~ /OK/) {
    $grp->{FSFile}->notSaved(1);
    lastActionBookmark($grp);
    $$node{$attr}=decode($newvalue);
    getNodes($grp);
    redraw_tree($grp);
  }
#  $grp->{'top'}->Unbusy();
  $d->destroy;
  undef $d;
}



sub whichTextColor {
  my ($grp,$arg)=@_;
  return undef unless $grp->{'FSFile'};

  return $textColor unless ($highlightAttributes);

  if ($grp->{FSFile}->FS->color($arg) eq 'Shadow') {
    return $textColorShadow;
  } elsif ($grp->{FSFile}->FS->color($arg) eq 'Hilite') {
    return $textColorHilite;
  } elsif ($grp->{FSFile}->FS->color($arg) eq 'XHilite') {
    return $textColorXHilite;
  } else {
    return $textColor;
  }
}

sub nodeOptions {
  my ($grp,$node)=@_;
  return (-outline => $nodeOutlineColor,
	  -fill =>
	  ($grp->{'currentNode'} eq $node) ?
	  $currentNodeColor :
	  (isShown($grp,$node,0) ?
	   $nodeColor :
	   $hiddenNodeColor)
	 );
}

sub nodeBoxOptions {
  my ($grp,$node)=@_;
  return (-fill =>
	  ($grp->{'currentNode'} eq $node) ?
	  $currentBoxColor :
	  (isShown($grp,$node,0) ?
	   $boxColor :
	   $hiddenBoxColor)
	 );
}


sub nodeCoords {
  my ($grp,$node)=@_;
  my ($nw,$nh)=
    (($grp->{'currentNode'} eq $node) ? $currentNodeWidth : $nodeWidth,
     ($grp->{'currentNode'} eq $node) ? $currentNodeHeight : $nodeHeight);

  return ($node->{"_tkXPOS_"}+($nodeWidth-$nw)/2,
	  $node->{"_tkYPOS_"}+($nodeHeight-$nh)/2,
	  $node->{"_tkXPOS_"}+$nh,
	  $node->{"_tkYPOS_"}+$nw);
}

sub wrappedLines {
  my ($grp,$font,$text,$width)=@_;
  use integer;
  return $grp->{'canvas'}->fontMeasure($font,$text)/$width + 1;
}


sub redraw_tree {
  my ($grp)=@_;
  my $node;
  my $parent;

  return if $insideEval;
  my @displayAttrs;
  @displayAttrs=$grp->{FSFile}->patterns() if (ref($grp->{FSFile}));
  saveFileStateUpdate($grp);
  foreach $node (@{$grp->{Nodes}}) {
    foreach (keys(%$node)) {
      delete $node->{$_} if (/^_tk(?:X|Text)/);
    }
  }
  recalculate_positions($grp);

  $grp->{'canvas'}->configure(-scrollregion =>['0c', '0c', $grp->{canvasWidth}, $grp->{canvasHeight}]);
  $grp->{'canvas'}->configure(-background => $backgroundColor) if (defined $backgroundColor);
  $grp->{'canvas'}->addtag('delete','all');
  $grp->{'canvas'}->delete('delete');

  $grp->{'pinfo'}={lastX => 0, lastY => 0};

  if ($drawSentenceInfo) {
    return unless $grp->{'FSFile'};
    my $valtext=$valueLine;
    my $currentfile=filename($grp->{FSFile}->filename);
    my $fontHeight=$grp->{'canvas'}->fontMetrics($font, -linespace);
    $valtext=~s/ +([.,!:;])|(\() |(\)) /\1/g;

    if ($valtext=~/^(.*)\/([^:]*):\s*(.*)/) {
      my $ftext="File: $currentfile, tree $1 of $2";
      my $vtext=$3;
      $grp->{'canvas'}->createText(0,$grp->{canvasHeight},-font => $font,-text => $ftext,
				   -justify => left, -anchor => nw);
      $grp->{canvasHeight}+=$fontHeight;
      $grp->{canvasWidth}=max($grp->{canvasWidth},$grp->{'canvas'}->fontMeasure($font,$ftext));
      $grp->{'canvas'}->createLine(0,$grp->{canvasHeight},
				   $grp->{'canvas'}->fontMeasure($font,$ftext),
				   $grp->{canvasHeight});
      $grp->{canvasHeight}+=$fontHeight;
      $grp->{'canvas'}->createText(0,$grp->{canvasHeight},-font => $font,-text => $vtext,
				   -justify => left, -anchor => nw,
				   -width => $grp->{canvasWidth});
      $grp->{canvasHeight}+=$fontHeight*(wrappedLines($grp,$font,$vtext,$grp->{canvasWidth})+1);
#      $grp->{'canvas'}->createLine(0,$grp->{canvasHeight},$grp->{canvasWidth},$grp->{canvasHeight});

    }
  }

  foreach $node (@{$grp->{Nodes}}) {
    $parent=$node->parent;
    use integer;
    if ($parent) {
      $$node{"_tkLine_"}=$grp->{'canvas'}->createLine($$node{"_tkXPOS_"}+$nodeWidth/2,
					     $$node{"_tkYPOS_"}+$nodeHeight/2,
					     $$parent{"_tkXPOS_"}+$nodeWidth/2,
					     $$parent{"_tkYPOS_"}+$nodeHeight/2,
						      '-arrow' =>$lineArrow,
						     '-width' => $lineWidth,
						     '-fill' => $lineColor);
      $grp->{'pinfo'}{$$node{"_tkLine_"}}=$node;
    }
  }

  my $lineHeight=$grp->{'canvas'}->fontMetrics($font, -linespace);
  ## The Nodes ##
  foreach $node (@{$grp->{Nodes}}) {
    $$node{"_tkOval_"}=$grp->{'canvas'}->createOval(nodeCoords($grp,$node),
						    nodeOptions($grp,$node));
    $grp->{'canvas'}->addtag('point', 'withtag', $$node{"_tkOval_"});


    ## Boxes around attributes
    if ($drawBoxes) {
      ## get maximum width stored here by recalculate_positions
      my $textWidth=$node->{'_tkXWidth'};
      $$node{"_tkTextBox_"}=
	$grp->{'canvas'}->
	  createRectangle($$node{"_tkXPOS_"}-$xmargin,
			  $$node{"_tkYPOS_"}+$nodeHeight+$nodeYSkip-$ymargin,
			  $$node{"_tkXPOS_"}+
			  $textWidth+$xmargin,
			  $$node{"_tkYPOS_"}+
			  ($#displayAttrs+1)*$lineHeight+
			  $nodeHeight+$nodeYSkip+$ymargin,
			  nodeBoxOptions($grp,$node));
    }

    ## Texts of attributes
    for ($i=0;$i<=$#displayAttrs;$i++) {

      ## Clear background
      $$node{"_tkTextBg".$i."_"}=
	$grp->{'canvas'}->
	  createRectangle($$node{"_tkXPOS_"},
			  $$node{"_tkYPOS_"}+$nodeHeight+$nodeYSkip+$i*$lineHeight,
			  $$node{"_tkXPOS_"}+$node->{"_tkX_$i"}+1,
			  #$grp->{'canvas'}->fontMeasure($font,PrepareText($grp,$node,$i))+1,
			  $$node{"_tkYPOS_"}+$nodeHeight+$nodeYSkip+($i+1)*$lineHeight,
			  -fill => $grp->{'canvas'}->cget('-background'), -outline => undef)
	  unless ($drawBoxes);
      $grp->{'canvas'}->addtag('textbg', 'withtag', $$node{"_tkTextBg".$i."_"});
      $grp->{'pinfo'}{$$node{"_tkTextBg".$i."_"}}=$node;

      ## Draw attribute
      ## Custom version (the tredish)
      ##
      ## in this case we use the following syntax:
      ## #{color} changes color of all the following text
      ## ${attribute} is expanded to the value of attribute (and the
      ##              text is made active, so that modification is possible)
      ## <?code?>     expands to the return value of the imbedded perl-code
      ##              ($${attribute} may be used inside the code and is expanded
      ##               to 'value'. \${attribute} is not interpolated before <?code?>,
      ##               but may be used in retur value and is interpolated later)
      my $msg=encode(InterpolateTextField($node,$displayAttrs[$i]));
      $msg=~s/([\$\#]{[^}]+})/\#\#\#\1\#\#\#/g;
      my $xskip=0;
      my $txt;
      my $at_text;
      my $j=0;
      my $color=undef;
      foreach (split(/\#\#\#/,$msg)) {
	if (/^\${([^}]+)}$/) {
	  $j++;
	  $at_text=PrepareTextField($node,$1);
	  $txt=$grp->{'canvas'}->
	    createText($$node{"_tkXPOS_"}+$xskip,
		       $$node{"_tkYPOS_"}+
		       $nodeHeight+$nodeYSkip+$i*$lineHeight,
		       -anchor => 'nw',
		       -text => $at_text,
		       -fill => defined($color) ? $color : whichTextColor($grp,$1),
		       -font => $font);
	  $xskip+=$grp->{'canvas'}->fontMeasure($font,$at_text);
	  $grp->{'canvas'}->addtag('text', 'withtag', $txt);
	  $grp->{'pinfo'}{$txt}=$node;
	  $$node{"_tkText[$1][$i][$j]_"}=$txt;
	} elsif (/^\#{([^}]+)}$/) {
	  unless ($noColor) {
	    $color=$1;
	    $color=undef if ($color eq 'default');
	    $color=$customColors[$1] if ($color=~/^custom([0-9])$/);
	  }
	} else {
	  if ($_ ne "") {
	    $txt=$grp->{'canvas'}->
	      createText($$node{"_tkXPOS_"}+$xskip,
			 $$node{"_tkYPOS_"}+
			 $nodeHeight+$nodeYSkip+$i*$lineHeight,
			 -anchor => 'nw',
			 -text => $_,
			 -fill => defined($color) ? $color : $textColor,
			 -font => $font);
	    $xskip+=$grp->{'canvas'}->fontMeasure($font,$_);
	  }
	}
      }
    }

    $grp->{'pinfo'}{$$node{"_tkOval_"}}=$node;
    $grp->{'pinfo'}{$$node{"_tkTextBox_"}}=$node if exists $$node{"_tkTextBox_"};
  }

  ## Canvas Custom Balloons ##
  if ($grp->{FSFile}) {
    my $hint=$grp->{FSFile}->hint;
    if ($grp->{CanvasBalloon}) {
      $grp->{CanvasBalloon}->
	attach($grp->{'canvas'}->Subwidget('scrolled'),
	       -balloonposition => 'mouse',
	       -msg => { map 
			 {
			   if (defined($_)) {
			     my $msg=InterpolateTextField($grp->{'pinfo'}{$_},$hint);
			     $msg=~s/\${([^}]+)}/$grp->{'pinfo'}{$_}->{$1}/eg;
			     $_ => encode($msg);
			 }
			 } $grp->{'canvas'}->find('withtag','point')
		       });
    }
  }
}


sub follow_mouse {
  my ($w, $grp) = @_;
  my $e = $w->XEvent;
  my($x, $y) = ($w->fpixels($e->x), $w->fpixels($e->y));
  scrollCanvasToXY($w, $grp, $x, $y);
}

sub follow_mouse_press {
  my ($w, $grp) = @_;
  my $e = $w->XEvent;
  my($x, $y) = ($w->fpixels($e->x), $w->fpixels($e->y));

  $grp->{'pinfo'}{'lastX'}=$x;
  $grp->{'pinfo'}{'lastY'}=$y;
  $grp->{'pinfo'}{'lastCanvasX'}=$w->canvasx($x);
  $grp->{'pinfo'}{'lastCanvasY'}=$w->canvasy($y);
}



sub scrollCanvasToXY {
  my ($w, $grp, $x, $y)=@_;
  my ($ax,$bx)=$w->xview;
  my ($ay,$by)=$w->yview;
  my $canvasX;

  my $sizeX=$w->fpixels($grp->{'canvasWidth'})*($bx-$ax);
  my $shiftX=($x-$grp->{'pinfo'}{'lastX'});
  if ($shiftX>0) {
    if ($grp->{'pinfo'}{'lastX'} == $sizeX) {
      $shiftX=0;
    } else {
      $shiftX/=$sizeX-$grp->{'pinfo'}{'lastX'}; # a fraction of our right move in window
    }
    $canvasX=$shiftX*
      ($w->fpixels($grp->{'canvasWidth'})-
	$grp->{'pinfo'}{'lastCanvasX'}); # this is where we should get on the canvas
  }
  else {
    if ($grp->{'pinfo'}{'lastX'} == 0) {
      $shiftX=0;
    } else{
      $shiftX/=$grp->{'pinfo'}{'lastX'}
    }
    $canvasX=$shiftX*
	$grp->{'pinfo'}{'lastCanvasX'}; # this is where we should get on the canvas
  }
  $canvasX+=$grp->{'pinfo'}{'lastCanvasX'};
  $w->xview(moveto =>
	    max(0,min(1,($canvasX-$x+1+$w->fpixels($w->cget('-borderwidth')))
		      /$grp->{'canvasWidth'})));

  # the same for Y
  my $sizeY=$w->fpixels($grp->{'canvasHeight'})*($by-$ay);
  my $shiftY=($y-$grp->{'pinfo'}{'lastY'});
  if ($shiftY>0) {
    if ($grp->{'pinfo'}{'lastY'} == $sizeY) {
      $shiftY=0;
    } else {
      $shiftY/=$sizeY-$grp->{'pinfo'}{'lastY'}; # a fraction of our right move in window
    }
    $canvasY=$shiftY*
      ($w->fpixels($grp->{'canvasHeight'})-
	$grp->{'pinfo'}{'lastCanvasY'}); # this is where we should get on the canvas
  }
  else {
    if ($grp->{'pinfo'}{'lastY'}==0) {
      $shiftY=0;
    } else {
      $shiftY/=$grp->{'pinfo'}{'lastY'};
    }
    $canvasY=$shiftY*
	$grp->{'pinfo'}{'lastCanvasY'}; # this is where we should get on the canvas
  }
  $canvasY+=$grp->{'pinfo'}{'lastCanvasY'};
  $w->yview(moveto =>
	    max(0,min(1,($canvasY-$y+1+$w->fpixels($w->cget('-borderwidth')))
		      /$grp->{'canvasHeight'})));


  $grp->{'pinfo'}{'lastX'}=$x;
  $grp->{'pinfo'}{'lastY'}=$y;
  $grp->{'pinfo'}{'lastCanvasX'}=$w->canvasx($x);
  $grp->{'pinfo'}{'lastCanvasY'}=$w->canvasy($y);
}

sub recalculate_positions {
  my ($grp)=@_;
  my $xpos=$baseXPos;
  my $ypos;
  my $minxpos; # used temporarily to place a node far enough from its left neighbour
  my $maxypos; # has different meaning from $minxpos; this one's used for canvasHeight
  my $canvasWidth=0;
  my $node;
  my $pattern_count=0;
  $pattern_count=$grp->{FSFile}->pattern_count if (ref($grp->{FSFile}));

  print "pattern count is $pattern_count\n";
  my $fontHeight=$grp->{'canvas'}->fontMetrics($font, -linespace);

  #print "Calculating positions ...\n";
  %prevnode=();
  $maxypos=0;
  foreach $node (@{$grp->{Nodes}}) {
    $ypos=0;
    $parent=$node->parent;
    while ($parent) {
      #print "!\n";
      $ypos++;
      $parent=$parent->parent;
    }
    $maxypos=max($maxypos,$ypos);
    $$node{"_tkYPOS_"}=$baseYPos+$ypos*(2*($nodeYSkip+$ymargin)+
					$pattern_count*$fontHeight+$nodeHeight);

    #print "got y position for ",$$node{"form"},"\n";


    my $textWidth=0;
    my $m;

    for ($i=0;$i<$pattern_count;$i++) {
      $m=$grp->{'canvas'}->fontMeasure($font,PrepareText($grp,$node,$i));
      $$node{"_tkX_$i"}=$m;
      $textWidth=$m if $m>$textWidth;
    }
    $$node{"_tkXWidth_"}=$textWidth;
    $minxpos=0;
    if ($prevnode{$ypos}) {
      $minxpos=$prevnode{$ypos}{"_tkXPOS_"}+$prevnode{$ypos}{"_tkXWidth_"}+
	$nodeXSkip+$nodeWidth+2*$xmargin;
    }
    $xpos=max($xpos,$minxpos);
    $$node{"_tkXPOS_"}=$xpos;
    $xpos+=$nodeXSkip+$nodeWidth;
    $canvasWidth=
      max($canvasWidth,
	  $$node{"_tkXPOS_"}+$$node{"_tkXWidth_"}+$baseXPos+$nodeWidth+2*$xmargin+$nodeXSkip);
    #print "got x position\n";

    $prevnode{$ypos}=$node;
    #print "$ypos ... ",$$node{"_tkYPOS_"},"\n";
  }
  #print "Width: $canvasWidth\n";
  $grp->{'canvasWidth'}=$canvasWidth;
  $grp->{'canvasHeight'}=$baseYPos+
    ($maxypos+1)*(2*($nodeYSkip+$ymargin)+$pattern_count*$fontHeight+$nodeHeight);
  #print "Done.\n";
}

sub currentUnhiden {
  my $grp=shift;
  return unless $grp->{'FSFile'};
  unless ($showHidden) {
    my $node=$grp->{FSFile}->FS->isHidden($grp->{'currentNode'});
    setCurrent($grp,$node->parent) if ($node and $node->parent);
  }
}

sub currentLeft {
  my $grp=shift;
  return unless $grp->{'FSFile'};
  if ($showHidden) {
    if ($grp->{'currentNode'}->lbrother) {
      setCurrent($grp,$grp->{'currentNode'}->lbrother);
      centerTo($grp,$grp->{'currentNode'});
    }
  } else {
    my $n=$grp->{'currentNode'}->lbrother;
    $n=$n->lbrother while ($n and defined($grp->{FSFile}->FS->hide)
			   and ($n->{$grp->{FSFile}->FS->hide} eq 'hide'));
    if ($n) {
      setCurrent($grp,$n);
      centerTo($grp,$grp->{'currentNode'});
    }
  }
}

sub currentRight {
  my $grp=shift;
  return unless $grp->{'FSFile'};
  if ($showHidden) {
    if ($grp->{'currentNode'}->rbrother) {
      setCurrent($grp,$grp->{'currentNode'}->rbrother);
      centerTo($grp,$grp->{'currentNode'});
    }
  } else {
    my $n=$grp->{'currentNode'}->rbrother;

    $n=$n->rbrother while ($n and defined($n->{$grp->{FSFile}->FS->hide})
			   and ($n->{$grp->{FSFile}->FS->hide} eq 'hide'));
    if ($n) {
      setCurrent($grp,$n);
      centerTo($grp,$grp->{'currentNode'});
    }
  }
}

sub currentDown {
  my $grp=shift;
  return unless $grp->{'FSFile'};
  if ($showHidden) {
    if ($grp->{'currentNode'}->firstson) {
      setCurrent($grp,$grp->{'currentNode'}->firstson);
      centerTo($grp,$grp->{'currentNode'});
    }
  } else {
    my $n=$grp->{'currentNode'}->firstson;
    $n=$n->rbrother while ($n and defined($n->{$grp->{FSFile}->FS->hide})
			   and $n->{$grp->{FSFile}->FS->hide} eq 'hide');
    if ($n) {
      setCurrent($grp,$n);
      centerTo($grp,$grp->{'currentNode'});
    }
  }
}



sub currentUp {
  my $grp=shift;
  if ($grp->{'currentNode'}->parent) {
    setCurrent($grp,$grp->{'currentNode'}->parent);
    centerTo($grp,$grp->{'currentNode'});
  }
}

sub setCurrent {
  my ($grp,$node)=@_;
  my $prev=$grp->{currentNode};
  my $n;
  $grp->{'currentNode'}=$node;
  foreach $n ($prev,$node) { 
    $grp->{'canvas'}->itemconfigure($n->{'_tkOval_'}, nodeOptions($grp,$n));
    $grp->{'canvas'}->itemconfigure($n->{'_tkTextBox_'},nodeBoxOptions($grp,$n))
      if ($drawBoxes and $n->{'_tkTextBox_'});
    $grp->{'canvas'}->coords($n->{'_tkOval_'}, nodeCoords($grp,$n));
  }
}

sub centerToXY {
  ($grp, $x, $y) = @_;
  ($ax,$bx)=$grp->{'canvas'}->xview;
  ($ay,$by)=$grp->{'canvas'}->yview;

  $shiftx=($bx-$ax)/2;
  $shifty=($by-$ay)/2;

  $grp->{'canvas'}->xview(moveto => min(max(0,$x/$grp->{'canvasWidth'}-$shiftx),1))
    if ($grp->{'canvasWidth'}-$shiftx);
  $grp->{'canvas'}->yview(moveto => min(max(0,$y/$grp->{'canvasHeight'}-$shifty),1))
    if ($y/$grp->{'canvasHeight'}-$shifty);
}

sub centerTo {
  ($grp, $node) = @_;
  centerToXY($grp,$$node{'_tkXPOS_'},$$node{'_tkYPOS_'});
}

sub doEvalHook {
  my ($grp,$hook)=(shift,shift);
#  my $hookparams=join ",", map { "\"$_\"" } @_;
  my $context=$grp->{macroContext};
  return unless $hook;

  $this=$grp->{'currentNode'};
  return unless $this;
  $root=$grp->{'root'};

  my $result;
  $FileNotSaved=$grp->{FSFile}->notSaved; # Macro may want to override this :)
  my $bookmark=bookmarkThis($grp);        # Save current position (as last action position)
  local $insideEval=1;
  unless ($macrosEvaluated) {
    eval ("@macros\n return 1;");
    $macrosEvaluated=1;
    if ($result or $@) {
      print STDERR "FirstEvaluation of macros\n" if $macroDebug;
      print STDERR "Returned with: $result\n$@\n" if $macroDebug;
    }
  }
  if ($context->can($hook)) {
    print STDERR "running hook $context"."::"."$hook\n" if $hookDebug;
    $result=eval { return &{"$context\:\:$hook"}(@_); };
  } elsif ($context ne "TredMacro" and TredMacro->can($hook)) {
    print STDERR "running hook Tredmacro"."::"."$hook\n" if $hookDebug;
#    $result=eval("return TredMacro\:\:$hook($hookparams);\n");
    $result=eval { return &{"TredMacro\:\:$hook"}(@_); };
  } else {
    return undef;
  }
  print "$@\n" if $@;
  lastActionBookmark($grp,$bookmark) if $FileNotSaved and !$grp->{FSFile}->notSaved;
  $grp->{FSFile}->notSaved($grp->{FSFile}->notSaved or $FileNotSaved);
  saveFileStateUpdate($grp);

  # This may be important
  # (we do not want to leave references to non-existsing
  #  objects later)
  $this=undef;
  $root=undef;

  print STDERR "Hook $hook resulted with $result\n" if $hookDebug;
  return $result;
}


sub doEvalMacro {
  my ($grp,$macro)=(shift,shift);
  return unless $macro;

  $this=$grp->{'currentNode'};
  return unless $this;
  $root=$grp->{'root'};

  my $result;
  $grp->{'top'}->Busy(-recurse => 1);
  $FileNotSaved=1; #$grp->{FSFile}->notSaved;  # Macro may want to override this :)
  $forceFileSaved=0; # Macro may want to override this :)
  my $bookmark=bookmarkThis($grp);
  $insideEval=1;

  unless ($macrosEvaluated) {
    eval ("@macros\n return 1;");
    $macrosEvaluated=1;
    if ($result or $@) {
      print STDERR "FirstEvaluation of macros\n" if $macroDebug;
      print STDERR "Returned with: $result\n$@\n" if $macroDebug;
    }
  }
#  $result=eval("return ".$macro."();\n@macros\n");  # this consumes memory!!!!
  print "Running $macro\n" if $macroDebug;
  $result=eval("return $macro;\n");

  if ($result or $@) {
    print STDERR "Had run: ",$macro,"\n" if $macroDebug;
    print STDERR "Returned with: $result\n$@\n" if $macroDebug;
  }
  unless ($forceFileSaved) {
    print STDERR "Macro claims file untouched\n"
      unless ($FileNotSaved);
    $grp->{FSFile}->notSaved($grp->{FSFile}->notSaved or $FileNotSaved);
    lastActionBookmark($grp,$bookmark) if $FileNotSaved;
  } else {
    print STDERR "Macro forsly claims file saved.\n";
    # using value of $FileNotSaved
    $grp->{FSFile}->notSaved($FileNotSaved);
    lastActionBookmark($grp,$bookmark) if $FileNotSaved;
  }
  $insideEval=0;

  getNodes($grp);     # memory ok, speed ok


  #------------------------------------------------------------
  #use Benchmark;
  #my $t0 = new Benchmark;
  #for (my $i=0;$i<=50;$i++) {
  #------------------------------------------------------------

  redraw_tree($grp);  # ??? 4kb/50 runs memory leaks???, speed ok
 
  #------------------------------------------------------------
  #}
  #my $t1 = new Benchmark;
  #my $td = timediff($t1, $t0);
  #print "$FileNotSaved the code took:",timestr($td),"\n";
  #------------------------------------------------------------


  # the rest of this routine is:
  # memory ok, speed ok
  setCurrent($grp,$this) if ($this);
  currentUnhiden($grp);

  # This may be important
  # (we do not want to leave references to non-existsing
  #  objects later)
  $this=undef;
  $root=undef;

  centerTo($grp,$grp->{currentNode});


  $grp->{'top'}->Unbusy;
  return $result;
}

sub resolveKey {
  my $grp=shift;
 context:
  foreach my $context ($grp->{macroContext},$grp->{macroContext} eq "TredMacro" ? () : "TredMacro") {
    foreach $key (@_) {
      if (exists ($keyBindings{$context}->{$key})) {
	return $keyBindings{$context}->{$key};
      }
    }
  }
  return undef;
}

sub evalMacro {
  my ($w,$grp,$prefix)=@_;
  my $key;
  my $e = $w->XEvent;
  my $A = uc($e->A);
  my @possib=();
  my $macro=undef;

  if ($keyboardDebug) {
    print STDERR "Pressed: (".ord($A)."), prefix $prefix, keysym ",$e->K,"/",$e->N,"\n";
    print STDERR "Maybe: ",$prefix.$pckey_shift_translates{$e->K},"\n";
  }

  push @possib,
    ($prefix.$A,
      ($prefix =~/SHIFT/ and exists($pckey_shift_translates{$e->K})) ?
	$prefix.$pckey_shift_translates{$e->K} : ()),
	$prefix.uc($e->K);

  $macro=resolveKey($grp,@possib);
  if (defined $macro) {
#    use Benchmark;
#    my $t0 = new Benchmark;
#    # ... your code here ...
#    for (my $i=0;$i<=50;$i++) {
      doEvalMacro($grp,$macro);
#    }
#    my $t1 = new Benchmark;
#    my $td = timediff($t1, $t0);
#    print "the code took:",timestr($td),"\n";

    return 1;
  }
  return undef;
}

sub currentNext {
  my ($grp)=@_;
  my $next=HNext($grp,$grp->{'currentNode'});
  if ($next) {
    setCurrent($grp,$next);
    centerTo($grp,$grp->{'currentNode'});
  }
}


sub currentPrev {
  my ($grp)=@_;
  my $prev=HPrev($grp,$grp->{'currentNode'});
  if ($prev) {
    setCurrent($grp,$prev);
    centerTo($grp,$grp->{'currentNode'});
  }
}


sub node_down {

    my($w,$grp) = @_;

    my $e = $w->XEvent;
    my($x, $y) = ($e->x, $e->y);
    my $node=$grp->{'pinfo'}{$w->find('withtag','current')};

    setCurrent($grp,$node);
    $w->dtag('selected');
    $w->addtag('selected', 'withtag', 'current');
    $w->raise('current');
    $grp->{'pinfo'}{'lastX'} = $x;
    $grp->{'pinfo'}{'lastY'} = $y;
    $grp->{'pinfo'}{'lastCanvasX'}=$w->canvasx($x);
    $grp->{'pinfo'}{'lastCanvasY'}=$w->canvasy($y);
} # end plot_down

sub node_move {

    my($w,$grp,$scroll) = @_;

    my $e = $w->XEvent;
    my($x, $y) = ($e->x, $e->y);
    my $node=$grp->{'pinfo'}->{$w->find('withtag','selected')};

    my $lcx=$grp->{'pinfo'}{'lastCanvasX'};
    my $lcy=$grp->{'pinfo'}{'lastCanvasY'};
    my $ncolor,$ocolor;

    if ($scroll) {
      $ncolor=$w->itemcget('selected','-fill');
      $ocolor=$w->itemcget('selected','-outline');
      $w->itemconfigure('selected',
			-fill => $grp->{'canvas'}->cget('-background'),
			-outline => $grp->{'canvas'}->cget('-background')
		       );
      scrollCanvasToXY($w, $grp, $x, $y);
    } else {
      $grp->{'pinfo'}{'lastCanvasX'}=$w->canvasx($x);
      $grp->{'pinfo'}{'lastCanvasY'}=$w->canvasy($y);
    }
    my($cx, $cy) = ($w->canvasx($x),$w->canvasy($y));
    $w->move('selected',  $cx-$lcx, $cy-$lcy);
    $w->itemconfigure('selected', -fill => $ncolor, -outline => $ocolor ) if $scroll;
    $w->itemconfigure('nearest', -fill => (isShown($grp,$node,0) ?
						     $nodeColor :
						     $hiddenNodeColor));
    $w->dtag('nearest');

    my @dots= $w->find('withtag','point');
    my $nearestNode=0;
    my $bestDist=10000;
    my $dist;
    foreach $p (@dots) {
      if ($grp->{'pinfo'}{$p} and $grp->{'pinfo'}{$p}!=$node) {
	$dist=
	  ($cx-$grp->{'pinfo'}{$p}{'_tkXPOS_'})*
	    ($cx-$grp->{'pinfo'}{$p}{'_tkXPOS_'})+
	      ($cy-$grp->{'pinfo'}{$p}{'_tkYPOS_'})*
		($cy-$grp->{'pinfo'}{$p}{'_tkYPOS_'});
	if ($bestDist>$dist) {
	  $bestDist=$dist;
	  $nearestNode=$grp->{'pinfo'}{$p};
	}
      }
    }
    if ($bestDist<800) {
      $w->addtag('nearest','withtag',$$nearestNode{"_tkOval_"});
      $w->itemconfigure($$nearestNode{"_tkOval_"}, -fill => $nearestNodeColor);
    }
} # end plot_move

sub node_release {
  my($w,$grp) = @_;
  return unless $grp->{'FSFile'};
  my $e = $w->XEvent;
  my($x, $y) = ($e->x, $e->y);
  my $parent;
  my $node;
  my $center=0;
  my $sel=$w->find('withtag','selected');
  $node=$grp->{'pinfo'}{$sel} if (defined ($sel));

  if ($node) {
    $p=$w->find('withtag','nearest');
    $w->dtag('selected');
    if (defined $p) {
      $parent=$grp->{'pinfo'}{$p};
      $w->itemconfigure($parent->{"_tkOval_"}, 
			  nodeOptions($grp,$parent));
      while ($parent) {
	$p=0, last if ($node eq $parent);
	$parent=$parent->parent;
      }
      if ($p and $grp->{'pinfo'}{$p} 
	  and $node->parent!=$grp->{'pinfo'}{$p}) {
	Paste(Cut($node),$grp->{'pinfo'}{$p},$grp->{FSFile}->FS->defs);
	$grp->{FSFile}->notSaved(1);
	lastActionBookmark($grp);
	redraw_tree($grp);
	centerTo($grp,$grp->{currentNode});
	return;
      }
    }
    # returning node to its position
    $w->coords($sel, nodeCoords($grp,$node));
  } else { redraw_tree($grp); }
}

sub PrepareTextField {
  my ($node,$atr)=@_;
  $text=$node->{$atr};
  $text=$1."*" if ($text =~/^([^\|]*)\|/);
  return encode($text);
}

sub InterpolateTextField {
  my ($node,$text)=@_;
  $text=~s/\<\?((?:[^?]|\?[^>])+)\?\>/eval InterpolateRefs($node,$1)/eg;
  return $text;
}

sub InterpolateRefs {
  my ($node,$text)=@_;
  $text=~s/\$\${([^}]+)}/"'".$node->{$1}."'"/eg;
  return $text;
}

sub PrepareText {
  my ($grp,$node,$index)=@_;
  return unless ref($grp->{FSFile});
  my $msg=InterpolateTextField($node,$grp->{FSFile}->pattern($index));
  $msg=~s/\#{[^}]+}//g;
  $msg=~s/\${([^}]+)}/PrepareTextField($node,$1)/eg;
  return encode($msg);
}
