#!/usr/bin/perl
# -*- cperl -*-
#
################################################################################
#use strict;

use vars qw($version $timestamp $about $lastupdate $opt_u $opt_h $opt_c
            $libDir $macroFile @filelists @openfiles $treeViewOpts $opt_m
            @backends @ISA @EXPORT @open_types @save_types $opt_l
            $insideEval %pckey_shift_translates @recentFiles $tredDebug
            $valueLine $appName %menuBindings %keyBindings
            $savedSavePixmap $normalSavePixmap
           );

$version='$Revision$ ';
$timestamp="Time-stamp: <2001-07-27 14:45:25 pajas>";
$about=
  "Copyright (c) 2001 by Petr Pajas\n".
  "This software is distributed under GPL - The General Public Licence\n".
  "Full text of the GPL can be found at http://www.gnu.org/copyleft/gpl.html";
$lastupdate=$1 if ($timestamp=~/\<([0-9-: ]+) /);
################################################################################
#
# This is "TrEd" - a simple viewer/editor of tree graphs in fs
# file-format used in Graph - program developed by M. Kren. TrEd is
# written entirely in Perl and for graphical output it uses PerlTk
# library as a frontend to Tk toolkit
#
################################################################################
#
# Usage:
# tred [-c <config-file>] [-m <macro-file>] [-l <filelist>] [-p printing-options]
#      ... file1[##N|#N] [file2[##N|#N] [...]]
#
# or
#
# tred -u  for usage
#
# or
#
# tred -h  for help
#
################################################################################


# Once we got rid of them we call getopt to read all the other options
use Tk;
use Tk::Wm;

package Tk::Wm;
# overwriting the original Tk::Wm::Post:
sub Post
{
 my ($w,$X,$Y)= @_;
 $X= int($X);
 $Y= int($Y);
 $w->positionfrom('user');
# $w->geometry("+$X+$Y");
 $w->MoveToplevelWindow($X,$Y);
 $w->deiconify;
## This causes the "slowness":
# $w->raise;
}

package main;


use Tk::Xrm;
# process the standard arguments for X resources
Tk::CmdLine::SetArguments();


use Getopt::Std;
getopts('m:c:l:t:hu');

if ($opt_u || $opt_h) {
  print <<EOH;
Usage:
 tred [-c <config-file>] [-m <macro-file>] [-t context] [-l <filelist>] file1[##N|#N] [file2[##N|#N] [...]]
or
 tred -u|-h    for usage/help

EOH
  exit unless $opt_h;
  print <<EOF;
This is `TrEd' - an interactive tool for editing tree graphs.

Each filename may be followed by suffices of the following forms:

#N      where N is a number possibly followed by one or more
	upper-case letters. In this case, #N tells TrEd to skip to the
	first tree the root of which has `#N' as a value of attribute
	called `form' (this feature is optimized for specific
	instances of fs-format used while working on The Prague
	Dependency Treebank)

##N     where N is a number. This makes TrEd to go to the N-th tree in
	the given file after the file is opened.

-m      specifies a macro file different from the one given in ~/.tredrc
	(or whatsoever) configuration file

-c      specifies a config-file to be used (overrides
	~/.tredrc and all the other files TrEd would otherwise try to
	search for).

-l      specifies a file containing list of files to open

-t      start in the given macro context (package). TredMacro is the
        default context, and it is used also when given the context
        is not found.

EOF
  exit;
}


# in Windows, if HOME not defined, use user's AppData folder instaed
if ($^O eq "MSWin32" and !exists $ENV{HOME}) {
  require Win32::Registry;
  my %shf;
  my $ShellFolders;

  my $shfolders="Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders";
  $::HKEY_CURRENT_USER->Open($shfolders,$ShellFolders) or die "Cannot read $shfolders $^E\n";
  $ShellFolders->GetValues(\%shf);
  $ENV{HOME}= $shf{AppData}[2];
}

# Default values of $libDir used to search for macro-file (tred.mac)
# and default-macro file (tred.def) are specified here. They may be
# overriden by value of LibDir in tred resource file (tredrc or ~/.tredrc - see above).
# It is also used to find TrEd::Config.pm module.

use FindBin;
if (exists $ENV{TREDHOME}) {
  $libDir=$ENV{TREDHOME};
} elsif (-d "$FindBin::RealBin/tredlib") {
  $libDir="$FindBin::RealBin/tredlib";
} elsif (-d "$FindBin::RealBin/../lib/tredlib") {
  $libDir="$FindBin::RealBin/../lib/tredlib";
} elsif (-d "$FindBin::RealBin/../lib/tred") {
  $libDir="$FindBin::RealBin/../lib/tred";
}
print "Trying $libDir\n" if ($libDir);

$macroFile=undef;

########## Config file #############
# this must be done before readconfig is first used
@filelists=();
@openfiles=();


# We *must* at least find TrEd::Config module to learn the correct libDir!!.
print "First I'm trying $libDir\n";
unshift @INC,$libDir if (-d $libDir);

do {
  my $ld=$libDir;
  require TrEd::Config;
  import TrEd::Config;
  import TrEd::Config qw(&read_config &apply_config &set_default_config_file_search_list);
  $libDir=$ld;
};

$TrEd::Config::treeViewOpts={
			     drawSentenceInfo => 0,
			     showHidden => 0,
			     customColors	 => ['darkgreen','darkblue','darkmagenta',
						     'orange','black','DodgerBlue4',
						     'red','gold','cyan','midnightblue']
			    };

if (defined $opt_c) {
  @TrEd::Config::config_file_search_list=($opt_c); # override any other possible config files
} else {
  set_default_config_file_search_list();
}
$TrEd::Config::set_user_config=\&setConfig;	# tred specific configuration

my $configFile=read_config();

$macroFile="$libDir/tred.mac" unless (defined $macroFile);
if (defined $opt_m) {
  $macroFile=$opt_m;
}
####################################

unless (-d $libDir) {
  print <<'EOL';
 TrEd couldn't find a tredlib directory. You may need to point
 to its location by the TREDHOME variable or add a correct LibDir
 field to your ~/.tredrc.

EOL
    die "Error: Couldn't find lib-directory.";
}


use Cwd;

use Tk::LabFrame;
use Tk::Listbox;
use Tk::HList;
use Tk::ItemStyle;
use Tk::Balloon;
use Tk::DialogBox;
use Tk::Tiler;
use Tk::BrowseEntry;

unshift @INC,$libDir unless (grep($_ eq $libDir, @INC));

require Fslib;
import Fslib;
import Fslib qw(&Ord &Value &Hide &SentOrd &AOrd &AValue &AHide &ASentOrd &Index);

# import min and max functions
require TrEd::MinMax;
import TrEd::MinMax;

# import encode and decode functions
require TrEd::Convert;
import TrEd::Convert;

# import read_macros etc.
require TrEd::Macros;
import TrEd::Macros;

# tree drawing module
require TrEd::TreeView;

# tree view windowing module
require TrEd::Window;

# tree printing module
require TrEd::Print;

# basic tree operations
require TrEd::Basics;
import TrEd::Basics;

$TrEd::Basics::on_tree_change= \&onTreeChange;
$TrEd::Basics::on_node_change= \&onNodeChange;
$TrEd::Basics::on_current_change= \&onCurrentChange;

#load back-ends
#require CSTS_SGML_SP_Backend;
@backends=('FSBackend',ImportBackends(qw/TrXMLBackend CSTS_SGML_SP_Backend CSTSBackend/));
#$CSTS_SGML_SP_Backend::doctype= "$libDir/csts.doctype";

require Filelist;

require Tk::MyFileSelect;
require Tk::BindMouseWheel;

# different namespace only to load local rather than system files
# (rel2abs is not supported in all instalations)
use File::Spec;
if (not File::Spec->can(rel2abs)) {
  print "Using TFile::Spec\n";
  require TFile::Spec;
  require TFile::Spec::Functions;
  import TFile::Spec::Functions qw(rel2abs);
} else {
  print "Using File::Spec\n";
  require File::Spec;
  require File::Spec::Functions;
  import File::Spec::Functions qw(rel2abs);
}

use Exporter;
@ISA=qw(Exporter);

@EXPORT= qw($insideEval
            $libDir
            @openfiles @filelists &min &max);

@open_types=
  (["FS files",           [qw/.fs .FS .Fs/]],
   ["gzipped FS files",   [qw/.fs.gz .FS.gz .FS.GZ/]],
   ["All files",        '*']
  );

@save_types=
  (["FS files",           [qw/.fs .FS .Fs/]],
   ["gzipped FS files",   [qw/.fs.gz .FS.gz .FS.GZ/]],
   ["All files",        '*']
  );

ApplyGlobalConfig();

# it seems, that under Windoze setting LC_NUMERIC back to us does not
# work, so I recommend not to use czech locales there, unless you
# really want the decimal points to be replaced by commas in
# postscript:)

if ($TrEd::Config::useCzechLocales) {
  use locale;
  use POSIX qw(locale_h);
  setlocale(LC_COLLATE,"cs_CZ");
  setlocale(LC_NUMERIC,"us_EN");
  setlocale(LANG,"czech");
}

sub bookmarkFilelist {
  foreach (@filelists) {
    return $_ if ref and $_->name eq 'Bookmarks';
  }
  return undef;
}

{
  my $default= new Filelist('Default');
  my @files;

  if ($opt_l and -f $opt_l) {
    if (open(F,"<$opt_l")) {
      @files=<F>;
      close(F);
      chomp @files;
    }
  }
  push(@files, @ARGV);

  @files= map { rel2abs($_) } @files;

  $default->add(0,@files);
  addNewFilelist(undef,$default);
  unless (bookmarkFilelist()) {
    print "Bookmarks: ".$ENV{HOME}.'/.tred_bookmarks'."\n";
    my $bookmarks= new Filelist('Bookmarks',$ENV{HOME}.'/.tred_bookmarks');
    addNewFilelist(undef,$bookmarks);
  }
}

$insideEval=0;

my %searchTemplate;

%pckey_shift_translates= (exclam=> 1, at=> 2, numbersign=> 3,
			   dollar=> 4, percent=> 5, asciicircum=> 6,
			   ampersand=> 7, asterisk=> 8, parenleft=> 9,
			   parenright=> 0, plus=> 'equal',
			   underscore=> 'minus',
			   less=> 'comma', greater=> 'period', 
			   question=> 'slash',
			   colon=> 'semicolon', quotedbl=> 'apostroph',
			   braceleft=> 'bracketleft', 
			   braceright=> 'bracketright',
			   bar=> 'backslash', asciitilde=> 'grave'
			  );

print STDERR "Reading macros from $macroFile...\n";
read_macros($macroFile,$libDir);		# read macros
print STDERR "done.\n";

startMain();	# display first tree

print STDERR "TrEd ended.\n";

exit;

############################
############################
############################

sub setConfig {
  my $confs=shift;

  foreach (0..9) {
    $recentFiles[$_]=$confs->{"recentfile$_"};
  }
  @recentFiles=grep {$_} @recentFiles;

  require Filelist;
  my $fl;
  foreach (grep /^filelist[0-9]+/, keys %$confs) {
    print "Reading $_\n"  if $tredDebug;
    $fl=Filelist->new(undef,$confs->{$_});
    next unless $fl;
    $fl->load();
    print STDERR "Reading filelist ".$fl->name." from ".$fl->filename."\n" if $tredDebug;
    addNewFilelist(undef,$fl);
  }

#    $CSTSBackend::csts2fs=$cstsToFs;
#    $CSTSBackend::fs2csts=$fsToCsts;

  print STDERR "Applying configuration.\n" if $tredDebug;
}

sub ApplyGlobalConfig {
  my ($grp)=@_;

  @normal_win_opts = qw/-relief flat -borderwidth 0 -highlightthickness 0/;
  @focused_win_opts = (qw/-relief flat/,
		       -highlightthickness  => $highlightWindowWidth,
		       -highlightbackground => $highlightWindowColor);
  return unless $grp;

  foreach (@{$grp->{treeWindows}}) {
    if ($_->{treeView} and $treeViewOpts->{backgroundColor}) {
      $_->{treeView}->canvas->configure(-background=> $treeViewOpts->{backgroundColor});
    }
  }
}

# TrEd::Window ? should openFile in focusedWindow
sub gotoFile {
  my ($grp,$fn,$no_recent)=@_;
  return 0 if doEvalHook($grp->{focusedWindow},"goto_file_hook") eq 'stop';
  return 0 if ($fn >= $grp->{currentFilelist}->file_count or $fn<0);

  $grp->{focusedWindow}->{currentFileNo}=$fn;
  openFile($grp,$grp->{currentFilelist}->file_at($grp->{focusedWindow}->{currentFileNo}),$no_recent);
  if ($grp->{Filelist} and
	$grp->{filelistCurrentFilelist} eq $grp->{currentFilelist}) {
    my $path=filelistEntryPath($grp->{currentFilelist},$grp->{focusedWindow}->{currentFileNo});
    $grp->{Filelist}->anchorSet($path);
    $grp->{Filelist}->selectionClear();
    $grp->{Filelist}->selectionSet($path);
  }
  return 1;
}

sub nextFile {
  my ($grp,$no_recent)=@_;
  return gotoFile($grp,$grp->{focusedWindow}->{currentFileNo}+1,$no_recent);
}
sub prevFile {
  my ($grp,$no_recent)=@_;
  return gotoFile($grp,$grp->{focusedWindow}->{currentFileNo}-1,$no_recent);
}

# TrEd::Window ?
sub resumeFile {
  my ($win,$fsfile,$keep)=@_;
  return unless ref($win) and ref($fsfile);
  print "Resuming file ".$fsfile->filename."\n"  if $tredDebug;
  closeFile($win,0,$keep);

  $win->{FSFile}=$fsfile;
  $win->{treeNo}=$fsfile->currentTreeNo;
  $win->{currentNode}=$fsfile->currentNode;
  saveFileStateUpdate($win);
}

sub fsfileDisplayingWindows {
  my ($grp,$fsfile)=@_;
  return 
    grep {
      $_->{FSFile} eq $fsfile 
    } @{$grp->{treeWindows}};
}

sub isFocused {
  my ($win)=@_;
  return $win eq $win->{framegroup}->{focusedWindow} ? 1 : 0;
}


sub closeFile {
  my ($win,$no_update,$keep)=@_;

  $win->{Nodes}=undef;
#  undef $NodeClipboard;
  $win->{root}=undef;
  my $fsfile=$win->{FSFile};
  if ($fsfile) {
    $fsfile->currentTreeNo($win->{treeNo});
    $fsfile->currentNode($win->{currentNode});
  }
  $win->{FSFile}=undef;
  $win->{treeNo}=undef;
  delete $win->{currentNode} if (exists $win->{currentNode});
  $win->{treeView}->clear_pinfo();
  $valueLine="" if (isFocused($win));
  if ($keep and $fsfile) {
    print STDERR "Postponing ".$fsfile->filename()."\n"  if $tredDebug;
  } else {
    if ($fsfile and not fsfileDisplayingWindows($win->{framegroup},$fsfile)) {
      print STDERR "Removing ".$fsfile->filename()." from list of open files\n"  if $tredDebug;
      @openfiles=grep { $_ ne $fsfile } @openfiles;
      undef $fsfile;
    }
  }
  unless ($no_update) {
    updateTitle($win->{framegroup});
    updatePostponed($win->{framegroup});
    get_nodes_win($win);
    redraw_win($win);
  }
}

sub ErrorMessage {
  my ($grp,$msg)=@_;
  if ($grp->{top}) {
    $grp->{top}->toplevel->
      messageBox(-icon=> 'error',
		 -message=> $msg,
		 -title=> 'Error', -type=> 'ok');
  } else {
    print STDERR "$msg\n";
  }
}

sub addToRecent {
  my ($grp,$f)=@_;

  if (defined($f)) {
    $f=rel2abs($f);
    @recentFiles=grep { $_ ne $f } @recentFiles;
    unshift @recentFiles,$f;
  }
  @recentFiles=@recentFiles[0..min($#recentFiles,9)];

  if ($grp->{RecentFileMenu}) {
    my $menu= $grp->{RecentFileMenu}->cget(-menu);
    $menu->delete(0,'end');
    my $i=0;
    foreach (@recentFiles) {
      $grp->{RecentFileMenu}->command(-label => "$i.  $_",
				      -underline=> 0,
				      -command=> [\&openFile,$grp,$_]);
      $i++;
    }
  }
}

sub bookmarkThis {
  my ($grp)=@_;
  my $f=undef;
  if (ref($grp->{focusedWindow}->{FSFile})) {
    $f=$grp->{focusedWindow}->{FSFile}->filename()."##".($grp->{focusedWindow}->{treeNo}+1);
    if ($grp->{focusedWindow}->{currentNode}) {
      my $root;
      my $i=0;
      $root=$grp->{focusedWindow}->{FSFile}->treeList->[$grp->{focusedWindow}->{treeNo}];
      while ($root and $root ne $grp->{focusedWindow}->{currentNode}) {
	$i++;
	$root=$root->following();
      }
      $f.=".$i" if ($root);
    }
  }
  return $f;
}

sub addBookmark {
  my ($grp)=@_;
  my $bl=bookmarkFilelist();
  return unless ref($bl);
  my $f=bookmarkThis($grp);
  if (defined($f)) {
    insertToFilelist($grp,$bl,$bl->count,$f);
    updateBookmarks($grp);
  }
}

sub lastActionBookmark {
  my ($grp,$bmk)=@_;
  my $f=defined($bmk) ? $bmk : bookmarkThis($grp);
  if (defined($f)) {
    print STDERR "Bookmarking last action at: $f\n" if $tredDebug;
    $grp->{lastActionBookmark}=$f;
    updateBookmarks($grp);
  }
}

sub updateBookmarks {
  my ($grp)=@_;

  if ($grp->{BookmarksFileMenu}) {
    print STDERR "Updating bookmark menu\n"  if $tredDebug;
    my $menu= $grp->{BookmarksFileMenu}->menu;
    $menu->delete(0,'end');
    $grp->{BookmarksFileMenu}->command(-label=> 'Add to bookmarks',
				       -underline=> 0,
				       -command=> [ \&addBookmark,$grp ]);
    $grp->{BookmarksFileMenu}->separator();
    if (defined($grp->{lastActionBookmark})) {
      $grp->{BookmarksFileMenu}->command(-label => "Last action",
					 -underline=> 0,
					 -command=> [ \&openFile,$grp,$grp->{lastActionBookmark} ]);
    }
    $grp->{BookmarksFileMenu}->separator();
    my $i=0;
    my $bl=bookmarkFilelist();
    return unless ref ($bl);
    foreach (bookmarkFilelist->files()) {
      print STDERR "$_\n";
      $grp->{BookmarksFileMenu}->command(-label => "$i.  ".$_,
				      -underline=> 0,
				      -command=> [ \&openFile,$grp,$_ ]);
      $i++;
    }
  }
}

sub updatePostponed {
  my ($grp)=@_;

  if ($grp->{PostponedFileMenu}) {
    print STDERR "Updating session menu\n"  if $tredDebug;
    my $menu= $grp->{PostponedFileMenu}->menu;
    $menu->delete(0,'end');
    $grp->{PostponedFileMenu}->command(-label=> 'Open files',
				       -state=> 'disabled',
				       -background=> '#444444'
				      );
    my $i=0;
    foreach (@openfiles) {
      $grp->{PostponedFileMenu}->command(-label => "$i.  ".$_->filename(),
				      -underline=> 0,
				      -command=> [\&openFile,$grp,$_->filename(),0,1]);
      $i++;
    }
    $grp->{PostponedFileMenu}->command(-label=> 'none',
				       -state=> 'disabled'
				      ) unless (@openfiles);
    $grp->{PostponedFileMenu}->command(-label=> 'File lists',
				       -state=> 'disabled',
				       -background=> '#444444'
				      );

    $i='A';
    foreach (@filelists) { 
      $grp->{PostponedFileMenu}->command(-label => "$i.  ".$_->name(),
					 -underline=> 0,
					 -command=> [\&selectFilelist,$grp,$_->name()]);
      $i++;
    }
  }
}

sub updateTitle {
  my ($grp)=@_;
  return unless ref($grp);
  if (defined($grp->{focusedWindow}->{currentFileNo}) and 
      ref($grp->{focusedWindow}->{FSFile}) and
      defined($grp->{currentFilelist})) {
    $grp->{top}->title("$appName    ".
		       $grp->{currentFilelist}->name()."(".($grp->{focusedWindow}->{currentFileNo}+1)."/".
		       $grp->{currentFilelist}->file_count()."): ".$grp->{focusedWindow}->{FSFile}->filename()
		      );
  } else {
    $grp->{top}->title("$appName");
  }
}

sub openFile {
  my ($grp,$f,$no_recent,$keep)= @_;
  my $win=$grp->{focusedWindow};
  my $goto= undef;
  my %fs=(fs=> 'FS format',
	  fgz=> 'gzipped FS format',
	  trxml=> 'tree XML format',
	  any=> 'any non-specific format (csts?), using CstsToFs');

  if ($f=~/(##?[0-9A-Z]+(?:\.[0-9]+)?)$/) {
    $f=~s/(##?[0-9A-Z]+(?:\.[0-9]+)?)$//;
      $goto=$1;
    print "Goto suffix is $goto\n";
  }

  $keep = askSaveFile($win,1)
    unless ($keep or ref($win->{FSFile}) and $win->{FSFile}->filename() eq $f);

  $win->toplevel->Busy(-recurse=> 1) unless $insideEval;
  foreach ($win->{FSFile},@openfiles) {
    if (ref($_) and $_->filename() eq $f) {
      print "Opening postponed file\n" if $tredDebug;
      resumeFile($win,$_,$keep);

      $win->{currentFileNo} =
	max(0,$win->{currentFileNo});
      insertToFilelist($grp,$grp->{currentFilelist},
		       $win->{currentFileNo},
		       $f.$goto);
      updateTitle($grp);
      applyFileSuffix($win,$goto);
      get_nodes_win($win);
      redraw_win($win);
      if ($win->{currentNode}) {
	centerToXY($win,0,0);
      }
      doEvalHook($win,"file_resumed_hook");
      addToRecent($grp,$f) unless $no_recent;
      $win->toplevel->Unbusy() unless $insideEval;
      return 2;
    }
  }

  closeFile($win,1,$keep);

  $win->{FSFile}= FSFile->newFSFile($f,@backends);
  $win->{FSFile}->changeFileFormat(($f=~/\.gz$/ ? "gz-compressed " : "").$win->{FSFile}->backend);
  print STDERR "empty or corrupt file!\n" 
    if ($win->{FSFile}->lastTreeNo<0);

  $win->{treeNo}=0;

  if ($win->{FSFile}) {
    push @openfiles, $win->{FSFile};
    updatePostponed($grp);
  }
  # add file to filelist
  $win->{currentFileNo}= max(0,$win->{currentFileNo});
  insertToFilelist($grp,$grp->{currentFilelist},$win->{currentFileNo},$f.$goto);
  updateTitle($grp);

  applyFileSuffix($win,$goto);
  get_nodes_win($win);
  print "running on $win, focused is $win->{framegroup}->{focusedWindow}\n";
  doEvalHook($win,"file_opened_hook");
  redraw_win($win);
  if ($win->{currentNode}) {
    centerToXY($win,0,0);
  }
  $win->toplevel->Unbusy() unless $insideEval;

  addToRecent($grp,$f);
  return 1;
}

sub applyFileSuffix {
  my ($win,$goto)= @_;
  return unless $win->{FSFile} and defined($goto) and $goto ne "";
  # -- smells like PDT-specific code, at least the second case
  # but we want it, dont we:)

  if ($goto=~/^##([0-9]+)/) {
    $win->{treeNo}=min(max(0,$1-1),$win->{FSFile}->lastTreeNo);
  } elsif ($goto=~/^#([0-9]+)/) {
    for (my $i=0;$i<=$win->{FSFile}->lastTreeNo;$i++) {
      $win->{treeNo}=$i,last if ($win->{FSFile}->treeList->[$i]->{form} eq "#$1");
    }
  }
  # new: we're the dot in .[0-9]+ (TM)
  my $root;
  if ($goto=~/\.([0-9]+)$/) {
    $root=$win->{FSFile}->treeList->[$win->{treeNo}];
    my $i=$1;
    while ($root and $i>0) {
      $i--;
      $root=$root->following();
    }
    $win->{currentNode}=$root if ($root);
  }
  # hey, caller, you should redraw after this!
}

sub saveFile {
  my ($win)=@_;
  return unless $win->{FSFile};

  my $f=$win->{FSFile}->filename;

  rename $f,$f."~" if (-f $f);

  $win->toplevel->Busy(-recurse=> 1) unless $insideEval;
  unless ($win->{FSFile}->writeFile($f)) {
    $win->toplevel->Unbusy() unless $insideEval;
    ErrorMessage($win->{framegroup},"Error saving file to '$f'\n($!)\n");
    return 0;
  }
  $win->toplevel->Unbusy() unless $insideEval;
  saveFileStateUpdate($win);
}

sub isShown { # test if node is shown (always 1 if $showHidden)
  my ($win,$node,$show)=@_;
  $show=$win->get_showHidden() unless defined $show;

  return 0 unless ($node and $win->{FSFile});
  return 1 if $show or not defined($win->{FSFile}->FS->hide());
  while ($node and ($node->{$win->{FSFile}->FS->hide()} ne 'hide')) {
    $node=$node->parent;
  }
  return ($node ? 0 : 1)
}

sub HNext { # same as Next but obey $showHidden
  my ($win,$node,$top)= @_;
  $node=Next($node,$top);
  while ($node) {
    return $node if (isShown($win,$node));
    $node=Next($node,$top);
  }
  return 0;
}

sub HPrev { # same as Next but obey $showHidden
  my ($win,$node,$top)= @_;
  $node=Prev($node,$top);
  while ($node) {
    return $node if (isShown($win,$node));
    $node=Prev($node,$top);
  }
  return 0;
}

sub update_value_line {
  my ($grp)=@_;
  my $win=$grp->{focusedWindow}; # only focused window uses the value line
  if ($win and $win->{FSFile}) {
    $valueLine=encode($win->{FSFile}->value_line($win->{treeNo}));
  } else {
    $valueLine="";
  }
  return $valueLine;
}

### Get Nodes

sub get_nodes_win {
  my ($win)=@_;

  if ($win->{FSFile}) {
    $win->{root}=$win->{FSFile}->treeList->[$win->{treeNo}];
    ($win->{Nodes},$win->{currentNode})= $win->{treeView}->nodes($win->{FSFile},
								 $win->{treeNo},
								 $win->{currentNode});
  } else {
    $win->{root}=undef;
    $win->{Nodes}=[];
    $win->{currentNode}=undef;
  }
  update_value_line($win->{framegroup}) if (isFocused($win));
}

sub get_nodes_fsfile {
  my ($grp,$fsfile)=@_;
  return if $insideEval;
  foreach (fsfileDisplayingWindows($grp,$fsfile)) {
    get_nodes_win($_);
  }
  return;
}

sub get_nodes_fsfile_tree {
  my ($grp,$fsfile,$tree_no)=@_;
  return if $insideEval;
  foreach (grep {$_->{treeNo} == $tree_no}
	   fsfileDisplayingWindows($grp,$fsfile)) {
    get_nodes_win($_);
  }
  return;
}

sub get_nodes_all {
  my ($grp)=@_;
  foreach (@{ $grp->{treeWindows} }) {
    get_nodes_win($_);
  }
  return;
}

############################################################
############################################################
############################################################
# Filelists
############################################################

sub selectFilelist {
  my ($grp,$list_name)=@_;
  my $fl=switchFilelist($grp,$list_name);
  print "Switching filelist to $list_name\n"  if $tredDebug;
  return unless defined($fl);

  if ($fl ne $grp->{currentFilelist}) {
    # save file position in the current file-list
    # before switching
    if (ref($grp->{focusedWindow}->{FSFile}) and
	$grp->{currentFilelist}->position($grp->{focusedWindow}->{FSFile}->filename())>=0) {
      $grp->{currentFilelist}->set_current($grp->{focusedWindow}->{FSFile}->filename());
    }
    $grp->{currentFilelist}=$fl;
  }

  # find current file
  $grp->{focusedWindow}->{currentFileNo}=max(0,$fl->position());
  my $file=$fl->file_at($grp->{focusedWindow}->{currentFileNo});

  print "Setting up file $file, no. $grp->{focusedWindow}->{currentFileNo}\n"  if $tredDebug;

  if (defined($file)) {
    openFile($grp,$file);
  } else {
    closeFile($grp->{focusedWindow},0,askSaveFile($grp->{focusedWindow},1));  #emtpy filelist
  }
}

# Find named filelist. Return undef if no such filelist exists
sub findFilelist {
  my ($name)=@_;
  for (@filelists) {
    return $_ if ($_->name eq $name);
  }
  return undef;
}


# this is only a local switch inside the file list dialog window,
# but returns filelist of a given name as a by-product
sub switchFilelist {
  my ($grp,$list_name)=@_;
  return undef unless ref($grp);
  my $fl=undef;
  if (ref($list_name)) {
    $fl=$list_name;
    $list_name=$fl->name();
  }
  return $grp->{filelistCurrentFilelist} 
    if (ref($grp->{filelistCurrentFilelist}) and 
	$list_name eq $grp->{filelistCurrentFilelist}->name);
  $fl=findFilelist($list_name) unless ($fl);
  return undef unless $fl;
  if ($grp->{Filelist}) {
    $grp->{filelistCurrentFilelist}=$fl;
    $fl->expand();
    feedHListWithFilelist($grp,$grp->{Filelist},$fl);
    my $activate=0;
    if (defined($fl->current)) {
      $activate=max(0,$fl->position);
    }
    my $path=filelistEntryPath($fl,$activate);
    $grp->{Filelist}->selectionClear();
    if (defined($path) and $path ne "") {
      $grp->{Filelist}->anchorSet($path);
      $grp->{Filelist}->see($path);
      $grp->{Filelist}->selectionSet($path);
    }
    $grp->{Filelist}->update();
  }
  return $fl;
}


sub createFilelistBrowseEntry {
  my ($grp,$w,$filelistref)=@_;
  my $ll= $w->BrowseEntry
    (
     -label=> 'File lists:',
     -variable=> $filelistref,
     -browsecmd=>
     [
      sub {
	my ($grp,$list,$l)=@_;
	switchFilelist($grp,$$list);
      },$grp,$filelistref
     ],
     -listcmd=>
     [ sub {
	 my $l=shift;
	 $l->delete(0,'end');
	 foreach (@filelists) {
	   $l->insert(0,$_->name);
	 }
       }]
    );
  $ll->Subwidget('entry')->bind
    ('<Return>',
     [ sub {
	 my ($w, $grp, $fl)=@_;
	 my $text=$w->get;
	 if (defined Index(\@filelists, $text)) {
	   switchFilelist($grp,$text);
	 } else {
	   return unless $text ne "";
	   my $d=$w->toplevel->
	     Dialog(-text=> "File-list named $text does not exist.\n".
		    "Do you want to create new filelist or rename current?",
		    -bitmap=> 'question',
		    -title=> 'Create/Rename?',
		    -buttons=> ['Create', 'Rename', 'Cancel']);
	   $d->bind('<Return>', sub { my $w=shift; my $f=$w->focusCurrent;
				      $f->Invoke if ($f and $f->isa('Tk::Button')) } );
	   my $answer=$d->Show();
	   if ($answer eq 'Create') {
	     push @filelists, Filelist->new($text);
	     switchFilelist($grp,$text);
	     updatePostponed($grp);
	   } elsif ($answer eq 'Rename') {
	     my $oldn=$grp->{filelistCurrentFilelist}->name();
	     $grp->{filelistCurrentFilelist}->rename($text);
	     updateBookmarks($grp)
	       if ($oldn eq 'Bookmarks');
	     $$fl=$text;
	     updatePostponed($grp);
	   } else {
	     $$fl=$grp->{filelistCurrentFilelist}->name
	       if ($grp->{filelistCurrentFilelist});
	   }
	 }
       },$grp,$filelistref ]);
  $ll->Subwidget('entry')->Subwidget('entry')->configure(qw/-background white -foreground black/);
  $ll->Subwidget('slistbox')->configure(qw/-background white -foreground black/);
  return $ll;
}

sub getFilelistLinePosition {
  my ($fl,$line)=@_;
  return undef unless ref($fl);
  my ($p,$f)=split /\t/,$line;
  return Index($fl->list_ref,$p);
}

sub insertToFilelist {

  my ($grp,$filelist,$position)=(shift,shift,shift);
  $filelist=$grp->{currentFilelist} unless defined($filelist);
  $position=$grp->{focusedWindow}->{currentFileNo} unless defined($position);
  return unless ref($filelist);


  print "Insert: ",$#_," ",$_[0]," is at position ",$filelist->position($_[0]),"\n"  if $tredDebug;
  return if ($#_==0 and $filelist->position($_[0])>=0);
  # this is the case when we add a file which is actually already there

  my @list=map { rel2abs($_) } @_;
  my $tmp;
  my $toplevel= $grp->{Filelist} ? $grp->{Filelist}->toplevel : $grp->{top};
  @list= map {
    if (-d $_) {
      $tmp=Query($toplevel,"Selection Pattern","Insert pattern for directory $_","*.*");
      $_= defined($tmp) ? File::Spec->catfile($_,$tmp) : undef;
    }
    $_;
  } @list;
  print "Inserting @list\n" if $tredDebug;
  $filelist->add($position+1,@list);

  if ($grp->{Filelist} and 
      $grp->{filelistCurrentFilelist} eq $filelist) {
    feedHListWithFilelist($grp,$grp->{Filelist},$filelist);
      $position=max(0,$filelist->position($_[0]));
    my $path=filelistEntryPath($filelist,$position);

    $grp->{Filelist}->selectionClear();
    if ($grp->{Filelist}->info('exists',$path)) {
      $grp->{Filelist}->anchorSet($path);
      $grp->{Filelist}->selectionSet($path);
      $grp->{Filelist}->see($path);
    }
    # select all files resulting from added patterns
    for (my $i=0 ; $i<$filelist->file_count ; $i++) {
      if (defined(Index(\@_,$filelist->file_pattern($i)))) {
	$grp->{Filelist}->selectionSet(filelistEntryPath($filelist,$i));
      }
    }
  }
}

sub removeFromFilelist {
  my ($grp,$filelist,$position)=(shift,shift,shift);
  $filelist=$grp->{currentFilelist} if not defined($filelist);
  $position=$grp->{focusedWindow}->{currentFileNo} if not defined($position);
  return unless ref($filelist);

  $filelist->remove(@_);
  if ($filelist eq $grp->{currentFilelist}) {
    $grp->{focusedWindow}->{currentFileNo}= min($grp->{focusedWindow}->{currentFileNo},
				$filelist->file_count-1);
  }

  if ($grp->{Filelist} and 
      $grp->{filelistCurrentFilelist} eq $filelist) {
    $position=min($position,$filelist->file_count-1);
    feedHListWithFilelist($grp,$grp->{Filelist},$filelist);
      $grp->{Filelist}->selectionClear();
    my $path;
    $path=$grp->{filelistCurrentFilelist}->list_ref->[$position];
    if ($grp->{Filelist}->info('exists',$path)) {
      $grp->{Filelist}->anchorSet($path);
      $grp->{Filelist}->selectionSet($path);
      $grp->{Filelist}->see($grp->{Filelist}->info('anchor'));
    }
  }
}

sub addNewFilelist {
  my ($grp,$fl)=@_;
  return if not defined($fl) or $fl eq "";
  for (@filelists) {
    if ($_->name eq $fl->name) {
      print STDERR "Filelist ",$fl->name," already exists, replacing!\n"
	if $tredDebug;
      @{ $_->list_ref }= $fl->list;
      $_->expand;
      if ($grp) {
	$grp->{filelistCurrentFilelist}=undef;
	switchFilelist($grp,$_);
      }
      undef $fl;
      return;
    }
  }
  if (not defined($fl->name) or $fl->name eq "") {
    undef $fl;
    return;
  }
  push @filelists, $fl;
  if ($grp) {
    switchFilelist($grp,$fl);
    updatePostponed($grp);
  }
}

sub deleteFilelist {
  my ($grp,$fl)=@_;
  print "Deleting filelist $fl,".$fl->name()."\n";
  return if (ref($fl) or $fl->name eq 'Default' or 
		 $fl->name eq 'Bookmarks');
  print "Allowed\n";
  @filelists=grep($_ ne $fl, @filelists);
  print join "\n","Filelists:",@filelists,"";
  print scalar(@filelists),"\n";
  $grp->{filelistCurrentFilelist}=undef;
  undef $fl;
  switchFilelist($grp,'Default');
  updatePostponed($grp);
}

sub filelistEntryPath {
  my ($fl,$index)= @_;
  return undef unless ref($fl);

  my $f= $fl->file_at($index);
  my $p= $fl->file_pattern($index);
  return $f eq $p ? $f : "$p\t$f";
}

sub feedHListWithFilelist {
  my ($grp,$hl,$fl)=@_;
  return unless ref($hl) and ref($fl);
  $hl->delete('all');
  my $pat;
  my $f;
  for(my $i=0;$i<$fl->file_count;$i++) {
    $pat=$fl->file_pattern($i);
    $f=$fl->file_at($i);
    next unless defined($pat) and defined($f);
    if ($pat eq $f) {
      $hl->add($f,
	       -itemtype=> 'imagetext',
	       -image=> $grp->{fileImage},
	       -data=> $f,
	       -text=> $f);
      next;
    }
    unless ( $hl->info('exists', $pat) ) {
      $hl->add("$pat",
	       -itemtype=> 'imagetext',
	       -image=> $grp->{folderImage},
	       -data=> $pat,
	       -text=> $pat);
    }
    $hl->add("$pat\t$f",
	     -itemtype=> 'imagetext',
	     -image=> $grp->{fileImage},
	     -data=> $f,
	     -text=> $f);
  }
}

sub filelistDialog {

  use Tk::LabFrame;

  my ($grp,$modal)=@_;
  if (defined($grp->{Filelist})) {
    if ($modal) {
      ShowDialog($grp->{Filelist}->toplevel);
    } else {
      $grp->{Filelist}->toplevel->deiconify;
      $grp->{Filelist}->toplevel->focus;
      $grp->{Filelist}->toplevel->raise;
    }
    return;
  }
  return if ($grp->{Filelist});
  my $filelist;
  if (!ref($grp->{currentFilelist})) {
    selectFilelist($grp,'Default');
  }
  $grp->{filelistCurrentFilelist}=$grp->{currentFilelist};
  $filelist=$grp->{filelistCurrentFilelist}->name;
  my $d= $grp->{top}->Toplevel(-title=> "Filelist");
  $d->withdraw;
  $grp->{filelistDialog}=$d;

  my $frame=$d->Frame();
  my $labframe=$frame->LabFrame(-label=> 'Files to add',
				-labelside=> 'acrosstop'
			       )->pack(qw/-expand yes -fill both -side left/);
  my $fl= $labframe->MyFileSelect(-selectmode=> 'extended',
				   -filetypes=> \@open_types)
    ->pack(qw/-expand yes -fill both -side left -padx 5 -pady 5/);

  $fl->Subwidget('filelist')->configure(qw/-background white -foreground black/);

  my $midframe=$frame->Frame()->pack(qw/-side left/);

  my $lframe=$frame->Frame()->pack(qw/-expand yes -fill both -side left -padx 5 -pady 5/);
  my $ll= createFilelistBrowseEntry($grp,$lframe,\$filelist);

  $ll->pack(qw/-expand yes -fill both -side top/);
  my $t= $lframe->Scrolled(qw/HList -relief sunken 
                     -selectmode extended
                     -width 60
                     -background white
		     -height 15 -scrollbars oe/,
			    -separator=> "\t"
			   )
    ->pack(qw/-expand yes -fill both -side top/);
  $t->BindMouseWheelVert();
  $grp->{Filelist}=$t;
  feedHListWithFilelist($grp,$t,$grp->{currentFilelist});

  $frame->pack(qw/-expand yes -fill both -side top/);


  $midframe->Button(-text=> 'Add -->',
		    -command=>[
			       sub {
				 my ($grp,$t,$l)=@_;
				 insertToFilelist($grp,
						  $grp->{filelistCurrentFilelist},
						  getFilelistLinePosition($grp->{filelistCurrentFilelist},
									  $t->info('anchor')),
						  $l->getSelectedFiles
						 );
				 updateBookmarks($grp)
				   if (ref($grp->{filelistCurrentFilelist}) and
				       $grp->{filelistCurrentFilelist}->name eq 'Bookmarks');
			       },$grp,$t,$fl])->pack(-side=> 'top');

  $midframe->Button(-text=> 'Remove',
		    -command=>[
			       sub { 
				 my ($grp,$t)=@_;
				 removeFromFilelist($grp,
						    $grp->{filelistCurrentFilelist},
						    getFilelistLinePosition($grp->{filelistCurrentFilelist},
									    $t->info('anchor')),
						    $t->info('selection'));
				 updateBookmarks($grp)
				   if (ref($grp->{filelistCurrentFilelist}) and
				       $grp->{filelistCurrentFilelist}->name eq 'Bookmarks');
			       },$grp,$t])->pack(-side=> 'top');

  unless ($modal) {
    $t->bind('<Return>'=> [
			    sub {
			      my ($w,$grp)=@_;
			      my $anchor=$grp->{Filelist}->info('anchor');
			      my $nextentry=$grp->{Filelist}->info('next',$anchor);
			      unless ($nextentry and
					$grp->{Filelist}->info('parent',$nextentry) eq $anchor) {
				$grp->{filelistCurrentFilelist}->
				  set_current($grp->{Filelist}->
					      info('data',$grp->{Filelist}->info('anchor')));
				selectFilelist($grp,$grp->{filelistCurrentFilelist});
			      }
			    },$grp]);
    $t->bind('<Double-1>'=> [
			      sub {
				my ($w,$grp)=@_;
				my $anchor=$grp->{Filelist}->info('anchor');
				my $nextentry=$grp->{Filelist}->info('next',$anchor);
				my $data=$grp->{Filelist}->info('data',$anchor);
				if ($nextentry and
					$grp->{Filelist}->info('parent',$nextentry) eq $anchor) {
				  # pattern -> edit
				  my $position=
				    $grp->{filelistCurrentFilelist}->find_pattern($data);
				  $data=Query($grp->{Filelist}->toplevel,"Selection Pattern",
					"Edit directory pattern for $data",$data);
				  if (defined($data)) {
				    print "Removing ",$grp->{Filelist}->info('data',$anchor),"\n" if $tredDebug;
				    $grp->{filelistCurrentFilelist}->remove($grp->{Filelist}->info('data',$anchor));
				    print "Adding $data\n" if $tredDebug;
				    $grp->{filelistCurrentFilelist}->add($position,$data);
				    feedHListWithFilelist($grp,$grp->{Filelist},$grp->{filelistCurrentFilelist});
				  }
				} else {
				  # file -> go to
				  $grp->{filelistCurrentFilelist}->set_current($data);
				  selectFilelist($grp,$grp->{filelistCurrentFilelist});
				}
			      },$grp ]);
    $d->Button(-text=> 'Go',
	     -command=> [ sub {
			     my ($grp)=@_;
			     $grp->{filelistCurrentFilelist}->
			       set_current($grp->{Filelist}->
					   info('data',$grp->{Filelist}->info('anchor')));
			     selectFilelist($grp,$grp->{filelistCurrentFilelist});
			   },$grp ])->pack(-padx=>'0.5c',-pady=>'0.2c',-side => 'left');
  }
  $d->bind('<Destroy>'=> [sub { shift;
				 my $grp=shift;
				 $grp->{Filelist}=undef;
				 $grp->{filelistCurrentFilelist}=undef;
			       },$grp ]);
  $d->bind('all','<Escape>'=>
	   [sub { shift;
		  $modal ?
		    shift->{selected_button}= "Cancel" :
		      shift->destroy();
		},$d ]);

  $d->Button(-text=> 'Close',
	     -command=> [sub {
			    $modal ?
			      shift->{selected_button}= "Cancel" :
				shift->destroy();
			  },$d ])
    ->pack(-padx=>'0.5c',-pady=>'0.2c',-side => 'right');

  $d->Button(-text=> 'Save',
	     -command=> [sub {
			    my ($grp,$d)=@_;
			    my $file=$grp->{filelistCurrentFilelist}->filename;
			    unless (defined ($file)  and $file ne "") {
			      my $initdir=dirname($file);
			      $initdir=cwd if ($initdir eq './');
			      $file= $d->getSaveFile(-filetypes=> 
								 [["Filelists",           ['.fl']]],
								 -title=> "Save filelist as ...",
								 -initialdir=> $initdir,
								 -initialfile=> filename($file));
			      $d->deiconify;
			      $d->focus;
			      $d->raise;
			      return unless (defined $file and $file ne "");
			      $grp->{filelistCurrentFilelist}->filename($file);
			    }
			    $grp->{filelistCurrentFilelist}->save;
			  },$grp,$d ])
    ->pack(-padx=>'0.5c',-pady=>'0.2c',-side => 'right');

  $d->Button(-text=> 'Load',
	     -command=> [sub {
			    my ($grp,$d)=@_;
			    my $file= $d->getOpenFile(-filetypes=> 
						      [["Filelists",           ['.fl']]],
						      -title=> "Load filelist ...");
			    $d->deiconify;
			    $d->focus;
			    $d->raise;
			    return unless (defined $file and $file ne "");
			    my $fl=Filelist->new(undef,$file);
			    return unless $fl;
			    $fl->load();
			    addNewFilelist($grp,$fl);
			  },$grp,$d ])
    ->pack(-padx=>'0.5c',-pady=>'0.2c',-side=>'right');

  $d->Button(-text=> 'Delete',
	     -command=> [sub {
			    my ($grp,$d)=@_;
			    deleteFilelist($grp,$grp->{filelistCurrentFilelist});
			  },$grp,$d ])
    ->pack(-padx=>'0.5c',-pady=>'0.2c',-side=>'right');

  if ($grp->{focusedWindow}->{currentFileNo}) {
    my $path=filelistEntryPath($grp->{filelistCurrentFilelist},$grp->{focusedWindow}->{currentFileNo});
    $t->anchorSet($path);
    $t->selectionClear();
    $t->selectionSet($path);
    $t->see($path);
  }
  $t->focus;
  if ($modal) {
    ShowDialog($d);
    $d->destroy();
    return $filelist;
  } else {
    $d->Popup;
    return $filelist;
  }

}

sub generateSortedMacroTable {
  my ($grp)=@_;
  my @macroTable= map { [ 
			 $_,
			 $menuBindings{$grp->{focusedWindow}->{macroContext}}->{$_}->[1],
			] } keys %{$menuBindings{$grp->{focusedWindow}->{macroContext}}};
  if ($grp->{macroListOrder} eq 'K') {
    return sort {
      my @a= split '\+',$a->[1];
      my @b= split '\+',$b->[1];
      return $#a <=> $#b if ($#a != $#b);
      return length($a[0]) cmp length($b[0]) if (length($a[0]) ne length($b[0]));
      return $a[0] cmp $b[0] if ($a[0] ne $b[0]);
      return length($a[1]) cmp length($b[1]) if (length($a[1]) ne length($b[1]));
      return $a[1] cmp $b[1] if ($a[1] ne $b[1]);
      return length($a[2]) cmp length($b[2]) if (length($a[2]) ne length($b[2]));
      return $a[2] cmp $b[2] if ($a[2] ne $b[2]);
      return length($a[3]) cmp length($b[3]) if (length($a[3]) ne length($b[3]));
      return $a[3] cmp $b[3] if ($a[2] ne $b[3]);
      return $a cmp $b;
    } @macroTable;
  } else {
    return sort { $a->[0] cmp $b->[0] } @macroTable;
  }
}

sub macrolistCreateItems {
  my ($grp,$t)=@_;
  $t->delete('all');
  foreach my $entry (generateSortedMacroTable($grp)) {
    $e= $t->addchild("");
    $t->itemCreate($e, 0, -itemtype=>'text', -text=>$entry->[0]);
    $t->itemCreate($e, 1, -itemtype=>'text', -text=>$entry->[1]);
  }
}

sub macrolistDialog {
  my $grp=shift;
  my $context=$grp->{focusedWindow}->{macroContext};
  if ($grp->{Macrolist}) {
    $grp->{Macrolist}->deiconify;
    $grp->{Macrolist}->focus;
    $grp->{Macrolist}->raise;
    return;
  }
  unless (scalar(keys %{$menuBindings{$context}})) {
    ErrorMessage($grp,"No named macros in current context ($context)");
    return;
  }
  my $d= $grp->{top}->Toplevel(-title=> "List of available named macros");
  $d->withdraw;
  $d->resizable(0,1);
  my $t= $d->Scrolled(qw/HList -columns 2 -background white 
           -selectmode browse
           -height 25 -relief sunken -scrollbars oe/);
  $t->BindMouseWheelVert();
  $grp->{Macrolist}=$d;
  my $e;
  my $maxw=0;
  macrolistCreateItems($grp,$t);

  $t->columnWidth(0,'');
  $t->columnWidth(1,'');
  $t->anchorSet('0');

  $t->configure(-width=> 0);
  $t->pack(qw/-expand yes -fill both/);
  $d->bind('<Return>'=>
	   [
	    sub {
	      my ($w,$grp,$t,$context)=@_;
	      doEvalMacro($grp->{focusedWindow},
			  $menuBindings{$context}->
			  {$t->itemCget($t->info('anchor'),0,'-text')}->[0]);
	    },$grp,$t,$context ]);
  $d->bind('<Double-1>'=> 
	   [
	    sub {
	      my ($w,$grp,$t,$context)=@_;
	      doEvalMacro($grp->{focusedWindow},
			  $menuBindings{$context}->
			  {$t->itemCget($t->info('anchor'),0,'-text')}->[0]);
	    },$grp,$t,$context ]);

  my $f=$d->Frame()->pack();
  $f->Radiobutton( -anchor  => 'nw',
		   -text    => 'Sort by name',
		   -variable=> \$grp->{macroListOrder},
		   -relief  => 'flat',
		   -command => [sub { #shift;
				       my ($grp,$t)=@_;
				       macrolistCreateItems($grp,$t);
				     },$grp,$t],
		   -value   => 'M'
		 )->pack(-side=> 'left',-padx=> 20);
  $f->Radiobutton( -anchor  => 'nw',
		   -text    => 'Sort by keyboard shortcut',
		   -variable=> \$grp->{macroListOrder},
		   -relief  => 'flat',
		   -command => [sub { #shift;
				       my ($grp,$t)=@_;
				       macrolistCreateItems($grp,$t);
				     },$grp,$t],
		   -value   => 'K'
		 )->pack(-side=> 'right',-padx=> 20);

  $d->Button(-text=> 'Run and Close',
	     -command=> [ sub {
			     my ($w,$grp,$t,$context)=@_;
			     my $mac=$t->itemCget($t->info('anchor'),0,'-text');
			     $w->destroy();
			     doEvalMacro($grp->{focusedWindow},
					 $menuBindings{$context}->{$mac}->[0]);


			   },$d,$grp,$t,$context ])->pack(-padx=>'0.5c',-pady=>'0.2c',-side=>'left');
  $d->bind($d,'<Destroy>'=> [sub { shift; shift->{Macrolist}=undef; },$grp ]);
  $d->bind('all','<Escape>'=>
	   [sub {
	      shift; shift->destroy();
	    },$d ]);

  $d->Button(-text=> 'Close',
		     -command=> [ sub {
				     shift->destroy();
				   },$d ])->pack(-padx=>'0.5c',-pady=>'0.2c',-side=>'right');
  $t->focus;
  $d->Popup;
}

sub printDialog {
  my $grp=shift;

  return unless $grp->{focusedWindow}->{FSFile};

  my $com=$grp->{printCommand};
  my $fil=$grp->{printPsFile};
  $fil=$grp->{focusedWindow}->{FSFile}->filename;
  $fil=~s/\.[^.]*$/.ps/;
  my $toFile=$grp->{printToFile};
  my $toEPS=$grp->{printToEPS};
#  my $useType1Font=$grp->{printUseType1Font};
  my $printRange=$grp->{printRange};
  my $snt=$grp->{printSentenceInfo};
  my $noRotate=$grp->{printNoRotate};

  my $d= $grp->{top}->DialogBox(-title=> "Print",
				-buttons=> ["OK", "Cancel"]);
  $d->resizable(0,0);
  addBindTags($d,'dialog');
  $d->bind('all','<Escape>'=> [sub { shift; shift->{selected_button}='Cancel'; },$d ]);
  $d->bind('all','<Tab>',[sub { shift->focusNext; }]);
  $d->bind('all','<Shift-Tab>',[sub { shift->focusPrev; }]);
  my $cf= $d->Frame();
  my $cl= $cf->Label(-text=> 'Print command:',
		     -anchor=> 'w',
		     -justify=> 'right')->pack(-side=> 'left');

  my $ce= $cf->Entry(-relief=> 'sunken',
		     -width=> 20,
		     -font=> $font,
		     -textvariable=> \$com)->pack(-side=> 'left');
  my $defaultBg=$ce->cget('-background');
  my $disabledBg=$d->cget('-background');

  $ce->configure($toFile 
		? (-state=> 'disabled',-background=> $disabledBg)
		: (-state=> 'normal', -background=> $defaultBg));


  $cf->pack(-pady=> '5m', -side=>'top');
  my $ff=$d->Frame();
  my $fl= $ff->Label(-text=> 'File name:',
		     -anchor=> 'w',
		     -justify=> 'right')->pack(-side=> 'left');

  my $fe= $ff->Entry(-relief=> 'sunken',
		     -width=> 50,
		     -font=> $font,
		     -textvariable=> \$fil)->pack(-side=> 'left');

  $fe->configure($toFile 
		? (-state=> 'normal', -background=> $defaultBg)
		: (-state=> 'disabled',-background=> $disabledBg));
  my $of=$d->Frame();
  my $bf=$of->Frame();
  $bf->Checkbutton(-text    => 'Print to file',
		   -variable=> \$toFile,
		   -command => [sub {
				  my ($t,$c,$f)=@_;
				  if ($$t) {
				    $f->focus;
				    $c->configure(-state=> 'disabled',
						  -background=> $disabledBg);
				    $f->configure(-state=> 'normal',
						  -background=> $defaultBg);
				  } else {
				    $c->focus;
				    $f->configure(-state=> 'disabled',
						  -background=> $disabledBg);
				    $c->configure(-state=> 'normal',
						  -background=> $defaultBg);
				  }
				},\$toFile,$ce,$fe ],
		   -relief  => 'flat')->pack(-fill=> 'y',-anchor=> 'nw');

  $bf->Checkbutton(-text    => 'Create EPS',
			  -variable=> \$toEPS,
			  -relief  => 'flat')->pack(-fill=> 'y',-anchor=> 'nw');

#    $bf->Checkbutton(-text    => 'Use Type1 Postscript Font',
#  			  -state=> $type1font ? 'normal' : 'disabled' ,
#  			  -variable=> \$useType1Font,
#  			  -relief  => 'flat')->pack(-fill=> 'y',-anchor=> 'nw');

  $bf->Checkbutton(-text=> 'Use colors',
		   -variable=> \$printColors,
		   -relief  => 'flat')->pack(-fill=> 'y',-anchor=> 'nw');
  $bf->Checkbutton(-text=> 'Print sentence',
		   -variable=> \$snt,
		   -relief  => 'flat')->pack(-fill=> 'y',-anchor=> 'nw');

  $bf->Checkbutton(-text    => 'Disable landscape rotation of wide trees',
			  -variable=> \$noRotate,
			  -relief  => 'flat')->pack(-fill=> 'y',-anchor=> 'nw');
  
  $bf->pack(-side=> 'right');
  $of->pack(-fill=> 'x',-padx=>'1c');
  my $sf= $d->Frame();
  $sf->Label(-text=> 'Page range:',
	     -anchor=> 'w',
	     -justify=> 'right')->pack(-side=> 'left');
  $sf->Entry(-relief=> 'sunken',
	     -width=> 20,
	     -font=> $font,
	     -textvariable=> \$printRange)->pack(-side=> 'left', -padx=>'2m');
  $sf->pack(-side=> 'bottom', -pady=> '5m');
  $ff->pack(-side=> 'bottom', -pady=> '5m');

#  $toFile ? $fe->focus : $ce->focus;
  my $result= ShowDialog($d,$toFile ? $fe : $ce,$grp->{top});
  $grp->{printRange}=$printRange;
#  $grp->{printSelection}= join(' ',grep { $lt->selectionIncludes($_) } (0 .. $lt->size-1));
  $grp->{printToFile}=$toFile;
  $grp->{printToEPS}=$toEPS;
  $grp->{printPsFile}=$ fil;
  $grp->{printSentenceInfo}=$snt;
  $grp->{printCommand}=$com;
#  $grp->{printUseType1Font}=$useType1Font;
  $grp->{printNoRotate}=$noRotate;
  $d->destroy;
  undef $d;
  if ($result=~ /OK/) {
    return ($printRange,$toFile,$toEPS,$fil,$snt,$com,
	    #$useType1Font,
	    $printColors,$noRotate);
  } else {
    return ();
  }
}

sub printThis {
  my ($grp)=@_;
  return unless $grp->{focusedWindow}->{FSFile};
  my $canvas=$grp->{top}->Canvas();
  my @print_opts=printDialog($grp);
  return unless scalar(@print_opts)>2;
  $print_opts[0]=$grp->{focusedWindow}->{treeNo}
    if (!defined($print_opts[0]) or $print_opts[0] eq "");
  TrEd::Print::print_trees($grp->{focusedWindow}->{FSFile},
			   $grp->{top},
			   $canvas,
			   @print_opts,
			   $grp->{focusedWindow}->{treeView}->get_showHidden(),
			   $psFontFile,
			   $psFontAFMFile,
#			   $type1font,
			   $prtFmtWidth,
			   $prtHMargin,
			   $prtFmtHeight,
			   $prtVMargin,
			   $psFontName,
			   $psFontSize,
			   $maximizePrintSize,
			   $psMedia,
			   $treeViewOpts
			  );
  $canvas->destroy();
}

sub switchContext {
  my ($win,$context)=@_;
  my $prevcontext=$win->{macroContext};
  return 0 if (doEvalHook($win,"pre_switch_context_hook",$prevcontext,$context)
	       eq 'stop');
  $win->{macroContext}=$context;
  $win->{framegroup}->{selectedContext}=$context if (isFocused($win));
  doEvalHook($win,"switch_context_hook",$prevcontext,$context);
  redraw_win($win);		# something should be done with display attrs vs windows maybe
}

sub onTreeChange {
  my ($win)=@_;
  get_nodes_fsfile_tree($win->{framegroup},$win->{FSFile},$win->{treeNo});
  if ($win->{currentNode}) {
    centerToXY($win,0,0);
  }
  redraw_fsfile_tree($win->{framegroup},$win->{FSFile},$win->{treeNo});
}

sub onNodeChange {
  my ($win)=@_;
  get_nodes_fsfile_tree($win->{framegroup},$win->{FSFile},$win->{treeNo});
  redraw_fsfile_tree($win->{framegroup},$win->{FSFile},$win->{treeNo});
}

sub onCurrentChange {
  my ($win,$node,$prev)=@_;
  my $n;
  $tv=$win->{treeView};
  foreach $n ($node,$prev) {
    $tv->canvas->itemconfigure($tv->get_node_pinfo($n,"Oval"),
			       nodeOptions($win,$n));
    if ($tv->get_node_pinfo($n,"NodeHasBox")) {
      $tv->canvas->itemconfigure($tv->get_node_pinfo($n,"TextBox"),
				 nodeBoxOptions($win,$n,0));
    }
    if ($tv->get_node_pinfo($n,"EdgeHasBox")) {
      $tv->canvas->itemconfigure($tv->get_node_pinfo($n,"EdgeTextBox"),
				 nodeBoxOptions($win,$n,1));
    }
    $tv->canvas->coords($tv->get_node_pinfo($n,"Oval"),
			$tv->node_coords($n,$win->{currentNode}));
  }
  unless ($prev eq $node) {
    $tv->apply_stored_style_opts("Oval",$prev);
    $tv->apply_stored_style_opts("TextBox",$prev);
    $tv->apply_stored_style_opts("EdgeTextBox",$prev);
    doEvalHook($win,"current_node_change_hook",$node,$prev) unless $insideEval;
  }
}

sub prepareFont {
  my ($grp,$font,$fn)=@_;
  print STDERR "Preparing fonts.\n" if $tredDebug;
  if ($$font!~/^-/) {
    my @a=split(/\s*,\s*/,$$font);
    my ($option,$value);
    my @b;
    foreach (@a) {
      ($option, $value)= split(/\s*:\s*/, $_, 2);
      push @b, "-".$option, $value if ($option=~/^(?:size|weight|family|slant|underline|overstrike)$/);
    }
      # try
    eval { $grp->{top}->fontDelete($fn) }; 
      # error would be displayed otherwise if yet undefined
      # and I'm lazy to remember or find out how to check
      # :)
    $grp->{top}->fontCreate($fn,@b);
    $$font=$fn;
  }
  #
  # There were problems with the following lines, so I'm skipping them  
  #
  # else {
  #  $grp->{top}->fontCreate('C_normal',$grp->{top}->fontActual($$font));
  #  $$font='C_normal';
  # }
}

sub prepareFonts {
  my $grp=shift;
  prepareFont($grp,\$font,'C_normal');
  $treeViewOpts->{font}=$font;
  prepareFont($grp,\$vLineFont,'C_vline');
}

sub addBindTags {
  my $w=shift @_;
  $w->bindtags([@_,$w,ref($w),$w,$w->toplevel,'all']);

}

sub cascadeMenus {
  my $uM=[ @_[0..min($maxMenuLines-1,$#_)] ];
  my $uuM=$uM;
  $i=$maxMenuLines;
  while ($i<=$#_) {
    $_=[@_[$i..min($i+$maxMenuLines-1,$#_)]];
    push @$uuM,[Cascade=> 'More...', -menuitems=> $_];
    $uuM=$_;
    $i+=$maxMenuLines;
  }
  return $uM;
}

sub saveFileStateUpdate {
  my ($win)=@_;
  return unless isFocused($win);
  return unless $win->{framegroup}->{saveButton};
  $win->{framegroup}->{saveButton}->
    configure(-image=>
	      ($win->{FSFile} and $win->{FSFile}->notSaved)
	      ? $normalSavePixmap : $savedSavePixmap);
}


sub About {
  my ($grp)=@_;
  my $message="";
  my $fileinfo="";
  my $colinf="";
  if ($grp->{focusedWindow}->{FSFile}) {
    $fileinfo=
      "Current file:\n".
	$grp->{focusedWindow}->{FSFile}->filename."\n".
	  "Format: ".$grp->{focusedWindow}->{FSFile}->fileFormat.", ".$grp->{focusedWindow}->{FSFile}->lastTreeNo." trees\n";
    my %colinf=(Shadow=> [], Hilite=>, XHilite=> []);
    foreach ($grp->{focusedWindow}->{FSFile}->FS->attributes) {
      push @{$colinf{$grp->{focusedWindow}->{FSFile}->FS->color($_)}},$_
	unless ($grp->{focusedWindow}->{FSFile}->FS->color($_) eq 'normal');
    }
    $colinf="Coloured attributes:\n    Highlited: ".join(",",@{$colinf{Hilite}}).
      "\n    XHighlited: ".join(",",@{$colinf{XHilite}}).
	"\n    Shadow: ".join(",",@{$colinf{Shadow}})."\n";
  }

  doEvalHook($grp->{focusedWindow},"about_file_hook",\$message);
  my $ver=$version;
  $ver=~s/\$//g;
  $grp->{top}->toplevel->
    messageBox(-icon=> 'info',
			  -type=> 'ok',
			  -message=>
			  "TrEd $ver\n\n$fileinfo$colinf$message\n$about\n\nLast update: $lastupdate",
			  -title=> 'About');
}

sub newTrEdWindow {
  my ($grp)=@_;

  my $win= new TrEd::Window(newTreeView($grp),framegroup=>$grp);
  $win->{macroContext}= $opt_t && exists($keyBindings{$opt_t}) 
    ? $opt_t : 'TredMacro';
  push @{$grp->{treeWindows}}, $win;
  return $win;
}

sub newTreeView {
  my ($grp)=@_;

  my $canvas=
    $grp->{top}->Scrolled('Canvas',
		   -width=> $defCWidth,
		   -height=> $defCHeight,
		   qw /-relief sunken
		       -borderwidth 2
                       -scrollbars osoe/,
		   -scrollregion=> [qw/0c 0c 1c 1c/],
		   $treeViewOpts->{backgroundColor} 
		   ? (-background=> $treeViewOpts->{backgroundColor}) : ()
		  );
  canvasBindMouseWheelVert($canvas);
  canvasBindMouseWheelHoriz($canvas,"Shift");
  createCanvasBindings($grp,$canvas);
  addBindTags($canvas,'my');
  addBindTags($canvas->Subwidget('scrolled'),'canvas');

  my $baloon=$grp->{top}->Balloon(-initwait=> $canvasBalloonInitWait,
				  -state=> 'balloon',
				  -background=> '#fff3b0');
  $baloon->Subwidget('message')->configure(-justify=> 'left',-font=> $font);
  my $treeView=new TrEd::TreeView($canvas,'CanvasBalloon'=> $baloon);
  $treeView->apply_options($treeViewOpts);
  return $treeView;
}

sub findCanvasWindow {
  my ($grp,$canvas)=@_;
  foreach (@{$grp->{treeWindows}}) {
    return $_ if $_->contains($canvas);
  }
  return undef;
}

sub focusCanvas {
  my ($c,$grp)=@_;
  if ($grp->{focusedWindow}) {
    return if $grp->{focusedWindow}->contains($c);
    $grp->{focusedWindow}->canvas()->configure(@normal_win_opts);
    $grp->{focusedWindow}->canvas()->update();
  }
  if ($c) {
    $c->configure(@focused_win_opts);
    $c->update();
  }
  my $newfocus=findCanvasWindow($grp,$c);
  if ($newfocus) {
    $grp->{selectedContext}=$newfocus->{macroContext};
    $treeViewOpts->{drawBoxes}=$newfocus->{treeView}->get_drawBoxes();
    $treeViewOpts->{drawEdgeBoxes}=$newfocus->{treeView}->get_drawEdgeBoxes();
    $treeViewOpts->{showHidden}=$newfocus->{treeView}->get_showHidden();
    $treeViewOpts->{highlightAttributes}=$newfocus->{treeView}->get_highlightAttributes;
    $grp->{focusedWindow}=$newfocus;
    update_value_line($grp);
    updateTitle($grp);
  } else {
    print STDERR "DID NOT FIND Window of $c\n";
  }
}

sub splitWindow {
  my ($grp,$dir)=@_;
  my $twin     = newTrEdWindow($grp);
  my $canvas=$twin->canvas();
  $canvas->configure(@normal_win_opts);
  $grp->{focusedWindow}->split_frame($canvas,$dir);
  focusCanvas($canvas,$grp);
}

sub removeWindow {
  my ($grp)=@_;
  my $win=$grp->{focusedWindow};
  if (@{$grp->{treeWindows}}>1) {
    @{$grp->{treeWindows}}=grep {$_ ne $win} @{$grp->{treeWindows}};
    closeFile($win,1,1);
    my $brother=$win->canvas_destroy();
    delete $grp->{focusedWindow};
    focusCanvas($brother,$grp);
    $win->{treeView}=undef;
    undef $win;
  }
}

sub canvasBindMouseWheelVert {
    my($w,$modifier)= @_;
    $modifier.="-" if ($modifier);
    $w->CanvasBind("<$modifier"."MouseWheel>",
              [ sub { $_[0]->yview('scroll',-($_[1]/120)*3,'units') }, Tk::Ev("D")]);
    if ($Tk::platform eq 'unix') {
        $w->CanvasBind("<$modifier"."4>", sub { $_[0]->yview('scroll', -3, 'units') unless $Tk::strictMotif; });
        $w->CanvasBind("<$modifier"."5>", sub { $_[0]->yview('scroll', 3, 'units') unless $Tk::strictMotif; });
    }
}

sub canvasBindMouseWheelHoriz {
    my($w,$modifier)= @_;
    $modifier.="-" if ($modifier);
    $w->CanvasBind("<$modifier"."MouseWheel>",
              [ sub { $_[0]->xview('scroll',-($_[1]/120)*3,'units') }, Tk::Ev("D")]);
    if ($Tk::platform eq 'unix') {
        $w->CanvasBind("<$modifier"."4>", sub { $_[0]->xview('scroll', -3, 'units')
				      unless $Tk::strictMotif; });
        $w->CanvasBind("<$modifier"."5>", sub { $_[0]->xview('scroll', 3, 'units')
				      unless $Tk::strictMotif; });
    }
}

sub keyBind {
  local $_=shift;
  s/-/+/g;
  s/Control/CTRL/g;
  return uc($_);
}

sub createCanvasBindings {
  my ($grp,$canvas) = @_;

  ## Canvas bindings 
  $canvas->CanvasBind('<ButtonPress>',[sub { focusCanvas(@_); },$grp]);
  $canvas->bind('text',
		'<Any-Enter>'
		=> [sub{
		      my ($c,$grp)=@_;
		      my $t=$c->find('withtag','current');
		      my $win=findCanvasWindow($grp,$c);
		      my $tv=$win->{treeView};
		      my $node=$tv->get_obj_pinfo($t);
		      $tv->store_node_pinfo($node,"SaveColor",
					    $c->itemcget($t,'-fill'));
		      $c->itemconfigure($t,-fill=> $activeTextColor);
		    }, $grp]);

  $canvas->bind('text',
		'<Any-Leave>'
		=> [sub{
		      my ($c,$grp)=@_;
		      my $t=$c->find('withtag','current');
		      my $win=findCanvasWindow($grp,$c);
		      my $tv=$win->{treeView};
		      my $node=$tv->get_obj_pinfo($t);
		      $c->itemconfigure('current',
					-fill=>
					$tv->get_node_pinfo($node,"SaveColor"));
		    }, $grp]);

  $canvas->bind('point', '<1>'=> [sub {node_down(@_) },$grp,0]);

  $canvas->bind('point', '<ButtonRelease-1>'=> [sub {node_release(@_)},$grp,0]);
  $canvas->bind('point', '<B1-Motion>'=> [sub {node_move(@_)},$grp]);
  $canvas->bind('point','<3>'=> [sub {node_down(@_)},$grp,1]);
  $canvas->bind('point', '<ButtonRelease-3>'=> [sub {node_release(@_)},$grp]);
  $canvas->bind('point','<B3-Motion>'=> [sub {node_move(@_)},$grp,1]);
  $canvas->CanvasBind('<2>'=> [sub {follow_mouse_press(@_)},$grp]);
  $canvas->CanvasBind('<B2-Motion>'=> [sub {follow_mouse(@_)},$grp]);
  $canvas->bind('point', '<Double-1>'=> [sub { editAttrs(@_); Tk->break; },$grp]);
  $canvas->bind('text', '<1>'=> [sub {node_down(@_) },$grp,0]);
  $canvas->bind('text', '<Double-1>'=> [sub { editAttr(@_); Tk->break; },$grp]);
  $canvas->bind('textbg', '<Double-1>'=> [sub { editAttr(@_); Tk->break; },$grp]);
}

sub startMain {
  my $firstFile=shift;
  my $node;
  my $parent;
  my %group;

  $group{top}=MainWindow->new;

  $group{folderImage}= $group{top}->Pixmap(-file=> Tk->findINC('folder.xpm'));
  $group{fileImage}  = $group{top}->Pixmap(-file=> Tk->findINC('file.xpm'));
  $group{lastActionBookmark}= $lastAction;

  if (defined($geometry)) {
    if ($geometry=~/^(.*)x(.*)\+([0-9]+)\+([0-9]+)/) {
        $geometry
	 = "$1x$2+".min($3,$group{top}->vrootwidth-$1).
	    "+".min($4,$group{top}->vrootheight-$2);
    }
    $group{top}->geometry($geometry);
  }
  prepareFonts(\%group);
  $group{treeWindows}=[];
  $group{focusedWindow}=newTrEdWindow(\%group);
  my $canvas = $group{focusedWindow}->canvas();
  $canvas->configure(@focused_win_opts);


  print "Starting in context $group{focusedWindow}->{macroContext}\n" if $tredDebug;

  $group{templateMatchMethod}=$defaultTemplateMatchMethod;
  $group{macroListOrder}=$defaultMacroListOrder;
  print STDERR "Main window created.\n" if $tredDebug;

  if (-f $appIcon) {
    print STDERR "adding icon-image.\n" if $tredDebug;
    $group{top}->iconimage($group{top}->Pixmap(-file=> "$appIcon"));
    print STDERR "done.\n" if $tredDebug;
  }

#  $group{top}->focusFollowsMouse;
  addBindTags($group{top},'my');

  print STDERR "Asking wm for exit-hook.\n" if $tredDebug;

  $group{top}->
    protocol('WM_DELETE_WINDOW'=> 
	     [sub { my $grp=shift;
		    doEvalHook($grp->{focusedWindow},"exit_hook");
		    # run user's exit_hook
		    askSaveFiles($grp);
		    closeFile($grp->{focusedWindow});
		    $grp->{top}->destroy;
		    $grp->{top}=undef;
		  },\%group]);


  print STDERR "Exit hook created.\n" if $tredDebug;

  $group{Balloon}=$group{top}->Balloon(-initwait=> 450, -balloonposition=> 'mouse',
					-state=> 'balloon', -background=> '#fff3b0');
  $group{frame}=$group{top}->Frame;


  print STDERR "Creating menubar.\n" if $tredDebug;


  $group{Menubar}=$group{top}->Frame(-relief=> $menubarRelief, -borderwidth=> 2);
  $group{Menubar}->pack(qw/-fill x/);
  $group{top}->Frame(qw/-relief sunken -height 2 -borderwidth 2/)->pack(qw/-fill x/);
  addBindTags($group{Menubar},'my');

  $group{FileMenu}= $group{Menubar}->Menubutton(qw/-text File -underline 0/);
  $group{FileMenu}->command(-label=> 'Open ...',
			    -underline=> 0,
			    -command=> [\&fileDialog, \%group]);
  $group{FileMenu}->command(-label=> 'Close',
			    -underline=> 0,
			    -command=> [ sub {
					    my ($grp)=@_;
					    removeFromFilelist($grp,
							       undef,
							       undef,
							       $grp->{currentFilelist}->list_ref->[$grp->{focusedWindow}->{currentFileNo}]);
					    closeFile($grp->{focusedWindow});
					  }
					 , \%group]);
  $group{FileMenu}->command(-label=> 'File List...',
			    -underline=> 5,
			    -command=> [\&filelistDialog, \%group]);
#	 [Button=> 'New',         -command=> [\&menus_error2, 'New']],
  $group{FileMenu}->command(-label=> 'Save',
			    -underline=> 0,
			    -command=> [ sub { saveFile($_[0]->{focusedWindow}); },\%group]);
  $group{FileMenu}->command(-label=> 'Save As ...', 
			    -underline=> 5 ,
			    -command=> [ sub { saveFileAs($_[0]->{focusedWindow}); }, \%group]);
  $group{FileMenu}->separator();
  $group{RecentFileMenu}=$group{FileMenu}->cascade(-label=> "Recent Files",
						   -underline=> 0);
  my $i=0;
  foreach (@recentFiles) {
    $group{RecentFileMenu}->command(-label => "$i.  $_",
				    -underline=> 0,
				    -command=> [\&openFile,\%group,$_]);
    $i++;
  }
#  $group{PostponedFileMenu}=$group{FileMenu}->cascade(-label=> "Postponed Files", -underline=> 0);

  $group{FileMenu}->separator();
  $group{FileMenu}->command(-label=> 'Previous File',
			    -underline=> 3,
			    -command=> [\&prevFile,\%group]);
  $group{FileMenu}->command(-label=> 'Next File',
			    -underline=> 0,
			    -command=> [\&nextFile,\%group]);
  $group{FileMenu}->separator();
  $group{FileMenu}->command(-label=> 'Print ...',
			    -underline=> 0,
			    -command=> [\&printThis,\%group]);
  $group{FileMenu}->separator();
  $group{FileMenu}->command(-label=>'Edit config file ...',
			    -underline=> 0,
			    -command=> [\&editConfig,\%group]);
  $group{FileMenu}->command(-label=>'Reload config ...',
			    -underline=> 3,
			    -command=> [sub {
					  read_config();
					  redraw_all(shift);
					},\%group]);
  $group{FileMenu}->separator();
  $group{FileMenu}->command(-label=>'Quit',
			    -underline=> 0,
			    -command=> [sub {
					  my $grp=shift;
					  askSaveFiles($grp);
					  $grp->{top}->destroy;
					},\%group]);
	
  $group{FileMenu}->pack(qw/-side left/);

  $group{ViewMenu}= $group{Menubar}->Menubutton(qw/-text View -underline 0 -menuitems/=>
	[
	 [Button=> 'Previous Tree',
	  -underline=> 0,
	  -command=> [sub {
			tiePrevTree($_[0]);
		      },\%group]],
	 [Button=> 'Next Tree',
	  -underline=> 0,
	  -command=> [sub {
			tieNextTree($_[0]);
		      },\%group]],
	 [Separator=> ''],
	 [Checkbutton=> 'Draw boxes around labels', -underline=> 0,
	  -variable=> \$treeViewOpts->{drawBoxes},
	  -command => [sub {
			 my ($grp)=@_;
			 # vice versa setting should be done when focus changes
			 $grp->{focusedWindow}->{treeView}->set_drawBoxes($treeViewOpts->{drawBoxes});
			 redraw_win($grp->{focusedWindow});
		       },\%group]],
	 [Checkbutton=> 'Draw boxes around edge labels', -underline=> 1,
	  -variable=> \$treeViewOpts->{drawEdgeBoxes},
	  -command => [sub {
			 my ($grp)=@_;
			 # vice versa setting should be done when focus changes
			 $grp->{focusedWindow}->{treeView}->set_drawEdgeBoxes($treeViewOpts->{drawEdgeBoxes});
			 redraw_win($grp->{focusedWindow});
		       },\%group]],
	 [Checkbutton=> 'Show Hidden Nodes', -underline=> 0,
	  -underline=> 5,
	  -variable=> \$treeViewOpts->{showHidden},
	  -command => [sub {
			 $win=$_[0]->{focusedWindow};
			 $win->{treeView}->set_showHidden($treeViewOpts->{showHidden});
			 get_nodes_win($win);
			 currentUnhiden($win);
			 redraw_win($win) },\%group]],
	 [Checkbutton=> 'Highlight Attributes', -underline=> 1,
	  -variable=> \$treeViewOpts->{highlightAttributes},
	  -command => [sub {
			   my ($grp)=@_;
			   $grp->{focusedWindow}->{treeView}->set_highlightAttributes($treeViewOpts->{highlightAttributes});
			   redraw_win($grp->{focusedWindow});
			 },\%group]],
	 [Checkbutton=> 'Sort Attributes in Dialogs', -underline=> 1,
	  -variable=> \$sortAttrs],
	 [Separator=> ''],
	 [Button=> "[1] Close current view", -underline=> 1,
	  -command=> [\&removeWindow,\%group]],
	 [Button=> "[2] Split view horizontally", -underline=> 1,
	  -command=> [\&splitWindow,\%group,'horiz']],
	 [Button=> "[3] Split view vertically", -underline=> 1,
	  -command=> [\&splitWindow,\%group,'vert']],
	 [Separator=> ''],
	 [Button=> 'List of sentences ...', -underline=> 1,
	  -command=> [\&viewSentencesDialog,\%group]],
	 [Separator=> ''],
	 [Button=> 'Customize Attributes ...', -underline=> 0,
	  -command=> [\&customAttrsDialog,\%group]],
	 [Separator=> ''],
	 [Button=> 'List of Named Macros ...', -underline=> 0,
	  -command=> [\&macrolistDialog,\%group]]
	])->pack(qw/-side left/);
  $group{NodeMenu}= $group{Menubar}->Menubutton(qw/-text Node -underline 0 -menuitems/=>
	[
	 [Button=> 'New Node', -underline=> 0, -command=> [sub {
					       my ($grp)=@_;
					       newNode($grp->{focusedWindow});
					     },\%group]],
	 [Button=> 'Remove Active Node', -underline=> 0, -command=> [sub {
					       my ($grp)=@_;
					       pruneNode($grp->{focusedWindow},$grp->{focusedWindow}->{currentNode});
					     },\%group]],
	 [Button=> 'Insert New Tree', -underline=> 0, -command=> [sub {
						      my ($grp)=@_;
						      newTree($grp->{focusedWindow});
						    },\%group]],
	 [Button=> 'Insert New Tree After', -underline=> 16, -command=> [sub {
						      my ($grp)=@_;
						      newTreeAfter($grp->{focusedWindow});
						    },\%group]],
	 [Button=> 'Remove Whole Current Tree', -underline=> 7, -command=> [sub {
						      my ($grp)=@_;
						      pruneTree($grp->{focusedWindow});
						    },\%group]],
	 [Separator=> ''],
	 [Button=> 'Edit Attributes ...',
	  -underline=> 0,
	  -command=> [sub {
			my ($grp)=@_;
			editAttrsDialog($grp->{focusedWindow},
					$grp->{focusedWindow}->{currentNode})
			  if ($grp->{focusedWindow}->{currentNode});
		      },\%group]],
	 [Separator=> ''],
	 [Button=> 'Find ...',
	  -underline=> 0,
	  -command=> [sub {
			my ($grp,$template)=@_;
			findNodeDialog($grp,$template)
			  if ($grp->{focusedWindow}->{currentNode});
		      },\%group,\%searchTemplate]],
	 [Button=> 'Find Next', -underline=> 7,
	  -command=> [\&doFindFirstTemplated,\%group,\%searchTemplate,1]],
	 [Button=> 'Find Previous', -underline=> 5,
	  -command=> [\&doFindPrevTemplated,\%group,\%searchTemplate,1]]

	])->pack(qw/-side left/);
  print STDERR "Creating user menu.\n" if $tredDebug;


  $group{PostponedFileMenu}= $group{Menubar}->Menubutton(qw/-text Session -underline 0/)
    ->pack(qw/-side left/);
  updatePostponed(\%group);

  $group{BookmarksFileMenu}= $group{Menubar}->Menubutton(qw/-text Bookmarks -underline 0/)
    ->pack(qw/-side left/);
  updateBookmarks(\%group);


  $group{ContextsMenu}=$group{Menubar}->
    Optionmenu(-variable=> \$group{selectedContext},
	       -command=> [sub { my ($grp,$context) = @_;
				 switchContext($grp->{focusedWindow}, $context);
			       },\%group],
	       -relief=> 'groove', #$menubarRelief,
	       -borderwidth=> 2,
	       -options=> [sort(keys(%keyBindings))])->pack(qw/-side right/);
  my $cM=[];
  if ($createMacroMenu) {
    push @$cM, 
      @{cascadeMenus(map { $keyBindings{TredMacro}->{$_}=~/$context\-\>(.*)/;
			   [Button=> $1,
			    -command=> [ sub {
					   doEvalMacro($_[0]->{focusedWindow},
						       $_[1]);
					 },\%group,
					 $keyBindings{TredMacro}->{$_}],
			    -accelerator=> "($_)"
			   ]
			 } sort(keys(%{$keyBindings{TredMacro}})))};

    foreach my $context (sort(keys(%keyBindings))) {
      if ($context ne "TredMacro") {
	push @$cM, 
	  [Cascade=> $context,
	   -menuitems=>
	   cascadeMenus(map { $keyBindings{$context}->{$_}=~/(?:$context\-\>)?(.*)/;
			      [Button=> $1,
			       -command=> [sub {
					   doEvalMacro($_[0]->{focusedWindow},
						       $_[1]);
					 },\%group,
					   $keyBindings{$context}->{$_}],
			       -accelerator=> "($_)"
			      ]
			    } sort(keys(%{$keyBindings{$context}})))];
      }
    }

    $group{MacroMenu}=$group{Menubar}->
      Menubutton(qw/-text Shortcuts -underline 0 -menuitems/=>
		 $cM)->pack(qw/-side left/);
  }

  $cM=[];
  push @$cM,
    @{cascadeMenus(map ([Button=> $_,
			 -command=> [sub {
				       doEvalMacro($_[0]->{focusedWindow},
						   $_[1]);
				     },
				     \%group,$menuBindings{TredMacro}->{$_}->[0]],
			 ($menuBindings{TredMacro}->{$_}->[1]) ?
			 (-accelerator=> "(".$menuBindings{TredMacro}->{$_}->[1].")") : ()],
			sort(keys(%{$menuBindings{TredMacro}}))))};

  foreach my $context (sort(keys(%menuBindings))) {
   if ($context eq "TredMacro") { 
   } else {
        push @$cM,
  	[Cascade=> $context,
  	 -menuitems=>
  	 cascadeMenus(map ([Button=> $_,
  			    -command=> [sub {
					  doEvalMacro($_[0]->{focusedWindow},
						      $_[1]);
					 },
					\%group,
					$menuBindings{$context}->{$_}->[0]],
  			    ($menuBindings{$context}->{$_}->[1]) ?
  			    (-accelerator=> "(".$menuBindings{$context}->{$_}->[1].")") : ()],
  			   sort(keys(%{$menuBindings{$context}}))))];
      }
  }
  $group{UserMenu}=$group{Menubar}->
    Menubutton(qw/-text User-defined -underline 0 -menuitems/=>
	       $cM)->pack(qw/-side left/);




  addBindTags($group{frame},'my');

  $group{HelpMenu}= $group{Menubar}->Menubutton(qw/-text Help -underline 0 -menuitems/=>
	[
	 [Button=> 'About',
	  -underline=> 0,
	  -command=> [\&About,\%group]]])->pack(qw/-side left/);


  $group{vLineFrame}=$group{top}->Frame();
  $group{valueLine}=$group{vLineFrame}->Scrolled(qw/Entry -state disabled -relief sunken
			   -borderwidth 2 -scrollbars s/, -font=> $vLineFont, -textvariable=> \$valueLine);
  $group{valueLine}->BindMouseWheelHoriz();


  print STDERR "Creating buttons.\n" if $tredDebug;

  $group{nextButton}=
    $group{frame}->Button(-takefocus=>0,
			  -text=> "Next",
			  -relief=> $buttonsRelief,
			  -image=> $group{top}->Pixmap(-file=>
						       "$libDir/right.xpm"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=>
			  [sub { tieNextTree($_[0]) },\%group]);
  $group{Balloon}->attach($group{nextButton},
		 -balloonmsg=> "see the next tree");
  addBindTags($group{nextButton},'my');
  $group{prevButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Prev",
			  -relief=> $buttonsRelief,
			  -image=> $group{top}->Pixmap(-file=>
						       "$libDir/left.xpm"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=>
			  [sub { tiePrevTree($_[0]) },\%group]);
  $group{Balloon}->attach($group{prevButton},
		 -balloonmsg=> "see the previous tree");
  addBindTags($group{prevButton},'my');

  $group{openButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Open",
			  -relief=> $buttonsRelief,
			  -image=>
			  $group{top}->Pixmap(-file=>
					      "$libDir/fileopen.xpm"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=>
			  [sub { fileDialog(@_) },\%group])
      ->pack(-side=>'left',-padx=>'1');
  $group{Balloon}->attach($group{openButton},
		 -balloonmsg=> "open file");
  addBindTags($group{openButton},'my');
  $normalSavePixmap=$group{top}->Pixmap(-file=>"$libDir/filefloppy.xpm");
  $savedSavePixmap=$group{top}->Pixmap(-file=>"$libDir/filesaved.xpm");
  $group{saveButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Save",
			  -relief=> $buttonsRelief,
			  -image=> $savedSavePixmap,
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [sub {
					saveFile($_[0]->{focusedWindow})
				      },\%group])->pack(-side=>'left',-padx=>'1');

  $group{Balloon}->attach($group{saveButton},
			  -balloonmsg=> "save current file");
  addBindTags($group{saveButton},'my');

  $group{prevFileButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Prev file",
			  -relief=> $buttonsRelief,
			  -image=> $group{top}->Pixmap(-file=>
						       "$libDir/start.xpm"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [sub { prevFile(@_); },\%group])->pack(-side=>'left',
									    -padx=>'1');
  $group{Balloon}->attach($group{prevFileButton},
			  -balloonmsg=> "visit the previous open file");
  addBindTags($group{prevFileButton},'my');

  $group{nextFileButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Next file",
			  -relief=> $buttonsRelief,
			  -image=> $group{top}->Pixmap(-file=>
						       "$libDir/finish.xpm"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [sub { nextFile(@_); },\%group])->pack(-side=>'left',
									    -padx=>'1');
  $group{Balloon}->attach($group{nextFileButton},
			  -balloonmsg=> "visit the next open file");
  addBindTags($group{nextFileButton},'my');


  $group{printButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Print",
			  -relief=> $buttonsRelief,
			  -image      => $group{top}->Pixmap(-file=>
							     "$libDir/fileprint.xpm"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [sub { printThis(@_) },\%group])->pack(-side=>'left',
									    -padx=>'1');
  $group{Balloon}->attach($group{printButton},
			  -balloonmsg=> "print ...");
  addBindTags($group{printButton},'my');

  $group{findButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Find",
			  -relief=> $buttonsRelief,
			  -image      => $group{top}->Pixmap(-file=>
							     "$libDir/find.xpm"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [sub {
					my ($grp,$template)=@_;
					findNodeDialog($grp,$template)
					  if ($grp->{focusedWindow}->{currentNode});
				      },\%group,\%searchTemplate])->pack(-side=>'left',
									 -padx=>'1');
  $group{Balloon}->attach($group{findButton},
			  -balloonmsg=> "Find node ...");
  addBindTags($group{findButton},'my');

  $group{findNextButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Find Next",
			  -relief=> $buttonsRelief,
			  -image      => $group{top}->Pixmap(-file=>
							     "$libDir/findnext.xpm"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&doFindFirstTemplated,\%group,\%searchTemplate,1])
      ->pack(-side=>'left', -padx=>'1');
  $group{Balloon}->attach($group{findNextButton},
			  -balloonmsg=> "Find next ...");
  addBindTags($group{findNextButton},'my');


  $group{findPrevButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Find Previous",
			  -relief=> $buttonsRelief,
			  -image=> $group{top}->Pixmap(-file=>
						       "$libDir/findprev.xpm"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&doFindPrevTemplated,\%group,\%searchTemplate,1])
      ->pack(-side=>'left', -padx=>'1');
  $group{Balloon}->attach($group{findPrevButton},
			  -balloonmsg=> "Find previous ...");
  addBindTags($group{findPrevButton},'my');


  $group{frame}->Frame()->pack(-side=> 'left', -padx=>'10');
  $group{prevButton}->pack(-side=> 'left', -padx=>'1');
  $group{nextButton}->pack(-side=> 'left', -padx=> '1');


  $group{attrButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Attributes",
			  -relief=> $buttonsRelief,
			  -image=> $group{top}->Pixmap(-file=>
						       "$libDir/tick.xpm"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [sub { customAttrsDialog(@_) },\%group])->pack(-side=>'right',
										    -padx=>'1');
  $group{Balloon}->attach($group{attrButton},
			  -balloonmsg=> "select visible attributes");

  $group{tieWinddowsButton}=
    $group{frame}->Checkbutton(-takefocus=>0,
			      -text=> "Tie Displayed Windows",
			      -variable=> \$group{tieWindows},
			       -relief=> $buttonsRelief,
			      -indicatoron => 0,
			      -image=>$group{top}->Pixmap(-file=>
							  "$libDir/tiewins.xpm"),
			      -borderwidth=> $buttonBorderWidth)->pack(-side=>'right',
								       -padx=>'1');
  $group{Balloon}->attach($group{tieWinddowsButton},
			  -balloonmsg=> "tie all views");


  $group{rmsplitButton}=
    $group{frame}->Button(-takefocus=>0, 
			  -text=> "Remove Current View",
			  -relief=> $buttonsRelief,
			  -image=> $group{top}->Pixmap(-file=>
						       "$libDir/rmsplit.xpm"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&removeWindow,\%group])->pack(-side=>'right',
								     -padx=>'1');
  $group{Balloon}->attach($group{rmsplitButton},
			  -balloonmsg=> "remove current view");

  $group{hsplitButton}=
    $group{frame}->Button(-takefocus=>0, 
			  -text=> "Split View Horizontally",
			  -relief=> $buttonsRelief,
			  -image=> $group{top}->Pixmap(-file=>
						       "$libDir/hsplit.xpm"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&splitWindow,\%group,'horiz'])->pack(-side=>'right',
									    -padx=>'1');


  $group{Balloon}->attach($group{hsplitButton},
			  -balloonmsg=> "split view horizontally");
  $group{vsplitButton}=
    $group{frame}->Button(-takefocus=>0, 
			  -text=> "Split View Vertically",
			  -relief=> $buttonsRelief,
			  -image=> $group{top}->Pixmap(-file=>
						       "$libDir/vsplit.xpm"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&splitWindow,\%group,'vert'])->pack(-side=>'right',
									   -padx=>'1');
  $group{Balloon}->attach($group{hsplitButton},
			  -balloonmsg=> "split view vertically");


  print STDERR "Packing widgets.\n" if $tredDebug;


  $group{frame}->pack(-fill=> 'x', -padx=> '1', -pady=> 1);


  $group{valueLine}->pack(qw/-side left -fill x -expand yes/);
  $group{sentButton}=
    $group{vLineFrame}->Button(-takefocus=>0, -text=> "Sentences",
			    -relief=> $buttonsRelief,
			    -image=> $group{top}->Pixmap(-file=>
							  "$libDir/view_sent.xpm"),
			    -borderwidth=> $buttonBorderWidth,
			    -command=> [sub { viewSentencesDialog(@_) },\%group])
      ->pack(qw/-side right -padx 1 -anchor n/);
  $group{vLineFrame}->pack(qw/-fill x -expand no/);


  # frame canvas here
  $group{focusedWindow}->frame_widget($canvas,[],
				      [qw/-side left/])->pack(qw/-expand yes -fill both/);

  print STDERR "Binding keystrokes...\n" if $tredDebug;
  $group{Menubar}->bind('Menubutton','<Escape>', sub { shift->Leave(); } );
  $group{frame}->
    bind('my','<Alt-KeyPress>'=>
	 [sub {
	    if (defined(evalMacro(@_))) {
	      Tk->break;
	    } else {
	      # Actually, this should work by it self. And it realy
	      # does, but not under windows :-) Well, do not laugh,
	      # too early, Linux users. With menu (not menubutton)
	      # this is the same there, only vice versa.
	      my ($w,$grp,$mod)=@_;
	      my $mbar=$grp->{Menubar};
	      foreach my $child ($mbar->children) {
		if ($child->class eq 'Menubutton' and $child->FindMenu($w->XEvent->K)) {
		  $child->ButtonUp() if ($^O eq "MSWin32"); 
		  # This ButtonUp is needed for some reason under
		  # Windows, otherwise the button remains active even
		  # when you leave the window! Window$ realy suck!!!!
		  last;
		}
	      }
	      Tk->break;
	    }
	  }, \%group,'ALT+']);

  #  $group{frame}->bind('my','<Control-x><KeyPress>'=>
  #			[sub { evalMacro(@_); Tk->break; }, \%group, 'CTRL-X+' ]);

  $group{frame}->bind('my','<KeyPress>'=>
			[sub {
			   evalMacro(@_); Tk->break;
			 }, \%group, '' ]);

  foreach (qw(Shift Control Meta Alt Control-Shift Control-Alt
              Control-Meta Alt-Shift Meta-Shift)) {
    foreach my $event (qw(KeyPress Right Left Up Down
                          Return comma period Next Prior greater less)) {
      $group{frame}->bind('my',"<$_-$event>"=>
			    [sub { evalMacro(@_); Tk->break; },
			     \%group, keyBind($_)."+"])
	unless ("$_-$event" eq "Alt-KeyPress")
    }
  }

  $group{top}->bind('all','<Tab>',undef);

  $group{frame}->Tk::bind('Busy','<Escape>',[\&_search_busy, \%group]);
  $group{top}->Tk::bind('Busy','<Escape>',[\&_search_busy, \%group]);

  $group{top}->bind('my', '<Tab>'=>
		    [sub { currentNext($_[1]->{focusedWindow});
			   Tk->break; },\%group]);
  $group{frame}->bind('my',
		      '<Shift-ISO_Left_Tab>'=>
		      [sub { currentPrev($_[1]->{focusedWindow});
			     Tk->break; },\%group]);
  $group{frame}->bind('my',
		      '<Shift-Tab>'=>
		      [sub { currentPrev($_[1]->{focusedWindow});
			     Tk->break; },\%group]);

  $group{frame}->bind('my',
		      '<period>'=> 
		      [sub { onIdleNextTree($_[1]->{focusedWindow}); },
		       \%group]);
  $group{frame}->bind('my','<comma>'=> 
		      [sub { onIdlePrevTree($_[1]->{focusedWindow}); },
		       \%group]);
  $group{frame}->bind('my','<Next>'=> 
		      [sub { onIdleNextTree($_[1]->{focusedWindow}); },
		       \%group]);
  $group{frame}->bind('my','<Prior>'=> 
		      [sub { onIdlePrevTree($_[1]->{focusedWindow}); }
		       ,\%group]);
  $group{frame}->bind('my','<greater>'=>
		      [sub { my $fw=$_[1]->{focusedWindow};
			     gotoTree($fw,
				      $fw->{FSFile}->lastTreeNo);
			     Tk->break;
			   },\%group]);
  $group{frame}->bind('my','<less>'=> 
		      [sub { gotoTree($_[1]->{focusedWindow},0);
			     Tk->break;
			   },\%group]);

  $group{frame}->bind('my',
		      '<KeyPress-Return>'=>
		      [sub { editAttrsDialog($_[1]->{focusedWindow},
			     $_[1]->{focusedWindow}->{currentNode});
			 Tk->break;
		       },\%group]);
  $group{frame}->bind('my','<KeyPress-Left>'=>
		      [sub {
			 currentLeft($_[1]);
			 Tk->break;
		       },\%group]);
  $group{frame}->bind('my','<KeyPress-Right>'=>
		      [sub {
			 currentRight($_[1]);
			 Tk->break;
		       },\%group]);
  $group{frame}->bind('my','<KeyPress-Up>'=>
		      [sub {
			 currentUp($_[1]);
			 Tk->break;
		       },\%group]);
  $group{frame}->bind('my','<KeyPress-Down>'=>
		      [sub {
			 currentDown($_[1]);
			 Tk->break;
		       },\%group]);

  $group{focusedWindow}->canvas->focus;

  $group{printToFile}=0;
  $group{printCommand}='lpr';
  $group{printPsFile}=$psFile;

  print STDERR "Binding canvas destroy...\n" if $tredDebug;
  $group{top}->bind($group{frame},
		    '<Destroy>',
		      [ sub {
			  shift;
			  my $grp=shift;
			  $geometry=$group{top}->geometry();
			  print "geometry is $geometry\n";
			  if ($^O eq "MSWin32" and $group{top}->state() eq 'zoomed') {
			    $geometry=~s/\+[-0-9]+\+[-0-9]+/+-3+-3/;
			  }
			  print "state is ",$group{top}->state(),"\n"  if $tredDebug;
			},\%group ]);

  print STDERR "GUI prepared.\nOpenning first file ...." if $tredDebug;

  selectFilelist(\%group,'Default');
#    $group{currentFilelist}=$filelists[0];
#    if ($group{currentFilelist}->file_at(0)) {
#      openFile(\%group,$group{currentFilelist}->file_at(0));
#    }
  
  print STDERR "done.\nStarting main loop.\n" if $tredDebug;

  exit if doEvalHook($group{focusedWindow},"start_hook") eq 'stop'; # run start_hook

  # Starting ------------------------------------------

  MainLoop;


  # Finished ------------------------------------------

  # Save configuration
  print STDERR "Saving some configuration options.\n" if $tredDebug;
  my @conf;
  my $ommit="canvasheight|canvaswidth|recentfile[0-9]+|geometry|lastaction|filelist[0-9]+";
  if (open(F,"<$configFile")) {
    @conf= grep { !/^\s*(?:$ommit)\s*=/i } <F>;
    close(F);
  }
  #  $geometry=~s/^[0-9]+x[0-9]+//;
  if ($group{lastActionBookmark}) {
    $group{lastActionBookmark}=~s/\\/\\\\/g;
    push @conf,"LastAction\t=\t".$group{lastActionBookmark}."\n" if $group{lastActionBookmark};
  }
  do {
    my $s;
    push @conf,
      "Geometry\t=\t".$geometry."\n",
      "CanvasHeight\t=\t".$defCHeight."\n",
      "CanvasWidth\t=\t".$defCWidth."\n",
	map { 
	  $s=$recentFiles[$_];
	  $s=~s/\\/\\\\/g;
	  "RecentFile$_\t=\t$s\n"
	} 0..$#recentFiles;

    my $i=0;
    foreach (@filelists) {
      if (ref($_) and defined($_->filename) and $_->filename ne "") {
	$_->save;
	$s=$_->filename();
	$s=~s/\\/\\\\/g;
	push @conf,"filelist".$i++."\t=\t".$s."\n";
      }
    }
  };
  chomp $conf[$#conf];
  $group{top}=undef;
  saveConfig(\%group,@conf);
  print STDERR "Done.\n" if $tredDebug;
}

sub onIdleNextTree {
  my ($win)=@_;
  return unless $win->{FSFile};
  $win->{treeNo}=max(0,min($win->{treeNo}+1,$win->{FSFile}->lastTreeNo));
  update_value_line($win->{framegroup});
  $win->toplevel->afterCancel($myIdle) if ($myIdle);
  $win->{framegroup}->{valueLine}->idletasks();
  $myIdle=
    $win->toplevel->afterIdle([sub {
				 my $win=shift;
				 my $no=$win->{treeNo};
				 # this is to force getNodes & redraw
				 $win->{treeNo}=-1;
				 gotoTree($win,$no);
				 $myIdle=undef;
			       },$win]);
  Tk->break;
}

sub onIdlePrevTree {
  my ($win)=@_;
  return unless $win->{FSFile};
  if ($win->{treeNo}>0) {
    $win->{treeNo}--;
    update_value_line($win->{framegroup});
    $win->toplevel->afterCancel($myIdle) if ($myIdle);
    $win->{framegroup}->{valueLine}->idletasks();
    $myIdle=
      $win->toplevel->afterIdle([ sub {
				    my $win=shift;
				    my $no=$win->{treeNo};
				    # this is to force getNodes & redraw
				    $win->{treeNo}=-1;
				    gotoTree($win,$no);
				    $myIdle=undef;
				  },$win]);
  }
  Tk->break;
}


# This patches $dialog->Show which implicitly focuses the default button;
# here focus stays where it is.
# Usage: my $dlg=DialogBox(); ...; ShowDialog($dlg);
sub ShowDialog {
  my ($cw, $focus, $oldFocus)= @_;

  $oldFocus= $cw->focusCurrent unless $oldFocus;
  my $oldGrab= $cw->grabCurrent;
#  my $old_grab= $cw->grabSave;
#  my $old_focus= $cw->grabSave;
  my $grabStatus= $oldGrab->grabStatus if ($oldGrab);

#  $cw->grab;

  $cw->Popup();


  Tk::catch {
    $cw->grab;
  };
  $focus->focusForce if ($focus);
  Tk::DialogBox::Wait($cw);

  eval {
    $oldFocus->focusForce;
  };
  #&$old_grab;
  #&$old_focus;
  
  $cw->withdraw;
  $cw->grabRelease;
  if ($oldGrab) {
    if ($grabStatus eq 'global') {
      $oldGrab->grabGlobal;
    } else {
      $oldGrab->grab;
    }
  }

  return $cw->{selected_button};
}

sub fileDialog {
  my $grp= shift;
  my $file;

#  use Tk::FileSelect;
#  my $FSref= $grp->{top}->FileSelect(-selectmode=> extended);
#  print $FSref->Show;

  $file= $grp->{top}->getOpenFile(-filetypes=> \@open_types);
  if (defined $file and $file ne '') {
    return openFile($grp,$file);
  }
  return 0;
}

sub saveFileAs {
  my ($win)= @_;
  my $initdir;
  return unless $win->{FSFile};
  my $file=$win->{FSFile}->filename;

  $initdir=dirname($file);
  $initdir=cwd if ($initdir eq './');


  $file= $win->toplevel->getSaveFile(-filetypes=> \@save_types,
				     -title=> "Save As ...",
				     -d $initdir ? (-initialdir=> $initdir) : (),
     				     $^O eq 'MSWin32' ? () : (-initialfile=> filename($file)));
  if (defined $file and $file ne '') {
    $win->{FSFile}->changeFilename($file);
    updateTitle($win->{framegroup});
    return saveFile($win);
  }
  return 0;
}

sub askSaveFiles {
  my ($grp)= @_;

  @{$grp->{treeWindows}} = grep { $_ ne $grp->{focusedWindow} } @{$grp->{treeWindows}};
  unshift @{$grp->{treeWindows}},$grp->{focusedWindow};
  my $win;
  foreach $win (@{ $grp->{treeWindows} }) {
    print $win,"\n";
    if ($win->{FSFile}) {
      focusCanvas($win->canvas(),$win->{framegroup});
      askSaveFile($win);
      closeFile($win,1);
    }
  }

  while (@openfiles) {
    resumeFile($grp->{focusedWindow},shift @openfiles);
    updateTitle($grp);
    get_nodes_win($grp->{focusedWindow});
    redraw_win($grp->{focusedWindow});
    if ($grp->{focusedWindow}->{currentNode}) {
      centerToXY($grp->{focusedWindow},0,0);
    }
    $grp->{top}->update();
    askSaveFile($grp->{focusedWindow},0);
  }
}

sub askSaveFile {
  my ($win,$keep)=@_;
  return 0 unless
    ref($win->{FSFile}) and
      $win->{FSFile}->notSaved;

  my $d=$win->toplevel->Dialog(-text=> 
			       $win->{FSFile}->filename().
			       "\n\nFile may be changed!\nDo you want to save it?",
			       -bitmap=> 'question', 
			       -title=> 'Save File Dialog',
			       -buttons=> ['Yes','No', $keep ? 'Keep' : ()]);
  $d->bind('<Return>', sub { my $w=shift; my $f=$w->focusCurrent;
			     $f->Invoke if ($f and $f->isa('Tk::Button')) } );
  my $answer=$d->Show();
  if ($answer eq 'Yes') {
    saveFile($win);
    return 0;
  } elsif ($answer eq 'Keep') {
    return 1;
  }
}

sub saveConfig {
 my $grp=shift;

 if (open(F,">$configFile")) {
   print F @_;
   close(F);
 } else {
   my $lasterr=$!;
   my ($trc)=<'~/.tredrc'>;
   my ($dc,$ic)=stat($configFile);
   my ($dh,$ih)=stat($trc);
   if ($configFile ne $trc and ($dc != $dh or $ic != $ih) and
       (!defined($grp->{top}) or
       $grp->{top}->toplevel->
       messageBox(-icon=> 'warning',
		  -message=> "Cannot write configuration to $configFile\n($lasterr)\n\n".
		  "Shell I try to save it to ~/.tredrc?\n",
		  -title=> 'Configuration cannot be saved',
		  -type=> 'YesNo',
		  #			  -default=> 'Yes' # problem: Windows 'yes', UNIX 'Yes'
		 )=~ /yes/i)) {
     if (open(F,">".$trc)) {
       print F @_;
       close(F);
       $configFile=$trc;
     } else {
       ErrorMessage($grp,'Cannot write to "'.$trc.'"!'."\n($!)\n".
		    "\nConfiguration could not be saved!\n");
     }
   } else {
     ErrorMessage($grp,"Cannot write to \"$configFile\"!"."\n($lasterr)\n".
		  "\nConfiguration could not be saved!");
   }
 }
}

sub editConfig {
  my $grp=shift;
  return unless $grp;
  if ($grp->{configDialog}) {
    $grp->{configDialog}->deiconify;
    $grp->{configDialog}->focus;
    $grp->{configDialog}->raise;
    return;
  }
  $grp->{configDialog}= $grp->{top}->Toplevel(-title=> "Edit Resource File ($configFile)" , 
						   -width=> "10c");
  my $d=$grp->{configDialog};
  $d->withdraw;
#  $d->resizable(0,0);
  $d->bind('<Return>'=> [sub {1;}]);
  my $t= $d->
    Scrolled(qw/Text -relief sunken -borderwidth 2 -setgrid true
		     -height 30 -scrollbars oe/);
  $t->pack(qw/-expand yes -fill both/);
  $t->BindMouseWheelVert();
  my $bottom=$d->Frame()->pack(qw/-expand yes -fill both/);
  $bottom->
    Button(-text=> "  Save and Apply  ",
	   -command=> [sub {
			  my ($grp,$d,$t)=@_;
			  saveConfig($grp,$t->get("0.0","end"));
			  apply_config(split(/\n/,$t->get("0.0","end")));
			  addToRecent($grp);
			  prepareFonts($grp);
			  updateTitle($grp);
			  $grp->{valueLine}->configure(-font=> $vLineFont);
			  foreach (@{$grp->{treeWindows}}) {
			    $_->apply_options($treeViewOpts);
			  }
			  ApplyGlobalConfig($grp);
			  redraw_all($grp);
#			  $d->destroy;
			},$grp,$d,$t])
      ->pack(-side=> 'left', -expand=> 1,  -padx=> 1, -pady=> 1);
  $bottom->Button(-text=> "  Apply  ",
		  -command=> [sub {
				 my $grp=shift;
				 apply_config(split(/\n/,shift->get("0.0","end")));
				 addToRecent($grp);
				 prepareFonts($grp);
				 updateTitle($grp);
				 $grp->{valueLine}->configure(-font=> $vLineFont);
				 foreach (@{$grp->{treeWindows}}) {
				   $_->apply_options($treeViewOpts);
				 }
				 ApplyGlobalConfig($grp);
				 redraw_all($grp);
			       },$grp,$t])
    ->pack(-side=> 'left', -expand=> 1,  -padx=> 1, -pady=> 1);

  $bottom->Button(-text=> "  Close  ", -command=> [sub { shift->destroy; },$d])
    ->pack(-side=> 'left', -expand=> 1,  -padx=> 1, -pady=> 1);

  $d->bind('<Destroy>'=> [sub { shift; shift->{configDialog}=undef; },$grp ]);
  $d->bind($d,'<Escape>'=> [sub { shift; shift->destroy(); },$d]);
  if (open(F,"<$configFile")) {
    $t->insert('0.0',join "",<F>);
    close(F);
  }
  $t->mark(qw/set insert 0.0/);
  $d->Popup;
}


sub QueryString {
  my ($grp, $title, $label,$default_text)=@_;
  my $newvalue=encode($default_text);
  my $d=$grp->{top}->DialogBox(-title=> $title,
				 -buttons=> ["OK", "Cancel"]);
  $d->bind('all','<Escape>'=> [sub { shift; shift->{selected_button}='Cancel'; },$d ]);
  addBindTags($d,'dialog');
  my $e=$d->add(Entry,-relief=> 'sunken',
		    -width=> 40,
		    -takefocus=> 1,
		    -font=> $font,
		    -textvariable=> \$newvalue);
  my $l= $d->Label(-text=> encode($label),
		    -anchor=> 'e',
		    -justify=> 'right');
  $l->pack(-side=>'left');
  $e->pack(-side=>'right');
  $d->resizable(0,0);
#  $e->focus;
  my $result= ShowDialog($d,$e,$grp->{top});
  $d->destroy;
  undef $d;
  if ($result=~ /OK/) {
    return decode($newvalue);
  } else {
    return undef;
  }
}

sub Query {
  my ($w, $title, $label,$default_text)=@_;
  my $newvalue=encode($default_text);
  my $d=$w->DialogBox(-title=> $title,
				 -buttons=> ["OK", "Cancel"]);
  $d->bind('all','<Escape>'=> [sub { shift; shift->{selected_button}='Cancel'; },$d ]);
  addBindTags($d,'dialog');
  my $e=$d->add(Entry,-relief=> 'sunken',
		    -width=> 40,
		    -takefocus=> 1,
		    -font=> $font,
		    -textvariable=> \$newvalue);
  my $l= $d->Label(-text=> encode($label),
		    -anchor=> 'e',
		    -justify=> 'right');
  $l->pack(-side=>'top');
  $e->pack(-side=>'left');
  $d->resizable(0,0);
#  $e->focus;
  my $result= ShowDialog($d,$e,$w);
  $d->destroy;
  undef $d;
  if ($result=~ /OK/) {
    return decode($newvalue);
  } else {
    return undef;
  }
}

sub selectValuesDialog {
 my ($grp, $attr, $vals, $selected, $may_add, $lastFocus,$force)=@_;
 my $a;
 my $multi=0;
 my @prevSelectionSet;

 $top=$grp->{top};
 $top->Busy(-recurse=> 1);
 my $enabled=($force or doEvalHook($grp->{focusedWindow},
				   'enable_attr_hook',
				   $attr,
				   "ambiguous") ne 'stop');

 my $d=$top->DialogBox(-title=> "$attr: select values", -width=> '8c',
		       -buttons=> $enabled ? ["OK", "Cancel"] : ["Cancel"]);
 $d->bind('all','<Escape>'=> [sub { shift; shift->{selected_button}='Cancel'; },$d ]);
 $d->resizable(0,0);
 my $l=$d->Scrolled(qw/Listbox -relief sunken -takefocus 1 -scrollbars oe/,
		    -height=> min($maxDisplayedValues,scalar(@$vals)),
		    -font=> $font)->pack(qw/-expand yes -fill both/);
 $l->insert('end',@$vals);
 $l->BindMouseWheelVert();
 if ($enabled) {
   $l->bind('<Double-ButtonPress-1>'=>
	    [sub { my $w=shift;
		   my $d=shift;
		   my $e= $w->XEvent;
		   $w->BeginSelect($w->index($e->xy));
		   $d->{selected_button}='OK';
		 },$d
	    ]);
 }
 my $act=0;
 for ($a=0;$a<@$vals;$a++)  {
   if (grep { $$vals[$a] eq $_ } @$selected) {
     $l->selectionSet($a);
     if (not $act) {
       print "Activating $a\n"  if $tredDebug;
       $act=1;
       $l->activate($a);
       $l->see($a);
     }
   }
 }
 if ($enabled) {
   $d->Checkbutton(-text    => 'multiple select',
		   -variable=> \$multi,
		   -command => [sub {
				   shift->configure(-selectmode=> $multi ? 'multiple' : 'browse');
				 },$l],
		   -relief  => 'flat')->pack();
   if ($may_add) {
     $d->Button(-text=> 'Add',
		-command=> [sub {
			       my ($grp,$l,$vals)=@_;
			       my $val=QueryString($grp,"Add new value","Value");
			       return unless defined $val;
			       push @$vals,$val;
			       $l->insert('end',$val);
			       $l->selectionClear(0,$l->size-1) unless $multi;
			       $l->selectionSet($l->size-1);
			     },$grp,$l,$vals])->pack();
   }
 }
 $top->Unbusy();
 $l->focus;
 my $result= ShowDialog($d,$l,$lastFocus);
 if ($result=~ /OK/) {
   # Hajic wanted this (I wash my hands):
   # first we store the values, which were selected originaly and stayed selected
   foreach my $s (@$selected) { 
     push @prevSelectionSet, (grep { $$vals[$_] eq $s } (0 .. $l->size-1));
   }
   @$selected=();
   foreach (@prevSelectionSet) {
     if ($l->selectionIncludes($_)) {
       $l->selectionClear($_);
       push @$selected,$$vals[$_];
     }
   }
   foreach (0 .. $l->size-1) {
     push @$selected, $$vals[$_] if $l->selectionIncludes($_);
   }
   $d->destroy;
   undef $d;
   return 1;
 }
 $d->destroy;
 undef $d;
 return 0;
}

sub viewSentencesDialog {
  my $grp=shift;
  return unless $grp and ref($grp->{focusedWindow}->{FSFile});
  if ($grp->{sentDialog}) {
    $grp->{sentDialog}->deiconify;
    $grp->{sentDialog}->focus;
    $grp->{sentDialog}->raise;
    return;
  }
  $grp->{sentDialog}= 
    $grp->{top}->Toplevel(-title=> "List of sentences for ".$grp->{focusedWindow}->{FSFile}->filename(),
			    -width=> "10c");
  my $d=$grp->{sentDialog};
  $d->withdraw;
#  $d->resizable(0,0);
  $d->bind('<Return>'=> [sub {1;}]);
  use Tk::ROText;
  my $t= $d->
    Scrolled(qw/ROText -relief sunken -borderwidth 2 -setgrid true
                     -spacing3 6 -wrap word -background white
		     -height 20 -scrollbars oe/,-font=>$font);
  $t->pack(qw/-expand yes -fill both/);
  $t->BindMouseWheelVert();
  my $bottom=$d->Frame()->pack(qw/-expand yes -fill both/);

  $bottom->Button(-text=> "  Close  ", -command=> [sub { shift->destroy; },$d])
    ->pack(-side=> 'left', -expand=> 1,  -padx=> 1, -pady=> 1);

  $d->bind('<Destroy>'=> [sub { shift; shift->{sentDialog}=undef; },$grp ]);
  $d->bind('all','<Escape>'=> [sub { shift; shift->destroy(); },$d]);

  foreach my $r ($grp->{focusedWindow}->{FSFile}->trees()) {
    my @nodes=();
    my $sentord= $grp->{focusedWindow}->{FSFile}->FS->sentord || $grp->{focusedWindow}->{FSFile}->FS->order;
    my $value= $grp->{focusedWindow}->{FSFile}->FS->value;
    while ($r) {
      push @nodes,$r;
      $r=$r->following();
    }
    $t->insert('end',
	       join (" ",
	       map { encode($_->{$value}) }
	       sort { $a->{$sentord} <=> $b->{$sentord} } @nodes)."\n");
  }
  $d->Popup;
}


sub editListAttr {
  my ($win, $value, $attr,$d)=@_;
  return unless $win->{FSFile};
  my @vals= map { encode($_) } $win->{FSFile}->FS->listValues($attr);
  #print "splitting ",$value{$attr},"\n";
  my @selected= map { encode($_) } split /\|/,$value;
  #print "splitted to ", join ('-',@selected),"\n";

  if (selectValuesDialog($win->{framegroup},$attr,\@vals,\@selected,0,$d)) {
    return decode(join('|',@selected));
  }
  return undef;
}

sub editAmbiguousAttr {
  my ($win, $value, $attr)=@_;
  my @vals= map { encode($_) }split /\|/,$value;
  my @selected= @vals;
  
  if (selectValuesDialog($win->{framegroup},$attr,\@vals,\@selected,1,$win->toplevel)) {
    return decode(join('|',@selected));
  }
  return undef;
}

sub focusxEditDn {
  my ($w,$i,$e,$f,$atord)=@_;
  if ($i+1<@$atord) {
    $f->see($e->{$atord->[$i+1]});
    $e->{$atord->[$i+1]}->focus;
  }
  Tk->break;
}

sub focusxEditUp {
  my ($w,$i,$e,$f,$atord)=@_;
  if ($i>0) {
    $f->see($e->{$atord->[$i-1]});
    $e->{$atord->[$i-1]}->focus;
  }
  Tk->break;
}

sub editAttrsDialog {
  my ($win,$node)=@_;
  return if (doEvalHook($win,"do_edit_node_hook",$node) eq 'stop');
  return unless $win->{FSFile};
  my @vals;
  my %e=();
  my @atord=$win->{FSFile}->FS->attributes;
  if ($sortAttrs) {
    @atord=sort {uc($a) cmp uc($b)} $win->{FSFile}->FS->attributes
      unless (doEvalHook($win,"sort_attrs_hook",\@atord));
  }
  my $rows=min($maxDisplayedAttributes,$#atord+1);
  my ($a,$b,$r);

  $win->toplevel->Busy(-recurse=>1);
  my $d=$win->toplevel->DialogBox(-title=> "Edit Node Attributes", -width=> '10c',
				 -buttons=> ["OK", "Cancel"]);
  $d->bind('all','<Escape>'=> [sub { shift; shift->{selected_button}='Cancel'; },$d ]);
  my $ff=$d->Frame(-relief=> 'groove',
		   -bd => 1);
  my $f= $ff->Scrolled('Pane',
		      -sticky => 'we',
		      -scrollbars=> 'oe');
  $f->BindMouseWheelVert("","EditEntry");

  my $lwidth;
  foreach (@atord) {
    $lwidth=max($lwidth,length($_));
  }
  my $height=0;
  for (my $i=0;$i<=$#atord;$i++) {
    $_=$atord[$i];
    # Reliefs: raised, sunken, flat, ridge, and groove.
    my $eef=$f->Frame()->pack(qw/-side top -expand yes -fill x/);
    $eef->Label(-text=> $_,
		-justify => 'left',
		-width =>$lwidth,
		-anchor=> 'nw')->pack(qw/-side left/);

    if  ($win->{FSFile}->FS->isList($_) or
	 $$node{$_}=~/^(?:[^\|\\]|\\.)*\|/) { # readonly entry and buttons for list
      $r= $eef->Frame();
      $e{$_}= $r->Entry(-relief=> 'sunken', -takefocus=> 1,
			 -font=> $font)->pack(qw/-expand yes -fill both -side left/);
      addBindTags($e{$_},"EditEntry");
	$b=$r->Button(-text=> "...", -takefocus=> 0,
		      -command=> [sub {
				     my ($e,$win,$node,$attr,$d)=@_;
				     my $result=
				       ($win->{FSFile}->FS->isList($attr)
					? editListAttr($win,$e->get,$attr)
					: editAmbiguousAttr($win,$e->get,$attr,$d));
				     if (defined $result) {
				       $e->configure(-state=> 'normal');
				       $e->delete(0,length($e->get));
				       $e->insert(0,$result);
				       $e->configure(-state=> 'disabled');
				     }
				   },$e{$_},$win,$node,$_,$d])
	  ->pack(qw/-side right/);
	$e{$_}->bind($e{$_},'<Return>',[sub { shift; shift->invoke; Tk->break; },$b]);
	$e{$_}->bind($e{$_},'<Double-ButtonPress-1>',[sub { shift; shift->invoke; Tk->break; },$b]);
      $e{$_}->insert(0,encode($$node{$_}));
      $e{$_}->configure(-state=> 'disabled');
      $r->pack(qw/side right -expand yes -fill both/);
      $height += max($b->reqheight,$e{$_}->reqheight()) if ($i<$rows);
    } else {
      $e{$_}= $eef->Entry(-relief=> 'sunken', -takefocus=> 1,
			 -font=> $font)->pack(qw/-side right -expand yes -fill both/);
      addBindTags($e{$_},"EditEntry");
      $e{$_}->insert(0,encode($$node{$_}));
      if (doEvalHook($win,'enable_attr_hook',$_,"normal") eq 'stop') {
	$e{$_}->configure(-state=> 'disabled');
      }
      $height += $e{$_}->reqheight() if ($i<$rows);
    }
    $f->bind($e{$_}, '<Tab>',       [\&focusxEditDn,$i,\%e,$f,\@atord]);
    $f->bind($e{$_}, '<Down>',      [\&focusxEditDn,$i,\%e,$f,\@atord]);
    $f->bind($e{$_}, '<Shift-Tab>', [\&focusxEditUp,$i,\%e,$f,\@atord]);
    $f->bind($e{$_}, '<Shift-ISO_Left_Tab>',
	                            [\&focusxEditUp,$i,\%e,$f,\@atord]);
    $f->bind($e{$_}, '<Up>',        [\&focusxEditUp,$i,\%e,$f,\@atord]);
  }
  $f->configure(-height => $height);
  $f->pack(qw/-expand yes -fill both/);
  $ff->pack(qw/-expand yes -fill both/);
  $win->toplevel->Unbusy();

  my $result= ShowDialog($d,($atord[0] ? $e{$atord[0]}->focus : undef),$win->toplevel);
  if ($result=~ /OK/) {
    $win->{FSFile}->notSaved(1);
    lastActionBookmark($win->{framegroup});
    foreach $a (@atord) {
      $$node{$a}=decode($e{$a}->get);
    }
    doEvalHook($win,"after_edit_node_hook",$node,1);
    get_nodes_fsfile_tree($win->{framegroup},$win->{FSFile},$win->{treeNo});
    redraw_fsfile_tree($win->{framegroup},$win->{FSFile},$win->{treeNo});
  } else {
     doEvalHook($win,"after_edit_node_hook",$node,0);
   }
  undef %e;
  foreach $_ (@r) {$_->destroy;}
  @r=();
  $f->destroy;
  $d->destroy;
  undef $d;

}

sub customAttrsDialog {
  my ($grp)=@_;
  my $win=$grp->{focusedWindow};
  return if (doEvalHook($win,"customize_attrs_hook",$node) eq 'stop');

  return unless $win->{FSFile};

  $grp->{top}->Busy(-recurse=>1);
  my $d=$grp->{top}->
    DialogBox(-title=> "Customize Visible Attributes",
	      -width=> '10c',
	      -buttons=> ["OK", "Cancel"]);

  my $f= $d->Frame(qw/-relief sunken -bd 1/);
  $f->Frame(qw/-height 6/)->pack(qw/-side bottom/);
  my $af= $f->Frame();
  $af->Frame(qw/-height 6/)->pack();
  $af->Label(qw/-text Attributes -anchor nw -justify left/)->pack(qw/-fill both/);
  my $al= $af->Scrolled(qw/Listbox
                     -bg white
                     -width 0
                     -relief sunken
                     -borderwidth 2 -setgrid true
                     -scrollbars oe
                     -exportselection 0/)->pack(qw/-pady 3 -expand yes -fill y/);
  $al->BindMouseWheelVert();
  my @atord=$win->{FSFile}->FS->attributes;
  if ($sortAttrs) {
    @atord=sort {uc($a) cmp uc($b)} $win->{FSFile}->FS->attributes
      unless (doEvalHook($win,"sort_attrs_hook",\@atord));
  }
  $al->insert('end',@atord);
  $af->pack(qw/-padx 5 -side left -fill y/);
  my $cf= $f->Frame();
  $cf->Frame(qw/-height 6/)->pack();
  $cf->Label(-text=> 'Display patterns',qw/-anchor nw -justify left/)->pack(qw/-fill x/);
  my $cl=
    $cf->Scrolled(qw/Listbox -relief sunken
                     -bg white
                     -borderwidth 2
                     -setgrid true
		     -scrollbars osoe
                     -selectmode extended
                     -exportselection 0/
		 )->pack(qw/-side top -expand yes
                            -fill both
                            -padx 3 -pady 3/);
  $cl->BindMouseWheelVert();
  $cl->insert('end',$win->{FSFile}->patterns,'   ');
  $cf->Frame(qw/-height 6/)->pack();
  $cf->Label(-text=> 'Hint pattern',qw/-anchor nw -justify left/)->pack(qw/-fill x/);
  my $t=
    $cf->Scrolled(qw/Text -relief sunken
                     -borderwidth 2 -setgrid true
		     -height 4 -scrollbars osoe
                     -width 50
                     -exportselection 1
                     -wrap none/
		 )->pack(qw/-side top -expand yes
                            -fill both
                            -padx 3 -pady 3/);
  $t->insert('0.0',$win->{FSFile}->hint);
  $t->BindMouseWheelVert();
  my $e= $d->Entry(qw/-relief sunken -borderwidth 2/);

  my $bf= $f->Frame();
  $bf->Button(-text=> "Add/Paste",
	      -command=>
	      sub {
		if ($e->get ne "") {
		  $cl->insert('active',$e->get);
		} elsif($al->selectionIncludes($al->index('active'))) {
		  $cl->insert('active','${'.$al->get('active').'}');
		}
		$e->selectionRange(0,'end');
	      }
	     )->pack(qw/-side top -expand yes -padx 3 -pady 3/);

  $bf->Button(-text=> "Cut",
	      -command=>
	      sub {
		$cl->selectionClear($cl->index('end')-1)
		  if ($cl->selectionIncludes($cl->index('end')-1));
		while (defined(($cl->curselection)[0])) {
		  $e->delete(0,'end');
		  $e->insert('insert',$cl->get(($cl->curselection)[0]));
		  $cl->delete(($cl->curselection)[0]);
		}
	      }
	     )->pack(qw/-side top expand yes -padx 3 -pady 3/);
  $bf->Button(-text=> "Delete",
	      -command=>
	      sub {
		$cl->selectionClear($cl->index('end')-1)
		  if ($cl->selectionIncludes($cl->index('end')-1));
		while (defined(($cl->curselection)[0])) {
		  $cl->delete(($cl->curselection)[0]);
		}
	      }
	     )->pack(qw/-side top expand yes -padx 3 -pady 3/);


  $bf->Button(-text=> "Add as hint",
	      -command=>
	      sub {
		if ($e->get ne "") {
		  Tk::catch { $t->delete('sel.first','sel.last') };
		  $t->insert('insert',$e->get);
		}
		$e->selectionRange(0,'end');
	      }
	     )->pack(qw/-side top -expand yes -padx 3 -pady 3/);


  $bf->pack(qw/-padx 5 -side left -fill y/);
  $cf->pack(qw/-padx 5 -side left -expand yes -fill both/);

  $f->pack(qw/-padx 3 -pady 3 -side top -expand yes -fill both/);
  my $eff=$d->Frame(qw/-relief sunken -bd 1/)->
    pack(qw/-padx 3 -pady 3 -side top -fill x/);
  $eff->Frame(qw/-height 6/)->pack();
  $d->Label(-text => "Edit attribute pattern",
	    -anchor => 'nw', -justify => 'left')
    ->pack(-in => $eff, qw/-padx 3 -pady 3 -side top -expand yes -fill x/);

  $e->pack(-in => $eff,qw/-padx 3 -pady 3 -side top -expand yes -fill x/);
  $e->raise($eff);
  $d->bind('all','<Escape>'=>
	   [sub { shift;
		  shift->{selected_button}='Cancel';
		},$d ]);
  $al->bind('<Double-1>'=> 
	   sub {
	     $e->delete('sel.first','sel.last')
	       if ($e->selectionPresent);
	     $e->insert('insert','${'.$al->get('active').'}');
	     $e->focus();
	   }
	  );
  $cl->bind('<Double-1>'=> 
	   sub {
	     return if ($cl->index('active')== $cl->index('end')-1);
	     if ($e->selectionPresent) {
	       $e->delete('sel.first','sel.last')
	     }
	     $e->insert('insert',$cl->get('active'));
	     $e->focus();
	   }
	  );
  $d->bind('<Return>'=> [sub {1;}]);
#  $d->resizable(0,0);
  $grp->{top}->Unbusy();

  my $result= ShowDialog($d,$e,$grp->{top});

  if ($result=~ /OK/) {
    $win->{FSFile}->changeHint($t->get('0.0','end - 1 chars'));
    $win->{FSFile}->changePatterns($cl->get(0,$cl->index('end')-2));
    redraw_fsfile($grp,$win->{FSFile},$win->{treeNo});
  }
  $d->destroy;
  undef $d;
}


#####################################################
#####################################################
#####################################################
# Node searching
#####################################################

sub findNodeDialog {
  my ($grp,$template)=@_;
  return unless $grp->{focusedWindow}->{FSFile};
  my $r;
  my @vals;
  my @atord=$grp->{focusedWindow}->{FSFile}->FS->attributes;
  if ($sortAttrs) {
    @atord=sort {uc($a) cmp uc($b)} $grp->{focusedWindow}->{FSFile}->FS->attributes
      unless (doEvalHook($grp->{focusedWindow},"sort_attrs_hook",\@atord));
  }

  my $b;
  my $a;
  my $rows=min($maxDisplayedAttributes,$#atord+1);
  my %e=();
  $grp->{top}->Busy(-recurse=>1);
  my $d=$grp->{top}->DialogBox(-title=> "Find Node By Attributes", -width=> '10c',
				 -buttons=> ["Find"]);
  my $bcl=$d->Subwidget('bottom')->Button(-text=> "Clear",
				  -command=> [sub { my $e=shift;
						     foreach (keys %$e) {
						       $e->{$_}->delete(0,'end');
						     }
						   },\%e] );
  my $bca=$d->Subwidget('bottom')->Button(-text=> "Cancel", 
				  -command=> [sub { shift->{selected_button}= "Cancel"},$d] );
  foreach ($bcl,$bca) {
    $_->configure(-width=> 10, -pady=> 0) if ($Tk::platform eq 'MSWin32');
    $_->pack(-side=> 'left', -expand=> 1,  -padx=> 1, -pady=> 1);
  }

  $d->bind('all','<Escape>'=> [sub { shift; shift->{selected_button}='Cancel'; },$d ]);
  my $ff=$d->Frame(-relief=> 'groove',
		   -bd => 1);
  my $f= $ff->Scrolled('Pane',
		      -sticky => 'we',
		      -scrollbars=> 'oe');
  $f->BindMouseWheelVert("","EditEntry");

  my $lwidth;
  foreach (@atord) {
    $lwidth=max($lwidth,length($_));
  }
  my $height=0;
  for (my $i=0;$i<=$#atord;$i++) {
    $_=$atord[$i];
    # Reliefs: raised, sunken, flat, ridge, and groove.
    my $eef=$f->Frame()->pack(qw/-side top -expand yes -fill x/);
    $eef->Label(-text=> $_,
		-justify => 'left',
		-width =>$lwidth,
		-anchor=> 'nw')->pack(qw/-side left/);
    $e{$_}= $eef->Entry(-relief=> 'sunken', -takefocus=> 1,
			-font=> $font)->pack(qw/-side right -expand yes -fill both/);
    addBindTags($e{$_},"EditEntry");
    $e{$_}->insert(0,encode($template->{$_}));
    $height += $e{$_}->reqheight() if ($i<$rows);
    $f->bind($e{$_}, '<Tab>',       [\&focusxEditDn,$i,\%e,$f,\@atord]);
    $f->bind($e{$_}, '<Down>',      [\&focusxEditDn,$i,\%e,$f,\@atord]);
    $f->bind($e{$_}, '<Shift-Tab>', [\&focusxEditUp,$i,\%e,$f,\@atord]);
    $f->bind($e{$_}, '<Shift-ISO_Left_Tab>',
	                            [\&focusxEditUp,$i,\%e,$f,\@atord]);
    $f->bind($e{$_}, '<Up>',        [\&focusxEditUp,$i,\%e,$f,\@atord]);
  }
  $f->configure(-height => $height);
  $f->pack(qw/-expand yes -fill both/);
  $ff->pack(qw/-expand yes -fill both/);

  do {
    my $of=$d->Frame()->pack(qw/-expand yes -fill x/);
    $of->Label(-text=> 'Search method: ')->pack(qw/-side left/);
    $of->Optionmenu(-variable=> \$grp->{templateMatchMethod},
		    -textvariable=> \$grp->{templateMatchMethod},
		    -options=> ['Regular expression',
				'Exhaustive regular expression',
				'Wildcard pattern',
				'Literal'])->pack(qw/-side left/);
  };
  my $of=$d->Frame()->pack(qw/-expand yes -fill x/);
  $of->Label(-text=> 'Search file-list: ')->pack(qw/-side left/);
  my $om=$of->Optionmenu(-textvariable=> \$grp->{searchFilelist})->pack(qw/-side left/);
  $om->options(['[Current file only]', map { $_->name } @filelists]);
  
  $of->Button(-text=> 'Edit',
	      -command=> [ sub {
			      my ($grp)=@_;
			      my $name=filelistDialog($grp,1);
			      $om->options(['[Current file only]',map { $_->name } @filelists]);
			      $grp->{searchFilelist}=$name if (ref(findFilelist($name)));
			    },$grp,$om])->pack(qw/-side left/);
  $grp->{top}->Unbusy();
  my $result= ShowDialog($d,($atord[0] ? $e{$atord[0]}->focus : undef),$grp->{top});
  if ($result=~ /Find/) {
    foreach $a (@atord) {
      $template->{$a}=decode($e{$a}->get);
    }
    # Clear all empty rules
    foreach (keys %$template) {
      delete $template->{$_} unless defined($template->{$_}) and $template->{$_} ne '';
    }
    if ($grp->{searchFilelist} ne '[Current file only]') {
      my $fl=findFilelist($grp->{searchFilelist});
      if (ref($fl) and $fl->file_count>0 ) {
	local $insideEval=1;                 # no redraw
	$fl->set_current($fl->file_at(0));
	selectFilelist($grp,$fl);
      }
    } else { 
      $grp->{searchFilelist}=undef;
    }
    doFindFirstTemplated($grp,$template,0);
  }
  $d->destroy;
  undef $d;
}

#####################################
# bound to Escape for busy widgets
#####################################
sub _search_busy {
  my ($w,$grp)=@_;
  print STDERR $grp->{focusedWindow}->{currentFileNo}."stopped by user\n" if ($tredDebug);
  $grp->{stopSearch}=1;
  Tk->break;
}

#####################################
# called after file open to process
# event queue and let user interrupt
# the search process
#####################################
sub _quick_update {
  my $grp=shift;
  $grp->{top}->Unbusy();
  $grp->{top}->update();
  $grp->{top}->Busy(-recurse=> 1);
}

######################################
# start searching for a next node
# and display result unless succeeded
######################################
sub doFindFirstTemplated {
  my ($grp,$template,$cont)=@_;
  return undef unless ($grp->{focusedWindow}->{currentNode});
  my $result;
  $grp->{top}->Busy(-recurse=> 1);

  print "Starting search!\n"  if $tredDebug;
  unless ($result=findFirstTemplated($grp,$template,$cont)) {
    redraw_win($grp->{focusedWindow});
    $grp->{top}->toplevel->
      messageBox(-icon=> 'warning',
		 -message=> $grp->{stopSearch} ? "Interrupted by user!" : "No matching node found!",
		 -title=> 'Find',
		 -type=> 'ok');
  }
  $grp->{top}->Unbusy();
  return $result;
}

######################################
# start searching for a prev node
# and display result unless succeeded
######################################
sub doFindPrevTemplated {
  my ($grp,$template,$cont)=@_;
  return undef unless ($grp->{focusedWindow}->{currentNode});
  my $result;
  $grp->{top}->Busy(-recurse=> 1);

  unless ($result=findPrevTemplated($grp,$template,$cont)) {
    redraw_win($grp->{focusedWindow});
    $grp->{top}->toplevel->
      messageBox(-icon=> 'warning',
		 -message=> $grp->{stopSearch} ? "Interrupted by user!" : "No matching node found!",
		 -title=> 'Find',
		 -type=> 'ok');
  }
  $grp->{top}->Unbusy();
  return $result;
}

######################################
# compare nodes with template
######################################
sub cmpTemplateField {
  my ($grp,$val,$templ)=@_;
  my $method=substr($grp->{templateMatchMethod},0,1);
  return $val=~ /^$templ$/ if ($method eq 'E');
  return $val=~ /$templ/ if ($method eq 'R');
  return $val eq $templ if ($method eq 'L');
  if ($method eq 'W') {
    $templ=~s/[.^$(){}<>\\]/\\\&/g;
    $templ=~s/\*/.\*/g;
    $templ=~s/\?/./g;
    return $val=~ /^$templ$/;
  }
  return $val eq $templ;
}

######################################
# go to next node in searchlist
######################################
sub nextNodeInSearchFilelist {
  my ($grp,$node,$tree)=@_;
  my $win=$grp->{focusedWindow};

  $node=(HNext($win,$node) || 
	 $win->{FSFile}->treeList->[(++$$tree)]);
  return $node if ($node or !defined($grp->{searchFilelist}));

  # this realises filelist search
  local $insideEval=1;
  my $result=nextFile($grp,1);
  $win->{treeNo}=-1; # force redraw in gotoTree
  $$tree=0;
  # we especially wait for Escape
  _quick_update($grp);
  while (!$grp->{stopSearch} and $result and !$win->{currentNode}) {
    $result=nextFile($grp,1);
    # we especially wait for Escape
    _quick_update($grp);
    $win->{treeNo}=-1; # force redraw in gotoTree
  }
  return (!$grp->{stopSearch} and $result) ? $win->{currentNode} : undef;
}

######################################
# find next matching node
######################################
sub findFirstTemplated {
  my ($grp,$template,$skipfirst)=@_;

  my $win=$grp->{focusedWindow};

  return unless $win->{FSFile};
  my $node=$win->{currentNode};
  my $tree=$win->{treeNo};
  my $a;
  $grp->{stopSearch}=0;

  $node=nextNodeInSearchFilelist($grp,$node,\$tree) if ($skipfirst);
  while ($node) {
    unless (grep (!cmpTemplateField($grp,$node->{$_},$template->{$_}), keys (%$template)))
      {
	gotoTree($win,$tree);
	setCurrent($win, $node);
	centerTo($win,$node);
	return $node;
      }
    $node=nextNodeInSearchFilelist($grp,$node,\$tree);
  }
  return undef;
}

######################################
# go to the last node of a tree
######################################
sub lastSubtreeNode {
  my ($top)=@_;
  return undef unless $top;
  while ($top->firstson) {
    $top=$top->firstson;
    $top=$top->rbrother while ($top->rbrother);
  }
  return $top;
}

######################################
# go to previous node in search list
######################################
sub prevNodeInSearchFilelist {
  my ($grp,$node,$tree)=@_;
  $node=HPrev($grp->{focusedWindow},$node);
  unless ($node or $$tree==0) {
    $node=lastSubtreeNode($grp->{focusedWindow}->{FSFile}->treeList->[(--$$tree)]);
    $node=HPrev($grp->{focusedWindow},$node) unless (isShown($grp->{focusedWindow},$node));
  }
  return $node if $node or !defined($grp->{searchFilelist});

  # this realises filelist search
  local $insideEval=1;
  my $result=prevFile($grp,1);
  # we especially wait for Escape
  _quick_update($grp);
  $grp->{focusedWindow}->{treeNo}=-1; # force redraw in gotoTree
  while ($result and !$grp->{stopSearch}
	 and !$grp->{focusedWindow}->{FSFile} || $grp->{focusedWindow}->{FSFile}->lastTreeNo<0) {
    $result=prevFile($grp,1);
    # we especially wait for Escape
    _quick_update($grp);
    $grp->{focusedWindow}->{treeNo}=-1; # force redraw in gotoTree
  }
  if ($result and !$grp->{stopSearch}) {
    $$tree=$grp->{focusedWindow}->{FSFile}->lastTreeNo;
    $node=lastSubtreeNode($grp->{focusedWindow}->{FSFile}->treeList->[$$tree]);
    return $node;
  }
  return undef;
}

######################################
# find previous matching node
######################################
sub findPrevTemplated {
  my ($grp,$template,$skipfirst)=@_;
  return unless $grp->{focusedWindow}->{FSFile};
  my $node=$grp->{focusedWindow}->{currentNode};
  my $tree=$grp->{focusedWindow}->{treeNo};
  my $a;
  $grp->{stopSearch}=0;

  $node=prevNodeInSearchFilelist($grp,$node,\$tree) if ($skipfirst);

  while ($node) {
    unless (grep (!cmpTemplateField($grp,$node->{$_},$template->{$_}), keys (%$template)))
      {
	gotoTree($grp->{focusedWindow}, $tree);
	setCurrent($grp->{focusedWindow}, $node);
	centerTo($grp->{focusedWindow},$node);
	return $node;
      }
    $node=prevNodeInSearchFilelist($grp,$node,\$tree);
  }
  return undef;
}

#############################################
#End of Searching functions
#############################################
#############################################
#############################################



sub editAttrs {
  my ($w,$grp)=@_;
  my $win=findCanvasWindow($grp,$w);
  my $node=$win->{treeView}->get_obj_pinfo($w->find('withtag','current'));
  editAttrsDialog($win,$node);
}

sub editAttr {
  my ($w,$grp)=@_;
  my $win=findCanvasWindow($grp,$w);
  return unless($win and $win->{FSFile});
  my $attr;
  my $newvalue;

  my $t=$w->find('withtag','current');
  my $tv=$win->{treeView};
  my $node=$tv->get_obj_pinfo($t);
  my $d;
  setCurrent($win,$node);
  $attr=$tv->get_gen_pinfo("attr:$t");
  my $result= doEvalHook($win,'do_edit_attr_hook',$attr,$node);
  return 0 if $result eq 'stop';

  if ($win->{FSFile}->FS->isList($attr)) {
    $newvalue= editListAttr($win,$node->{$attr},$attr,$grp->{top});
    if (defined($newvalue)) {
      $win->toplevel->Busy(-recurse=> 1);
      $win->{FSFile}->notSaved(1);
      lastActionBookmark($grp);
      $$node{$attr}=$newvalue;
      doEvalHook($win,"after_edit_attr_hook",$node,$attr,1);
      get_nodes_fsfile_tree($grp,$win->{FSFile},$win->{treeNo});
      redraw_fsfile_tree($grp,$win->{FSFile},$win->{treeNo});
      $win->toplevel->Unbusy();
    } else {
      doEvalHook($win,"after_edit_attr_hook",$node,$attr,0);
    }
    return;
  }

  if ($$node{$attr}=~/^(?:[^\|\\]|\\.)*\|/) {
    $newvalue= editAmbiguousAttr($win,$node->{$attr},$attr);
    if (defined $newvalue) {
      $grp->{top}->Busy(-recurse=> 1);
      $win->{FSFile}->notSaved(1);
      lastActionBookmark($grp);
      $$node{$attr}=$newvalue;
      doEvalHook($win,"after_edit_attr_hook",$node,$attr,1);
      get_nodes_fsfile_tree($grp,$win->{FSFile},$win->{treeNo});
      redraw_fsfile_tree($grp,$win->{FSFile},$win->{treeNo});
      $grp->{top}->Unbusy();
    } else {
      doEvalHook($win,"after_edit_attr_hook",$node,$attr,0);
    }
    return;
  }

  $grp->{top}->Busy(-recurse=> 1);

  $newvalue=encode($node->{$attr});
  $d= $grp->{top}->DialogBox(-title=> "Edit Node Attribute",
				-buttons=> ["OK", "Cancel"]);
  $d->bind('all','<Escape>'=> [sub { shift; shift->{selected_button}='Cancel'; },$d ]);
  $d->resizable(0,0);
  addBindTags($d,'dialog');
  my $l= $d->Label(-text=> $attr,
		    -anchor=> 'e',
		    -justify=> 'right')->pack(-side=>'left');
  my $e= $d->Entry(-relief=> 'sunken',
		    -width=> 40,
		    -state=> (doEvalHook($win,'enable_attr_hook',
					  $attr,"normal") eq 'stop') ? 'disabled' : 'normal',
		    -takefocus=> 1,
		    -font=> $font,
		    -textvariable=> \$newvalue)->pack();
  $e->icursor('end');
  $grp->{top}->Unbusy();
  $result= ShowDialog($d,$e,$grp->{top});
  if ($result=~ /OK/) {
    $win->{FSFile}->notSaved(1);
    lastActionBookmark($grp);
    $$node{$attr}=decode($newvalue);
    doEvalHook($win,"after_edit_attr_hook",$node,$attr,1);
    get_nodes_fsfile_tree($grp,$win->{FSFile},$win->{treeNo});
    redraw_fsfile_tree($grp,$win->{FSFile},$win->{treeNo});
  } else {
    doEvalHook($win,"after_edit_attr_hook",$node,$attr,0);
  }
  $d->destroy;
  undef $d;
}


#############################################
# redraw tree etc.
#############################################

sub nodeOptions {
  my ($win,$node)=@_;
  return $win->{treeView}->node_options($node,
					$win->{FSFile}->FS,
					$win->{currentNode});
}

sub nodeBoxOptions {
  my ($win,$node,$edge)=@_;
  return $win->{treeView}->node_box_options($node,
					 $win->{FSFile}->FS,
					 $win->{currentNode},$edge);
}

sub call_redraw_hook {
#  my ($grp);
#  return doEvalHook($win,"redraw_hook");
}

sub call_draw_node_hook {
# the problem here and above is that the calls
# to hooks should pass win reference. But redraw
# cannot even call hooks, and has no notion about
# window objects.
#
# we have to settle this down yet.
# the best solution seems to me to change
# the API of redraw to redraw($win,$valueLine)
#
# (still, $valueLine should seems obsolette)
#
}

sub redraw_win {
  my ($win)=@_;
  return if $insideEval;
  saveFileStateUpdate($win);
  #------------------------------------------------------------
  #{
  #use Benchmark;
  #my $t0= new Benchmark;
  #for (my $i=0;$i<=50;$i++) {
  #------------------------------------------------------------

  $win->{treeView}->
      redraw($win->{FSFile},
	     $win->{currentNode},
	     $win->{Nodes},
	     $valueLine);	# CHANGE THIS (this is just for printing)
  #------------------------------------------------------------
  #}
  #my $t1= new Benchmark;
  #my $td= timediff($t1, $t0);
  #print "redraw: the code took:",timestr($td),"\n";
  #}
  #------------------------------------------------------------

  return;
}

sub redraw_fsfile {
  my ($grp,$fsfile)=@_;
  return if $insideEval;
  foreach (fsfileDisplayingWindows($grp,$fsfile)) {
    redraw_win($_);
  }
  return;
}

sub redraw_fsfile_tree {
  my ($grp,$fsfile,$tree_no)=@_;
  return if $insideEval;
  foreach (grep {$_->{treeNo} == $tree_no}
	   fsfileDisplayingWindows($grp,$fsfile)) {
    redraw_win($_);
  }
  return;
}

sub redraw_all {
  my ($grp)=@_;
  foreach (@{ $grp->{treeWindows} }) {
    redraw_win($_);
  }
  return;
}

sub follow_mouse {
  my ($w, $grp)= @_;
  my $e= $w->XEvent;
  my $win=findCanvasWindow($grp,$w);
  my($x, $y)= ($w->fpixels($e->x), $w->fpixels($e->y));
  scrollCanvasToXY($w, $win, $x, $y);
}

sub follow_mouse_press {
  my ($w, $grp)= @_;
  my $win=findCanvasWindow($grp,$w);
  my $tv=$win->{treeView};
  my $e= $w->XEvent;
  my($x, $y)= ($w->fpixels($e->x), $w->fpixels($e->y));

  $tv->store_gen_pinfo("lastX",$x);
  $tv->store_gen_pinfo("lastY",$y);
  $tv->store_gen_pinfo("lastCanvasX",$w->canvasx($x));
  $tv->store_gen_pinfo("lastCanvasY",$w->canvasy($y));
}



sub scrollCanvasToXY {
  my ($w, $win, $x, $y)=@_;
  my ($ax,$bx)=$w->xview;
  my ($ay,$by)=$w->yview;
  my $canvasX;
  my $tv=$win->{treeView};

  my $sizeX=$w->fpixels($tv->{canvasWidth})*($bx-$ax);
  my $shiftX=($x-$tv->get_gen_pinfo("lastX"));
  if ($shiftX>0) {
    if ($tv->get_gen_pinfo("lastX")== $sizeX) {
      $shiftX=0;
    } else {
      $shiftX/=$sizeX-$tv->get_gen_pinfo("lastX"); # a fraction of our right move in window
    }
    $canvasX=$shiftX*
      ($w->fpixels($tv->{canvasWidth})-
       $tv->get_gen_pinfo("lastCanvasX")); # this is where we should get on the canvas
  } else {
    if ($tv->get_gen_pinfo("lastX")== 0) {
      $shiftX=0;
    } else {
      $shiftX/=$tv->get_gen_pinfo("lastX");
    }
    $canvasX=$shiftX*
      $tv->get_gen_pinfo("lastCanvasX"); # this is where we should get on the canvas
  }
  $canvasX+=$tv->get_gen_pinfo("lastCanvasX");
  $w->xview(moveto=>
	    max(0,min(1,($canvasX-$x+1+$w->fpixels($w->cget('-borderwidth')))
		      /$tv->{canvasWidth})));

  # the same for Y
  my $sizeY=$w->fpixels($tv->{canvasHeight})*($by-$ay);
  my $shiftY=($y-$tv->get_gen_pinfo("lastY"));
  if ($shiftY>0) {
    if ($tv->get_gen_pinfo("lastY")== $sizeY) {
      $shiftY=0;
    } else {
      $shiftY/=$sizeY-$tv->get_gen_pinfo("lastY"); # a fraction of our right move in window
    }
    $canvasY=$shiftY*
      ($w->fpixels($tv->{canvasHeight})-
       $tv->get_gen_pinfo("lastCanvasY")); # this is where we should get on the canvas
  } else {
    if ($tv->get_gen_pinfo("lastY")==0) {
      $shiftY=0;
    } else {
      $shiftY/=$tv->get_gen_pinfo("lastY");
    }
    $canvasY=$shiftY*
      $tv->get_gen_pinfo("lastCanvasY"); # this is where we should get on the canvas
  }
  $canvasY+=$tv->get_gen_pinfo("lastCanvasY");
  $w->yview(moveto=>
	    max(0,min(1,($canvasY-$y+1+$w->fpixels($w->cget('-borderwidth')))
		      /$tv->{canvasHeight})));


  $tv->store_gen_pinfo("lastX",$x);
  $tv->store_gen_pinfo("lastY",$y);
  $tv->store_gen_pinfo("lastCanvasX",$w->canvasx($x));
  $tv->store_gen_pinfo("lastCanvasY",$w->canvasy($y));
}

sub currentUnhiden {
  my ($win)=@_;
  return unless $win->{FSFile};
  unless ($win->{treeView}->{showHidden}) {
    my $node=$win->{FSFile}->FS->isHidden($win->{currentNode});
    setCurrent($win,$node->parent) if ($node and $node->parent);
  }
}

sub currentLeft {
  my $grp=shift;
  my $win=$grp->{focusedWindow};
  return unless $win->{FSFile};
  if ($win->{treeView}->{showHidden}) {
    if ($win->{currentNode}->lbrother) {
      setCurrent($win,$win->{currentNode}->lbrother);
      centerTo($win,$win->{currentNode});
    }
  } else {
    my $n=$win->{currentNode}->lbrother;
    $n=$n->lbrother while ($n and defined($win->{FSFile}->FS->hide)
			   and ($n->{$win->{FSFile}->FS->hide} eq 'hide'));
    if ($n) {
      setCurrent($win,$n);
      centerTo($win,$win->{currentNode});
    }
  }
}

sub currentRight {
  my $grp=shift;
  my $win=$grp->{focusedWindow};
  return unless $win->{FSFile};
  if ($win->{treeView}->{showHidden}) {
    if ($win->{currentNode}->rbrother) {
      setCurrent($win,$win->{currentNode}->rbrother);
      centerTo($win,$win->{currentNode});
    }
  } else {
    my $n=$win->{currentNode}->rbrother;

    $n=$n->rbrother while ($n and defined($n->{$win->{FSFile}->FS->hide})
			   and ($n->{$win->{FSFile}->FS->hide} eq 'hide'));
    if ($n) {
      setCurrent($win,$n);
      centerTo($win,$win->{currentNode});
    }
  }
}

sub currentDown {
  my $grp=shift;
  my $win=$grp->{focusedWindow};
  return unless $win->{FSFile};
  if ($win->{treeView}->{showHidden}) {
    if ($win->{currentNode}->firstson) {
      setCurrent($win,$win->{currentNode}->firstson);
      centerTo($win,$win->{currentNode});
    }
  } else {
    my $n=$win->{currentNode}->firstson;
    $n=$n->rbrother while ($n and defined($n->{$win->{FSFile}->FS->hide})
			   and $n->{$win->{FSFile}->FS->hide} eq 'hide');
    if ($n) {
      setCurrent($win,$n);
      centerTo($win,$win->{currentNode});
    }
  }
}

sub currentUp {
  my $grp=shift;
  my $win=$grp->{focusedWindow};
  if ($win->{currentNode}->parent) {
    setCurrent($win,$win->{currentNode}->parent);
    centerTo($win,$win->{currentNode});
  }
}

sub centerToXY {
  my ($win, $x, $y)= @_;
  my ($ax,$bx)=$win->{treeView}->canvas->xview;
  my ($ay,$by)=$win->{treeView}->canvas->yview;

  my $shiftx=($bx-$ax)/2;
  my $shifty=($by-$ay)/2;

  $win->{treeView}->canvas->xview(moveto=> min(max(0,$x/$win->{treeView}->{canvasWidth}-$shiftx),1))
    if ($win->{treeView}->{canvasWidth}-$shiftx);
  $win->{treeView}->canvas->yview(moveto=> min(max(0,$y/$win->{treeView}->{canvasHeight}-$shifty),1))
    if ($y/$win->{treeView}->{canvasHeight}-$shifty);
}

sub centerTo {
  my ($win, $node)= @_;
  my $tv=$win->{treeView};
  centerToXY($win,
	     $tv->get_node_pinfo($node,"XPOS"),
	     $tv->get_node_pinfo($node,"YPOS"));
}

sub doEvalHook {
  my ($win,$hook)=(shift,shift);
  return unless $hook and $win->{currentNode};
  my $bookmark=bookmarkThis($grp->{framegroup});  # Save current position (as last action position)

  local $insideEval=1;

  $TredMacro::this=$win->{currentNode};
  $TredMacro::root=$win->{root};
  $TredMacro::libDir=$libDir;
  $FileNotSaved=$win->{FSFile}->notSaved;
  $TredMacro::forceFileSaved=0;
  my $result=do_eval_hook($win,$win->{macroContext},$hook,@_);
  warn "$@\n" if $@;
  lastActionBookmark($grp->{framegroup},$bookmark) if $FileNotSaved and !$win->{FSFile}->notSaved;
  $win->{FSFile}->notSaved($win->{FSFile}->notSaved or $FileNotSaved);
  saveFileStateUpdate($win);

  $TredMacro::this=undef;
  $TredMacro::root=undef;
  $TredMacro::grp=undef;

  print STDERR "Hook $hook resulted with $result\n" if $hookDebug;
  return $result;
}

sub doEvalMacro {
  my ($win,$macro)=(shift,shift);
  return unless $macro and $win->{currentNode};

  $win->toplevel->Busy(-recurse=> 1);
  my $bookmark=bookmarkThis($win->{framegroup});

  $insideEval=1;

  $TredMacro::this=$win->{currentNode};
  $TredMacro::root=$win->{root};
  $TredMacro::libDir=$libDir;
  $TredMacro::FileNotSaved=1;
  $TredMacro::forceFileSaved=0;
  $TredMacro::Redraw='file';
  my $result=do_eval_macro($win,$macro);

  unless ($TredMacro::forceFileSaved) {
    print STDERR "Macro claims file untouched\n"
      unless ($TredMacro::FileNotSaved);
    $win->{FSFile}->notSaved($win->{FSFile}->notSaved or $TredMacro::FileNotSaved);
    lastActionBookmark($win->{framegroup},$bookmark) if $TredMacro::FileNotSaved;
  } else {
    print STDERR "Macro forsly claims file saved.\n";
    $win->{FSFile}->notSaved($TredMacro::FileNotSaved);
    lastActionBookmark($win->{framegroup},$bookmark) if $TredMacro::FileNotSaved;
  }
  $insideEval=0;

  #------------------------------------------------------------
  #use Benchmark;
  #my $t0= new Benchmark;
  #for (my $i=0;$i<=50;$i++) {
  ### ??? 4kb/50 runs memory leaks in redraw (probably in Tk)
  #------------------------------------------------------------
  if ($TredMacro::Redraw eq 'all') {
    redraw_all($win->{framegroup});
    get_nodes_all($win->{framegroup});
  } elsif ($TredMacro::Redraw eq 'win') {
    get_nodes_win($win);
    redraw_win($win);
  } elsif ($TredMacro::Redraw eq 'tree') {
    get_nodes_fsfile_tree($win->{framegroup},$win->{FSFile},$win->{treeNo});
    redraw_fsfile_tree($win->{framegroup},$win->{FSFile},$win->{treeNo});
  } elsif ($TredMacro::Redraw eq 'tie') {
    if ($win->{framegroup}->{tieWindows}) {
      get_nodes_all($win->{framegroup});
      redraw_all($win->{framegroup});
    } else {
      get_nodes_win($win);
      redraw_win($win);
    }
  } elsif ($TredMacro::Redraw eq 'none') {
    # do nothing
  } else {
    get_nodes_fsfile($win->{framegroup},$win->{FSFile});
    redraw_fsfile($win->{framegroup},$win->{FSFile});  
  }
  #------------------------------------------------------------
  #}
  #my $t1= new Benchmark;
  #my $td= timediff($t1, $t0);
  #print "$TredMacro::FileNotSaved the code took:",timestr($td),"\n";
  #------------------------------------------------------------

  # the rest of this routine is:
  # memory ok, speed ok
  setCurrent($win,$TredMacro::this) if ($TredMacro::this);
  currentUnhiden($win);

  $TredMacro::this=undef;
  $TredMacro::root=undef;
  $TredMacro::grp=undef;

  centerTo($win,$win->{currentNode});

  $win->toplevel->Unbusy;
  return $result;
}

sub resolveKey {
  my $grp=shift;
 context:
  foreach my $context ($grp->{focusedWindow}->{macroContext},$grp->{focusedWindow}->{macroContext} eq "TredMacro" ? () : "TredMacro") {
    foreach $key (@_) {
      if (exists ($keyBindings{$context}->{$key})) {
	return $keyBindings{$context}->{$key};
      }
    }
  }
  return undef;
}

sub evalMacro {
  my ($w,$grp,$prefix)=@_;
  my $win=$grp->{focusedWindow};
  my $key;
  my $e= $w->XEvent;
  my $A= uc($e->A);
  my @possib=();
  my $macro=undef;

  if ($keyboardDebug) {
    print STDERR "Pressed: (".ord($A)."), prefix $prefix, keysym ",$e->K,"/",$e->N,"\n";
    print STDERR "Maybe: ",$prefix.$pckey_shift_translates{$e->K},"\n";
  }

  push @possib,
    ($prefix.$A,
      ($prefix=~/SHIFT/ and exists($pckey_shift_translates{$e->K})) ?
	$prefix.uc($pckey_shift_translates{$e->K}) : ()),
	$prefix.uc($e->K);

  $macro=resolveKey($grp,@possib);
  if (defined $macro) {
#    use Benchmark;
#    my $t0= new Benchmark;
#    # ... your code here ...
#    for (my $i=0;$i<=50;$i++) {
      doEvalMacro($win,$macro);
#    }
#    my $t1= new Benchmark;
#    my $td= timediff($t1, $t0);
#    print "the code took:",timestr($td),"\n";

    return 1;
  }
  return undef;
}

sub tieNextTree {
  my ($grp)=@_;
  if ($grp->{tieWindows}) {
    print "Shifting to tie next\n";
    foreach (@{$grp->{treeWindows}}) {
      nextTree($_) if ($_->{FSFile});
      print "$_ has now ", $_->{treeNo},"\n";
    }
  } else {
    nextTree($grp->{focusedWindow}) if ($grp->{focusedWindow}->{FSFile});
  }
}

sub tiePrevTree {
  my ($grp)=@_;
  if ($grp->{tieWindows}) {
    foreach (@{$grp->{treeWindows}}) {
      prevTree($_) if ($_->{FSFile});
    }
  } else {
    prevTree($grp->{focusedWindow}) if ($grp->{focusedWindow}->{FSFile});
  }
}

sub currentNext {
  my ($win)=@_;
  my $next=HNext($win,$win->{currentNode});
  if ($next) {
    setCurrent($win,$next);
    centerTo($win,$win->{currentNode});
  }
}


sub currentPrev {
  my ($win)=@_;
  my $prev=HPrev($win,$win->{currentNode});
  if ($prev) {
    setCurrent($win,$prev);
    centerTo($win,$win->{currentNode});
  }
}


sub node_down {
  my($w,$grp)= @_;
  my $win=findCanvasWindow($grp,$w);
  my $tv=$win->{treeView};
  my $e= $w->XEvent;
  my($x, $y)= ($e->x, $e->y);
  my $node=$tv->get_obj_pinfo($w->find('withtag','current'));

  setCurrent($win,$node);
  $w->dtag('selected');
  $w->addtag('selected', 'withtag', 'current');
  $w->raise('current');
  $tv->store_gen_pinfo("lastX",$x);
  $tv->store_gen_pinfo("lastY",$y);
  $tv->store_gen_pinfo("lastCanvasX",$w->canvasx($x));
  $tv->store_gen_pinfo("lastCanvasY",$w->canvasy($y));
}				# end plot_down

sub node_move {
  my($w,$grp,$scroll)= @_;
  my $win=findCanvasWindow($grp,$w);
  my $tv=$win->{treeView};
  my $e= $w->XEvent;
  my($x, $y)= ($e->x, $e->y);
  my $node=$tv->get_obj_pinfo($w->find('withtag','selected'));

  my $lcx=$tv->get_gen_pinfo('lastCanvasX');
  my $lcy=$tv->get_gen_pinfo('lastCanvasY');
  my ($ncolor,$ocolor);

  if ($scroll) {
    $ncolor=$w->itemcget('selected','-fill');
    $ocolor=$w->itemcget('selected','-outline');
    $w->itemconfigure('selected',
		      -fill=> $tv->canvas->cget('-background'),
		      -outline=> $tv->canvas->cget('-background')
		     );
    scrollCanvasToXY($w, $win, $x, $y);
  } else {
    $tv->store_gen_pinfo('lastCanvasX',$w->canvasx($x));
    $tv->store_gen_pinfo('lastCanvasY',$w->canvasy($y));
  }
  my($cx, $cy)= ($w->canvasx($x),$w->canvasy($y));
  $w->move('selected',  $cx-$lcx, $cy-$lcy);
  $w->itemconfigure('selected', -fill=> $ncolor, -outline=> $ocolor ) if $scroll;
  my $nearest=$tv->get_obj_pinfo($w->find('withtag','nearest'));
  if ($nearest) {
    $w->itemconfigure('nearest',nodeOptions($win,$nearest));
    $tv->apply_stored_style_opts("Oval",$nearest);
    $w->dtag('nearest');
  }

  my @dots= $w->find('withtag','point');
  my $nearestNode=0;
  my $bestDist=10000;
  my $dist;
  foreach $p (@dots) {
    my $n=$tv->get_obj_pinfo($p);
    if ($n and $n!=$node) {
      $dist=
	($cx-$tv->get_node_pinfo($n,"XPOS"))*
	  ($cx-$tv->get_node_pinfo($n,"XPOS"))+
	    ($cy-$tv->get_node_pinfo($n,"YPOS"))*
	      ($cy-$tv->get_node_pinfo($n,"YPOS"));
      if ($bestDist>$dist) {
	$bestDist=$dist;
	$nearestNode=$n;
      }
    }
  }
  if ($bestDist<800) {
    $w->addtag('nearest','withtag',$tv->get_node_pinfo($nearestNode,"Oval"));
    $w->itemconfigure($tv->get_node_pinfo($nearestNode,"Oval"),
		      -fill=> $tv->get_nearestNodeColor);
  }
}				# end plot_move

sub node_release {
  my($w,$grp)= @_;
  my $win=findCanvasWindow($grp,$w);
  my $tv=$win->{treeView};
  return unless $win->{FSFile};
  my $e= $w->XEvent;
  my($x, $y)= ($e->x, $e->y);
  my $parent;
  my $node;
  my $center=0;
  my $sel=$w->find('withtag','selected');
  $node=$tv->get_obj_pinfo($sel) if (defined ($sel));

  if ($node) {
    $p=$w->find('withtag','nearest');
    $w->dtag('selected');
    if (defined $p) {
      $parent=$tv->get_obj_pinfo($p);
      $w->itemconfigure($tv->get_node_pinfo($parent,"Oval"),
			  nodeOptions($win,$parent));
      while ($parent) {
	$p=0, last if ($node eq $parent);
	$parent=$parent->parent;
      }
      if ($p and $tv->get_obj_pinfo($p) 
	  and $node->parent!=$tv->get_obj_pinfo($p)) {
	Paste(Cut($node),
	      $tv->get_obj_pinfo($p),
	      $win->{FSFile}->FS->defs);
	$win->{FSFile}->notSaved(1);
	lastActionBookmark($grp);
	redraw_fsfile_tree($grp,$win->{FSFile},$win->{treeNo});
	centerTo($win,$win->{currentNode});
	return;
      }
    }
    # returning node to its position
    $w->coords($sel, $tv->node_coords($node,$win->{currentNode}));
  } else { redraw_fsfile_tree($grp,$win->{FSFile},$win->{treeNo}); }
}

