#!/usr/bin/env perl
# -*- cperl -*-
#
# $Id$
#
##############################################################################
#
# This is "TrEd" - a viewer and editor of tree graphs, such as
# dependency trees. TrEd uses PerlTk library as a GUI toolkit.
#
##############################################################################

#use strict;

if ($^V lt v5.6.0) {
  print STDERR '-' x 50,"\n";
  print STDERR "WARNING: Your version of perl is older than v5.6.0\n";
  print STDERR "THINGS MAY NOT WORK AS EXPECTED OR NOT AT ALL!\n";
  print STDERR '-' x 50,"\n\n";
}

use vars qw($version $about $opt_u $opt_h $opt_c
	    $opt_t $opt_W $opt_G $opt_R $opt_X $opt_q $opt_B $opt_p
	    $opt_n $opt_D $opt_v $opt_H $opt_I
            $libDir
	    $macroFile @filelists @openfiles $treeViewOpts $opt_m
            @backends @ISA @EXPORT @open_types @save_types $opt_l $opt_s
            $stylesheetFile $opt_S
            $insideEval %pckey_shift_translates @recentFiles $tredDebug
            $valueLine $appName $ioBackends %menuBindings %keyBindings
            $savedSavePixmap $normalSavePixmap $NewFileNo $stderr $stdout
	    $userlogin
	    %save_types %backend_map $debug @normal_win_opts @focused_win_opts
	    $normalUndoPixmap
	    $normalRedoPixmap
	    $normalNextPixmap
	    $normalPrevPixmap
	    $locale_charset
	    $no_secondary
           );

$version='$Id$';
$about=
  "Copyright (c) 2000-2003 by Petr Pajas\n".
  "This software is distributed under GPL - The General Public Licence\n".
  "Full text of the GPL can be found at http://www.gnu.org/copyleft/gpl.html";


# Get user's login name
($userlogin) = (getlogin() || ($^O ne 'MSWin32') && getpwuid($<) || 'unknown');
($userlogin =~ /\S/) || warn "Couldn\'t deterbmine user\'s login name\n";

use Tk;

# work around a bug in Tk
if (defined $Tk::encodeFallback and $Tk::encodeFallback == Encode::FB_PERLQQ() and
    Encode::FB_PERLQQ() != Encode::PERLQQ()) {
  $Tk::encodeFallback    = Encode::PERLQQ();
}

use Tk::Config ();
use Tk::Wm;
use IO;

package Tk::Wm;
# overwriting the original Tk::Wm::Post:
sub Post
{
 my ($w,$X,$Y)= @_;
 $X= int($X);
 $Y= int($Y);
 $w->positionfrom('user');
# $w->geometry("+$X+$Y");
 $w->MoveToplevelWindow($X,$Y);
 $w->deiconify;
## This causes the "slowness":
# $w->raise;
}

package main;


#use Tk::Xrm;
# process the standard arguments for X resources
Tk::CmdLine::SetArguments();

# Once we got rid of them we call getopt to read all the other options
use Getopt::Std;
getopts('qm:c:l:t:n:p:vhuW:GI:HDYB:RX:s:S:');

if ($opt_u || $opt_h) {
  print <<'EOH';
Usage:
 tred [-q] [-c <config-file>] [-m|-I <macro-file>] [-t context]
      [-l <filelist>] [-n encoding] file1[##N|#N] [file2[##N|#N] [...]]
or
 tred -u|-h|-v    for usage/help/version

EOH
  exit unless $opt_h;
  print <<'EOF';
This is TrEd - an interactive tool for editing tree graphs.

Each filename may be followed by suffixes of the following forms:

#N      where N is a number possibly followed by one or more
	upper-case letters. In this case, #N tells TrEd to skip to the
	first tree the root of which has `#N' as a value of attribute
	called `form' (this feature is optimized for specific
	instances of fs-format used while working on The Prague
	Dependency Treebank)

##N     where N is a number. This makes TrEd to go to the N-th tree in
	the given file after the file is opened.

-m      specifies a macro file different from the one given in your
	configuration file (tred.mac by default)

-I      specifies an additional macro file

-c      specifies a config-file to be used (overrides
	~/.tredrc and all the other files TrEd would otherwise try to
	search for).

-l      specifies a file containing a list of files to open

-t      start in the given macro context (package). TredMacro is the
        default context, and it is used also when the given context
        is not found.

-S      stylesheet file (overrides ~/.tred-stylesheets)

-s      start with the given pattern stylesheet.

-n      allows to specify the default charset for FS files (useful
        with perl >= 5.7)

-p      split window to given number of subwindows (horizontally if
        positive, vertically if negative) and open n'th file
        in n'th subwindow.


Other options:

-q              be quiet
-H              Start with showing hidden nodes
-G              Do not initially resize window to its last geomtery.
-W <window_id>  Embed main window into the given window
-Y              Don't load secondary files
-B <backends>   Comma separated list of additional backends to import

Options specific to CSTS backend:

-R              build tectogrammatic trees from CSTS files

-X <gov>,<ord>[,<hide>] - use attribute <gov> to build tree from CSTS
                files, <ord> to order nodes, <hide> to distinguish
                hidden nodes
EOF
  exit;
}

$no_secondary = $opt_Y;

if ($opt_v) {
  my $ver=$version;
  $ver=~s/\$//g;
  print "TrEd $ver\nPerl: $]\nPlatform: $^O\nTk: $Tk::VERSION\n\n";
  exit;
}


# in Windows, if HOME not defined, use user's AppData folder instaed
if ($^O eq "MSWin32" and !exists $ENV{HOME}) {
  require Win32::Registry;
  my %shf;
  my $ShellFolders;

  my $shfolders="Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders";
  $::HKEY_CURRENT_USER->Open($shfolders,$ShellFolders) or
    die "Cannot read $shfolders $^E\n";
  $ShellFolders->GetValues(\%shf);
  $ENV{HOME}= $shf{AppData}[2];
}

# Default values of $libDir used to search for macro-file (tred.mac)
# and default-macro file (tred.def) are specified here. They may be
# overriden by value of LibDir in tred resource file (tredrc or ~/.tredrc - see above).
# It is also used to find TrEd::Config.pm module.

use FindBin;
if (exists $ENV{TREDHOME}) {
  $libDir=$ENV{TREDHOME};
} elsif (-d "$FindBin::RealBin/tredlib") {
  $libDir="$FindBin::RealBin/tredlib";
} elsif (-d "$FindBin::RealBin/../lib/tredlib") {
  $libDir="$FindBin::RealBin/../lib/tredlib";
} elsif (-d "$FindBin::RealBin/../lib/tred") {
  $libDir="$FindBin::RealBin/../lib/tred";
}
print "Trying $libDir\n" if ($libDir and !$opt_q);

$macroFile=undef;

_set_encoding(\*STDERR,':utf8',"STDERR");
_set_encoding(\*STDOUT,':utf8',"STDOUT");

$stylesheetFile = $opt_S ne '' ? $opt_S : $ENV{HOME}."/.tred-stylesheets";

########## Config file #############
# this must be done before readconfig is first used
@filelists=();
@openfiles=();

# We *must* at least find TrEd::Config module to learn the correct libDir!!.
print "First I'm trying $libDir\n" unless $opt_q;
unshift @INC,$libDir if (-d $libDir);

do {
  my $ld=$libDir;
  require TrEd::Config;
  import TrEd::Config;
  import TrEd::Config qw(&read_config &apply_config &set_default_config_file_search_list);
  $libDir=$ld;
};

$TrEd::Config::treeViewOpts={
			     drawSentenceInfo => 0,
			     showHidden => 0,
			     customColors	 =>
			       {0 => 'darkgreen',
				1 => 'darkblue',
				2 => 'darkmagenta',
				3 => 'orange',
				4 => 'black',
				5 => 'DodgerBlue4',
				6 => 'red',
				7 => 'gold',
				8 => 'cyan',
				9 => 'midnightblue'}
			    };

if (defined $opt_c) {
  @TrEd::Config::config_file_search_list=($opt_c); # override any other possible config files
} else {
  set_default_config_file_search_list();
}
$TrEd::Config::set_user_config=\&setConfig;	# tred specific configuration

my $configFile=read_config();

$TrEd::Convert::inputenc=$opt_n if $opt_n;
$TrEd::Config::treeViewOpts->{showHidden} = 1 if $opt_H;

$iconPath = "$libDir/icons/default" unless (defined $iconPath);

$macroFile="$libDir/tred.mac" unless (defined $macroFile);

if (defined $opt_m) {
  $macroFile=$opt_m;
}
####################################

unless (-d $libDir) {
  print <<'EOL';
 TrEd couldn't find a tredlib directory. You may need to point
 to its location by the TREDHOME variable or add a correct LibDir
 field to your ~/.tredrc.

EOL
    die "Error: Couldn\'t find lib-directory.";
}


use Cwd;

use Tk::LabFrame;
use Tk::Listbox;
use Tk::HList;
use Tk::ItemStyle;
use Tk::DialogBox;
use Tk::Tiler;
use Tk::BrowseEntry;
use Tk::Pane;
use Tk::Dialog;
use Tk::Font;

unshift @INC,$libDir unless (grep($_ eq $libDir, @INC));

require Fslib;
import Fslib;
import Fslib qw(&Index $FSError);

$tredDebug=1 if $opt_D;
$TrEd::TreeView::Debug=1 if $opt_D;
$Fslib::Debug=1 if $opt_D;
$IOBackend::Debug=1 if $opt_D;

# import min and max functions
require TrEd::MinMax;
import TrEd::MinMax;

# import encode and decode functions
require TrEd::Convert;
import TrEd::Convert;

if ($TrEd::Convert::support_unicode) {
  require Tk::Entry;
  require Tk::Text;
#  require Tk::UCSKeyBind;
}

# import read_macros etc.
require TrEd::Macros;
import TrEd::Macros;

$TrEd::Macros::defines{TRED}=1;

# tree drawing module
require TrEd::TreeView;

# tree view windowing module
require TrEd::Window;

# tree printing module
require TrEd::Print;

# basic tree operations
require TrEd::Basics;
import TrEd::Basics;

$TrEd::Basics::on_tree_change= \&onTreeChange;
$TrEd::Basics::on_node_change= \&onNodeChange;
$TrEd::Basics::on_current_change= \&onCurrentChange;

#load back-ends
#require CSTS_SGML_SP_Backend;
@backends=('FSBackend',ImportBackends(split(/,/,$opt_B),split(/,/,$ioBackends),
				      qw/NTREDBackend PMLBackend CSTS_SGML_SP_Backend TrXMLBackend TEIXMLBackend StorableBackend AG2FS/
				     ));

require Filelist;

require Tk::MyFileSelect;
require Tk::ImgButton;
require Tk::BindMouseWheel;
require Tk::Balloon;
require Tk::JComboBox_0_02;


$stdout=\*STDOUT;
$stderr=\*STDERR;

sub STYLESHEET_FROM_FILE { "<From File>" };
sub NEW_STYLESHEET { "<New From Current>" };
sub DELETE_STYLESHEET { "<Delete Current>" };


use Exporter;
@ISA=qw(Exporter);

@EXPORT= qw($insideEval
            $libDir $stderr $stdout
            @openfiles @filelists &min &max);

%backend_map=(
	      fs => 'FSBackend',
	      csts => 'CSTS_SGML_SP_Backend',
	      pml => 'PMLBackend',
	      trxml => 'TrXMLBackend',
	      teixml => 'TEIXMLBackend',
	      ntred => 'NTREDBackend',
	      storable => 'StorableBackend'
	 );

@open_types=
  (["Supported",  [qw/.fs .csts .pls .t .a .pls.gz .fs.gz .t.gz .a.gz .csts.gz/]],
   ["FS files",           [qw/.fs .FS .Fs .fs.gz .FS.gz/]],
   ["CSTS files",           [qw/.cst .csts .cst.gz .csts.gz/]],
   ["Perl Storable files",  [qw/.pls .pls.gz/]],
   ["PDT-PML files",  [qw/.t .a .t.gz .a.gz .pml .pml.gz .xml .xml.gz/]],
   ["All files",        '*']
  );

%save_types=(
	     fs =>
	     [["FS files",           [qw/.fs .FS .Fs/]],
	      ["gzipped FS files",   [qw/.fs.gz .FS.gz .FS.GZ/]],
	      ["All files",        '*']
	     ],
	     pml =>
	     [["PML files",           [qw/.t .a .pml .xml/]],
	      ["gzipped PML files",   [qw/.t.gz .a.gz .pml.gz .xml.gz/]],
	      ["All files",        '*']
	     ],
	     csts =>
	     [["CSTS files",           [qw/.cst .csts/]],
	      ["gzipped CSTS files",   [qw/.cst.gz .csts.gz/]],
	      ["All files",        '*']
	     ],
	     trxml =>
	     [["TrXML files",          [qw/.trx .trxml .xml/]],
	      ["gzipped TrXML files",   [qw/.trx.gz .trxml.gz .xml.gz/]],
	      ["All files",        '*']
	     ],
	     teixml =>
	     [["TEIXML files",          [qw/.tei .xml/]],
	      ["gzipped TEIXML files",   [qw/.tei.gz .xml.gz/]],
	      ["All files",        '*']
	     ],
	     storable =>
	     [["Perl Storable files",          [qw/.pls .pls.gz/]],
	      ["All files",        '*']
	     ],
	     all =>
	     [["All files",        '*']
	     ],
	    );

ApplyGlobalConfig();

if ($]>=5.008) {
  eval {
    require I18N::Langinfo;
    $locale_charset = I18N::Langinfo::langinfo(I18N::Langinfo::CODESET());
  };
}

sub uniq { my %a; grep { !($a{$_}++) } @_ }

sub conv_from_locale {
  my ($str)=@_;
  if ($locale_charset and $TrEd::Convert::support_unicode) {
    require Encode;
    return Encode::decode($locale_charset,$str);
  } else {
    return $str;
  }
}

# it seems, that under Windoze setting LC_NUMERIC back to us does not
# work, so I recommend not to use czech locales there, unless you
# really want the decimal points to be replaced by commas in
# postscript:-)
use locale;
use POSIX qw(locale_h);

($TrEd::Config::useLocales) && do {
  $ENV{LC_ALL}=undef;
  setlocale(LC_ALL,undef);

  if ($TrEd::Convert::support_unicode) {
    my $lc_collate=setlocale(LC_COLLATE);
    if ($lc_collate !~ /\.utf-?8/i) {
      setlocale(LC_COLLATE,$lc_collate.".UTF-8");
    }
    my $lc_ctype=setlocale(LC_CTYPE);
    $lc_ctype=~s/\.utf-?8//i; # Tk doesn't support this
    setlocale(LC_CTYPE,$lc_ctype);
  }
  setlocale(LC_NUMERIC,"C");
};

($TrEd::Config::useCzechLocales or
 setlocale('LANG') =~ /^cs_CZ|^czech/) && do {
  $ENV{LC_ALL}=undef;
  setlocale(LC_ALL,undef);

  if ($TrEd::Convert::support_unicode) {
    setlocale(LC_COLLATE,"cs_CZ.UTF-8");
    setlocale('LANG',"cs_CZ.UTF-8");
    setlocale('LC_CTYPE',"cs_CZ");
  } else {
    setlocale(LC_COLLATE,"cs_CZ");
    setlocale('LANG',"cs_CZ");
  }
  setlocale(LC_NUMERIC,"C");
};

print STDERR "Creating filelists...\n" if $tredDebug;
{
  my $default= new Filelist('Default');
  $default->add(0,absolutize(@ARGV)) if @ARGV;
  addNewFilelist(undef,$default);
}

if ($opt_l) {
  # create Default filelists
  my @fl_files;
  foreach my $l (split /\s*,\s*/,$opt_l) {
    print STDERR "Reading -l filelist $l...\n" if $tredDebug;
    if (open(F,"<$l")) {
      my @f=<F>;
      shift @f if ($l=~/\.fl$/i and $f[0]!~m{[/.]} and ! -f absolutize($f[0]));
      s/\s+$// for @f;
      push @fl_files,\@f;
      close(F);
    } else {
      print STDERR "Warning: Can't open filelist $l: ".conv_from_locale($!)."\n";
    }
  }
  # define filelists CmdLine-1, CmdLine-2, etc.
  my $fl_no=-1;
  foreach (grep {@{$_}} @fl_files) {
    my $fl = new Filelist('CmdLine'.$fl_no);
    $fl->add(0, absolutize(@{shift @fl_files}));
    addNewFilelist(undef,$fl);
    $fl_no--;
  }
  print STDERR "Done...\n" if $tredDebug;
  # create Bookmarks filelist
  unless (bookmarkFilelist()) {
    print "Bookmarks: ".$ENV{HOME}.'/.tred_bookmarks'."\n" if $tredDebug;
    my $bookmarks= new Filelist('Bookmarks',$ENV{HOME}.'/.tred_bookmarks');
    addNewFilelist(undef,$bookmarks);
  }
}

$insideEval=0;

my %searchTemplate;

%pckey_shift_translates= (exclam=> 1, at=> 2, numbersign=> 3,
			   dollar=> 4, percent=> 5, asciicircum=> 6,
			   ampersand=> 7, asterisk=> 8, parenleft=> 9,
			   parenright=> 0, plus=> 'equal',
			   underscore=> 'minus',
			   less=> 'comma', greater=> 'period', 
			   question=> 'slash',
			   colon=> 'semicolon', quotedbl=> 'apostroph',
			   braceleft=> 'bracketleft', 
			   braceright=> 'bracketright',
			   bar=> 'backslash', asciitilde=> 'grave'
			  );

$opt_R && Csts2fs::setupTR();
if ($opt_X ne "") {
  Csts2fs::setupSpec(split ',',$opt_X);
  Fs2csts::setupSpec(split ',',$opt_X);
}

print STDERR "Reading macros from $macroFile...\n" unless $opt_q;
read_macros($macroFile,$libDir);		# read macros
if ($opt_I) {
  print STDERR ("Reading additional macros from $opt_I...\n") unless $opt_q;
  push @TrEd::Macros::macros,"\n","package TredMacro;\n";
  read_macros($opt_I,$libDir,1);
}

print STDERR "done.\n" unless $opt_q;

startMain();	# display first tree

print STDERR "TrEd ended.\n" unless $opt_q;

exit;

############################
############################
############################

sub icon {
  my ($grp, $name)=@_;
  unless (exists $grp->{icon}{$name}) {
    my @extensions=qw(gif xpm);
    eval { require Tk::PNG };
    if (not($@)) {
      unshift @extensions,'png';
    } else {
      warn "PNG icons not supported by running Tk\n" if $tredDebug;
    }
    # prepend $libDir to relative paths
    my $default=0;
    my $split = ($^O eq "MSWin32") ? ',' : ':';
    my @paths = (map {
      my $p =
      m{^\s*\Q${TrEd::Convert::Ds}\E} ? $_ : $libDir."/icons/".$_;
      $default = 1 if $p eq $libDir."/icons/default";
      $p;
    } split(/$split/o,$iconPath));
    # add default theme, unless already in the list
    push @paths, $libDir."/icons/default" unless $default;
    DIR: for my $dir (@paths) {
      for my $ext (@extensions) {
	my $file = "$dir/$name.$ext";
	if (-f $file) {
	  if ($ext eq 'xpm') {
	    #print "Loading pixmap icon $file\n" if $tredDebug;
	    $grp->{icon}{$name} = 
	      $grp->{top}->Pixmap(-file => $file);
	  } else {
	    require Tk::PNG if $ext eq 'png';
	    #print "Loading photo icon $file\n" if $tredDebug;
	    $grp->{icon}{$name} = 
	      $grp->{top}->Photo(-format => $ext, -file => $file);
	  }
	  last DIR;
	} else {
	  #print "Icon not found $file\n" if $tredDebug;
	}
      }
    }
  }
  print "No icon found for $name\n" if (not $grp->{icon}{$name} and $tredDebug);
  return $grp->{icon}{$name};
}

sub __debug {
  print STDERR @_,"\n" if $tredDebug;
}

sub get_open_filename {
  my $w = shift;
  my %opts=@_;
  if ($openFilenameCommand) {
    my $c = $openFilenameCommand;
    my $types = ref($opts{-filetypes}) ?
      join " ",map { "*".$_ } map { @{$_->[1]} } @{$opts{-filetypes}} : "*";
    my $title = $opts{-title} || 'Open';
    my $initialdir = $opts{-initialdir} || '.';
    $c=~s/\%t/"$title"/g;
    $c=~s/\%m/"$types"/g;
    $c=~s/\%d/"$initialdir"/g;
    my $ret = `$c`;
    s/\s+$// for $ret;
    return $ret;
  } else {
    $w->getOpenFile(%opts);
  }
}

sub get_save_filename {
  my $w = shift;
  my %opts=@_;
  if ($saveFilenameCommand) {
    my $c = $saveFilenameCommand;
    my $types = ref($opts{-filetypes}) ?
      join " ",map { "*".$_ } map { @{$_->[1]} } @{$opts{-filetypes}} : "*";
    my $title = $opts{-title} || 'Open';
    my $initialdir = $opts{-initialdir}.$TrEd::Convert::Ds || '';
    my $initialfile = $opts{-initialfile} || '';
    $c=~s/\%t/"$title"/g;
    $c=~s/\%m/"$types"/g;
    $c=~s/\%d/"$initialdir"/g;
    $c=~s/\%f/"$initialfile"/g;
    my $ret = `$c`;
    s/\s+$// for $ret;
    return $ret;
  } else {
    $w->getSaveFile(%opts);
  }
}

sub get_widget_descendants {
  my ($w)=@_;
  if (UNIVERSAL::isa($w,'Tk::Widget')) {
    return ($w,map { get_widget_descendants($_) } $w->children);
  } else {
    return ();
  }
}

sub get_all_widgets {
  my ($grp)=@_;
  get_widget_descendants($grp->{top});
}

sub get_entry_type {
  my $Entry = "Entry";
  my @Eopts;
  eval {
    require Tk::HistEntry;
    $Entry = "SimpleHistEntry";
    @Eopts = qw(-case 0 -match 1);
  };
  undef $@;
  return ($Entry,@Eopts);
}

sub set_grp_history {
  my ($grp,$e,$h,$list)=@_;
  if ($e->can('history')){
    push @$list,[$e,$h] if (ref($list));
    $grp->{"hist_$h"}=[] unless ref($grp->{"hist_$h"});
    $e->history($hist);
  }
}

sub get_grp_history {
  my ($grp,$e,$h)=@_;
  if ($e->can('historyAdd')) {
    $grp->{"hist_$h"}=[] unless ref($grp->{"hist_$h"});
    my $v = $e->get;
    $e->historyAdd($v) if $v ne "";
    @{$grp->{"hist_$h"}} = $e->history();
  }
}

sub get_grp_histories {
  my ($grp,$list)=@_;
  foreach my $E (@$list) {
    get_grp_history($grp,@$E);
  }
}

sub saveStyleSheets {
  my ($grp)=@_;
  open my $f, '>:utf8',$stylesheetFile || do {
    print STDERR "can't write to stylesheet file: $stylesheetFile\n" if $debug;
    return 0;
  };
  foreach my $stylesheet (keys (%{$grp->{stylesheets}})) {
    next if $stylesheet eq STYLESHEET_FROM_FILE();
    print $f "#"x 50,"\n";
    print $f "stylesheet: $stylesheet\n";
    for ($grp->{stylesheets}->{$stylesheet}) {
      if ($_->{context} =~ /\S/) {
	print $f map { "context: ".$_."\n" } split /\n/, $_->{context};
      }
      print $f map { local $_=$_; tr/\n/\013/; $_."\n" } 
	map { /^#/ ? 'node:'.$_ : $_ } @{$_->{patterns}};
      print $f map { "hint: ".$_."\n" } split /\n/, $_->{hint};
    }
    print $f "\n\n";
  }
  close $f;
}

sub readStyleSheets {
  my ($grp,$filename)=@_;
  $filename = $stylesheetFile unless defined $filename;
  open my $f, '<:utf8',$filename || do {
    print STDERR "no stylesheet file: $filename\n" if $debug;
    return 0;
  };
  my $stylesheet="Default";
  $grp->{stylesheets}={};
  while (<$f>) {
    s/\s+$//;
    next unless /\S/;
    next if /^#/;
    if (/^stylesheet:\s*(.*)/) {
      $stylesheet = $1;
    } elsif (s/^(hint|context):\s*//) {
      if ($grp->{stylesheets}->{$stylesheet}->{$1} ne "") {
	$grp->{stylesheets}->{$stylesheet}->{$1}.="\n".$_;
      } else {
	$grp->{stylesheets}->{$stylesheet}->{$1}.=$_;
      }
    } else {
      tr/\013/\n/;
      push @{$grp->{stylesheets}->{$stylesheet}->{patterns}},$_;
    }
    chomp $grp->{stylesheets}{$stylesheet}{$_} for qw(hint context);
  }
  close $f;
}

sub bookmarkFilelist {
  foreach (@filelists) {
    return $_ if ref and $_->name eq 'Bookmarks';
  }
  return undef;
}

sub setConfig {
  my $confs=shift;

  foreach (0..9) {
    $recentFiles[$_]=$confs->{"recentfile$_"};
  }
  @recentFiles=grep {$_} @recentFiles;

  require Filelist;
  my $fl;
  foreach (grep /^filelist[0-9]+/, keys %$confs) {
    print "Reading $_\n"  if $tredDebug;
    $fl=Filelist->new(undef,$confs->{$_});
    next unless $fl;
    $fl->load();
    print STDERR "Reading filelist ".$fl->name." from ".$fl->filename."\n" if $tredDebug;
    addNewFilelist(undef,$fl);
  }

#    $CSTSBackend::csts2fs=$cstsToFs;
#    $CSTSBackend::fs2csts=$fsToCsts;

  print STDERR "Applying configuration.\n" if $tredDebug;
}

sub ApplyGlobalConfig {
  my ($grp)=@_;

  my $bg = $treeViewOpts->{backgroundColor} || 'white';
  my $bgoff = $treeViewOpts->{backgroundColorNofocus} || $bg; #'#fbfbfb';
  @normal_win_opts = (qw/-relief flat -borderwidth 0 -highlightthickness 0 /,
		      -background => $bgoff);
  @focused_win_opts = (qw/-relief flat/,
		       -highlightthickness  => $highlightWindowWidth,
		       -highlightbackground => $highlightWindowColor,
		       -bg => $bg
		      );
  return unless $grp;

  delete $grp->{icon};
  foreach my $button (grep { UNIVERSAL::isa($_,'Tk::Button') } get_all_widgets($grp)) {
    my $icon = $button->cget('-image');
    if (defined $icon) {
      my $f = filename($icon->cget('-file'));
      $f=~s/\..*//;
      my $new = icon($grp,$f);
      Tk::catch {
	$button->configure(-image => $new) if $new;
      };
    }
  }

  Tk::catch {
    $grp->{valueLine}->configure(-height => $valueLineHeight,
				 ($valueLineReverseLines ? () :
				  (-wrap => $valueLineWrap))
				);
  };
  update_value_line($grp);
  update_status_line($grp->{focusedWindow});
  print STDERR $@ if $@;
  update_treeviews($grp);
  $grp->{top}->afterCancel($grp->{autoSaveCallback});
  $grp->{autoSaveCallback}=$grp->{top}->repeat($autoSave*60000, [\&autoSaveAll,$grp]) if $autoSave>0;
}

sub update_treeviews {
  my ($grp) = @_;
  foreach my $w (@{$grp->{treeWindows}}) {
    if ($w->{treeView}) {
      my $c = $w->{treeView}->canvas;
      if ($grp->{focusedWindow} == $w) {
	$c->configure(@focused_win_opts);
	$c->itemconfigure('stipple',-state=> 'hidden');
      } else {
	$c->configure(@normal_win_opts);
	$c->itemconfigure('stipple',-state=> $stippleInactiveWindows ? 'normal' : 'hidden');
      }
    }
  }
}

sub fileSchema {
  my ($fsfile)=@_;
  return $fsfile->metaData('schema');
}

sub lastFileNo {
  my ($win)=@_;
  return $win->{currentFilelist} ? $win->{currentFilelist}->file_count()-1 : -1;x
}

sub currentFileNo {
  my ($win)=@_;
  return $win->{currentFileNo};
}

sub cast_to_win {
  my ($gw)=@_;
  return UNIVERSAL::isa($gw,'TrEd::Window') ? $gw :
    (ref($gw) ? $gw->{focusedWindow} : undef);
}

sub cast_to_grp {
  my ($gw)=@_;
  return UNIVERSAL::isa($gw,'TrEd::Window') ? $gw->{framegroup} : $gw;
}

sub grp_win {
  my ($gw)=@_;
  return (cast_to_grp($gw),cast_to_win($gw));
}


# TrEd::Window ? should openFile in focusedWindow
sub gotoFile {
  my ($grp_or_win,$fn,$no_recent,$no_redraw)=@_;
  my ($grp,$win) = grp_win($grp_or_win);
  return unless $win->{currentFilelist};
  return 0 if doEvalHook($win,"goto_file_hook") eq 'stop';
  return 0 if ($fn>=$win->{currentFilelist}->file_count() or $fn<0);
  $win->{currentFileNo}=$fn;
  my $result = openFile($win,filelistFullFileName($win,$fn),
			-norecent => $no_recent, -noredraw => $no_redraw);
  if ($grp->{Filelist} and
	$grp->{filelistCurrentFilelist} eq $win->{currentFilelist}) {
    my $path=filelistEntryPath($win->{currentFilelist},$fn);
    $grp->{Filelist}->anchorSet($path);
    $grp->{Filelist}->selectionClear();
    $grp->{Filelist}->selectionSet($path);
  }
  return $result;
}

sub filelistFullFileName {
  my ($win, $fn)=@_;
  my $grp = cast_to_grp($win);
  return undef unless $win->{currentFilelist};
  my $filename=$win->{currentFilelist}->file_at($fn);

  return $filename if $filename =~ m(^[[:alnum:]]+:/) or $filename =~ m(^\s*\|);

  if ($filename!~/^\s*[\/~]/ and
      ($^O ne 'MSWin32' or $filename!~/^\s*([[:alpha:]]:)?\\/)) {
    # relative filename
    if (dirname($win->{currentFilelist}->filename()) ne "") {
      $filename=dirname($win->{currentFilelist}->filename()).$filename;
    }
  }
  return $filename;
}

sub nextOrPrevFile {
  my ($grp_or_win,$delta,$no_recent,$real)=@_;
  my ($grp,$win) = grp_win($grp_or_win);
  return 0 if ($delta==0);
  my $op=$grp->{noOpenFileError};
  $grp->{noOpenFileError}=1;
  my $filename;
  my $pos = $win->{currentFileNo}+$delta;
  if ($real and $win->{FSFile}) {
    my $prev_filename= $win->{FSFile}->filename;
    my $f = $filename = filelistFullFileName($win,$pos);
    ($prev_filename) = parse_suffix($prev_filename);
    ($f) = parse_suffix($f);
    while ($f eq $prev_filename) {
      $pos+=$delta;
      $f=$filename=filelistFullFileName($win,$pos);
      ($f) = parse_suffix($f);
    }
  } else {
    $filename=filelistFullFileName($win,$pos);
  }
  my $result=gotoFile($win,$pos,$no_recent);
  my $quiet=0;
  my $response;
  while (!(defined($result) and $result == 0) and $result != -1 and (!$win->{FSFile} or $win->{FSFile}->lastTreeNo<0)) {
    my $trees = $win->{FSFile} ? $win->{FSFile}->lastTreeNo+1 : 0;
    unless ($quiet) {
      my $f=filelistFullFileName($win,$pos);
      $response=
	errorDialog($win,
		    "Error: open failed",
		    "File is unreadable, empty, corrupted, or does not exist ($trees trees read)!"
		      ."\nPossible problem was:",
		    'Trying to load: '.$f."\n".
		    $grp->{lastOpenError},
		    -buttons => ["Try next","Skip to next correct file","Cancel"]
		   );
      last if ($response eq "Cancel");
      $quiet=1 if ($response eq "Skip to next correct file");
    }
    $pos+=$delta;
    $result=gotoFile($win,$pos,$no_recent);
  }
  $grp->{noOpenFileError}=$op;
  return $result;
}

sub nextRealFile {
  my ($grp_or_win,$no_recent)=@_;
  return nextOrPrevFile($grp_or_win,1,$no_recent,1);
}

sub prevRealFile {
  my ($grp_or_win,$no_recent)=@_;
  return nextOrPrevFile($grp_or_win,-1,$no_recent,1);
}

sub nextFile {
  my ($grp_or_win,$no_recent)=@_;
  return nextOrPrevFile($grp_or_win,1,$no_recent);
}

sub prevFile {
  my ($grp_or_win,$no_recent)=@_;
  return nextOrPrevFile($grp_or_win,-1,$no_recent);
}

sub tieNextFile {
  my ($grp,$win) = grp_win(shift);
  if ($grp->{tieWindows}) {
    foreach my $w (@{$grp->{treeWindows}}) {
      nextFile($w) if ($w->{FSFile});
    }
  } else {
    nextFile($win) if ($win->{FSFile});
  }
}

sub tiePrevFile {
  my ($grp,$win) = grp_win(shift);
  if ($grp->{tieWindows}) {
    foreach my $w (@{$grp->{treeWindows}}) {
      prevFile($w) if ($w->{FSFile});
    }
  } else {
    prevFile($win) if ($win->{FSFile});
  }
}


sub tieGotoFile {
  my ($grp,$win) = grp_win(shift);
  if ($grp->{tieWindows}) {
    foreach my $w (@{$grp->{treeWindows}}) {
      gotoFile($w,@_) if ($w->{FSFile});
    }
  } else {
    gotoFile($win,@_) if ($win->{FSFile});
  }
}


sub resumeFile {
  my ($win,$fsfile,$keep)=@_;
  $keep||=$win->{framegroup}->{keepopen};
  return unless ref($win) and ref($fsfile);
  print "Resuming file ".$fsfile->filename."\n"  if $tredDebug;

  closeFile($win,-keep_postponed => $keep);

  $win->{FSFile}=$fsfile;
  $win->{treeNo}=$fsfile->currentTreeNo;
  $win->{currentNode}=$fsfile->currentNode;
  saveFileStateUpdate($win);
}

sub fsfileDisplayingWindows {
  my ($grp,$fsfile)=@_;
  return 
    grep {
      $_->{FSFile} eq $fsfile 
    } @{$grp->{treeWindows}};
}

sub stylesheetUsingWindows {
  my ($grp,$stylesheet)=@_;
  return 
    grep {
      $_->{stylesheet} eq $stylesheet
    } @{$grp->{treeWindows}};
}


sub isFocused {
  my ($win)=@_;
  return $win eq $win->{framegroup}->{focusedWindow} ? 1 : 0;
}

sub initAppData {
  my ($fsfile)=@_;
  unless (ref($fsfile->appData('undostack'))) {
    $fsfile->changeAppData('undostack',[]);
    $fsfile->changeAppData('undo',-1);
    $fsfile->changeAppData('lockinfo',undef);
  }
  $fsfile->changeAppData('fs-part-of',[]) unless ref($fsfile->appData('fs-part-of'));
  $fsfile->changeAppData('ref',{}) unless ref($fsfile->appData('ref'));
}

sub setFSLockInfo {
  my ($fsfile,$lockinfo)=@_;
  $fsfile->changeAppData('lockinfo',$lockinfo);
}

sub _clear_err {
  undef $!; undef $@;
}

sub _last_err {
  my ($ret) = grep { $_ ne "" } ($_[0], $@, conv_from_locale($!));
  return $ret;
}

sub setLock {
  my ($f) = @_; # filename
  my $proto = IOBackend::get_protocol($f);
  $f=IOBackend::strip_protocol($f) if ($proto eq 'file');
  return undef if ($proto eq 'ntred' or $proto =~ /$noLockProto/);
  my $lock=eval { IOBackend::open_backend($f.".lock","w") };
  if ($@ or not ref($lock)) {
    warn "Error creating lock-file: "._last_err()."\n";
    return undef;
  };
  chmod 644, $lock if $proto eq 'file';
  my $mtime = [stat($f)]->[9];
  my $lockinfo = "by user ".$userlogin.'@'.$ENV{HOSTNAME}." pid ".$$." at ".localtime()." mtime: $mtime";
  $lock->print($lockinfo)."\n";
  IOBackend::close_backend($lock);
  return $lockinfo;
}

sub readLock {
  my ($f) = @_; # filename
  my $proto = IOBackend::get_protocol($f);
  if ($proto eq 'file') {
    $f=IOBackend::strip_protocol($f);
    return undef unless -f "$f.lock";
  }

  return undef if ($proto eq 'ntred' or $proto =~ /$noLockProto/);
  my $lockinfo;
  eval {
    print STDERR "reading lock $f.lock\n" if $tredDebug;
    my ($file,$remove_file) = IOBackend::fetch_file($f.".lock");
    open my $lock,"<",$file;
    $lockinfo = $lock->getline();
    $lock->close();
    unlink $file if $remove_file;
    $lockinfo =~ s/[\n\r]+$//;
  };
  print $@ if $@;
  print STDERR "Fetched lock $lockinfo\n" if $lockinfo and $tredDebug;
  return $lockinfo;
}

sub removeLock {
  my ($fsfile,$f,$force) = @_; # filename
  $f=$fsfile->filename() unless defined $f;
  my $proto = IOBackend::get_protocol($f);
  $f=IOBackend::strip_protocol($f) if ($proto eq 'file');
  return undef if ($proto eq 'ntred' or $proto =~ /$noLockProto/);
  if ($force or !$fsfile or checkLock($fsfile,$f) =~ /^my|^changed/) {
    print STDERR "removing lock $f.lock\n" if $tredDebug;
    IOBackend::unlink_uri($f.".lock");
  }
}

# check if a file has .lock
# returns: none (no lock), my (locked by us), locked
sub checkLock {
  my ($fsfile,$f) = @_; # filename
  $f = $fsfile->filename() if ($fsfile and not defined($f));
  my $current_mtime = [stat($f)]->[9];
#  return "none" if (not $f=~s{^file://}{} and $f =~ m{^[[:alnum:]]+://});
  my $lockinfo = readLock($f);
  if ($lockinfo ne "") {
    my ($user, $host, $pid) = $lockinfo =~ /^by user (.*?)@(.*?) pid (\d+)/;
    if ($fsfile and $fsfile->appData('lockinfo')) {
      my $ourlockinfo = $fsfile->appData('lockinfo');
      my ($mtime)= $ourlockinfo =~ / mtime: (\d+)$/;
      if ($ourlockinfo =~ /^locked (.*)/) {
	if ($1 ne $lockinfo) {
	  return "opened by us ignoring the lock $1, but later locked again ".$lockinfo;
	} elsif ($mtime != $current_mtime) {
	  my $l = $1;
	  $ourlockinfo =~ s/^locked //;
	  $ourlockinfo =~ s/ mtime: .*$//;
	  return "opened by us ignoring the lock $l and later changed by the lock owner";
	} else {
	  return "opened by us ignoring the lock $1, who still owns the lock, but has not saved the file since";
	}
      } elsif ($ourlockinfo ne $lockinfo) {
	if ($current_mtime != $mtime) {
	  return "stolen and changed ".$lockinfo." (previously locked $ourlockinfo)";
	} else {
	  return "stolen (but not yet changed) ".$lockinfo." (previously locked $ourlockinfo)";
	}
      } elsif ($mtime != $current_mtime) {
	return "changed by another program"
      } else {
	return "my"
      }
    } elsif ($pid == $$ and $user eq $userlogin and $host eq $ENV{HOSTNAME}) {
      return "my";
    } else {
      return "locked ".$lockinfo;
    }
  } elsif ($fsfile and $fsfile->appData('lockinfo')) {
    my $ourlockinfo = $fsfile->appData('lockinfo');
    my ($mtime)= $ourlockinfo =~ / mtime: (\d+)$/;
    if ($ourlockinfo =~ /^locked (.*)/) {
      if ($current_mtime != $mtime) {
	$ourlockinfo =~ s/^locked //;
	$ourlockinfo =~ s/ mtime: (.*)$//;
	return "opened by us ignoring a lock $1 who released the lock, but the file has changed since";
      } else {
	return "opened by us ignoring a lock $1, who released the lock without making any changes";
      }
    } else {
      if ($current_mtime != $mtime) {
	return "changed by another program and our lock was removed";
      } else {
	return "originally locked by us but the lock was stolen from us by an unknown thief. The file seems unchanged";
      }
    }
  } else {
    return "none";
  }
}

sub closeFile {
  my ($win,%opts)=@_;

  my $fsfile;
  if ($opts{-fsfile}) {
    $fsfile = $opts{-fsfile};
    __debug("Closing ",$opts{-fsfile}->filename,"\n");
  } else {
    $fsfile = $win->{FSFile};
    if ($fsfile) {
      doEvalHook($win,"file_close_hook");
      $fsfile->currentTreeNo($win->{treeNo});
      $fsfile->currentNode($win->{currentNode});
    }
  }
  if (!$opts{-keep_postponed} and
	$fsfile and ref($fsfile->appData('fs-part-of')) and
	@{$fsfile->appData('fs-part-of')}) {
    warn "Ignoring close to ".$fsfile->filename." - part of ".
      $fsfile->appData('fs-part-of')->[0]->filename."\n";
    return;
  }

  my @wins;
  if ($opts{-all_windows} and $fsfile) {
    @wins=fsfileDisplayingWindows($win->{framegroup},$fsfile);
  } elsif (!$opts{-fsfile}) {
    @wins=($win);
  }

  foreach my $w (@wins) {
    $w->{Nodes}=undef;
    #  undef $NodeClipboard;
    $w->{root}=undef;
    $w->{FSFile}=undef;
    $w->{treeNo}=undef;
    delete $w->{currentNode} if (exists $w->{currentNode});
    $w->{treeView}->clear_pinfo();
    set_value_line($w->{framegroup},"") if (isFocused($w));
  }
  if ($opts{-keep_postponed} and $fsfile) {
    print STDERR "Postponing ".$fsfile->filename()."\n"  if $tredDebug;
  } else {
    if ($fsfile and not fsfileDisplayingWindows($win->{framegroup},$fsfile)) {
      my $f = $fsfile->filename();
      print STDERR "Removing $f from list of open files\n"  if $tredDebug;
      @openfiles=grep { $_ ne $fsfile } @openfiles;
      my $autosave = autosave_filename($f);
      unlink $autosave if defined $autosave;
      removeLock($fsfile,$f);

      # remove dependency
      my $requires = $fsfile->metaData('fs-require');
      if ($requires) {
	foreach my $req (@$requires) {
	  my $req_fs = ref($fsfile->appData('ref')) ? $fsfile->appData('ref')->{$req->[0]} : undef;
	  if (ref($req_fs) eq 'FSFile') {
	    if (ref($req_fs->appData('fs-part-of'))) {
	      @{$req_fs->appData('fs-part-of')} = grep { $_ != $fsfile } @{$req_fs->appData('fs-part-of')};
	    }
	    unless (fsfileDisplayingWindows($win->{framegroup},$req_fs)) {
	      print STDERR "Attempting to close dependent ".$req_fs->filename."\n" if $tredDebug;
	      closeFile($win,  %opts, -fsfile => $req_fs,-keep_postponed => 0);
	    }
	  }
	}
      }
      undef $fsfile;
    }
  }
  unless ($opts{-no_update}) {
    updateTitle($win->{framegroup});
    updatePostponed($win->{framegroup});
    foreach my $w (@wins) {
      get_nodes_win($w);
      redraw_win($w);
    }
  }
}

sub plainErrorMessage {
  my ($grp,$msg)=@_;
  my $top;
  if (ref($grp)=~/^Tk::/) {
    $top = $grp->toplevel;
  } elsif ($grp->{top}) {
    $top = $grp->{top}->toplevel;
  } else {
    print STDERR "$msg\n";
    return;
  }
  $top->messageBox(-icon=> 'error',
		   -message=> $msg,
		   -title=> 'Error', -type=> 'ok');
}

# a simple dialog with one big text entry
sub textDialog {
  my ($grp_or_win,$dialog_opts,$label1_opts,$label2_opts,$text_opts,$msg,$bind)=@_;
  my ($grp,$win)=grp_win($grp_or_win);
  my $d= $grp->{top}->DialogBox( %$dialog_opts   );
  $d->Label( %$label1_opts )
    ->pack(-pady => 5,-side => 'top', -fill => 'x')  if defined $label1_opts;
  $d->Label( %$label2_opts )->pack(-pady => 10,-side => 'top', -fill => 'x')
    if defined $label2_opts;
  my $tags = delete $text_opts->{-tags};
  my $t=$d->Scrolled(
    (delete $text_opts->{-readonly} ? 'ROText' : 'Text'),
    qw/-relief sunken -borderwidth 2 -scrollbars oe/,%$text_opts);
  $t->Subwidget('scrolled')->menu->delete('File');
  $t->pack(qw/-side top -expand yes -fill both/);
  $t->BindMouseWheelVert();
  if ($bind) {
    my %b = ( dialog => $d, text => $t );
    foreach my $what (keys %b) {
      if (ref($bind->{$what})) {
	foreach (@{$bind->{$what}}) {
	  $b{$what}->bind(@$_);
	}
      }
    }
  }
  $t->insert('0.0',ref($msg) ? @$msg : $msg);
  $t->markUnset('insert');
  $t->markSet('insert','0.0');
  if (ref($tags)) {
    foreach my $tag (keys %$tags) {
      $t->tagConfigure($tag,@{$tags->{$tag}})
    }
  }
  $t->focus;
  $d->Show;
}

sub errorDialog {
  my ($grp_or_win,$title,$msg1,$msg2,%opts)=@_;
  my ($grp,$win)=grp_win($grp_or_win);
  my $d= $grp->{top}->DialogBox(-title=> $title,
				($opts->{-buttons} ? (-buttons=> ['OK']) : ()),
				%opts
			       );
  $d->Label(-text => "ERROR",
	    -justify => 'left',
	    -foreground => 'red'
	   )
    ->pack(-pady => 5,-side => 'top', -fill => 'x');
  $d->Label(-text => $msg1,
	    -justify => 'left'
	   )->pack(-pady => 10,-side => 'top', -fill => 'x');
  my $t= $d->
    Scrolled(qw/Text -relief sunken -borderwidth 2
		-scrollbars oe/);
  $t->Subwidget('scrolled')->menu->delete('File');
  $t->pack(qw/-side top -expand yes -fill both/);
#  disable_scrollbar_focus($t);
  $t->BindMouseWheelVert();
  $t->insert('0.0',$msg2);
  $d->Show;
}

sub dlgReturn {
  my ($w,$no_default)=@_;
  my $f=$w->focusCurrent;
  my $button;
  if ($f and $f->isa('Tk::Button')) {
    $button = $f;
  } elsif (!$no_default) {
    $button = $w->toplevel->{default_button};
  }
  if ($button) {
    $button->flash;
    $button->invoke;
  }
  Tk->break;
}

sub _descendant_widgets {
  return ($_[0],map {_descendant_widgets($_)} $_[0]->children);
}

sub _bind_buttons {
  my ($w,$top)=@_;
  $top||=$w->toplevel;
  foreach my $button (grep { ref($_) and $_->isa('Tk::Button') } _descendant_widgets($w)) {
    my $ul=$button->cget('-underline');
    if (defined($ul) and $ul>=0) {
      my $text=$button->cget('-text');
      my $key=lc(substr($text,$ul,1));
      $key=~s/^\.$/period/;
      $top->bind("<Alt-$key>", [sub { $_[1]->flash; $_[1]->invoke; },$button]);
    }
  }
}

sub userQuery {
  my ($win, $message, %opts) = @_;
  my $d = $win->toplevel->Dialog(
				 %opts
				);
  $d->add('Label', -text => $message,
	  -wraplength => 300)->pack();
  $d->bind('<Return>', \&dlgReturn);
  if (exists($opts{-buttons}) and 
      grep { $_ eq 'Cancel' } @{$opts{-buttons}}) {
    escapeButton($d,'Cancel',1);

  }
  $d->bind('all','<Tab>',[sub { shift->focusNext; }]);
  return $d->Show;
}


sub addToRecent {
  my ($grp,$f)=@_;
  if (defined($f)) {
    ($f)=absolutize($f);
    @recentFiles=grep { $_ ne $f } @recentFiles;
    unshift @recentFiles,$f;
  }
  @recentFiles=@recentFiles[0..min($#recentFiles,9)];

  if ($grp->{RecentFileMenu}) {
    my $menu= $grp->{RecentFileMenu}->cget(-menu);
    $menu->delete(0,'end');
    my $i=0;
    foreach my $rf (@recentFiles) {
      $grp->{RecentFileMenu}->command(-label => "$i.  $rf",
				      -underline=> 0,
				      -command=> [\&openStandaloneFile,$grp,$rf]);
      $i++;
    }
  }
}

sub getNodeNo {
  my ($win,$node)=@_;
  if ($node) {
    my $root;
    my $i=0;
    $root=$win->{FSFile}->treeList->[$win->{treeNo}];
    while ($root and $root ne $node) {
      $i++;
      $root=$root->following();
    }
    if ($root) {
      return $i;
    }
  }
}

sub bookmarkThis {
  my ($grp)=@_;
  my $f=undef;
  my $win=$grp->{focusedWindow};
  if (ref($win->{FSFile})) {
    $f=$win->{FSFile}->filename()."##".($win->{treeNo}+1);
    my $nodeno=getNodeNo($win,$win->{currentNode});
    if (defined($nodeno)) {
      $f.=".$nodeno";
    }
  }
  return $f;
}

sub addBookmark {
  my ($grp)=@_;
  my $bl=bookmarkFilelist();
  return unless ref($bl);
  my $f=bookmarkThis($grp);
  if (defined($f)) {
    insertToFilelist($grp,$bl,$bl->count,$f);
    updateBookmarks($grp);
  }
}

sub lastActionBookmark {
  my ($grp,$bmk)=@_;
  my $f=defined($bmk) ? $bmk : bookmarkThis($grp);
  if (defined($f)) {
    print STDERR "Bookmarking last action at: $f\n" if $tredDebug;
    $grp->{lastActionBookmark}=$f;
    updateBookmarks($grp);
  }
}

sub updateBookmarks {
  my ($grp)=@_;

  if ($grp->{BookmarksFileMenu}) {
    print STDERR "Updating bookmark menu\n"  if $tredDebug;
    my $menu= $grp->{BookmarksFileMenu}->menu;
    $menu->delete(0,'end');
    $grp->{BookmarksFileMenu}->command(-label=> 'Add to bookmarks',
				       -underline=> 0,
				       -command=> [ \&addBookmark,$grp ]);
    $grp->{BookmarksFileMenu}->separator();
    if (defined($grp->{lastActionBookmark})) {
      $grp->{BookmarksFileMenu}->command(-label => "Last action",
					 -underline=> 0,
					 -command=> [ \&openStandaloneFile,$grp,$grp->{lastActionBookmark} ]);
    }
    $grp->{BookmarksFileMenu}->separator();
    my $i=0;
    my $bl=bookmarkFilelist();
    return unless ref ($bl);
    foreach my $b (bookmarkFilelist->files()) {
      print STDERR "$b\n" if $tredDebug;
      $grp->{BookmarksFileMenu}->command(-label => "$i.  ".$b,
				      -underline=> 0,
				      -command=> [ \&openStandaloneFile,$grp,$b ]);
      $i++;
    }
  }
}

sub updatePostponed {
  my ($grp)=@_;
  if ($grp->{PostponedFileMenu}) {
    print STDERR "Updating session menu\n"  if $tredDebug;
    my $menu= $grp->{PostponedFileMenu}->menu;
    $menu->delete(0,'end');
    $grp->{PostponedFileMenu}->command(-label=> 'Options',
				       -state=> 'disabled',
				       -background=> '#444444'
				      );
    $grp->{PostponedFileMenu}->checkbutton(-label => 'Don\'t close file when opening a new one',
	  -variable=> \$grp->{keepfiles});
    $grp->{PostponedFileMenu}->checkbutton(-label => 'Add open files to default file-list',
	  -variable=> \$grp->{appenddefault});
    $grp->{PostponedFileMenu}->checkbutton(-label => 'Preserve patterns on reload',
	  -variable=> \$reloadKeepsPatterns);
    $grp->{PostponedFileMenu}->checkbutton(-label => 'Build TGTS from CSTS',
					   -variable=> \$grp->{buildTGTSfromCSTS},
					   -command => [sub {
							  my ($grp)=@_;
							  if ($grp->{buildTGTSfromCSTS}) {
							    Csts2fs::setupTR();
							  } else {
							    Csts2fs::setupAR();
							  }
							},$grp]
					  );

    $grp->{PostponedFileMenu}->command(-label=> 'Open files',
				       -state=> 'disabled',
				       -background=> '#444444'
				      );
    my $i=0;
    foreach my $of (@openfiles) {
      $grp->{PostponedFileMenu}->command(-label => "$i.  ".$of->filename(),
				      -underline=> 0,
				      -command=> [\&openStandaloneFile,$grp,
						  $of->filename(),-keep => 1]);
      $i++;
    }
    $grp->{PostponedFileMenu}->command(-label=> 'none',
				       -state=> 'disabled'
				      ) unless (@openfiles);
    $grp->{PostponedFileMenu}->command(-label=> 'File lists',
				       -state=> 'disabled',
				       -background=> '#444444'
				      );

    $i='A';
    foreach my $fl (sort {lc($a->name()) cmp lc($b->name())} @filelists) { 
      $grp->{PostponedFileMenu}->command(-label => "$i.  ".$fl->name(),
					 -underline=> 0,
					 -command=> [\&selectFilelist,$grp,$fl->name()]);
      $i++;
    }
  }
}

sub updateTitle {
  my ($grp)=@_;
  my $win = $grp->{focusedWindow};
  return unless ref($grp);
  if (defined($win->{currentFileNo}) and 
      ref($win->{FSFile})) {
    my $filelist_info='';
    if ($win->{currentFilelist}) {
      $filelist_info=$win->{currentFilelist}->name()."(".($win->{currentFileNo}+1)."/".
	$win->{currentFilelist}->file_count()."): ";
    }
    $grp->{top}->title("$appName    ".
		       $filelist_info.
		       $win->{FSFile}->filename()
		      );
  } else {
    $grp->{top}->title("$appName");
  }
}

sub newFileFromCurrent {
  my ($grp,$keep)=@_;
  $keep||=$grp->{keepopen};
  my $win=$grp->{focusedWindow};
  return unless $win->{FSFile};
  $win->toplevel->Busy(-recurse=> 1) unless $insideEval;
  my $cur=$win->{FSFile};
  my $new=$cur->clone(0);
  $new->changeFilename('unnamed'.sprintf('%03d',$NewFileNo++));
  $cur=undef;
  my $answer = askSaveFile($win,1,1);
  return 0 if $answer == -1;
  $keep=$keep || $answer;
  closeFile($win,-no_update => 1,-keep_postponed => $keep);
#  $new->new_tree(0);
  $win->{FSFile}=$new;
  push @openfiles, $win->{FSFile};
  updatePostponed($grp);

  # add file to filelist
  $win->{currentFileNo}= max(0,$win->{currentFileNo});
  updateTitle($grp);
  get_nodes_win($win);
  doEvalHook($win,"file_opened_hook");
  switchContext($win,$opt_t,1)
    if ($opt_t ne "" and
	$win->{macroContext} ne $opt_t);
  redraw_win($win);
  centerTo($win,$win->{currentNode});
  $win->toplevel->Unbusy() unless $insideEval;

#  addToRecent($grp,$new->filename);
  return 1;
}

sub parse_suffix {
  my ($filename)=@_;
  $filename=~s/(##?[0-9A-Z]+(?:-?\.[0-9]+)?)$//;
  return ($filename,$1);
}


# openStandaloneFile should be called whenever a file is opened via
# a non-filelist operation (such as nextFile, or gotoFile)

sub openStandaloneFile {
  my ($grp_or_win,$file) = @_;
  my ($grp,$win)=grp_win($grp_or_win);
  if ($grp->{appenddefault}) {
    my $ret = openFile(@_);
    if ($ret) {
      my $fl=selectFilelistNoUpdate($grp,'Default');
      print STDERR "$win->{currentFileNo}\n";
      $win->{currentFileNo}=insertToFilelist($win,$win->{currentFilelist},
					     $win->{currentFileNo},
					     $file.$goto);
    }
    updateTitle($grp);
    return $ret;
  } else {
    my $ret = openFile(@_);
    undef $win->{currentFilelist};
    $win->{currentFileNo} = -1;
    updateTitle($grp);
    return $ret;
  }
}


sub reloadFile {
  my $win=cast_to_win(shift);
  if (ref($win->{FSFile}) and $win->{FSFile}->filename()) {
    my $f=$win->{FSFile}->filename();
    my @patterns=$win->{FSFile}->patterns();
    my $hint=$win->{FSFile}->hint();
    ($f)=parse_suffix($f);
    my $no=$win->{treeNo}+1;
    my $nodeidx=0;
    do {			# $node is undefined after this block
      my $node=$win->{currentNode};
      while ($node) { $nodeidx++; $node=$node->previous() };
    };
    $nodeidx--;
    return if askSaveFile($win,0,1) == -1;
    closeFile($win,-all_windows => 1);
    openFile($win, "$f##$no.$nodeidx", -noredraw => 1, -nohook=>1);
    if ($win->{FSFile} and $reloadKeepsPatterns) {
      $win->{FSFile}->changePatterns(@patterns);
      $win->{FSFile}->changeHint($hint);
    }
    get_nodes_win($win);
    redraw_win($win);
    centerTo($win,$win->{currentNode});
  }
}

sub openFile {
  my ($grp_or_win,$fname,%opts)= @_;
  my ($grp,$win)=grp_win($grp_or_win);
  my $no_err = $grp->{noOpenFileError};

  undef $grp->{lastOpenError};

  my ($f,$goto) = parse_suffix($fname);
  print "Goto suffix is $goto\n" if defined($goto) and $tredDebug;

  $opts{-keep} ||= $grp->{keepfiles};

  $win->toplevel->Busy(-recurse=> 1) unless $insideEval;

  # File already open in current window? Simple!
  if ($win->{FSFile} and $win->{FSFile}->filename() eq $f) {
    unless ($opts{-preload}) {
      updateTitle($grp);
      applyFileSuffix($win,$goto);
      get_nodes_win($win, $opts{-noredraw});
      doEvalHook($win,"file_resumed_hook") unless $opts{-nohook};
      unless ($opts{-noredraw}) {
	redraw_win($win);
	centerTo($win,$win->{currentNode});
      }
      addToRecent($grp,$f) unless $opts{-norecent};
    }
    $win->toplevel->Unbusy() unless $insideEval;
    return $win->{FSFile};
  }

  # Shell we close current file?
  if ($opts{-preload} or !$opts{-keep}) {
    if (fsfileDisplayingWindows($grp,$win->{FSFile})<2) {
      my $answer = askSaveFile($win,1,1);
      if ($answer == -1) {
	$win->toplevel->Unbusy() unless $insideEval;
	return undef;
      }
      $opts{-keep} = $answer;
    }
  }
  closeFile($win,-no_update =>1 , -keep_postponed => $opts{-keep})
    unless $opts{-preload};

  # Search open files for requested file, resume if available
  unless ($opts{-justheader}) {
    foreach my $of ($win->{FSFile},@openfiles) {
      if (ref($of) and $of->filename() eq $f) {
	print "Opening postponed file\n" if $tredDebug;
	unless ($opts{-preload}) {
	  resumeFile($win,$of,$opts{-keep});
	  updateTitle($grp);
	  applyFileSuffix($win,$goto);
	  get_nodes_win($win, $opts{-noredraw});
	  doEvalHook($win,"file_resumed_hook") unless $opts{-nohook};
	  unless ($opts{-noredraw}) {
	    redraw_win($win);
	    centerTo($win,$win->{currentNode});
	  }
	  addToRecent($grp,$f) unless $opts{-norecent};
	}
	$win->toplevel->Unbusy() unless $insideEval;
	return $of;
      }
    }
  }

  # We're going to open a file: check locks
  my $lock = checkLock(undef,$f);
  print STDERR "LOCK: $lock\n" if $tredDebug;
  my $lockinfo;
  if ($lock  =~ /^locked/) {
    my $answer = userQuery($win,
			   "File $f is $lock.",
			   -bitmap=> 'question',
			   -title => "Accessing locked file?",
			   -buttons => ['Open anyway', 'Steal lock', 'Cancel']);
    if ($answer eq 'Cancel') {
      redraw_win($win) unless ($opts{-preload} or $opts{-noredraw});
      $win->toplevel->Unbusy() unless $insideEval;
      return undef;
    } elsif ($answer eq 'Steal lock') {
      $lockinfo=setLock($f)
    } else {
      $lockinfo = $lock;
      print STDERR "LOCKINFO: $lockinfo\n";
    }
  } elsif ($lockFiles) {
    $lockinfo=setLock($f);
  }

  # Check autosave file
  my $recover='No';
  my $autosave=autosave_filename($f);
  if (not $no_err and defined($autosave) and -r $autosave) {
    $recover=
      userQuery($win,
		"File seems to have an auto-saved recovery file from a previous session.\n".
		"Shell I try to use the recovery file?",
		-bitmap=> 'question',
		-title => "Recover file?",
		-buttons => ['Yes', 'No', 'No, delete recovery file']);
  }

  my $backends = doEvalHook($win,'get_backends_hook',@backends);
  my $fsfile;
  # Autosave file requested
  if ($recover eq 'Yes') {
    # Open recovery file
    _clear_err();
    $fsfile =
      FSFile->newFSFile($autosave,$TrEd::Convert::inputenc,(ref($backends) ? @$backends : @backends));
    initAppData($fsfile) if ref($fsfile);
    $grp->{lastOpenError}=_last_err();
    if (ref($fsfile) and $fsfile->lastTreeNo>=0 and $Fslib::FSError==0) {
      # Success
      $fsfile->changeFilename($f);
      $fsfile->notSaved(2);
      setFSLockInfo($fsfile, $lockinfo) if $lockFiles;
    } else {
      # Recovery failed
      my $trees=$fsfile ? $fsfile->lastTreeNo+1 : 0;
      my $answer =
	errorDialog($win,
		    "Error: recovery failed",
		    "Recovery file is corrupted ($trees trees read)!".
		    "\nPossible problem was:",
		    $grp->{lastOpenError},
		    -buttons => ['Open the original file', 'Ignore', 'Cancel']);
      if ($answer eq 'Open the original file') {
	closeFile($win,-no_update => 1) unless $opts{-preload};
	_clear_err();
	$fsfile=
	  FSFile->newFSFile($f,$TrEd::Convert::inputenc,(ref($backends) ? @$backends : @backends));
	initAppData($fsfile) if ref($fsfile);
	$grp->{lastOpenError}=_last_err();
	setFSLockInfo($fsfile, $lockinfo) if $lockFiles;
      } elsif ($answer eq 'Ignore') {
	redraw_win($win) unless ($opts{-preload} or $opts{-noredraw});
	$win->toplevel->Unbusy() unless $insideEval;
	return undef;
      }	else {
	closeFile($win,-no_update => 1) unless
	  $opts{-preload} or $fsfile->lastTreeNo>=0;
	$no_err=1;
      }
    }
  } else {
    if ($recover eq 'No, delete recovery file') {
      unlink $autosave;
    }
    # Open requeseted file
    _clear_err();
    $fsfile= FSFile->newFSFile($f,$TrEd::Convert::inputenc,(ref($backends) ? @$backends : @backends));
    initAppData($fsfile) if ref($fsfile);
    $grp->{lastOpenError}=_last_err();
    setFSLockInfo($fsfile, $lockinfo) if $lockFiles;
  }

  if ($fsfile and $fsfile->lastTreeNo>=0 and $Fslib::FSError==0) {
    $fsfile->changeFileFormat(($f=~/\.gz$/ ? "gz-compressed " : "").$fsfile->backend);


    unless ($no_secondary) {
    # if backend requested another FS-file, load it
    # and store it in appData('ref') hash table
    #
    # mark this secondary FS-file as part of the original file
    # so that they can be closed together
      my $requires = $fsfile->metaData('fs-require');
      if ($requires) {
	for my $req (@$requires) {
	  my $req_filename = absolutize_path($fsfile->filename,$req->[1]);
	  print STDERR "Pre-loading dependent $req_filename ($req->[1]) as appData('ref')->{$req->[0]}\n" if $tredDebug;
	  my $req_fs = openFile($win,$req_filename,-preload => 1);
	  if (!(ref($req_fs) and $req_fs->lastTreeNo>=0 and $Fslib::FSError==0)) {
	    undef $fsfile;
	    closeFile($win, -fsfile => $req_fs, -no_update => 1);
	    last;
	  } else {
	    push @{ $req_fs->appData('fs-part-of') }, $fsfile; # is this a good idea?
	    __debug("Setting appData('ref')->{$req->[0]} to $req_fs");
	    $fsfile->appData('ref')->{$req->[0]}=$req_fs;
	  }
	}
      }
    }
  }
  # don't make this an else for the above if: something might have changed in
  # the above block
  unless ($fsfile and $fsfile->lastTreeNo>=0 and $Fslib::FSError==0) {
    unless ($no_err) {
      my $trees=$fsfile ? $fsfile->lastTreeNo+1 : 0;
      errorDialog($win,
		  "Error: open failed",
		  "File '$f' is unreadable, empty, corrupted, or does not exist ($trees trees read)!".
		  "\nPossible problem was:",
		  $grp->{lastOpenError});

    }
    closeFile($win,-no_update => 1) unless $opts{-preload};
    removeLock(undef, $f) if $lockinfo and $lockinfo !~ /^locked/;
  }

  $win->{FSFile}=$fsfile unless $opts{-preload};
  $win->{treeNo}=0;
  if ($fsfile) {
    if ($opts{-justheader}) {
      $f=sprintf('%03d',$NewFileNo++)."_new_".filename($f);
      $fsfile->changeFilename($f);
      $fsfile->changeTrees();
#      $fsfile->new_tree(0);
      $fsfile->notSaved(1);
    }
    push @openfiles, $fsfile;
  }
  updatePostponed($grp);
  # add file to filelist
  updateTitle($grp) unless $opts{-preload};

  applyFileSuffix($win,$goto) unless $opts{-preload};
  doEvalHook($win,"file_opened_hook") if ($fsfile and !$opts{-nohook});
  unless ($opts{-preload}) {
    switchContext($win,$opt_t,1)
      if ($opt_t ne "" and
	    $win->{macroContext} ne $opt_t);
    get_nodes_win($win,$opts{-noredraw});
    unless ($opts{-noredraw}) {
      redraw_win($win);
      centerTo($win,$win->{currentNode});
    }
  }
  $win->toplevel->Unbusy() unless $insideEval;

  addToRecent($grp,$f);
  return $fsfile;
}

sub getNodeByNo {
  my ($win,$no)=@_;
  my $root=$win->{FSFile}->treeList->[$win->{treeNo}];
  my $i=$no;
  while ($root and $i>0) {
    $i--;
    $root=$root->following();
  }
  return $root;
}

sub applyFileSuffix {
  my ($win,$goto)= @_;
  return unless $win->{FSFile} and defined($goto) and $goto ne "";
  # -- smells like PDT-specific code, at least the second case
  # but we want it, dont we:)

  if ($goto=~/^##([0-9]+)/) {
    $win->{treeNo}=min(max(0,$1-1),$win->{FSFile}->lastTreeNo);
  } elsif ($goto=~/^#([0-9]+)/) {
    for (my $i=0;$i<=$win->{FSFile}->lastTreeNo;$i++) {
      $win->{treeNo}=$i,last if ($win->{FSFile}->treeList->[$i]->{form} eq "#$1");
    }
  }
  # new: we're the dot in .[0-9]+ (TM)
  if ($goto=~/\.([0-9]+)$/) {
    my $root=getNodeByNo($win,$1);
    if ($root) {
      $win->{currentNode}=$root;
      unless (isShown($win,$root)) {
	$win->{treeView}->set_showHidden(1);
      }

    }
  }
  # hey, caller, you should redraw after this!
}

sub autosave_filename {
  my ($f)=@_;
  my $base=filename($f);
  return undef unless ($f=~s/\Q${base}\E$/#$base#.#tred#/);
  return $f;
}

sub autoSaveAll {
  my ($grp)=@_;
  my $top=$grp->{top};
  my @files=grep { $_->notSaved == 1 } @openfiles;
  return unless @files;
  $top->title("Autosaving...");
  $top->Busy(-recurse=> 1) if (!$insideEval);
  foreach my $fsfile (@files) {
    my $f=autosave_filename($fsfile->filename);
    print STDERR "auto-saving recovery file ".$fsfile->filename." to '$f'\n" if $tredDebug;

    # this is not a kosher implementation but
    # there is no way to call a hook on fsfile
    # not owned by any windows, sigh!
    my ($win) = fsfileDisplayingWindows($grp,$fsfile);
    $win = $grp->{focusedWindow} unless $win;
    return if doEvalHook($win,"file_autosave_hook",$fsfile) eq 'stop';

    unless ($fsfile->writeFile($f)) {
      print STDERR "Error auto-saving file to '$f'\n(".conv_from_locale($!)."\n";
      next;
    }
    $fsfile->notSaved(2);
  }
  updateTitle($grp);
  $top->Unbusy() unless $insideEval;
}

sub saveFile {
  my ($win,$f)=@_;
  $win=cast_to_win($win);
  return unless $win->{FSFile};
  $f=$win->{FSFile}->filename unless defined($f);

  my $lock = checkLock($win->{FSFile},$f);
  if ($lock =~ /^locked|^stolen|^opened/) {
    if (userQuery($win,
		  "File $f was $lock!",
		  -bitmap=> 'question',
		  -title => "Saving locked file?",
		  -buttons => ['Steal lock and save','Cancel']) eq 'Cancel') {
      $win->toplevel->Unbusy() unless $insideEval;
      return -1;
    }
  } elsif ($lock =~ /^originally locked by us/) {
    if (userQuery($win,
		  "File $f has been $lock, so saving it now seems quite safe.",
		  -bitmap=> 'question',
		  -title => "Saving changed file?",
		  -buttons => ['Save','Cancel']) eq 'Cancel') {
      $win->toplevel->Unbusy() unless $insideEval;
      return -1;
    }
  } elsif ($lock =~ /^changed/) {
    if (userQuery($win,
		  "File $f has been $lock! Saving it now would overwrite those changes made by the other program.",
		  -bitmap=> 'question',
		  -title => "Saving changed file?",
		  -buttons => ['Save anyway','Cancel']) eq 'Cancel') {
      $win->toplevel->Unbusy() unless $insideEval;
      return -1;
    }
  }

  $win->toplevel->Busy(-recurse=> 1) unless $insideEval;

  my $refs_to_save={};
  if (!askSaveReferences($win,$win->{FSFile},$refs_to_save,$file) or
      doEvalHook($win,"file_save_hook",$f) eq 'stop') {
    updateTitle($win->{framegroup});
    $win->toplevel->Unbusy() unless $insideEval;
    return;
  }
  eval {
    IOBackend::rename_uri($f,$f."~") unless $f=~/^ntred:/
  };
  print STDERR $@;
  $win->{FSFile}->changeAppData('refs_save',$refs_to_save);
  my $result = $win->{FSFile}->writeFile($f);
  $win->{FSFile}->changeAppData('refs_save',undef);
  unless ($result) {
    $win->toplevel->Unbusy() unless $insideEval;
    errorMessage($win,"Error while saving file to '$f'!\nI'll try to recover the original from backup.\n".conv_from_locale($!)."\n"."Check file and directory permissions.\nSee also the console error output.",1);
    undef $!;
    eval {
      IOBackend::rename_uri($f."~",$f) unless $f=~/^ntred:/; # if (-f $f);
    };
    my $err = "Error while renaming backup file $f~ back to $f.\n"._last_err();
    errorMessage($win,$err,1) if $err;
    return -1;
  }
  setFSLockInfo($win->{FSFile}, setLock($f)) if $lockFiles;
  $win->toplevel->Unbusy() unless $insideEval;
  saveFileStateUpdate($win);
  my $autosave=autosave_filename($f);
  unlink $autosave if defined($autosave);
  return 1;
}

sub isShown { # test if node is shown (always 1 if $showHidden)
  my ($win,$node,$show)=@_;
  $show=$win->{treeView}->get_showHidden() unless defined $show;

  return 0 unless ($node and $win->{FSFile});
  return 1 if $show or not defined($win->{FSFile}->FS->hide());
  while ($node and ($node->getAttribute($win->{FSFile}->FS->hide()) eq 'hide')) {
    $node=$node->parent;
  }
  return ($node ? 0 : 1)
}

sub HNext { # same as Next but obey $showHidden
  my ($win,$node,$top)= @_;
  $node=Next($node,$top);
  while ($node) {
    return $node if (isShown($win,$node));
    $node=Next($node,$top);
  }
  return 0;
}

sub HPrev { # same as Next but obey $showHidden
  my ($win,$node,$top)= @_;
  $node=Prev($node,$top);
  while ($node) {
    return $node if (isShown($win,$node));
    $node=Prev($node,$top);
  }
  return 0;
}

sub NextDisplayed { # same as Next but obey $showHidden
  my ($win,$node,$top)= @_;
  $node=Next($node,$top);
  while ($node) {
    return $node if ($win->treeView->node_is_displayed($node));
    $node=Next($node,$top);
  }
  return 0;
}

sub PrevDisplayed { # same as Next but obey $showHidden
  my ($win,$node,$top)= @_;
  $node=Prev($node,$top);
  while ($node) {
    return $node if ($win->treeView->node_is_displayed($node));
    $node=Prev($node,$top);
  }
  return 0;
}

sub get_value_line {
  my ($win,$fsfile,$no,$no_numbers,$tags)=@_;
  my $vl;
  if ($fsfile) {
    $vl=doEvalHook($win,"get_value_line_hook",$fsfile,$no);
    if (defined($vl)) {
      if (ref($vl)) {
	unless ($tags) {
	  $vl = encode(join '',map { $_->[0] } @$vl);
	} else {
	  $vl=[ map { $_->[0]=encode($_->[0]); $_ } grep { $_->[0] ne "" } @$vl ];
	}
      } else {
	$vl=encode($vl);
      }
    } else {
      $vl=$win->{treeView}->value_line($fsfile,$no,$no_numbers,$tags,$win);
    }
  } else {
    $vl="";
  }
  return $vl;
}

sub reverseWrapLines {
  my ($widget,$font,$text,$width)=@_;
  use integer;
  my @toks;
  if (ref($text)) {
    @toks = @$text;
  } else {
    @toks = map { [$_,''] } split /\s+/, $text;
  }
  my @result;
  my $wd=0;
  my $w;
  my $t=pop(@toks);
  my @lines=();
  while ($t) {
    $w=$widget->fontMeasure($font," $t->[0]");
    if (($wd+$w>=$width) && (@result>0)) {
      push @lines, (@result,["\n",'space']);
      @result=($t);
      $wd=$widget->fontMeasure($font,$t->[0]);
    } else {
      $wd+=$w;
      unshift @result, $t;
    }
    $t=pop(@toks);
  }
  push @lines,@result;
  return \@lines;
}

sub set_value_line {
  my ($grp,$v)=@_;
  my $vl=$grp->{valueLine};
  $vl->configure(qw(-state normal));
  $vl->delete('0.0','end');
  if ($valueLineWrap eq 'word' and
      $valueLineReverseLines) {
    $vl->configure(qw(-wrap none));
    $v=reverseWrapLines($grp->{valueLine},$vLineFont,$v,
			$grp->{valueLine}->width()-15);
  }
  my @oldtags=grep {/^FSNode/} $vl->tagNames();
  if (@oldtags) {
    $vl->tagDelete(@oldtags);
  }
  if (ref($v)) {
    my %tags;
    @tags{ map { @$_[1..$#$_] } @$v }=();
    foreach my $tag (keys(%tags)) {
      if ($tag=~/^\s*-/) {
	eval {
	  $vl->tagConfigure(
			    $tag => (map { (/^\s*(-[[:alnum:]]+)\s*=>\s*(.*\S)\s*$/) }  split(/,/,$tag)));
	};
	print $@ if $@;
      }
    }
    $vl->Subwidget('scrolled')->insert('end','',undef,
				       map { ($_->[0], [@$_[1..$#$_]]) } @$v);
  } else {
    $vl->Subwidget('scrolled')->insert('0.0',$v);
  }
  $vl->tagAdd('all','0.0','end');
  $vl->tagConfigure('all',-justify => $valueLineAlign);
  $vl->configure(qw(-state disabled));
#   print "<dump>\n";
#   my @dump=$vl->dump('0.0','end');
#   while (@dump) {
#     my ($K,$V,$I) = (shift @dump, shift @dump, shift @dump);
#     if ($K eq 'tagon') { 
#       print "<tag value=\"$V\">";
#     } elsif ($K eq 'tagoff') {
#       print "</tag>";
#     } else {
#       print $V;
#     }
#   }
#   print "\n</dump>\n";
  return $v;
}

sub update_status_line {
  my ($win)=@_;
  return unless $win;
  return unless $displayStatusLine;
  my $l=doEvalHook($win,"get_status_line_hook");
  set_status_line($win->{framegroup},$l);
}

sub set_status_line {
  my ($grp,$text)=@_;
  my $sl=$grp->{statusLine};
  return unless $sl;
  $sl->configure(qw(-state normal));
  $sl->delete('0.0','end');
  my @oldtags=$sl->tagNames();
  if (@oldtags) {
    $sl->tagDelete(@oldtags);
  }
  $sl->insert('end',encode($grp->{statusLineText}),undef)
    unless ($grp->{statusLineText} eq "");
  $sl->insert('end'," | ",undef) if ($text);

  if (ref($text)) {
    my ($fields,$styles)=@$text;
    my $i=0;
    $sl->insert('end',map { $i=!$i; $i ? encode($_) : $_ } @$fields);
    while (@$styles) {
      my $style=shift @$styles;
      my $opts=shift @$styles;
      $sl->tagConfigure($style, @$opts);
    }
  } else {
    $sl->insert('0.0',encode($text));
  }
#  $sl->tagAdd('all','0.0','end');
#  $sl->tagConfigure('all');
  $sl->configure(qw(-state disabled));
  return $text;
}

sub update_tree_pos {
  my ($grp)=@_;
  my $win=$grp->{focusedWindow}; # only focused window uses the value line
  if ($win->{FSFile}) {
    $grp->{vLineNumLabel}->configure(-text => ($win->{treeNo}+1)."/".($win->{FSFile}->lastTreeNo+1));
  } else {
    $grp->{vLineNumLabel}->configure(-text => "-/-");
  }
#  $grp->{vLineNumLabel}->update();
}

sub update_value_line {
  my ($grp)=@_;
  my $win=$grp->{focusedWindow}; # only focused window uses the value line
  update_tree_pos($grp);
  return set_value_line($grp,get_value_line($win,$win->{FSFile},
					    $win->{treeNo},1,1));
}

### Get Nodes

sub get_nodes_win {
  my ($win,$noredraw)=@_;
  if ($win->{FSFile}) {
    $win->{treeNo}=0 if ($win->{treeNo}<0 and $win->{FSFile}->lastTreeNo>=0);
    $win->{root}=$win->{FSFile}->treeList->[$win->{treeNo}];
    print "get_nodelist_hook\n" if $tredDebug;
    my $l=doEvalHook($win,"get_nodelist_hook",
		     $win->{FSFile},
		     $win->{treeNo},
		     $win->{currentNode},
		     $win->{treeView}->get_showHidden());
    if (ref($l) eq 'ARRAY' and @$l==2) {
      print "using hook's list\n" if $tredDebug;
      ($win->{Nodes},$win->{currentNode})=@$l;
    } else {
      print "using default get_node_list\n" if $tredDebug;
      ($win->{Nodes},$win->{currentNode})= $win->{treeView}->nodes($win->{FSFile},
								   $win->{treeNo},
								   $win->{currentNode});
    }
  } else {
    print "no nodes to get\n" if $tredDebug;
    $win->{root}=undef;
    $win->{Nodes}=[];
    $win->{currentNode}=undef;
  }
  update_value_line($win->{framegroup}) if (isFocused($win) and !$noredraw);
}

sub get_nodes_fsfile {
  my ($grp,$fsfile)=@_;
  return if $insideEval;
  foreach my $w (fsfileDisplayingWindows($grp,$fsfile)) {
    get_nodes_win($w);
  }
  return;
}

sub get_nodes_fsfile_tree {
  my ($grp,$fsfile,$tree_no)=@_;
  return if $insideEval;
  foreach my $w (grep {$_->{treeNo} == $tree_no}
	   fsfileDisplayingWindows($grp,$fsfile)) {
    get_nodes_win($w);
  }
  return;
}

sub get_nodes_all {
  my ($grp)=@_;
  foreach my $w (@{ $grp->{treeWindows} }) {
    get_nodes_win($w);
  }
  return;
}

############################################################
############################################################
############################################################
# Filelists
############################################################

sub selectFilelistNoUpdate {
  my ($grp_or_win,$list_name)=@_;
  my ($grp,$win)=grp_win($grp_or_win);
  my $fl=switchFilelist($grp,$list_name);
  print "Switching filelist to $list_name\n" if $tredDebug;
  return unless defined($fl);
  if ($fl ne $win->{currentFilelist}) {
    # save file position in the current file-list
    # before switching
    $win->{currentFilelist}->set_current(filelistFullFileName($win,$win->{currentFileNo}))
      if ref($win->{currentFilelist});
    $win->{currentFilelist}=$fl;
  }
  $win->{currentFileNo}=max(0,$fl->position());
  return $fl;
}

sub selectFilelist {
  my ($grp_or_win,$list_name)=@_;
  my ($grp,$win)=grp_win($grp_or_win);
  my $fl = selectFilelistNoUpdate(@_);
  if ($win->{currentFileNo}>=$fl->file_count()) {
    closeFile($win);
  } else {
    $win->{currentFileNo}--;
    nextFile($win);
  }
  updateTitle($grp);
}

# Find named filelist. Return undef if no such filelist exists
sub findFilelist {
  my ($name)=@_;
  for (@filelists) {
    return $_ if ($_->name eq $name);
  }
  return undef;
}

sub looseFilePositionInFilelist {
  my ($filelist,$fsfile) = @_;
  return undef unless ref($filelist);
  my $fname = ref($fsfile) ? $fsfile->filename() : $fsfile;
  my $pos = $filelist->position($fsfile);
  return $pos if $pos >= 0;

  ($fname)=parse_suffix($fname);
  my $files=$filelist->files_ref;
  my $basedir=$filelist->dirname();
  my $relfname=$fname;
  if (index($fname,$basedir)==0) {
    $relfname=substr($fname,length($basedir));
  }
  for (my $i=0; $i < $filelist->file_count; $i++) {
    my ($fn) = parse_suffix($files->[$i]->[0]);
    return $i if ($fname eq $fn or $relfname eq $fn);
  }
  return -1;
}



# this is only a local switch inside the file list dialog window,
# but returns filelist of a given name as a by-product
sub switchFilelist {
  my ($grp,$list_name)=@_;
  return undef unless ref($grp);
  my $fl=undef;
  if (ref($list_name)) {
    $fl=$list_name;
    $list_name=$fl->name();
  }
  return $grp->{filelistCurrentFilelist} 
    if (ref($grp->{filelistCurrentFilelist}) and 
	$list_name eq $grp->{filelistCurrentFilelist}->name);
  $fl=findFilelist($list_name) unless ($fl);
  return undef unless $fl;
  if ($grp->{Filelist}) {
    $grp->{filelistCurrentFilelist}=$fl;
    $fl->expand();
    feedHListWithFilelist($grp,$grp->{Filelist},$fl);
    my $activate=0;
    if (defined($fl->current)) {
      $activate=max(0,$fl->position);
    }
    my $path=filelistEntryPath($fl,$activate);
    $grp->{Filelist}->selectionClear();
    if (defined($path) and $path ne "") {
      $grp->{Filelist}->anchorSet($path);
      $grp->{Filelist}->see($path);
      $grp->{Filelist}->selectionSet($path);
    }
    $grp->{Filelist}->update();
  }
  return $fl;
}


sub createFilelistBrowseEntry {
  my ($grp,$w,$filelistref)=@_;
  my $ll= $w->BrowseEntry
    (
     -label=> 'File lists:',
     -variable=> $filelistref,
     -browsecmd=>
     [
      sub {
	my ($grp,$list,$l)=@_;
	switchFilelist($grp,$$list);
      },$grp,$filelistref
     ],
     -listcmd=>
     [ sub {
	 my $l=shift;
	 $l->delete(0,'end');
	 foreach (@filelists) {
	   $l->insert(0,$_->name);
	 }
       }]
    );
  $ll->Subwidget('entry')->bind
    ('<Return>',
     [ sub {
	 my ($w, $grp, $fl)=@_;
	 my $text=$w->get;
	 if (findFilelist($text)) {
	   switchFilelist($grp,$text);
	 } else {
	   return unless $text ne "";
	   my $d=$w->toplevel->
	     Dialog(-text=> "File-list named $text does not exist.\n".
		    "Do you want to create new filelist or rename current?",
		    -bitmap=> 'question',
		    -title=> 'Create/Rename?',
		    -buttons=> ['Create', 'Rename', 'Cancel']);
	   $d->bind('<Return>', \&dlgReturn);
	   my $answer=$d->Show();
	   if ($answer eq 'Create') {
	     addFilelist(Filelist->new($text));
	     switchFilelist($grp,$text);
	     updatePostponed($grp);
	   } elsif ($answer eq 'Rename') {
	     my $oldn=$grp->{filelistCurrentFilelist}->name();
	     $grp->{filelistCurrentFilelist}->rename($text);
	     updateBookmarks($grp)
	       if ($oldn eq 'Bookmarks');
	     $$fl=$text;
	     updatePostponed($grp);
	   } else {
	     $$fl=$grp->{filelistCurrentFilelist}->name
	       if ($grp->{filelistCurrentFilelist});
	   }
	 }
       },$grp,$filelistref ]);
  $ll->Subwidget('entry')->Subwidget('entry')->configure(qw/-background white -foreground black/);
  $ll->Subwidget('slistbox')->configure(qw/-background white -foreground black/);
  return $ll;
}

sub addFilelist {
  my ($fl)=@_;
  push @filelists, $fl;
  print "adding filelist ".$fl->name()."\n";
  return $fl;
}

sub getFilelistLinePosition {
  my ($fl,$line)=@_;
  return undef unless ref($fl);
  my ($p,$f)=split /\t/,$line;
  return Index($fl->list_ref,$p);
}

sub insertToFilelist {
  my ($grp_or_win,$filelist,$position)=(shift,shift,shift);
  my ($grp,$win)=grp_win($grp_or_win);
  $filelist=$win->{currentFilelist} unless defined($filelist);
  $position=$win->{currentFileNo} unless defined($position);
  return -1 unless ref($filelist);


  print "Insert: ",$#_," ",$_[0]," is at position ",$filelist->position($_[0]),"\n"  if $tredDebug;
  return -1 if ($#_==0 and $filelist->position($_[0])>=0);
  # this is the case when we add a file which is actually already there

  my @list=map absolutize($_),@_;
  my $tmp;
  my $toplevel= $grp->{Filelist} ? $grp->{Filelist}->toplevel : $grp->{top};
  @list= map {
    if (-d $_) {
      $grp->{'hist-fileListPattern'}=[] unless $grp->{'hist-fileListPattern'};
      $tmp=Query($toplevel,"Selection Pattern","Insert pattern for directory $_","*.*",1,$grp->{'hist-fileListPattern'});
      use File::Spec;
      $_= defined($tmp) ? File::Spec->catfile($_,$tmp) : undef;
    }
    $_;
  } @list;
  print "Inserting @list\n" if $tredDebug;
  $filelist->add($position+1,@list);

  if ($grp->{Filelist} and 
      $grp->{filelistCurrentFilelist} eq $filelist) {
    feedHListWithFilelist($grp,$grp->{Filelist},$filelist);
      $position=max(0,$filelist->position($_[0]));
    my $path=filelistEntryPath($filelist,$position);

    $grp->{Filelist}->selectionClear();
    if ($grp->{Filelist}->info('exists',$path)) {
      $grp->{Filelist}->anchorSet($path);
      $grp->{Filelist}->selectionSet($path);
      $grp->{Filelist}->see($path);
    }
    # select all files resulting from added patterns
    for (my $i=0 ; $i<$filelist->file_count ; $i++) {
      if (defined(Index(\@_,$filelist->file_pattern($i)))) {
	$grp->{Filelist}->selectionSet(filelistEntryPath($filelist,$i));
      }
    }
  }
  return $position+1;
}

sub removeFromFilelist {
  my ($grp_or_win,$filelist,$position)=(shift,shift,shift);
  my ($grp,$win)=grp_win($grp_or_win);
  $filelist=$win->{currentFilelist} if not defined($filelist);
  $position=$win->{currentFileNo} if not defined($position);
  return unless ref($filelist);

  $filelist->remove(@_);
  if ($filelist eq $win->{currentFilelist}) {
    $win->{currentFileNo}= min($win->{currentFileNo},
			       $filelist->file_count-1);
  }

  if ($grp->{Filelist} and 
      $grp->{filelistCurrentFilelist} eq $filelist) {
    $position=min($position,$filelist->file_count-1);
    feedHListWithFilelist($grp,$grp->{Filelist},$filelist);
      $grp->{Filelist}->selectionClear();
    my $path;
    $path=$grp->{filelistCurrentFilelist}->list_ref->[$position];
    if ($grp->{Filelist}->info('exists',$path)) {
      $grp->{Filelist}->anchorSet($path);
      $grp->{Filelist}->selectionSet($path);
      $grp->{Filelist}->see($grp->{Filelist}->info('anchor'));
    }
  }
}

sub addNewFilelist {
  my ($grp,$fl)=@_;
  return if not defined($fl) or $fl eq "";
  for my $l (@filelists) {
    if ($l->name eq $fl->name) {
      print STDERR "Filelist ",$fl->name," already exists, replacing!\n"
	if $tredDebug;
      @{ $l->list_ref }= $fl->list;
      $l->expand;
      if ($grp) {
	$grp->{filelistCurrentFilelist}=undef;
	switchFilelist($grp,$l);
      }
      undef $fl;
      return;
    }
  }
  if (not defined($fl->name) or $fl->name eq "") {
    undef $fl;
    return;
  }
  push @filelists, $fl;
  if ($grp) {
    switchFilelist($grp,$fl);
    updatePostponed($grp);
  }
}

sub deleteFilelist {
  my ($grp,$fl)=@_;
  return unless ref($fl);
  print "Deleting filelist $fl,".$fl->name()."\n" if $tredDebug;
  return if ($fl->name eq 'Default' or
	     $fl->name eq 'Bookmarks');
  print "Allowed\n" if $tredDebug;
  @filelists=grep($_ ne $fl, @filelists);
  print join "\n","Filelists:",@filelists,"" if $tredDebug;
  print scalar(@filelists),"\n" if $tredDebug;
  $grp->{filelistCurrentFilelist}=undef;
  undef $fl;
  switchFilelist($grp,'Default');
  updatePostponed($grp);
}

sub filelistEntryPath {
  my ($fl,$index)= @_;
  return undef unless ref($fl);

  my $f= $fl->file_at($index);
  my $p= $fl->file_pattern($index);
  return $f eq $p ? $f : "$p\t$f";
}

sub feedHListWithFilelist {
  my ($grp,$hl,$fl)=@_;
  return unless ref($hl) and ref($fl);
  $hl->delete('all');
  my $pat;
  my $f;
  for(my $i=0;$i<$fl->file_count;$i++) {
    $pat=$fl->file_pattern($i);
    $f=$fl->file_at($i);
    next unless defined($pat) and defined($f);
    if ($pat eq $f) {
      $hl->add($f,
	       -itemtype=> 'imagetext',
	       -image=> $grp->{fileImage},
	       -data=> $f,
	       -text=> $f);
      next;
    }
    unless ( $hl->info('exists', $pat) ) {
      $hl->add("$pat",
	       -itemtype=> 'imagetext',
	       -image=> $grp->{folderImage},
	       -data=> $pat,
	       -text=> $pat);
    }
    $hl->add("$pat\t$f",
	     -itemtype=> 'imagetext',
	     -image=> $grp->{fileImage},
	     -data=> $f,
	     -text=> $f);
  }
}

sub filelistDialog {

  use Tk::LabFrame;
  my ($grp,$modal)=@_;
  my $win = $grp->{focusedWindow};
  if (defined($grp->{Filelist})) {
    if ($modal) {
      ShowDialog($grp->{Filelist}->toplevel);
    } else {
      $grp->{Filelist}->toplevel->deiconify;
      $grp->{Filelist}->toplevel->focus;
      $grp->{Filelist}->toplevel->raise;
    }
    return;
  }
  return if ($grp->{Filelist});

  $grp->{top}->Busy(-recurse=>1);
  my $filelist;
  if (!ref($win->{currentFilelist})) {
    if ($win->{FSFile}) {
      errorMessage($win,"Can't manage file-lists while visiting a file not belonging to any file-list! ".
		   "Please, switch to a file-list (e.g. using Session->Default) and try again.",1);
      return;
    } else {
      selectFilelist($grp,'Default');
    }
  }
  $grp->{filelistCurrentFilelist}=$win->{currentFilelist};
  $filelist=$grp->{filelistCurrentFilelist}->name;
  my $d= $grp->{top}->Toplevel(-title=> "Filelist");
  $d->withdraw;
  $grp->{filelistDialog}=$d;

  my $botframe=$d->Frame()->pack(qw/-fill both -side bottom/);
  my $topframe=$d->Frame()->pack(qw/-fill both -side top -expand 1/);

  my $labframe=$topframe->LabFrame(-label=> 'Files to add',
				-labelside=> 'acrosstop'
			       )->pack(qw/-expand yes -fill both -side left/);
  $labframe->Subwidget('label')->configure(-underline => 0);
  my $fl= $labframe->MyFileSelect(-selectmode=> 'extended',
				  -takefocus => 1,
				  -filetypes=> \@open_types)
    ->pack(qw/-expand yes -fill both -side left -padx 5 -pady 5/);
  $fl->Subwidget('filelist')->configure(-background => 'white', -setgrid => 1);
  $d->bind("<Alt-f>",[$fl->Subwidget('filelist')->Subwidget('scrolled'),'focus']);

  my $leftframe=$topframe->Frame();
  my $midframe=$topframe->Frame();

  my $rightframe=$topframe->Frame();

  my $ll= createFilelistBrowseEntry($grp,$rightframe,\$filelist);
  $ll->pack(qw/-expand no -fill x -side top/);

  # Bloody hell, how do I underline BrowseEntry labels?
  foreach (grep { ref($_) and $_->isa('Tk::Label') } _descendant_widgets($ll)) {
    $_->configure( -underline => 1 );
  }
  $d->bind("<Alt-i>",[$ll->Subwidget('entry'),'focus']);
  $grp->{Balloon}->attach($ll,-balloonmsg=>
			  "Select a file-list to display.\nTo rename the selected file-list, type in a new name and press Enter.");

  my $t= $rightframe->Scrolled(qw/HList -relief sunken
				  -selectmode extended
				  -width 60
				  -height 15 -scrollbars oe/,
			       -separator=> "\t"
			      )
    ->pack(qw/-expand yes -fill both -side top/);
  disable_scrollbar_focus($t);
  $t->BindMouseWheelVert();
  $grp->{Filelist}=$t;
  feedHListWithFilelist($grp,$t,$grp->{focusedWindow}->{currentFilelist});

  my @pad = qw(-padleft 7 -padright 7 -padmiddle 5 );
  my @b_pack = qw(-padx 0.1c -pady 0.2c -side right);
  $midframe->ImgButton(-text=> 'Add',
		       -image => icon($grp,"1rightarrow"),
		       @pad,
		       -underline=> 0,
		       -balloon => $grp->{Balloon},
		       -balloonmsg=> "Add files selected on the left\nto the file-list on the right.",
		       -command=>[
				  sub {
				    my ($grp,$t,$l)=@_;
				    insertToFilelist($grp,
						     $grp->{filelistCurrentFilelist},
						     getFilelistLinePosition($grp->{filelistCurrentFilelist},
									     $t->info('anchor')),
						     $l->getSelectedFiles
						    );
				    updateBookmarks($grp)
				      if (ref($grp->{filelistCurrentFilelist}) and
					  $grp->{filelistCurrentFilelist}->name eq 'Bookmarks');
				  },$grp,$t,$fl])->pack(qw/-fill x -expand yes -pady 0.2c -side top/);

  $midframe->ImgButton(-text=> 'Remove',
		       -image => icon($grp,"1leftarrow"),
		       @pad,
		       -underline=> 0,
		       -balloon => $grp->{Balloon},
		       -balloonmsg=> "Remove selected files on the right from the file-list.",
		       -underline=> 4,
		       -command=>[
			       sub { 
				 my ($grp,$t)=@_;
				 removeFromFilelist($grp,
						    $grp->{filelistCurrentFilelist},
						    getFilelistLinePosition($grp->{filelistCurrentFilelist},
									    $t->info('anchor')),
						    $t->info('selection'));
				 updateBookmarks($grp)
				   if (ref($grp->{filelistCurrentFilelist}) and
				       $grp->{filelistCurrentFilelist}->name eq 'Bookmarks');
			       },$grp,$t])->pack(qw/-fill x -expand yes -pady 0.2c -side top/);

  unless ($modal) {
    $midframe->ImgButton(-text=> 'Show in TrEd',
			 -image => icon($grp,"button_ok"),
		      -balloon => $grp->{Balloon},
		      -balloonmsg=> "Open the file-list on the selected position.",
		      @pad,
		      -underline=> 0,
		      -command=> [ sub {
				     my ($grp)=@_;
				     $grp->{filelistCurrentFilelist}->
				       set_current($grp->{Filelist}->
						   info('data',$grp->{Filelist}->info('anchor')));
				     selectFilelist($grp,$grp->{filelistCurrentFilelist});
				   },$grp ])->pack(qw/-fill x -expand yes -pady 0.2c -side top/);
    $t->bind('<Return>'=> [
			    sub {
			      my ($w,$grp)=@_;
			      my $anchor=$grp->{Filelist}->info('anchor');
			      my $nextentry=$grp->{Filelist}->info('next',$anchor);
			      unless ($nextentry and
					$grp->{Filelist}->info('parent',$nextentry) eq $anchor) {
				$grp->{filelistCurrentFilelist}->
				  set_current($grp->{Filelist}->
					      info('data',$grp->{Filelist}->info('anchor')));
				selectFilelist($grp,$grp->{filelistCurrentFilelist});
			      }
			    },$grp]);
    $t->bind('<Double-1>'=> [
			      sub {
				my ($w,$grp)=@_;
				my $anchor=$grp->{Filelist}->info('anchor');
				my $nextentry=$grp->{Filelist}->info('next',$anchor);
				my $data=$grp->{Filelist}->info('data',$anchor);
				if ($nextentry and
					$grp->{Filelist}->info('parent',$nextentry) eq $anchor) {
				  # pattern -> edit
				  my $position=
				    $grp->{filelistCurrentFilelist}->find_pattern($data);
				  $grp->{'hist-fileListPattern'}=[] unless $grp->{'hist-fileListPattern'};
				  $data=Query($grp->{Filelist}->toplevel,"Selection Pattern",
					"Edit directory pattern for $data",$data,1,$grp->{'hist-fileListPattern'});
				  if (defined($data)) {
				    print "Removing ",$grp->{Filelist}->info('data',$anchor),"\n" if $tredDebug;
				    $grp->{filelistCurrentFilelist}->remove($grp->{Filelist}->info('data',$anchor));
				    print "Adding $data\n" if $tredDebug;
				    $grp->{filelistCurrentFilelist}->add($position,$data);
				    feedHListWithFilelist($grp,$grp->{Filelist},$grp->{filelistCurrentFilelist});
				  }
				} else {
				  # file -> go to
				  $grp->{filelistCurrentFilelist}->set_current($data);
				  selectFilelist($grp,$grp->{filelistCurrentFilelist});
				}
			      },$grp ]);
  }
  $d->bind('<Destroy>'=> [sub { shift;
				 my $grp=shift;
				 $grp->{Filelist}=undef;
				 $grp->{filelistCurrentFilelist}=undef;
			       },$grp ]);
  $d->bind('all','<Escape>'=>
	   [sub { shift;
		  $modal ?
		    shift->{selected_button}= "Cancel" :
		      shift->destroy();
		},$d ]);

  $botframe->ImgButton(-text => 'Close',
	     -image => icon($grp,"button_cancel"),
	     -balloon => $grp->{Balloon},
	     -balloonmsg => "Close this window.",
	     -underline=> 0,
	     @pad,
	     -command=> [sub {
			   $modal ?
			     shift->{selected_button}= "Cancel" :
			       shift->destroy();
			 },$d ])
    ->pack(@b_pack);

  $botframe->ImgButton(-text=> 'Delete',
		-image=> icon($grp,"editdelete"),
		-balloon => $grp->{Balloon},
		-balloonmsg=> "Delete current file-list.",
		@pad,
		-underline=> 0,
		-command=> [sub {
			      my ($grp,$d)=@_;
			      deleteFilelist($grp,$grp->{filelistCurrentFilelist});
			    },$grp,$d ])
    ->pack(@b_pack);

  $botframe->ImgButton(-text=> 'Save',
		-image=> icon($grp,"filesave"),
		-balloon => $grp->{Balloon},
		-balloonmsg=> "Save current file-list to a file.",
		@pad,
		-underline=> 0,
		-command=> [sub {
			    my ($grp,$d)=@_;
			    my $file=$grp->{filelistCurrentFilelist}->filename;
			    unless (defined ($file)  and $file ne "") {
			      my $initdir=dirname($file);
			      $initdir=cwd if ($initdir eq './');
			      $initdir=~s!${TrEd::Convert::Ds}$!!m;
			      $file= get_save_filename($d,-filetypes=> 
								 [["Filelists",           ['.fl']],
								  ["All files",           ['*','*.*']]
								 ],
								 -title=> "Save filelist as ...",
								 -initialdir=> $initdir,
								 -initialfile=> filename($file));
			      $d->deiconify;
			      $d->focus;
			      $d->raise;
			      $file.=".fl" unless $file=~/\.fl$/;
			      return unless (defined $file and $file ne "");
			      $grp->{filelistCurrentFilelist}->filename($file);
			    }
			    $grp->{filelistCurrentFilelist}->save;
			  },$grp,$d ])
    ->pack(@b_pack);

  $botframe->ImgButton(-text=> 'New',
		-image=> icon($grp,"filenew"),
		-balloon => $grp->{Balloon},
		-balloonmsg=> "Create a new (empty) file-list.",
		-underline=> 0,
		@pad,
		-command=> [sub {
			   my ($grp,$d,$filelistref)=@_;
			   my $name = QueryString($d,"File-list name", "Name: ");
			   $d->deiconify;
			   $d->focus;
			   $d->raise;
			   if (findFilelist($name)) {
			     userQuery($d,
				       "File-list named '$name' already exists.\n",
				       -title => "File-list already exists",
				       -buttons => ["OK"]);
			   } else {
			     addFilelist(Filelist->new($name));
			     $$filelistref=$name;
			     switchFilelist($grp,$name);
			     updatePostponed($grp);
			   }
			 },$grp,$d,\$filelist ])
    ->pack(@b_pack);

  $botframe->ImgButton(-text=> 'Load',
		-image => icon($grp,"fileopen"),
		-balloon => $grp->{Balloon},
		-balloonmsg=> "Load a file-list from a file.",
		@pad,
		-underline=> 0,
		-command=> [sub {
			   my ($grp,$d,$filelistref)=@_;
			   my $file= get_open_filename($d,-filetypes=> 
						       [["Filelists",           ['.fl']],
							["All files",           ['*','*.*']]
						       ],
						       -title=> "Load filelist ...");
			   $d->deiconify;
			   $d->focus;
			   $d->raise;
			   return unless (defined $file and $file ne "");
			   my $fl=Filelist->new(undef,$file);
			   return unless $fl;
			   print "Loading filelist: $file\n";
			   $fl->load();
			   addNewFilelist($grp,$fl);
			   $$filelistref=$fl->name();
			 },$grp,$d,\$filelist ])
    ->pack(@b_pack);

  $leftframe->pack(qw/-padx 5 -side left -fill y/);
  $midframe->pack(qw/-padx 5 -side left/);
  $rightframe->pack(qw/-padx 5 -side left -fill y/);
  $topframe->pack(qw/-padx 3 -pady 3 -side top -expand yes -fill both/);

  if ($grp->{focusedWindow}->{currentFileNo}) {
    my $path=filelistEntryPath($grp->{filelistCurrentFilelist},$grp->{focusedWindow}->{currentFileNo});
    $t->selectionClear();
    if ($path ne "") {
      eval {
	$t->anchorSet($path);
	$t->selectionSet($path);
	$t->see($path);
      };
    }
  }
  $t->focus;
  _bind_buttons($d,$d);
  $grp->{top}->Unbusy();
  if ($modal) {
    ShowDialog($d);
    $d->destroy();
    return $filelist;
  } else {
    $d->Popup;
    return $filelist;
  }

}

sub getContexts {
  return
    uniq sort (keys(%menuBindings), 
	       keys(%keyBindings))
}

sub generateSortedMacroTable {
  my ($grp,$context) = @_;
  my %macro_to_key = reverse %{$keyBindings{$context}};
  my @macroTable= map {
    my ($macro,$key) = @{ $menuBindings{$context}{$_} };
    [ $_, ($keyBindings{$context}{$key} eq $macro ? $key : $macro_to_key{$macro}) ]
  } keys %{$menuBindings{$context}};
  if ($grp->{macroListOrder} eq 'K') {
    return sort {
      my @a= split '\+',$a->[1];
      my @b= split '\+',$b->[1];
      return $#a <=> $#b if ($#a != $#b);
      return length($a[0]) cmp length($b[0]) if (length($a[0]) ne length($b[0]));
      return $a[0] cmp $b[0] if ($a[0] ne $b[0]);
      return length($a[1]) cmp length($b[1]) if (length($a[1]) ne length($b[1]));
      return $a[1] cmp $b[1] if ($a[1] ne $b[1]);
      return length($a[2]) cmp length($b[2]) if (length($a[2]) ne length($b[2]));
      return $a[2] cmp $b[2] if ($a[2] ne $b[2]);
      return length($a[3]) cmp length($b[3]) if (length($a[3]) ne length($b[3]));
      return $a[3] cmp $b[3] if ($a[2] ne $b[3]);
      return $a cmp $b;
    } @macroTable;
  } else {
    return sort { $a->[0] cmp $b->[0] } @macroTable;
  }
}

sub macrolistCreateItems {
  my ($grp,$t,$context)=@_;
  my $e;
  $t->delete('all');
  foreach my $entry (generateSortedMacroTable($grp,$context)) {
    $e= $t->addchild("");
    $t->itemCreate($e, 0, -itemtype=>'text', -text=>$entry->[0]);
    $t->itemCreate($e, 1, -itemtype=>'text', -text=>$entry->[1]);
  }
}

sub macrolistDialog {
  my ($grp)=@_;
  my $context=$grp->{focusedWindow}->{macroContext};
  if ($grp->{Macrolist}) {
    $grp->{Macrolist}->deiconify;
    $grp->{Macrolist}->focus;
    $grp->{Macrolist}->raise;
    return;
  }
  unless (scalar(getContexts())) {
    errorMessage($grp->{focusedWindow},"No named macros in current context ($context)",1);
    return;
  }
  my $d= $grp->{top}->Toplevel(-title=> "List of available named macros");
  $d->withdraw;
  $d->resizable(0,1);
  $d->minsize('200','200');
#c  -Background white
  my $topframe = $d->Frame;
  my $t= $topframe->Scrolled(qw/HList -columns 2
           -selectmode browse
           -height 25 -relief sunken -scrollbars oe/);
  disable_scrollbar_focus($t);
  $t->BindMouseWheelVert();
  $grp->{Macrolist}=$d;
  my $e;
  my $maxw=0;
  macrolistCreateItems($grp,$t,$context);

  $t->columnWidth(0,'');
  $t->columnWidth(1,'');
  $t->anchorSet('0');

  $t->configure(-width=> 0);
  $d->bind('<Return>'=>
	   [
	    sub {
	      my ($w,$grp,$t,$ctxt)=@_;
	      doEvalMacro($grp->{focusedWindow},
			  $menuBindings{$ctxt}->
			  {$t->itemCget($t->info('anchor'),0,'-text')}->[0]);
	    },$grp,$t,\$context ]);
  $d->bind('<Double-1>'=> 
	   [
	    sub {
	      my ($w,$grp,$t,$ctxt)=@_;
	      doEvalMacro($grp->{focusedWindow},
			  $menuBindings{$$ctxt}->
			  {$t->itemCget($t->info('anchor'),0,'-text')}->[0]);
	    },$grp,$t,\$context ]);

  my $f=$topframe->Frame();
  $f->Label(-text => "Context: ")->pack(qw/-side left/);
  $f->Optionmenu(-options      => [getContexts()],
		 -textvariable => \$context,
		 -command      => [sub { my ($g,$list,$ctxt) = @_;
					 macrolistCreateItems($g,$list,$ctxt);
				       },$grp,$t],
		 -relief       => 'groove', #$menubarRelief,
		 -borderwidth  => 2)->pack(qw/-side left -padx 5/);

  $f->Button(-text=> 'Export as HTML',
	     -underline => 0,
	     -command=> [ sub {
			    my ($w,$grp,$t,$ctxt)=@_;
			    my $html = openSimpleHtml($t,$$ctxt.".html","Save list of $$ctxt macros",$ENV{HOME});
			    if ($html) {
			      print $html "<h2>TrEd Macros - $$ctxt</h2>\n";
			      print $html "<table>\n";
			      my $odd = 0;
			      foreach my $child ($t->info('children','')) {
				print $html "  <tr ",($odd ? 'bgcolor="#ffffff"' : 'bgcolor="#eeeeee"'),
				  ,">\n    <td>",$t->itemCget($child,0,'-text'),
				  "</td>\n    <td>", $t->itemCget($child,1,'-text'),"</td>\n  </tr>\n";
				$odd = !$odd;
			      }
			      print $html "</table>\n";
			      closeSimpleHtml($html);
			    }
			  },$d,$grp,$t,\$context ])->pack(-padx=>'0.5c',-pady=>'0.2c',-side=>'right');

  $f->Radiobutton( -anchor  => 'nw',
		   -underline => 8,
		   -text    => 'Sort by keyboard shortcut',
		   -variable=> \$grp->{macroListOrder},
		   -relief  => 'flat',
		   -command => [sub { #shift;
				       my ($grp,$t,$ctxt)=@_;
				       macrolistCreateItems($grp,$t,$$ctxt);
				     },$grp,$t,\$context],
		   -value   => 'K'
		 )->pack(-side=> 'right',-padx=> 20);
  $f->Radiobutton( -anchor  => 'nw',
		   -underline => 8,
		   -text    => 'Sort by name',
		   -variable=> \$grp->{macroListOrder},
		   -relief  => 'flat',
		   -command => [sub { #shift;
				       my ($grp,$t,$ctxt)=@_;
				       macrolistCreateItems($grp,$t,$$ctxt);
				     },$grp,$t,\$context],
		   -value   => 'M'
		 )->pack(-side=> 'right',-padx=> 20);

  my $botframe=$d->Frame();
  $botframe->Button(-text=> 'Run and Close',
		    -underline => 0,
	     -command=> [ sub {
			     my ($w,$grp,$t,$ctxt)=@_;
			     my $mac=$t->itemCget($t->info('anchor'),0,'-text');
			     $w->destroy();
			     doEvalMacro($grp->{focusedWindow},
					 $menuBindings{$$ctxt}->{$mac}->[0]);
			   },$d,$grp,$t,\$context ])->pack(-padx=>'0.5c',-pady=>'0.2c',-side=>'left');


  $botframe->Button(-text=> 'Close',
		    -underline => 0,
		     -command=> [ sub {
				     shift->destroy();
				   },$d ])->pack(-padx=>'0.5c',-pady=>'0.2c',-side=>'right');
  $d->bind($d,'<Destroy>'=> [sub { shift; shift->{Macrolist}=undef; },$grp ]);
  $d->bind('all','<Escape>'=> [sub { shift->toplevel->destroy(); },$d ]);

  $f->pack(qw/-side bottom -fill x/);
  $t->pack(qw/-side top -fill both -expand 1/);


  $botframe->pack(qw/-side bottom -fill both/);
  $topframe->pack(qw/-side top -fill both -ipady 3 -ipadx 3 -expand 1/);

  _bind_buttons($d,$d);
  $t->focus;
  $d->Popup;
}


sub copyTreesDialog {
  my ($grp)=@_;
  return unless $grp->{focusedWindow}->{FSFile};
  my ($Entry, @Entry) = get_entry_type();
  my $range=$grp->{focusedWindow}->{treeNo}+1;
  my $source=$grp->{focusedWindow}->{FSFile};
  my $destination=$grp->{focusedWindow}->{FSFile};
  my $d= $grp->{top}->DialogBox(-title=> 'Copy Trees',
				-buttons=> ['OK', 'Cancel']);
  $d->bind('<Return>',\&dlgReturn);
  $d->resizable(0,0);
  addBindTags($d,'dialog');
  escapeButton($d,'Cancel',1);
  $d->bind('all','<Tab>',[sub { shift->focusNext; }]);
  $d->bind('all','<Shift-Tab>',[sub { shift->focusPrev; }]);
  $d->bind('all','<Shift-ISO_Left_Tab>',[sub { shift->focusPrev; }]);
  my $ff= $d->Frame();
  $ff->Label(-text=> 'Destination file:',
	     -anchor=> 'w',
	     -justify=> 'right')->pack(-side=> 'left');
  my @items;
  my $i=1;
  foreach my $of (@openfiles) {
    push @items,$i++.". ".$of->filename();
  }
  $ff->Optionmenu(
		  -relief => $buttonsRelief,
		  -options => \@items,
		  -variable => \$destination
		 )->pack(qw/-side left -padx 10/);
  $ff->pack(qw/-pady 10 -padx 10 -side top -expand yes -fill x/);
  my $sf= $d->Frame();
  my $re=$sf->$Entry(@Entry,
		     -relief=> 'sunken',
		     -width=> 20,
		     -font=> $font,
		     -textvariable=> \$range);
  set_grp_history($grp, $re, 'treeRange');
  $sf->Label(-text=> 'Trees selection (range):',
	     -anchor=> 'w',
	     -justify=> 'right')->pack(-side=> 'left');
  $re->pack(qw/-side left -padx 10 -fill x -expand yes/);
  $sf->Button(-image=> icon($grp,'1leftarrow'),
	      -command =>
	      [sub {
		  my ($grp,$range)=@_;
		  $$range=sentViewGetSelection($grp,$grp->{sentDialogSelection});
	       },$grp,\$range])->pack(qw/-padx 10 -side left/);
  $sf->Button(-image=> icon($grp,'contents'),
	      -command=> [sub {
			    my ($grp,$d,$range,$source)=@_;
			    my $list=[];
			    foreach (TrEd::Print::parse_print_list($source,$$range)) {
			      $list->[$_-1]=1;
			    }
			    $$range=sentViewGetSelection($grp,
							 viewSentencesDialog($grp,$d,$source,
									     $list
									    ));
			  },$grp,$d,\$range,$source])->pack(qw/-padx 10 -side left/);
  $sf->pack(qw/-pady 10 -padx 10 -side bottom -expand yes -fill x/);


  my $result= ShowDialog($d,$re,$grp->{top});
  get_grp_history($grp, $re, 'treeRange') if ($result=~ /OK/);
  $d->destroy();
  undef $d;
  if ($result=~ /OK/) {
    $destination=~/^(\d+)/;
    my $fs=$openfiles[$1-1];
    return unless ref($fs);
    my @list=TrEd::Print::parse_print_list($source,$range);
    my $tree;
    my $any;
    foreach my $l (@list) {
      $tree=$source->tree($l-1);
      if ($tree) {
	$fs->insert_tree($fs->FS->clone_subtree($tree),
			 $fs->lastTreeNo+1);
	$any=1;
      }
    }
    if ($any) {
      $fs->notSaved(1);
      get_nodes_fsfile($grp,$fs);
      redraw_fsfile($grp,$fs);
    }
  }
}

sub initTTFonts {
  my ($grp)=@_;
  print STDERR "Collecting TTF fonts\n";# if $tredDebug;
  $grp->{ttfonts}=TrEd::Print::get_ttf_fonts(map TrEd::Config::tilde_expand($_),
					     split /,/,$ttFontPath);
}

sub warnWin32PrintConvert {
  my ($win)=@_;
  return 'Continue' if $^O ne 'Win32' or
    $NoConvertWarning;
  userQuery($win,
"Note, that this feature may not work properly on your system ".
"unless some external tools, namely ImageMagick and GhostView, are ".
"installed and configured properly.\n\n".
"To avoid this message, add NoConvertWarning=1 to your configuration file.",
	    -title => "Warning",
	    -buttons => ["Continue","Cancel"]);
}

sub warn55PrintConvert {
  my ($win)=@_;
  return 'Continue' if $NoConvertWarning;
  my $version = `$imageMagickConvert -help`;
  ($version) = split /\n/,$version;
  return 'Continue' unless ($version =~ /ImageMagick 5\.5\./);
  userQuery($win,
	    "Your version of ImageMagick ($version) is known to hang when converting from EPS. ".
            "We suggest that you upgrade ImageMagick to version >= 6.0 or downgrade to <= 5.4.7. ".
            "If you are sure you want to continue ".
	    "and risk that TrEd will stop responding, press Continue.\n".
	    "It is strongly recommended that you Cancel the operation now.\n\n".
	    "To avoid this message, add NoConvertWarning=1 to your configuration file.",
	    -title => "Warning",
	    -buttons => ["Cancel","Continue anyway"]);
}


sub updatePrintDialogState {
  my ($grp,$w, $s, $extension)=@_; # widgets, state
  my %t=map { $_ => 1} keys %$w; # toggle
  my @disable;
  if ($s->{printTo} eq 'printer') {
    @disable = qw(resolution file format_PDF);
  } elsif ($s->{printTo} eq 'file') {
    @disable = qw(resolution command);
  } elsif ($s->{printTo} eq 'convert') {
    @disable = qw(command psMedia prtFmtWidth prtFmtHeight);
  }
  if ($s->{psMedia} ne 'User') {
    push @disable, qw(prtFmtWidth prtFmtHeight);
  }

  if ($s->{format} eq 'EPS') {
    push @disable,qw(font printRange psMedia prtFmtWidth prtFmtHeight);
  } elsif ($s->{format} eq 'PS') {
    push @disable,qw(font);
  } elsif ($s->{format} eq 'PDF') {
    push @disable,qw(printTo_printer);
    unless ($grp->{ttfonts}) {
      $w->{font}->toplevel->Busy(-recurse => 1);
      initTTFonts($grp);
      foreach (sort {$a cmp $b} keys %{$grp->{ttfonts}}) {
#	$w->{font}->insert('end',$_);
	$w->{font}->addItem($_);
      }
      if (exists($grp->{ttfonts}->{$initTTFont})) {
	$s->{ttFont} = $s->{initTTFont};
      } else {
	$s->{ttFont} = '';
      }
      $w->{font}->toplevel->Unbusy();
    }
  }
  $t{$_}=0 for (@disable);
  $s->{file}=~s/\.[^.]*$/.$extension/ if defined($extension) and
    not($s->{printTo} eq 'convert' and $extension =~ /^(?:pdf|e?ps)$/);

  if ($s->{psMedia} eq 'BBox') {
    $s->{prtFmtWidth} = '';
    $s->{prtFmtHeight} = '';
  } elsif ($s->{psMedia} eq 'User') {
    $s->{prtFmtWidth} = $s->{defaultPrtFmtWidth};
    $s->{prtFmtHeight} = $s->{defaultPrtFmtHeight};
  } else {
    $s->{prtFmtWidth} = $TrEd::Print::media{$s->{psMedia}}[0];
    $s->{prtFmtHeight} = $TrEd::Print::media{$s->{psMedia}}[1];
  }
  foreach my $widget (keys %t) {
    if ($t{$widget}) {
      print "On: $widget: $w->{$widget}\n";
      eval { $w->{$widget}->configure(-state => 'normal') };
      eval { $w->{$widget}->configure(($w->{$widget}->isa('Tk::Entry') or
				       $w->{$widget}->isa('Tk::BrowseEntry') or
				       $w->{$widget}->isa('JComboBox_0_02')
				      ) ?
				      (-background => $s->{defaultBg}) : ()
				     ) };
    } else {
      print "Off: $widget: $w->{$widget}\n";
      eval { $w->{$widget}->configure(-state=> 'disabled') };
      eval { $w->{$widget}->configure(($w->{$widget}->isa('Tk::Entry') or
				       $w->{$widget}->isa('Tk::BrowseEntry') or
				       $w->{$widget}->isa('JComboBox_0_02')
				      ) ?
				      (-background => $s->{disabledBg}) : ()
				     ) };
    }
    print "---\n";
  }
}

sub printDialog {
  my ($grp)=@_;
  my $win = $grp->{focusedWindow};
  return unless $win->{FSFile};
  my ($Entry,@Entry) = get_entry_type();
  my $e_hist;

  my (%w,%s); # widgets, state
  $s{command}=$grp->{printCommand} || 'lpr';
  $s{file}=$grp->{printPsFile};
  $s{file} =doEvalHook($win,"print_tree_filename_hook");
  $s{file}=$win->{FSFile}->filename if $s{file} eq "";
  $grp->{printFileExtension} ||= "ps";
  $s{file}=~s/\.[^.]*$/.$grp->{printFileExtension}/;
  $s{printTo}=$grp->{printToFile} || 'printer';
  $s{format}=$grp->{printFormat} || 'PS';
  $s{resolution}=$grp->{printImageMagickResolution} || 80;
  $s{printRange}=$win->{treeNo}+1;# unless $printRange ne "";
  $s{printSentence}=$grp->{printSentenceInfo};
  $s{noRotate}=$grp->{printNoRotate};
  $s{printColors}=$grp->{printColors};
  $s{defaultPrtFmtWidth}=$prtFmtWidth;
  $s{defaultPrtFmtHeight}=$prtFmtHeight;
  $s{prtFmtWidth}=$prtFmtWidth;
  $s{prtFmtHeight}=$prtFmtHeight;
  $s{prtHMargin}=$prtHMargin;
  $s{prtVMargin}=$prtVMargin;
  $s{psMedia}=$psMedia;
  $s{initTTFont} = $ttFont;
  if ($grp->{ttfonts} and exists($grp->{ttfonts}->{$ttFont})) {
    $s{ttFont} = $ttFont;
  } else {
    $s{ttFont} = '';
  }

  # Dialog
  my $d= $grp->{top}->DialogBox(-title=> "Print",
				-buttons=> ["OK", "Cancel"]);
  $d->resizable(0,0);
  addBindTags($d,'dialog');
  escapeButton($d,'Cancel',1);
  $d->bind('<Return>',\&dlgReturn);
  $d->bind('all','<Tab>',[sub { shift->focusNext; }]);
  $d->bind('all','<Shift-ISO_Left_Tab>',[sub { shift->focusPrev; }]);
  $d->bind('all','<Shift-Tab>',[sub { shift->focusPrev; }]);

  # Command Entry
  my $cf= $d->Frame()->pack(qw/-pady 10 -padx 10 -side top -expand yes -fill x/);
  $w{command_label}= $cf->Label(-text=> 'Print command:',
				-anchor=> 'w',
				-justify=> 'right')->pack(-side=> 'left');
  $w{command}= $cf->$Entry(@Entry,
			   -relief=> 'sunken',
			   -width=> 20,
			   -font=> $font,
			   -textvariable=> \$s{command})
    ->pack(qw/-padx 10 -side left -expand yes -fill x/);
  set_grp_history($grp, $w{command}, 'printCommand', $e_hist);
  $s{defaultBg}=$w{command}->cget('-background');
  $s{disabledBg}=$d->cget('-background');

  # Page format selection
  my $mf = $d->Frame()->pack(qw/-pady 10 -padx 10 -side top -expand yes -fill x/);
  $mf->Label(-text=> 'Media:',
	     -anchor=> 'w',
	     -justify=> 'right')->pack(-side=> 'left');

  $w{prtFmtWidth} = $mf->$Entry(@Entry,
				-textvariable => \$s{prtFmtWidth},
				-width => 5,
				-validate => 'key',
				-validatecommand => sub { shift =~ /^\s*\d*\s*$/ });
  set_grp_history($grp, $w{prtFmtWidth}, 'printFmtWidth',$e_hist);
  $w{prtFmtHeight} = $mf->$Entry(@Entry,
				 -textvariable => \$s{prtFmtHeight},
				 -width => 5,
				 -validate => 'key',
				 -validatecommand => sub { shift =~ /^\s*\d*\s*$/ });
  set_grp_history($grp, $w{prtFmtWidth}, 'printFmtHeight',$e_hist);

  # Page media
  $w{psMedia}=$mf->Optionmenu(
			      -relief => $buttonsRelief,
			      -options => ['BBox', 'User', sort {$a cmp $b} grep !/\d+x\d+|^ISO/, 
					   keys %TrEd::Print::media ],
			      -font => ref($font) ? $font->Clone(-size => 8) :
			      $d->Font(-family => 'sans', -size => 8),
			      -textvariable => \$s{psMedia}, # global variable in TrEd::Config
			      -command => [\&updatePrintDialogState,$grp,\%w,\%s,undef]
			)->pack(-side=> 'left');
  $w{prtFmtHeight}->raise($w{psMedia});
  $w{prtFmtWidth}->raise($w{psMedia});
  $mf->Label(-text=> 'Width:',
	     -padx => 10,
	     -anchor=> 'w',
	     -justify=> 'right')->pack(-side=> 'left');
  $w{prtFmtHeight}->pack(-side=> 'left');
  $mf->Label(-text=> 'Height:',
	     -padx => 10,
	     -anchor=> 'w',
	     -justify=> 'right')->pack(-side=> 'left');
  $w{prtFmtWidth}->pack(-side=> 'left');

  # Page Margins
  $mf->Label(-text=> 'X margin:',
	     -padx => 10,
	     -anchor=> 'w',
	     -justify=> 'right')->pack(-side=> 'left');
  $w{prtHMargin} = $mf->$Entry(@Entry,
			       -textvariable => \$s{prtHMargin},
			       -width => 5,
			       -validate => 'key',
			       -validatecommand => 
			       sub { shift =~ /^\s*\d*[cimp]?\s*$/ })->pack(-side=> 'left');
  set_grp_history($grp, $w{prtHMargin}, 'printHMargin',$e_hist);
  $mf->Label(-text=> 'Y margin:',
	     -padx => 10,
	     -anchor=> 'w',
	     -justify=> 'right')->pack(-side=> 'left');
  $w{prtVMargin}=$mf->$Entry(@Entry,
			     -textvariable => \$s{prtVMargin},
			     -width => 5,
			     -validate => 'key',
			     -validatecommand => 
			     sub { shift =~ /^\s*\d*[cimp]?\s*$/ })->pack(-side=> 'left');
  set_grp_history($grp, $w{prtVMargin}, 'printVMargin',$e_hist);


  # Output filename
  my $ff=$d->Frame();
  $w{file_label}= $ff->Label(-text=> 'File name:',
			     -anchor=> 'w',
			     -justify=> 'right')->pack(-side=> 'left');
  $w{file}= $ff->$Entry(@Entry,
			-relief=> 'sunken',
			-width=> 50,
			-font=> $font,
			-textvariable=> \$s{file})
    ->pack(qw/-padx 10 -side left -expand yes -fill x/);
  $d->bind('<Alt-r>',[sub{shift;shift->{file}->focus},\$w]);
  set_grp_history($grp, $w{file}, 'printFile',$e_hist);
  if ($s{file} ne "") {
    my $start = rindex($fil,"/")+1;
    my $end = rindex($fil,".");
    if ($start<$end) {
      $w{file}->selectionClear();
      $w{file}->selectionRange($start,$end);
      $w{file}->icursor($start);
    }
  }

  # Print range
  my $sf= $d->Frame();
  $w{printRange}=$sf->$Entry(@Entry,
			     -relief=> 'sunken',
			     -width=> 20,
			     -font=> $font,
			     -textvariable=> \$s{printRange});
  set_grp_history($grp, $w{printRange}, 'printRange',$e_hist);
  $w{findFile} = $ff->Button(-text => '...',
			     -underline => 0,
		      -command =>
		      [sub {
			 my ($d,$s)=@_;
			 my $initdir=dirname($s->{file});
			 $initdir=cwd() if ($initdir eq './');
			 $initdir=~s!${TrEd::Convert::Ds}$!!m;
			 my $file=
			   get_save_filename($d,-title => "Print To File ...",
					     $^O eq 'MSWin32' ? () :
					     (-initialfile=> filename($s->{file})),
					     -d $initdir ? (-initialdir=> $initdir) : (),
					     -filetypes=>
					     [
					      ($s->{format} eq 'PDF' ?
					      ["PDF files", [qw/.pdf .PDF/]] :
					      ["PostScript files", [qw/.ps .eps .PS .EPS/]]),
					      ["All files", '*']
					     ]
					    );
			 $s->{file}=$file if (defined $file and $file ne '');
		       },$d,\%s])->pack(qw/-padx 10 -side left/);

  # TrueType font
  my $of=$d->Frame();
  my $bf=$of->Frame();

  my %fmtbut;
  my $pbf = $bf->Frame();
  $w{font_label}=$pbf->Label(-text=> 'Font (TTF):',
			       -anchor=> 'sw',
			       -justify=> 'right');




#   $w{font}=$pbf->BrowseEntry(
# 				-relief=> 'sunken',
# 				-width=> 30,
# 				-variable => \$s{ttFont},
# 				-choices => [$grp->{ttfonts} ? (sort {$a cmp $b} keys %{$grp->{ttfonts}}) : ()]
# 			       );
  $w{font}=$pbf->JComboBox_0_02(
    -width => 30,
    -relief => 'flat',
    -textvariable => \$s{ttFont},
    -choices => [$grp->{ttfonts} ? (sort {$a cmp $b} keys %{$grp->{ttfonts}}) : ()],
    -mode => 'editable',
    -validate => 'match',
    -takefocus => 1,
    -borderwidth => 0,
    -highlightcolor => 'black',
    -highlightbackground => 'gray',
    -highlightthickness => 1,
    -background => 'gray',
    -popupbackground => 'black',
    -borderwidth => 1,
    -buttonrelief => 'ridge'
#    -buttonbitmap => 'combo'
   );


  # Bitmap Resolutions
  my $imf=$bf->Frame();
  $w{resolution}=$imf->Optionmenu(
				  -relief => $buttonsRelief,
				  -options => ['50','60', '75','80','90','100','120','135','150','160','180',
					       '200','225','240','260','300','360','600','720'],
				  -variable => \$s{resolution}
				 );

  my %printbuttons = ( printer => [$bf,'Send to printer',undef,8],
		       file =>[$bf,'Print to file','eps',9],
		       convert =>[$imf,'Convert to bitmap format (ImageMagick)','png',0]
		     );

  # print To buttons
  foreach (qw(printer file convert)) {
    $w{"printTo_$_"} = $printbuttons{$_}[0]->
      Radiobutton(-text    => $printbuttons{$_}[1],
		  -value   => $_,
		  -underline => $printbuttons{$_}[3],
		  -variable=> \$s{printTo},
		  -relief  => 'flat',
		  -command =>
		  [\&updatePrintDialogState,$grp,\%w,\%s,$printbuttons{$_}[2]]
		 );
  }
  foreach (qw(printer file)) {
    $w{"printTo_$_"}->pack(qw/-fill y -anchor nw/);
  }
  $w{printTo_convert}->pack(qw/-anchor w -side left -fill y -expand 1/);
  $imf->Label(-text => "Resolution")->pack(qw/-padx 10 -side left/);
  $imf->pack(qw/-fill x -expand yes -anchor nw/);

  $bf->Frame()->pack(qw/-pady 5/);

  # output format buttons
  my %fmtbuttons = ( PS => [$bf,'Create PostScript','ps',11],
		     EPS =>[$bf,'Create EPS','eps',7],
		     PDF =>[$pbf,'Create PDF','pdf',8]
		   );
  foreach (qw(PS EPS PDF)) {
    $w{"format_$_"} = $fmtbuttons{$_}[0]->
      Radiobutton(-text    => $fmtbuttons{$_}[1],
		  -value   => $_,
		  -underline => $fmtbuttons{$_}[3],
		  -variable=> \$s{format},
		  -relief  => 'flat',
		  -command =>
		  [\&updatePrintDialogState,$grp,\%w,\%s,$fmtbuttons{$_}[2]]
		 );
  }
  foreach (qw(PS EPS)) {
    $w{"format_$_"}->pack(qw/-fill y -anchor nw/);
  }
  $w{format_PDF}->pack(qw/-anchor w -side left -fill y -expand 1/);
  $w{font_label}->pack(qw/-padx 10 -side left/);
  $w{font}->pack(qw/-padx 10 -side left/);
  $pbf->raise($w{format_EPS});
  $w{resolution}->pack(qw/-padx 10 -side left/);
  $pbf->pack(qw/-fill x -expand yes -anchor nw/);

  $bf->Frame()->pack(qw/-pady 5/);

  # print options
  $w{printColors}=$bf->Checkbutton(-text=> 'Use colors',
				   -underline => 0,
			       -variable=> \$s{printColors},
			       -relief  => 'flat')->pack(-fill=> 'y',-anchor=> 'nw');
  $w{printSentence}=$bf->Checkbutton(-text=> 'Print sentence',
				     -underline => 8,
				 -variable=> \$s{printSentence},
				 -relief  => 'flat')->pack(-fill=> 'y',-anchor=> 'nw');

  $w{noRotate}=
    $bf->Checkbutton(-text    => 'Disable landscape rotation of wide trees',
		     -underline => 18,
		     -variable=> \$s{noRotate},
		     -relief  => 'flat')->pack(-fill=> 'y',-anchor=> 'nw');
  $bf->pack(-side=> 'left');
  $of->pack(qw/-padx 10 -pady 10 -side top -expand yes -fill x/);
  $sf->Label(-text=> 'Page range:',
	     -underline => 5,
	     -anchor=> 'w',
	     -justify=> 'right')->pack(-side=> 'left');
  $d->bind('<Alt-r>',[sub{shift;shift->{printRange}->focus},\$w]);
  $w{printRange}->pack(qw/-side left -padx 10 -fill x -expand yes/);

  for ($sf,$ff) {
    $_->raise($of);
  }

  # fill range buttons
  $sf->Button(-image=> icon($grp,'1leftarrow'),
	      -command =>
	      [sub {
		 my ($grp,$w)=@_;
		 $w->{printRange}=sentViewGetSelection($grp,$grp->{sentDialogSelection});
	       },$grp,\%w])->pack(qw/-padx 10 -side left/);
  $sf->Button(-image=> icon($grp,'contents'),
	      -command=> [sub {
			    my ($grp,$win,$d,$w)=@_;
			    my $list=[];
			    foreach (TrEd::Print::parse_print_list(
					  $win->{FSFile},
					   $w->{printRange})) {
			      $list->[$_-1]=1;
			    }
			    $w->{printRange}=
			      sentViewGetSelection($grp,
				 viewSentencesDialog($grp,$d,
				 $win->{FSFile},
				 $list));
			  },$grp,$win,$d,\%w ])->pack(qw/-padx 10 -side left/);

  $sf->pack(qw/-pady 10 -padx 10 -side bottom -expand yes -fill x/);
  $ff->pack(qw/-pady 10 -padx 10 -side bottom -expand yes -fill x/);

  updatePrintDialogState($grp,\%w,\%s, $grp->{printFileExtension});
#  $toFile ? $fe->focus : $ce->focus;
  _bind_buttons($d,$d);
  my $result= ShowDialog($d,$s{printTo} eq "command" ? $w{command} : $w{file},$grp->{top});
  $grp->{printRange}=$s{printRange};
  $grp->{printToFile}=$s{printTo};
  $grp->{printFormat}=$s{format};
  $grp->{printPsFile}=$s{file};
  $psMedia=$s{psMedia};
  ($grp->{printFileExtension})=$s{file}=~m!\.([^.\\/]+)$!;
  $grp->{printSentenceInfo}=$s{printSentence};
  $grp->{printCommand}=$s{command};
  $grp->{printImageMagickResolution}=$s{resolution};
  $grp->{printNoRotate}=$s{noRotate};
  $grp->{printColors}=$s{printColors};
  $ttFont=$s{ttFont};
  $prtHMargin=$s{prtHMargin};
  $prtVMargin=$s{prtVMargin};
  get_grp_histories($grp,$e_hist) if ($result =~ /OK/);
  $d->destroy;
  undef $d;
  if ($result=~ /OK/) {
    return () if $s{printTo} eq 'convert' and
                 warnWin32PrintConvert($win) eq 'Cancel';
    return () if $s{printTo} eq 'convert' and
                 warn55PrintConvert($win) eq 'Cancel';
    return ($s{printRange},
	    ($s{printTo} eq 'file') ? 1 : 0,
	    ($s{printTo} eq 'convert' or $s{format} eq 'EPS') ? 1 : 0,
	    ($s{format} eq 'PDF') ? 1 : 0,
	    $s{file},
	    $s{printSentence} ? sub { get_value_line($win,$_[0],$_[1],1,0) } : undef,
	    (($s{printTo} eq 'convert') ?
	     "$imageMagickConvert -density $s{resolution} - $s{file}" : $s{command}),
	    $s{printColors},$s{noRotate});
  } else {
    return ();
  }
}

sub printThis {
  my ($grp)=@_;
  my $win = $grp->{focusedWindow};
  return unless $win->{FSFile};

## uncomment to get preview (see also below)
#  my $dlg = $grp->{top}->DialogBox(-title=> 'Print Preview',
#				   -buttons=> ['Close']);
#  my $canvas=$dlg->Scrolled('Canvas');

  my $canvas=$grp->{top}->Canvas();
  my @print_opts;
  my $err;
  do {{
    @print_opts=printDialog($grp);
    return unless scalar(@print_opts)>2;
    $err = ($print_opts[3] and (!$grp->{ttfonts} or !$grp->{ttfonts}->{$ttFont}));
    plainErrorMessage($grp,"You must select TrueType font for PDF!") if $err;
  }} while ($err);
  $print_opts[0]=$grp->{focusedWindow}->{treeNo}+1
    if (!defined($print_opts[0]) or $print_opts[0] eq "");

  my $stylesheet = $win->{stylesheet};
  my $ss = undef;
  if ($stylesheet ne STYLESHEET_FROM_FILE()) {
    $ss=$win->{framegroup}->{stylesheets}->{$stylesheet};
  }
  $TrEd::TreeView::on_get_root_style = [\&onGetRootStyle,$win];
  $TrEd::TreeView::on_get_node_style = [\&onGetNodeStyle,$win];

  TrEd::Print::print_trees($grp->{focusedWindow}->{FSFile},
			   $grp->{top},
			   $canvas,
			   @print_opts,
			   $grp->{focusedWindow}->{treeView}->get_showHidden(),
			   {
			    'PS' => $psFontFile,
			    'AFM' => $psFontAFMFile,
			    'TTF' => ($grp->{ttfonts} ? $grp->{ttfonts}->{$ttFont} : ""),
			    'Size' => $psFontSize,
			   },
			   $prtFmtWidth,
			   $prtHMargin,
			   $prtFmtHeight,
			   $prtVMargin,
			   $maximizePrintSize,
			   $psMedia,
			   $treeViewOpts,
			   $ss
			  );

  $TrEd::TreeView::on_get_root_style = undef;
  $TrEd::TreeView::on_get_node_style = undef;


## uncomment to get preview (see also above)
#  $canvas->pack();
#  ShowDialog($dlg);

  $canvas->destroy();
}

sub getWindowPatterns {
  my ($win)=@_;
  if ($win->treeView->patterns()) {
    return @{$win->treeView->patterns()}
  } elsif ($win->{FSFile}) {
    return $win->{FSFile}->patterns();
  } else {
    return ();
  }
}

sub getWindowHint {
  my ($win)=@_;
  if (defined($win->treeView->hint)) {
    return ${$win->treeView->hint()};
  } elsif ($win->{FSFile}) {
    return $win->{FSFile}->hint();
  } else {
    return undef;
  }
}

sub getWindowContextRE {
  my ($win)=@_;
  my $grp = cast_to_grp($win);
  my $stylesheet = $win->{stylesheet};
  if (exists($grp->{stylesheets}->{$stylesheet})) {
    return $grp->{stylesheets}->{$stylesheet}->{context};
  } else {
    return undef;
  }
}

sub applyWindowStylesheet {
  my ($win,$stylesheet)=@_;
  return unless $win;
  my $s=$win->{framegroup}->{stylesheets}->{$stylesheet};
  if ($stylesheet eq STYLESHEET_FROM_FILE()) {
    $win->treeView()->set_patterns(undef);
    $win->treeView()->set_hint(undef);
  } else {
    if ($s) {
      $win->treeView()->set_patterns($s->{patterns});
      $win->treeView()->set_hint(\$s->{hint});
    }
  }
  $win->{stylesheet}=$stylesheet;
}

sub updateStylesheetMenu {
  my ($grp)=@_;
  __debug("calling updateStylesheetMenu");
    $grp->{StylesheetMenu}->configure(-options => getStylesheetMenuList($grp));
}

sub getStylesheetMenuList {
  my ($grp,$all)=@_;
  my $context=$grp->{focusedWindow}->{macroContext};
  undef $context if $context eq 'TredMacro';
  my $match;
  [STYLESHEET_FROM_FILE(),NEW_STYLESHEET(),DELETE_STYLESHEET(),
   grep { 
     if ($all or !defined($context)) { 1 } else {
       $match = $grp->{stylesheets}{$_}{context};
       $match = '.*' unless $match =~ /\S/;
       $context =~ /^${match}$/x ? 1 : 0;
     }
   } sort keys %{$grp->{stylesheets}}];
}

sub switchStylesheet {
  my ($grp,$stylesheet)=@_;
  my $win=$grp->{focusedWindow};
  return unless ref($win);
  my $prevstylesheet=$win->{stylesheet};
  return if $prevstylesheet eq $stylesheet;
  if ($stylesheet eq NEW_STYLESHEET()) {
    $stylesheet=QueryString($grp,"Stylesheet name", "Name: ");
    if (!defined($stylesheet)) {
      $stylesheet=$prevstylesheet;
    } elsif (exists($grp->{stylesheets}->{$stylesheet})) {
      errorMessage($win,
		   "Stylesheet named '$stylesheet' already exists!\n",1);
      $stylesheet=$prevstylesheet;
    } else {
      my ($hint,$context,$patterns) = getStylesheetPatterns($win);
      $grp->{stylesheets}->{$stylesheet}->{hint}=$hint;
      $grp->{stylesheets}->{$stylesheet}->{context}=$context;
      $grp->{stylesheets}->{$stylesheet}->{patterns}=$patterns;
      updateStylesheetMenu($grp);
      saveStyleSheets($grp);
    }
    applyWindowStylesheet($win,$stylesheet);
    $grp->{selectedStylesheet} = $stylesheet;
  } elsif ($stylesheet eq DELETE_STYLESHEET()) {
    if ($prevstylesheet eq STYLESHEET_FROM_FILE()) {
      $grp->{selectedStylesheet} = $prevstylesheet;
      return 0;
    }
    $stylesheet=$prevstylesheet;
    my $answer=userQuery($win,
			 "Really delete stylesheet '$stylesheet'?",
			 -bitmap=> 'question',
			 -title => "Delete stylesheet?",
			 -buttons => ['Yes', 'No']);
    if ($answer eq 'Yes') {
      deleteStylesheet($grp,$stylesheet);
      saveStyleSheets($grp);
    } else {
      $grp->{selectedStylesheet} = $stylesheet;
      return 0;
    }
  } else {
    return 0 if (doEvalHook($win,"pre_switch_stylesheet_hook",
			    $prevstylesheet,$stylesheet) eq 'stop');
    applyWindowStylesheet($win,$stylesheet);
    doEvalHook($win,"switch_stylesheet_hook",$prevstylesheet,$stylesheet);
    if ($win->{FSFile}) {
      get_nodes_win($win);
      redraw_win($win);
    }
  }
  return 1;
}

sub switchContext {
  my ($win,$context,$noredraw)=@_;
  my $grp = cast_to_grp($win);
  my $prevcontext=$win->{macroContext};
  $win->{macroContext}=$context;
  my $ret = doEvalHook($win,"allow_switch_context_hook",$prevcontext,$context);
  if ($ret eq 'stop') {
    $win->{macroContext}=$prevcontext;
    $grp->{selectedContext}=$prevcontext if (isFocused($win));
    return 0;
  }
  $win->{macroContext}=$prevcontext;
  return 0 if (doEvalHook($win,"pre_switch_context_hook",$prevcontext,$context) eq 'stop');
  $win->{macroContext}=$context;
  $grp->{selectedContext}=$context if (isFocused($win));
  doEvalHook($win,"switch_context_hook",$prevcontext,$context);
  unless ($noredraw) {
    updateStylesheetMenu($grp);
    get_nodes_win($win);
    redraw_win($win);		# something should be done with display attrs vs windows maybe
  }
}

sub onGetNodeStyle {
  my ($treeview,$node,$styles,$win)=@_;
  doEvalHook($win,"node_style_hook",$node,$styles);
}
sub onGetRootStyle {
  my ($treeview,$node,$styles,$win)=@_;
  doEvalHook($win,"root_style_hook",$node,$styles);
}

sub onTreeChange {
  my ($win)=@_;
  get_nodes_fsfile_tree($win->{framegroup},$win->{FSFile},$win->{treeNo});
  redraw_fsfile_tree($win->{framegroup},$win->{FSFile},$win->{treeNo});
  centerTo($win,$win->{currentNode});
}

sub onNodeChange {
  my ($win)=@_;
  get_nodes_fsfile_tree($win->{framegroup},$win->{FSFile},$win->{treeNo});
  redraw_fsfile_tree($win->{framegroup},$win->{FSFile},$win->{treeNo});
}

sub update_value_line_current {
  my ($win,$node)=@_;
  my $grp=$win->{framegroup};
  my $vl=$grp->{valueLine};
  if ($win == $grp->{focusedWindow}) {
    eval {
      $vl->tagRemove('current','0.0','end');
      $vl->tagRemove('sel','0.0','end');
      my $tag = doEvalHook($win,"highlight_value_line_tag_hook",$node);
      $tag = "$node" unless defined $tag;
      my ($first,$last)=('0.0','0.0');
      while (($first,$last)=$vl->tagNextrange("$tag",$last)) {
 	$vl->tagAdd('current',
		    $first,$last);
# 		    $tag.".first",
# 		    $tag.".last",
#	   );
 	$vl->see('current.first');
      }
    };
  }
}

sub onCurrentChange {
  my ($win,$node,$prev)=@_;
  my $n;
  my $tv=$win->{treeView};
  update_value_line_current($win,$node);
  foreach $n ($node,$prev) {
    $tv->canvas->itemconfigure($tv->get_node_pinfo($n,"Oval"),
			       nodeOptions($win,$n)
			      );
    if ($tv->get_node_pinfo($n,"NodeHasBox")) {
      $tv->canvas->itemconfigure($tv->get_node_pinfo($n,"TextBox"),
				 nodeBoxOptions($win,$n,0));
    }
    if ($tv->get_node_pinfo($n,"EdgeHasBox")) {
      $tv->canvas->itemconfigure($tv->get_node_pinfo($n,"EdgeTextBox"),
				 nodeBoxOptions($win,$n,1));
    }
    $tv->canvas->coords($tv->get_node_pinfo($n,"Oval"),
			$tv->node_coords($n,$win->{currentNode}));
    $tv->apply_stored_style_opts("Oval",$n);
  }
  $tv->apply_stored_style_opts("CurrentOval",$node);
  unless ($prev eq $node) {
    $tv->apply_stored_style_opts("TextBox",$prev);
    $tv->apply_stored_style_opts("EdgeTextBox",$prev);
    doEvalHook($win,"current_node_change_hook",$node,$prev) unless $insideEval;
    update_status_line($win);
## experiment with persistent node editor
#    if ($win->{framegroup}->{attrsEditor}) {
#      editAttrsDialog_schema($win,$node)
#    }
  }
}

sub prepareFont {
  my ($grp,$font,$fn)=@_;
  print STDERR "Preparing fonts.\n" if $tredDebug;
  if ($$font!~/^\s*-/ and $$font!~/^\s*\{/) {
    my @a=split(/\s*,\s*/,$$font);
    my ($option,$value);
    my @b;
    foreach (@a) {
      ($option, $value)= split(/\s*:\s*/, $_, 2);
      push @b, "-".$option, $value if ($option=~/^(?:size|weight|family|slant|underline|overstrike)$/);
    }
      # try
    eval { $grp->{top}->fontDelete($fn) }; 
      # error would be displayed otherwise if yet undefined
      # and I'm lazy to remember or find out how to check
      # :)
    $grp->{top}->fontCreate($fn,@b);
    $$font=$fn;
  }
  #
  # There were problems with the following lines, so I'm skipping them  
  #
  # else {
  #  $grp->{top}->fontCreate('C_normal',$grp->{top}->fontActual($$font));
  #  $$font='C_normal';
  # }
}

sub prepareFonts {
  my ($grp)=@_;
  prepareFont($grp,\$font,'C_normal');
  $treeViewOpts->{font}=$font;
  prepareFont($grp,\$vLineFont,'C_vline');
  eval { # eval, in case fonts already exist
    $grp->{top}->fontCreate(qw/C_fixed   -family courier   -size 9/);
    $grp->{top}->fontCreate(qw/C_default -family helvetica -size 9/);
    $grp->{top}->fontCreate(qw/C_bold    -family helvetica -size 9 -weight bold/);
    $grp->{top}->fontCreate(qw/C_italic  -family helvetica -size 9 -slant italic/);
  };

}

sub addBindTags {
  my $w=shift @_;
  $w->bindtags([@_,$w,ref($w),$w,$w->toplevel,'all']);

}

sub cascadeMenus {
  $maxMenuLines=max($maxMenuLines,3);
  my $uM=[ @_[0..min($maxMenuLines-1,$#_)] ];
  my $uuM=$uM;
  my $i=$maxMenuLines;
  while ($i<=$#_) {
    my $m = [@_[$i..min($i+$maxMenuLines-1,$#_)]];
    push @$uuM,[Cascade=> 'More...', -menuitems=> $m];
    $uuM=$m;
    $i+=$maxMenuLines;
  }
  return $uM;
}

sub saveFileStateUpdate {
  my ($win)=@_;
  return unless isFocused($win);
  return unless $win->{framegroup}->{saveButton};
  $win->{framegroup}->{saveButton}->
    configure(-state => (($win->{FSFile} and $win->{FSFile}->notSaved) ? 'normal' : 'disabled'));
#    configure(-image=>
#	      ($win->{FSFile} and $win->{FSFile}->notSaved)
#	      ? $normalSavePixmap : $savedSavePixmap);
}


sub About {
  my ($grp)=@_;
  my $message="";
  my $contextinfo="";
  my $fileinfo="";
  my $colinf="";
  if ($grp->{focusedWindow}->{FSFile}) {
    $fileinfo=
      "Current file:\n".
	$grp->{focusedWindow}->{FSFile}->filename."\n".
	  "Format: ".$grp->{focusedWindow}->{FSFile}->fileFormat.", ".$grp->{focusedWindow}->{FSFile}->lastTreeNo." trees\n";
    $contextinfo="Current context: ".$grp->{focusedWindow}->{macroContext}."\n";
    my %colinf=(Shadow=> [], Hilite=>, XHilite=> []);
    foreach ($grp->{focusedWindow}->{FSFile}->FS->attributes) {
      push @{$colinf{$grp->{focusedWindow}->{FSFile}->FS->color($_)}},$_
	unless ($grp->{focusedWindow}->{FSFile}->FS->color($_) eq 'normal');
    }
    $colinf="Coloured attributes:\n    Highlited: ".join(",",@{$colinf{Hilite}}).
      "\n    XHighlited: ".join(",",@{$colinf{XHilite}}).
	"\n    Shadow: ".join(",",@{$colinf{Shadow}})."\n";
  }

  doEvalHook($grp->{focusedWindow},"about_file_hook",\$message);
  my $ver=$version;
  $ver=~s/\$//g;
  $grp->{top}->toplevel->
    messageBox(-icon=> 'info',
			  -type=> 'ok',
			  -message=>
			  "TrEd $ver\nTk $Tk::VERSION\n\n$fileinfo$contextinfo$colinf$message\n$about\n",
			  -title=> 'About');
}

sub newTrEdWindow {
  my ($grp)=@_;

  my $win= new TrEd::Window(newTreeView($grp),framegroup=>$grp);
  $win->{macroContext}= $opt_t && exists($keyBindings{$opt_t}) 
    ? $opt_t : 'TredMacro';
  $win->{stylesheet} = STYLESHEET_FROM_FILE();
  push @{$grp->{treeWindows}}, $win;
  return $win;
}

sub newTreeView {
  my ($grp)=@_;

  my $canvas=
    $grp->{top}->Scrolled('Canvas',
		   -width=> $defCWidth,
		   -height=> $defCHeight,
		   qw /-relief sunken
		       -borderwidth 2
                       -scrollbars osoe/,
		   -scrollregion=> [qw/0c 0c 1c 1c/],
		   $treeViewOpts->{backgroundColor} 
		   ? (-background=> $treeViewOpts->{backgroundColor}) : ()
		  );
  canvasBindMouseWheelVert($canvas);
  canvasBindMouseWheelHoriz($canvas,"Shift");
  createCanvasBindings($grp,$canvas);
  addBindTags($canvas,'my');
  addBindTags($canvas->Subwidget('scrolled'),'canvas');

  my $balloon=$grp->{top}->Balloon(-initwait=> $canvasBalloonInitWait,
				  -state=> 'balloon',
				 );
  $balloon->Subwidget('message')->configure(-foreground=> $canvasBalloonForeground);

  $balloon->Tk::Toplevel::configure(-background=> $canvasBalloonBackground);
  $balloon->Subwidget('message')->configure(-justify=> 'left',-font=> $font);
  my $treeView=new TrEd::TreeView($canvas,'CanvasBalloon'=> $balloon);
  $treeView->apply_options($treeViewOpts);
  return $treeView;
}

sub findCanvasWindow {
  my ($grp,$canvas)=@_;
  foreach my $w (@{$grp->{treeWindows}}) {
    return $w if $w->contains($canvas);
  }
  return undef;
}

sub focusCanvas {
  my ($c,$grp)=@_;
  if ($grp->{focusedWindow}) {
    return if $grp->{focusedWindow}->contains($c);
    $grp->{focusedWindow}->canvas()->configure(@normal_win_opts);
    $grp->{focusedWindow}->canvas()->itemconfigure('stipple',-state=> $stippleInactiveWindows ? 'normal' : 'hidden');
    $grp->{focusedWindow}->canvas()->update();
  }
  if ($c) {
    $c->configure(@focused_win_opts);
    $c->itemconfigure('stipple',-state=> 'hidden');
    $c->update();
  }
  my $newfocus=findCanvasWindow($grp,$c);
  if ($newfocus) {
    $grp->{selectedContext}=$newfocus->{macroContext};
    $grp->{selectedStylesheet}=$newfocus->{stylesheet};
    $treeViewOpts->{drawBoxes}=$newfocus->{treeView}->get_drawBoxes();
    $treeViewOpts->{drawEdgeBoxes}=$newfocus->{treeView}->get_drawEdgeBoxes();
    $treeViewOpts->{showHidden}=$newfocus->{treeView}->get_showHidden();
    $treeViewOpts->{highlightAttributes}=$newfocus->{treeView}->get_highlightAttributes;
    $grp->{focusedWindow}=$newfocus;
    update_value_line($grp);
    update_status_line($grp->{focusedWindow});
    update_value_line_current($newfocus,$newfocus->{currentNode});
    updateTitle($grp);
    resetUndoStatus($newfocus);
    resetTreePosStatus($grp);
  } else {
    print STDERR "DID NOT FIND Window of $c\n";
  }
}

sub splitWindow {
  my ($grp,$dir,$nofocus)=@_;
  my $twin     = newTrEdWindow($grp);
  my $canvas=$twin->canvas();
  $canvas->configure(@normal_win_opts);
  $grp->{focusedWindow}->split_frame($canvas,$dir);
  foreach (qw(FSFile treeNo currentNode currentFileNo macroContext currentFilelist)) {
    $twin->{$_}=$grp->{focusedWindow}->{$_};
  }
  applyWindowStylesheet($twin,$grp->{selectedStylesheet});
  get_nodes_win($twin);
  redraw_win($twin);
  focusCanvas($canvas,$grp) unless $nofocus;
}

sub removeWindow {
  my ($grp)=@_;
  my $win=$grp->{focusedWindow};
  if (@{$grp->{treeWindows}}>1) {
    @{$grp->{treeWindows}}=grep {$_ ne $win} @{$grp->{treeWindows}};
    closeFile($win,-no_update => 1, -keep_postponed => 1);
    my $brother=$win->canvas_destroy();
    delete $grp->{focusedWindow};
    focusCanvas($brother,$grp);
    $win->{treeView}=undef;
    undef $win;
  }
}

sub canvasBindMouseWheelVert {
    my($w,$modifier)= @_;
    $modifier.="-" if ($modifier);
    $w->CanvasBind("<$modifier"."MouseWheel>",
              [ sub { $_[0]->yview('scroll',-($_[1]/120)*3,'units') }, Tk::Ev("D")]);
#    if ($Tk::platform eq 'unix') {
    $w->CanvasBind("<$modifier"."4>", sub { $_[0]->yview('scroll', -3, 'units')
					      unless $Tk::strictMotif; });
    $w->CanvasBind("<$modifier"."5>", sub { $_[0]->yview('scroll', 3, 'units')
					      unless $Tk::strictMotif; });
    if ($modifier eq "") {
      $w->CanvasBind("<6>", sub { $_[0]->xview('scroll', -3, 'units')
				    unless $Tk::strictMotif; });
      $w->CanvasBind("<7>", sub { $_[0]->xview('scroll', 3, 'units')
				    unless $Tk::strictMotif; });
    }

#    }
}

sub canvasBindMouseWheelHoriz {
    my($w,$modifier)= @_;
    $modifier.="-" if ($modifier);
    $w->CanvasBind("<$modifier"."MouseWheel>",
              [ sub { $_[0]->xview('scroll',-($_[1]/120)*3,'units') }, Tk::Ev("D")]);
    if ($Tk::platform eq 'unix') {
        $w->CanvasBind("<$modifier"."4>", sub { $_[0]->xview('scroll', -3, 'units')
				      unless $Tk::strictMotif; });
        $w->CanvasBind("<$modifier"."5>", sub { $_[0]->xview('scroll', 3, 'units')
				      unless $Tk::strictMotif; });
    }
}

sub keyBind {
  local $_=shift;
  s/-/+/g;
  s/Control/CTRL/g;
  return uc($_);
}

sub createCanvasBindings {
  my ($grp,$canvas) = @_;

  ## Canvas bindings 
  $canvas->CanvasBind('<ButtonPress>',[\&focusCanvas,$grp]);
  $canvas->bind('text',
		'<Any-Enter>'
		=> [sub{
		      my ($c,$grp)=@_;
		      my $win=findCanvasWindow($grp,$c);
		      my $tv=$win->{treeView};
		      my ($t)=$tv->find_item('withtag','current');
		      my $node=$tv->get_obj_pinfo($t);
		      $tv->store_node_pinfo($node,"SaveColor",
					    $c->itemcget($t,'-fill'));
		      $c->itemconfigure($t,-fill=> $activeTextColor);
		    }, $grp]);

  $canvas->bind('text',
		'<Any-Leave>'
		=> [sub{
		      my ($c,$grp)=@_;
		      my $win=findCanvasWindow($grp,$c);
		      my $tv=$win->{treeView};
		      my ($t)=$tv->find_item('withtag','current');
		      my $node=$tv->get_obj_pinfo($t);
		      $c->itemconfigure('current',
					-fill=>
					$tv->get_node_pinfo($node,"SaveColor"));
		    }, $grp]);

  # Button-1
  $canvas->bind('point', '<1>'=> [sub {node_down(@_) },$grp,0]);
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('point', "<$_-Button-1>"=> [sub {node_click_modif(@_)},$grp,$_]);
  }
  $canvas->bind('point', '<ButtonRelease-1>'=> [sub {node_release(@_)},$grp,0]);
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('point', "<$_-ButtonRelease-1>"=> [sub {node_release_modif(@_)},$grp,$_]);
  }
  $canvas->bind('point', '<B1-Motion>'=> [sub {node_move(@_)},$grp]);
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('point', "<$_-B1-Motion>"=> [sub {node_motion_modif(@_)},$grp]);
  }

  # Button-3
  $canvas->bind('point','<3>'=> [sub {node_down(@_)},$grp,1]);
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('point', "<$_-Button-3>"=> [sub {node_click_modif(@_)},$grp,$_."-3"]);
  }
  $canvas->bind('point', '<ButtonRelease-3>'=> [sub {node_release(@_)},$grp,3]);
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('point', "<$_-ButtonRelease-3>"=> [sub {node_release_modif(@_)},$grp."-3"]);
  }
  $canvas->bind('point','<B3-Motion>'=> [sub {node_move(@_)},$grp,1]);
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('point', "<$_-B3-Motion>"=> [sub {node_motion_modif(@_)},$grp."-3"]);
  }

  # Button-2
  $canvas->CanvasBind('<2>'=> [sub {follow_mouse_press(@_)},$grp]);
  $canvas->CanvasBind('<B2-Motion>'=> [sub {follow_mouse(@_)},$grp]);

  # Button-2
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('point', "<$_-Button-2>"=> [sub {node_click_modif(@_)},$grp,$_."-2"]);
  }
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('point', "<$_-ButtonRelease-2>"=> [sub {node_release_modif(@_)},$grp."-2"]);
  }
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('point', "<$_-B2-Motion>"=> [sub {node_motion_modif(@_)},$grp."-2"]);
  }


  # Double-1
  $canvas->bind('point', '<Double-1>'=> [sub { editAttrs(@_); Tk->break; },$grp]);
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('point', "<$_-Double-1>"=> [sub {node_doubleclick_modif(@_)},$grp,$_]);
  }

  # Text 1
  $canvas->bind('text', '<1>'=> [sub {node_down(@_) },$grp,0]);
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('text', "<$_-Button-1>"=> [sub {text_click_modif(@_)},$grp,$_]);
  }

  # Text Dobule-1
  $canvas->bind('text', '<Double-1>'=> [sub { editAttr(@_); Tk->break; },$grp]);
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('text', "<$_-Double-1>"=> [sub {text_doubleclick_modif(@_)},$grp,$_]);
  }

  # TextBg
  $canvas->bind('textbg', '<1>'=> [sub {node_down(@_) },$grp,0]);
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('textbg', "<$_-Button-1>"=> [sub {text_click_modif(@_)},$grp,$_]);
  }
  $canvas->bind('textbg', '<Double-1>'=> [sub { editAttr(@_); Tk->break; },$grp]);
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('textbg', "<$_-Double-1>"=> [sub {text_doubleclick_modif(@_)},$grp,$_]);
  }

  # TextBg 3
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('textbg', "<$_-Button-3>"=> [sub {text_click_modif(@_)},$grp,$_."-3"]);
  }
  # TextBg Double-3
  foreach (qw(Shift Control Alt Meta)) {
    $canvas->bind('textbg', "<$_-Double-3>"=> [sub {text_doubleclick_modif(@_)},$grp,$_."-3"]);
  }
}

sub startMain {
  my $firstFile=shift;
  my $node;
  my $parent;
  my %group;

  if ($opt_W) {
    $group{top}=MainWindow->new(-use => $opt_W);
  } else {
    $group{top}=MainWindow->new();
  }

#  eval {
#    require Tk::Stderr;
#    $group{top}->InitStderr;
#  } unless -t \*STDOUT;
#  undef $@;

  for (qw(ROText Text Entry HistEntry SimpleHistEntry
	  Listbox HList CodeText)) {
    $group{top}->option('add',"\*$_.background","white");
    $group{top}->option('add',"\*$_.foreground","black");
    $group{top}->option('add',"\*$_.disabledBackground","lightgray");
    $group{top}->option('add',"\*$_.disabledForeground","gray20");
  }
  if ($TrEd::Convert::support_unicode) {
    $group{top}->useinputmethods(1);
  }
  readStyleSheets(\%group);

  $group{autoSaveCallback}=$group{top}->repeat($autoSave*60000,
					       [\&autoSaveAll,\%group]) if $autoSave>0;

  $group{folderImage}= icon(\%group,'folder');
  $group{fileImage}  = icon(\%group,'document');
  $group{lastActionBookmark}= $lastAction;
  $group{selectedContext}=$opt_t || 'TredMacro';
  $group{buildTGTSfromCSTS}=$opt_R;

  if (not $opt_G and defined($geometry)) {
    if ($geometry=~/^(.*)x(.*)\+([0-9]+)\+([0-9]+)/) {
        $geometry
	 = "$1x$2+".min($3,$group{top}->vrootwidth-$1).
	    "+".min($4,$group{top}->vrootheight-$2);
    }
    $group{top}->geometry($geometry);
  }
  if ($opt_W) {

    $geometry = "600x400";
    $group{top}->sizefrom('program');
    $group{top}->geometry($geometry);
  }
  prepareFonts(\%group);
  $group{treeWindows}=[];
  $group{focusedWindow}=newTrEdWindow(\%group);
  my $canvas = $group{focusedWindow}->canvas();
  $canvas->configure(@focused_win_opts);

  print "Starting in context $group{focusedWindow}->{macroContext}\n" if $tredDebug;

  $group{templateMatchMethod}=$defaultTemplateMatchMethod;
  $group{macroListOrder}=$defaultMacroListOrder;
  print STDERR "Main window created.\n" if $tredDebug;

  if (-f $appIcon) {
    print STDERR "adding icon-image.\n" if $tredDebug;
    $group{top}->iconimage($group{top}->Pixmap(-file=> "$appIcon"));
    print STDERR "done.\n" if $tredDebug;
  }

#  $group{top}->focusFollowsMouse;
  addBindTags($group{top},'my');

  print STDERR "Asking wm for exit-hook.\n" if $tredDebug;

  $group{top}->
    protocol('WM_DELETE_WINDOW'=> 
	     [sub { my $grp=shift;
		    doEvalHook($grp->{focusedWindow},"exit_hook");
		    # run user's exit_hook
		    return if askSaveFiles($grp,1) == -1;
		    #closeFile($grp->{focusedWindow}, -all_windows => 1);
		    $grp->{top}->destroy;
		    $grp->{top}=undef;
		  },\%group]);


  print STDERR "Exit hook created.\n" if $tredDebug;

  $group{Balloon}=$group{top}->Balloon(-initwait=> $toolbarBalloonInitWait,
				       -balloonposition=> 'mouse',
				       -state=> 'balloon',
				      );
  $group{Balloon}->Subwidget('message')->configure(-foreground=> $toolbarBalloonForeground);
  $group{Balloon}->Tk::Toplevel::configure(-background=> $toolbarBalloonBackground);
  $group{frame}=$group{top}->Frame;

  print STDERR "Creating menubar.\n" if $tredDebug;


  $group{Menubar}=$group{top}->Frame(-relief=> $menubarRelief, -borderwidth=> 2);
  $group{Menubar}->pack(qw/-fill x/);
  $group{top}->Frame(qw/-relief sunken -height 2 -borderwidth 2/)->pack(qw/-fill x/);
  addBindTags($group{Menubar},'my');

  $group{FileMenu}= $group{Menubar}->Menubutton(qw/-text File -underline 0/);
  $group{FileMenu}->command(-label=> 'Open ...',
			    -underline=> 0,
			    -command=> [\&fileDialog, \%group]);
  $group{FileMenu}->command(-label=> 'Open URL ...',
			    -underline=> 5,
			    -command=> [\&urlDialog, \%group]);
  $group{FileMenu}->cascade(-label=> 'New',
			    -underline=>2,
			    -menuitems=>
			    [
			     [Button => 'From Template ...',
			      -underline=> 5,
			      -command=> [ \&fileDialog, \%group,1]
			     ],
			     [Button => 'From Current ...',
			      -underline=> 5,
			      -command=> [\&newFileFromCurrent, \%group, 1]
			     ]
			    ]
			   );
  $group{FileMenu}->command(-label=> 'Close',
			    -underline=> 0,
			    -command=> [ sub {
					    my ($grp)=@_;
					    return if askSaveFile($grp->{focusedWindow},0,1) == -1;
					    closeFile($grp->{focusedWindow},-all_windows => 1);
					  }
					 , \%group]);
  $group{FileMenu}->command(-label=> 'Close in Window',
			    -underline=> 7,
			    -command=> [ sub {
					    my ($grp)=@_;
					    my $keep;
					    if (fsfileDisplayingWindows($grp,
						$grp->{focusedWindow}->{FSFile})<2) {
					      $keep=askSaveFile($grp->{focusedWindow},1,1);
					      return if $keep == -1;
					    }
					    closeFile($grp->{focusedWindow}, -keep_postponed => $keep);
					  }
					 , \%group]);
  $group{FileMenu}->command(-label=> 'Close and remove from filelist',
			    -command=> [ sub {
					    my ($grp)=@_;
					    if (ref($grp->{focusedWindow}->{currentFilelist})) {
					      my $lr = $grp->{focusedWindow}->{currentFilelist}->list_ref;
					      removeFromFilelist($grp,
								 undef,
								 undef,
								 $lr->[$grp->{focusedWindow}->{currentFileNo}]) if $lr;
					    }
					    return if askSaveFile($grp->{focusedWindow},0,1) == -1;
					    closeFile($grp->{focusedWindow},-all_windows => 1);
					  }
					 , \%group]);

  $group{FileMenu}->command(-label=> 'File List...',
			    -underline=> 5,
			    -command=> [\&filelistDialog, \%group]);
#	 [Button=> 'New',         -command=> [\&menus_error2, 'New']],
  $group{FileMenu}->command(-label=> 'Save',
			    -underline=> 0,
			    -command=> [ sub { saveFile($_[0]->{focusedWindow}); },\%group]);
  $group{FileMenu}->command(-label=> 'Save As ...', 
			    -underline=> 5 ,
			    -command=> [ sub { saveFileAs($_[0]->{focusedWindow}); }, \%group]);
  $group{FileMenu}->separator();
  $group{RecentFileMenu}=$group{FileMenu}->cascade(-label=> "Recent Files",
						   -underline=> 0);
  my $i=0;
  foreach (@recentFiles) {
    $group{RecentFileMenu}->command(-label => "$i.  $_",
				    -underline=> 0,
				    -command=> [\&openStandaloneFile,\%group,$_]);
    $i++;
  }
#  $group{PostponedFileMenu}=$group{FileMenu}->cascade(-label=> "Postponed Files", -underline=> 0);

  $group{FileMenu}->separator();
  $group{FileMenu}->command(-label=> 'Previous File',
			    -underline=> 3,
			    -command=> [\&tiePrevFile,\%group]);
  $group{FileMenu}->command(-label=> 'Next File',
			    -underline=> 0,
			    -command=> [\&tieNextFile,\%group]);
  $group{FileMenu}->separator();
  $group{FileMenu}->command(-label=> 'Print ...',
			    -underline=> 0,
			    -command=> [\&printThis,\%group]);
  $group{FileMenu}->separator();
  $group{FileMenu}->command(-label=>'Edit config file ...',
			    -underline=> 0,
			    -command=> [\&editConfig,\%group]);
  $group{FileMenu}->command(-label=>'Reload config ...',
			    -underline=> 3,
			    -command=> [sub {
					  read_config();
					  reconfigure($_[0]);
					  redraw_all($_[0]);
					},\%group]);
  $group{FileMenu}->command(-label=>'Reload stylesheets ...',
			    -underline=> 3,
			    -command=> [sub {
					  readStyleSheets($_[0]);
					  redraw_all($_[0]);
					},\%group]);
  $group{FileMenu}->separator();
  $group{FileMenu}->command(-label=>'Quit',
			    -underline=> 0,
			    -command=> [sub {
					  my $grp=shift;
					  $grp->{top}->destroy
					    unless askSaveFiles($grp,1) == -1;
					},\%group]);
	
  $group{FileMenu}->pack(qw/-side left/);

  $group{ViewMenu}= $group{Menubar}->Menubutton(qw/-text View -underline 0 -menuitems/=>
	[
	 [Button=> 'Previous Tree',
	  -underline=> 0,
	  -command=> [sub {
			tiePrevTree($_[0]);
		      },\%group]],
	 [Button=> 'Next Tree',
	  -underline=> 0,
	  -command=> [sub {
			tieNextTree($_[0]);
		      },\%group]],
	 [Separator=> ''],
	 [Checkbutton=> 'Stipple Inactive Views', -underline=> 17,
	  -variable=> \$stippleInactiveWindows,
	  -command => [\&update_treeviews,\%group]],
	 [Checkbutton=> 'Draw boxes around labels', -underline=> 0,
	  -variable=> \$treeViewOpts->{drawBoxes},
	  -command => [sub {
			 my ($grp)=@_;
			 # vice versa setting should be done when focus changes
			 $grp->{focusedWindow}->{treeView}->set_drawBoxes($treeViewOpts->{drawBoxes});
			 redraw_win($grp->{focusedWindow});
		       },\%group]],
	 [Checkbutton=> 'Draw boxes around edge labels', -underline=> 1,
	  -variable=> \$treeViewOpts->{drawEdgeBoxes},
	  -command => [sub {
			 my ($grp)=@_;
			 # vice versa setting should be done when focus changes
			 $grp->{focusedWindow}->{treeView}->set_drawEdgeBoxes($treeViewOpts->{drawEdgeBoxes});
			 redraw_win($grp->{focusedWindow});
		       },\%group]],
	 [Checkbutton=> 'Show Hidden Nodes', -underline=> 0,
	  -underline=> 5,
	  -variable=> \$treeViewOpts->{showHidden},
	  -command => [sub {
			 my $win=$_[0]->{focusedWindow};
			 $win->{treeView}->set_showHidden($treeViewOpts->{showHidden});
			 get_nodes_win($win);
			 redraw_win($win);
			 ensureCurrentIsDisplayed($win);
		       },\%group]],
	 [Checkbutton=> 'Highlight Attributes', -underline=> 1,
	  -variable=> \$treeViewOpts->{highlightAttributes},
	  -command => [sub {
			   my ($grp)=@_;
			   $grp->{focusedWindow}->{treeView}->set_highlightAttributes($treeViewOpts->{highlightAttributes});
			   redraw_win($grp->{focusedWindow});
			 },\%group]],
	 [Checkbutton=> 'Sort Attributes in Dialogs', -underline=> 1,
	  -variable=> \$sortAttrs],
	 [Separator=> ''],
	 [Button=> "[1] Close current view", -underline=> 1,
	  -command=> [\&removeWindow,\%group]],
	 [Button=> "[2] Split view horizontally", -underline=> 1,
	  -command=> [\&splitWindow,\%group,'horiz']],
	 [Button=> "[3] Split view vertically", -underline=> 1,
	  -command=> [\&splitWindow,\%group,'vert']],
	 [Separator=> ''],
	 [Button=> 'List of sentences ...', -underline=> 8,
	  -command=> [\&viewSentences,\%group]],
	 [Button=> 'Select context ...', -underline=> 12,
	  -command=> [\&selectContext,\%group]],
	 [Button=> 'Select stylesheet ...', -underline=> 9,
	  -command=> [\&selectStylesheet,\%group]],
	 [Separator=> ''],
	 [Button=> 'Edit stylesheet ...', -underline=> 0,
	  -command=> [\&editStylesheetDialog,\%group]],
	 [Separator=> ''],
	 [Button=> 'List of Named Macros ...', -underline=> 0,
	  -command=> [\&macrolistDialog,\%group]]
	])->pack(qw/-side left/);
  $group{NodeMenu}= $group{Menubar}->Menubutton(qw/-text Node -underline 0 -menuitems/=>
	[
	 [Button=> 'New Node', -underline=> 0, -command=> [sub {
					       my ($grp)=@_;
					       my $win=$grp->{focusedWindow};
					       save_undo($win,prepare_undo($win,"New Node"));
					       newNode($win);
					     },\%group]],
	 [Button=> 'Remove Active Node', -underline=> 0, -command=> [sub {
					       my ($grp)=@_;
					       my $win=$grp->{focusedWindow};
					       save_undo($win,prepare_undo($win,'Remove Active Node'));
					       pruneNode($win,$win->{currentNode});
					     },\%group]],
	 [Button=> 'Insert New Tree', -underline=> 0, -command=> [sub {
						      my ($grp)=@_;
						      newTree($grp->{focusedWindow});
						    },\%group]],
	 [Button=> 'Insert New Tree After', -underline=> 16, -command=> [sub {
						      my ($grp)=@_;
						      newTreeAfter($grp->{focusedWindow});
						    },\%group]],
	 [Button=> 'Remove Whole Current Tree', -underline=> 7, -command=> [sub {
						      my ($grp)=@_;
						      pruneTree($grp->{focusedWindow});
						    },\%group]],
	 [Separator=> ''],
	 [Button=> 'Copy Trees ...', -underline=> 1,
	  -command=> [\&copyTreesDialog,\%group]],
	 [Separator=> ''],
	 [Button=> 'Edit Node ...',
	  -underline=> 0,
	  -command=> [sub {
			my ($grp)=@_;
			editAttrsDialog($grp->{focusedWindow},
					$grp->{focusedWindow}->{currentNode})
			  if ($grp->{focusedWindow}->{currentNode});
		      },\%group]],
	 [Separator=> ''],
	 [Button=> 'Find ...',
	  -underline=> 0,
	  -command=> [sub {
			my ($grp,$template)=@_;
			findNodeDialog($grp,$template)
			  if ($grp->{focusedWindow}->{currentNode});
		      },\%group,\%searchTemplate]],
	 [Button=> 'Find Next', -underline=> 7,
	  -command=> [\&doFindFirstTemplated,\%group,\%searchTemplate,1]],
	 [Button=> 'Find Previous', -underline=> 5,
	  -command=> [\&doFindPrevTemplated,\%group,\%searchTemplate,1]]

	])->pack(qw/-side left/);
  print STDERR "Creating user menu.\n" if $tredDebug;


  $group{PostponedFileMenu}= $group{Menubar}->Menubutton(qw/-text Session -underline 0/)
    ->pack(qw/-side left/);
  updatePostponed(\%group);

  $group{BookmarksFileMenu}= $group{Menubar}->Menubutton(qw/-text Bookmarks -underline 0/)
    ->pack(qw/-side left/);
  updateBookmarks(\%group);

  $group{ContextsMenu}=$group{Menubar}->
    Optionmenu(-options => [getContexts()],
	       -textvariable=> \$group{selectedContext},
	       -command=> [sub { my ($grp,$context) = @_;
				 switchContext($grp->{focusedWindow}, $context);
			       },\%group],
	       -relief=> 'groove', #$menubarRelief,
	       -borderwidth=> 2)->pack(qw/-side right -padx 5/);
  $group{Balloon}->attach($group{ContextsMenu},
			  -balloonmsg=> "macro context");

  my $cM=[];
  if ($createMacroMenu) {
#     push @$cM, 
#       @{cascadeMenus(map { $keyBindings{TredMacro}->{$_}=~/TredMacro\-\>(.*)/;
# 			   [Button=> $1,
# 			    -command=> [ sub {
# 					   doEvalMacro($_[0]->{focusedWindow},
# 						       $_[1]);
# 					 },\%group,
# 					 $keyBindings{TredMacro}->{$_}],
# 			    -accelerator=> "($_)"
# 			   ]
# 			 } sort(keys(%{$keyBindings{TredMacro}})))};

    foreach my $context (sort(keys(%keyBindings))) {
#      if ($context ne "TredMacro") {
	push @$cM,
	  [Cascade=> $context,
	   -menuitems=>
	   cascadeMenus(map { $keyBindings{$context}->{$_}=~/(?:$context\-\>)?(.*)/;
			      [Button=> $1,
			       -command=> [sub {
					   doEvalMacro($_[0]->{focusedWindow},
						       $_[1]);
					 },\%group,
					   $keyBindings{$context}->{$_}],
			       -accelerator=> "($_)"
			      ]
			    } sort(keys(%{$keyBindings{$context}})))];
#      }
    }

    $group{MacroMenu}=$group{Menubar}->
      Menubutton(qw/-text Shortcuts -underline 2 -menuitems/=>
		 $cM)->pack(qw/-side left/);
  }
  $cM=[];
#   push @$cM,
#     @{cascadeMenus(map ([Button=> $_,
# 			 -command=> [sub {
# 				       doEvalMacro($_[0]->{focusedWindow},
# 						   $_[1]);
# 				     },
# 				     \%group,$menuBindings{TredMacro}->{$_}->[0]],
# 			 ($menuBindings{TredMacro}->{$_}->[1]) ?
# 			 (-accelerator=> "(".$menuBindings{TredMacro}->{$_}->[1].")") : ()],
# 			sort(keys(%{$menuBindings{TredMacro}}))))};

  foreach my $context ("TredMacro",grep { $_ ne "TredMacro" } sort(keys(%menuBindings))) {
#   if ($context eq "TredMacro") { 
#   } else {
        push @$cM,
  	[Cascade=> $context,
  	 -menuitems=>
  	 cascadeMenus(map ([Button=> "$_",
  			    -command=> [sub {
					  doEvalMacro($_[0]->{focusedWindow},
						      $_[1]);
					 },
					\%group,
					$menuBindings{$context}->{$_}->[0]],
  			    ($menuBindings{$context}->{$_}->[1]) ?
  			    (-accelerator=> "(".$menuBindings{$context}->{$_}->[1].")") : ()],
  			   sort(keys(%{$menuBindings{$context}}))))];
#      }
  }
  $group{UserMenu}=$group{Menubar}->
    Menubutton(qw/-text User-defined -underline 0 -menuitems/=>
	       $cM)->pack(qw/-side left/);




  addBindTags($group{frame},'my');

  $group{HelpMenu}= $group{Menubar}->Menubutton(qw/-text Help -underline 0 -menuitems/=>
	[
	 [
	  Button=> 'About',
	  -underline=> 0,
	  -command=> [\&About,\%group]
	 ],
	 [
	  Button=> 'Examine bindings',
	  -underline=> 0,
	  -command=> [\&examineBindingsDialog,\%group]
	 ],
	 [Button => 'Reload macros', -underline => 0,
	  -command => [sub {
			 my ($grp)=@_;
			 doEvalHook($grp->{focusedWindow},"reload_macros_hook");
			 cleanup_tredmacro($grp);
			 read_macros($macroFile,$libDir);
			 if ($opt_I) {
                           push @TrEd::Macros::macros,"\n","package TredMacro;\n";
                           read_macros($opt_I,$libDir,1);
                         }
			 doEvalHook($grp->{focusedWindow},"macros_reloaded_hook");
			 redraw_all($grp);
		       },\%group]],
	 
	 [
	  Cascade=> 'Debugging messages',
	  -underline => 0,
	  -menuitems => [
			 [Checkbutton => 'tred', -underline => 0,
			  -variable => \$tredDebug],
			 [Checkbutton => 'macros', -underline => 0,
			  -variable => \$macroDebug],
			 [Checkbutton => 'hooks', -underline => 0,
			  -variable => \$hookDebug],
			 [Checkbutton => 'keyboard', -underline => 0,
			  -variable => \$keyboardDebug],
			 [Checkbutton => 'backend', -underline => 0,
			  -variable => \$Fslib::Debug],
			 [Checkbutton => 'view', -underline => 0,
			  -variable => \$TrEd::TreeView::Debug],
			]
	 ]
	])->pack(qw/-side left/);

  require Tk::Adjuster;
  $group{vLineFrame}=$group{top}->Frame();
  $group{valueLine}=
    $group{vLineFrame}->
      Scrolled(qw/ROText
		  -takefocus 0
		  -state disabled
                  -relief sunken -borderwidth 2
		  -scrollbars ose/,
		  -font => $vLineFont,
		  -height => $valueLineHeight,
	          ($valueLineReverseLines ? () : (-wrap => $valueLineWrap))
	      );
  $group{valueLine}->Subwidget('scrolled')->menu->delete('File');
  if ($displayStatusLine) {
#c		  -background white
    $group{statusLine}=
      $group{top}->
	ROText(qw(-takefocus 0
		  -state disabled
		  -borderwidth 2
		  -height 1
		 ),
	       -relief => 'sunken',
	       -font => $vLineFont);
    $group{statusLine}->menu->delete('File');
    $group{statusLine}->bind('<1>',
			    [sub {
				my ($w,$grp)=@_;
				my $Ev=$w->XEvent;
				my $win=$grp->{focusedWindow};
				doEvalHook($win,"status_line_click_hook",
					   $w->tagNames($w->index($Ev->xy)));
				Tk->break;
			      },\%group]
			   );
    $group{statusLine}->bind('<Double-1>',
			    [sub {
				my ($w,$grp)=@_;
				my $Ev=$w->XEvent;
				my $win=$grp->{focusedWindow};
				doEvalHook($win,"status_line_doubleclick_hook",
					   $w->tagNames($w->index($Ev->xy)));
				Tk->break;
			      },\%group]
			   );

  }
  $group{valueLine}->tagConfigure('current',
				  -background => $valueLineFocusBackground,
				  -foreground => $valueLineFocusForeground,
				 );
  $group{valueLine}->bind('<Double-1>',
			     [sub {
				my ($w,$grp)=@_;
				my $Ev=$w->XEvent;
				my $win=$grp->{focusedWindow};
				my (@tags)=
				  $w->tagNames($w->index($Ev->xy));
				my $ret;
				$ret = doEvalHook($win,"value_line_doubleclick_hook", @tags);
				if (ref($ret) and ref($ret) =~ /^FSNode/) {
				  setCurrent($win,$ret);
				  ensureCurrentIsDisplayed($win);
				  centerTo($win,$ret);
				  Tk->break;
				  return;
				} elsif ($ret ne 'stop') {
				  my $node=$win->{root};
				  while ($node) {
				    if (index(join("",@tags),${node})>=0) {
				      setCurrent($win,$node);
				      ensureCurrentIsDisplayed($win);
				      centerTo($win,$node);
				      Tk->break;
				      return;
				    }
				    $node=$node->following();
				  }
				}
				Tk->break;
			      },\%group]
			     );

  $group{vLineSeparator}=$group{top}->Adjuster();
  eval { # supported only on some platforms/version of Tk
    $group{valueLine}->configure(-foreground => $valueLineForeground,
                                 -background => $valueLineBackground);
  };
  $group{valueLine}->BindMouseWheelHoriz();


  print STDERR "Creating buttons.\n" if $tredDebug;

  $group{nextButton}=
    $group{frame}->Button(-takefocus=>0,
			  -text=> "Next",
			  -relief=> $buttonsRelief,
			  -image=> icon(\%group,"1rightarrow"),
			  -state=> 'disabled',
			  -borderwidth=> $buttonBorderWidth,
			  -command=>
			  [\&tieNextTree,\%group]);
  $group{Balloon}->attach($group{nextButton},
			  -balloonmsg=> "see the next tree in the file");
  addBindTags($group{nextButton},'my');

  $group{prevButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Prev",
			  -relief=> $buttonsRelief,
			  -image=> icon(\%group,"1leftarrow"),
			  -state=> 'disabled',
			  -borderwidth=> $buttonBorderWidth,
			  -command=>
			  [\&tiePrevTree,\%group]);
  $group{Balloon}->attach($group{prevButton},
			  -balloonmsg=> "see the previous tree the file");
  addBindTags($group{prevButton},'my');

  $group{openButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Open",
			  -relief=> $buttonsRelief,
			  -image=>
			  icon(\%group,"fileopen"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=>
			  [\&fileDialog,\%group])
      ->pack(-side=>'left',-padx=>'1');
  $group{Balloon}->attach($group{openButton},
		 -balloonmsg=> "open file");
  addBindTags($group{openButton},'my');
  $normalSavePixmap=icon(\%group,"filesave");
  $savedSavePixmap=icon(\%group,"filesaved");
  $group{saveButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Save",
			  -relief=> $buttonsRelief,
			  -image=> $normalSavePixmap,
			  -state => 'disabled',
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&saveFile,\%group])->pack(-side=>'left',-padx=>'1');

  $group{Balloon}->attach($group{saveButton},
			  -balloonmsg=> "save current file");
  addBindTags($group{saveButton},'my');

  $group{reloadButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Reload",
			  -relief=> $buttonsRelief,
			  -image=> icon(\%group,"reload"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&reloadFile,\%group])->pack(-side=>'left',-padx=>'1');

  $group{Balloon}->attach($group{reloadButton},
			  -balloonmsg=> "reload current file");
  addBindTags($group{reloadButton},'my');

  # Undo button

  $group{undoButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Undo",
			  -relief=> $buttonsRelief,
			  -image=> icon(\%group,"undo"),
			  -state=> 'disabled',
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&undo,\%group])->pack(-side=>'left',-padx=>'1');
  $group{Balloon}->attach($group{undoButton},
			  -balloonmsg=> "undo current file");
  addBindTags($group{undoButton},'my');

  # Redo button

  $group{redoButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Redo",
			  -relief=> $buttonsRelief,
			  -image=> icon(\%group,"redo"),
			  -state=> 'disabled',
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&re_do,\%group])->pack(-side=>'left',-padx=>'1');
    
  $group{Balloon}->attach($group{redoButton},
			  -balloonmsg=> "redo current file");
  addBindTags($group{redoButton},'my');



  $group{prevFileButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Prev file",
			  -relief=> $buttonsRelief,
			  -image=> icon(\%group,"start"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&tiePrevFile,\%group])->pack(-side=>'left',
									    -padx=>'1');
  $group{Balloon}->attach($group{prevFileButton},
			  -balloonmsg=> "visit the previous file in the file-list");
  addBindTags($group{prevFileButton},'my');

  $group{nextFileButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Next file",
			  -relief=> $buttonsRelief,
			  -image=> icon(\%group,"finish"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&tieNextFile,\%group])->pack(-side=>'left',
									    -padx=>'1');
  $group{Balloon}->attach($group{nextFileButton},
			  -balloonmsg=> "visit the next file in the file-list");
  addBindTags($group{nextFileButton},'my');


  $group{printButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Print",
			  -relief=> $buttonsRelief,
			  -image      => icon(\%group,"fileprint"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [sub { printThis(@_) },\%group])->pack(-side=>'left',
									    -padx=>'1');
  $group{Balloon}->attach($group{printButton},
			  -balloonmsg=> "print ...");
  addBindTags($group{printButton},'my');

  $group{findButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Find",
			  -relief=> $buttonsRelief,
			  -image      => icon(\%group,"find"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [sub {
					my ($grp,$template)=@_;
					findNodeDialog($grp,$template)
					  if ($grp->{focusedWindow}->{currentNode});
				      },\%group,\%searchTemplate])->pack(-side=>'left',
									 -padx=>'1');
  $group{Balloon}->attach($group{findButton},
			  -balloonmsg=> "Find node ...");
  addBindTags($group{findButton},'my');

  $group{findNextButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Find Next",
			  -relief=> $buttonsRelief,
			  -image      => icon(\%group,"viewmag+"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&doFindFirstTemplated,\%group,\%searchTemplate,1])
      ->pack(-side=>'left', -padx=>'1');
  $group{Balloon}->attach($group{findNextButton},
			  -balloonmsg=> "Find next ...");
  addBindTags($group{findNextButton},'my');


  $group{findPrevButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Find Previous",
			  -relief=> $buttonsRelief,
			  -image=> icon(\%group,"viewmag-"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&doFindPrevTemplated,\%group,\%searchTemplate,1])
      ->pack(-side=>'left', -padx=>'1');
  $group{Balloon}->attach($group{findPrevButton},
			  -balloonmsg=> "Find previous ...");
  addBindTags($group{findPrevButton},'my');


  $group{frame}->Frame()->pack(-side=> 'left', -padx=>'10');
  $group{prevButton}->pack(-side=> 'left', -padx=>'1');
  $group{nextButton}->pack(-side=> 'left', -padx=> '1');

  $group{attrButton}=
    $group{frame}->Button(-takefocus=>0, -text=> "Attributes",
			  -relief=> $buttonsRelief,
			  -image=> icon(\%group,"wizard"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [sub { editStylesheetDialog(@_) },\%group])->pack(-side=>'right',
										    -padx=>'1');
  $group{Balloon}->attach($group{attrButton},
			  -balloonmsg=> "customize display patterns\nof the selected stylesheet\n(e.g. change tree appearance, labels etc.)");

  $group{StylesheetMenu}=$group{frame}->
    Optionmenu(-options => [],
	       -textvariable=> \$group{selectedStylesheet},
	       -command=> [sub { my ($grp,$stylesheet) = @_;
				 switchStylesheet($grp, $stylesheet);
			       },\%group],
	       -relief=> 'groove', #$menubarRelief,
	       -borderwidth=> 2)->pack(qw/-side right -padx 3/);
  updateStylesheetMenu(\%group);
  $group{Balloon}->attach($group{StylesheetMenu},
			  -balloonmsg=> "stylesheet (tree appearance)");

  $group{tieWinddowsButton}=
    $group{frame}->Checkbutton(-takefocus=>0,
			      -text=> "Tie Displayed Windows",
			      -variable=> \$group{tieWindows},
			       -relief=> $buttonsRelief,
			      -indicatoron => 0,
			      -image=>icon(\%group,"lock"),
			      -borderwidth=> $buttonBorderWidth)->pack(-side=>'right',
								       -padx=>'1');
  $group{Balloon}->attach($group{tieWinddowsButton},
			  -balloonmsg=> "tie all views");


  $group{rmsplitButton}=
    $group{frame}->Button(-takefocus=>0, 
			  -text=> "Remove Current View",
			  -relief=> $buttonsRelief,
			  -image=> icon(\%group,"view_remove"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&removeWindow,\%group])->pack(-side=>'right',
								     -padx=>'1');
  $group{Balloon}->attach($group{rmsplitButton},
			  -balloonmsg=> "remove current view");

  $group{hsplitButton}=
    $group{frame}->Button(-takefocus=>0, 
			  -text=> "Split View Horizontally",
			  -relief=> $buttonsRelief,
			  -image=> icon(\%group,"view_top_bottom"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&splitWindow,\%group,'horiz'])->pack(-side=>'right',
									    -padx=>'1');


  $group{Balloon}->attach($group{hsplitButton},
			  -balloonmsg=> "split view horizontally");
  $group{vsplitButton}=
    $group{frame}->Button(-takefocus=>0, 
			  -text=> "Split View Vertically",
			  -relief=> $buttonsRelief,
			  -image=> icon(\%group,"view_left_right"),
			  -borderwidth=> $buttonBorderWidth,
			  -command=> [\&splitWindow,\%group,'vert'])->pack(-side=>'right',
									   -padx=>'1');
  $group{Balloon}->attach($group{vsplitButton},
			  -balloonmsg=> "split view vertically");


  print STDERR "Packing widgets.\n" if $tredDebug;

  $group{frame}->pack(-fill=> 'x', -padx=> '1', -pady=> 1);
  my $vlsubframe=$group{vLineFrame}->Frame();
  $group{vLineNumLabel}=$vlsubframe->Label(-text => '-/-')->pack(qw/-side top -fill x/);
  $group{Balloon}->attach($group{vLineNumLabel},
			  -balloonmsg=> "position of the current tree\nin the file (current/total)");

  $group{sentButton}=
    $vlsubframe->Button(-takefocus=>0, -text=> "Sentences",
			-relief=> $buttonsRelief,
			-image=> icon(\%group,"contents"),
			-borderwidth=> $buttonBorderWidth,
			-command=> [\&viewSentences,\%group])
      ->pack(qw/-side top -fill x/);
  $group{Balloon}->attach($group{sentButton},
			  -balloonmsg=> "View all trees as a list of 'sentences'...\nThis dialog also allows export to HTML.");

  $vlsubframe->pack(qw/-fill x -side right -padx 1 -anchor n/);
  $group{valueLine}->pack(qw/-side left -fill both -expand yes/);
  $group{vLineFrame}->pack(qw/-fill x -expand no/);


  $group{vLineSeparator}->packAfter($group{vLineFrame},-side => 'top');

  $group{statusLine}->pack(qw/-pady 2 -side bottom -fill x -expand no/) if $group{statusLine};

  # frame canvas here
  $group{focusedWindow}->frame_widget($canvas,[],
				      [qw/-side left/])->pack(qw/-expand yes -fill both/);
#  $group{sLineFrame}->pack(qw/-fill x -expand yes/);

  print STDERR "Binding keystrokes...\n" if $tredDebug;
  $group{Menubar}->bind('Menubutton','<Escape>', [sub { shift->Leave(); }] );

  foreach my $prefix ('Alt','Meta') {
    $group{frame}->
      bind('my',"<$prefix-KeyPress>"=>
	   [sub {
	      if (defined(evalMacro(@_))) {
		Tk->break;
	      } else {
		# Actually, this should work by it self. And it realy
		# does, but not under windows :-) Well, do not laugh,
		# too early, Linux users. With menu (not menubutton)
		# this is the same there, only vice versa.
		my ($w,$grp,$mod)=@_;
		my $mbar=$grp->{Menubar};
		foreach my $child ($mbar->children) {
		  if ($child->class eq 'Menubutton' and $child->FindMenu($w->XEvent->K)) {
		    $child->ButtonUp() if ($^O eq "MSWin32"); 
		    # This ButtonUp is needed for some reason under
		    # Windows, otherwise the button remains active even
		    # when you leave the window! Window$ suck anyway!
		    last;
		  }
		}
		Tk->break;
	      }
	    }, \%group,uc($prefix).'+']);
  }

  #  $group{frame}->bind('my','<Control-x><KeyPress>'=>
  #			[sub { evalMacro(@_); Tk->break; }, \%group, 'CTRL-X+' ]);

  $group{frame}->bind('my','<KeyPress>'=>
			[sub {
			   evalMacro(@_); Tk->break;
			 }, \%group, '' ]);

  foreach (qw(Shift Control Meta Alt Control-Shift Control-Alt
              Control-Meta Alt-Shift Meta-Shift)) {
    foreach my $event (qw(KeyPress Right Left Up Down
                          Return comma period Next Prior greater less)) {
      $group{frame}->bind('my',"<$_-$event>"=>
			    [sub { evalMacro(@_); Tk->break; },
			     \%group, keyBind($_)."+"])
	unless ("$_-$event" eq "Alt-KeyPress" or "$_-$event" eq "Meta-KeyPress")
    }
  }

  $group{top}->bind('all','<Tab>',undef);

  # New Busy window bindings
  $group{frame}->Tk::bind('Busy','<Escape>',[\&_search_busy, \%group]);
  $group{top}->Tk::bind('Busy','<Escape>',[\&_search_busy, \%group]);
  $group{top}->Tk::bind('Busy','<Any-KeyPress>',[\&Tk::Widget::_busy => 1]);
  $group{top}->Tk::bind('Busy','<Any-KeyRelease>',[\&Tk::Widget::_busy => 0]);
  $group{top}->Tk::bind('Busy','<Any-ButtonPress>',[\&Tk::Widget::_busy => 1]);
  $group{top}->Tk::bind('Busy','<Any-ButtonRelease>',[\&Tk::Widget::_busy => 0]);
  $group{top}->Tk::bind('Busy','<Any-Motion>',[\&Tk::Widget::_busy => 0]);
  $group{top}->bind('Tk::Listbox','<KeyPress>',\&list_isearch);

  $group{top}->bind('my', '<Tab>'=>
		    [sub { currentNext($_[1]->{focusedWindow});
			   Tk->break; },\%group]);
  $group{frame}->bind('my',
		      '<Shift-ISO_Left_Tab>'=>
		      [sub { currentPrev($_[1]->{focusedWindow});
			     Tk->break; },\%group]);
  $group{frame}->bind('my',
		      '<Shift-Tab>'=>
		      [sub { currentPrev($_[1]->{focusedWindow});
			     Tk->break; },\%group]);

  $group{frame}->bind('my',
		      '<period>'=> 
		      [sub { onIdleNextTree($_[1]->{focusedWindow}); },
		       \%group]);
  $group{frame}->bind('my','<comma>'=> 
		      [sub { onIdlePrevTree($_[1]->{focusedWindow}); },
		       \%group]);
  $group{frame}->bind('my','<Next>'=> 
		      [sub { onIdleNextTree($_[1]->{focusedWindow}); },
		       \%group]);
  $group{frame}->bind('my','<Prior>'=> 
		      [sub { onIdlePrevTree($_[1]->{focusedWindow}); }
		       ,\%group]);
  $group{frame}->bind('my','<greater>'=>
		      [sub { my $fw=$_[1]->{focusedWindow};
			     gotoTree($fw,
				      $fw->{FSFile}->lastTreeNo);
			     Tk->break;
			   },\%group]);
  $group{frame}->bind('my','<less>'=> 
		      [sub { gotoTree($_[1]->{focusedWindow},0);
			     Tk->break;
			   },\%group]);

  $group{frame}->bind('my',
		      '<KeyPress-Return>'=>
		      [sub { editAttrsDialog($_[1]->{focusedWindow},
			     $_[1]->{focusedWindow}->{currentNode});
			 Tk->break;
		       },\%group]);
  $group{frame}->bind('my','<KeyPress-Left>'=>
		      [sub {
			 $treeViewOpts->{reverseNodeOrder} ?
			 currentRight($_[1]) :
			 currentLeft($_[1]);
			 Tk->break;
		       },\%group]);
  $group{frame}->bind('my','<Shift-Left>'=>
		      [sub {
			 $treeViewOpts->{reverseNodeOrder} ?
			 currentRightWholeLevel($_[1]) :
			 currentLeftWholeLevel($_[1]);
			 Tk->break;
		       },\%group]);
  $group{frame}->bind('my','<KeyPress-Right>'=>
		      [sub {
			 $treeViewOpts->{reverseNodeOrder} ?
			 currentLeft($_[1]) :
			 currentRight($_[1]);
			 Tk->break;
		       },\%group]);
  $group{frame}->bind('my','<Shift-Right>'=>
		      [sub {
			 $treeViewOpts->{reverseNodeOrder} ?
			 currentLeftWholeLevel($_[1]) :
			 currentRightWholeLevel($_[1]);
			 Tk->break;
		       },\%group]);
  $group{frame}->bind('my','<KeyPress-Up>'=>
		      [sub {
			 currentUp($_[1]);
			 Tk->break;
		       },\%group]);
  $group{frame}->bind('my','<KeyPress-Down>'=>
		      [sub {
			 currentDown($_[1]);
			 Tk->break;
		       },\%group]);

  $group{focusedWindow}->canvas->focus;

  $group{printToFile}=0;
  $group{printCommand}=$defaultPrintCommand;
  $group{printPsFile}=$psFile;

  print STDERR "Binding canvas destroy...\n" if $tredDebug;
  $group{top}->bind($group{frame},
		    '<Destroy>',
		      [ sub {
			  shift;
			  my $grp=shift;
			  $geometry=$group{top}->geometry();
			  print "geometry is $geometry\n" if $tredDebug;
			  if ($^O eq "MSWin32" and $group{top}->state() eq 'zoomed') {
			    $geometry=~s/\+[-0-9]+\+[-0-9]+/+-3+-3/;
			  }
			  print "state is ",$group{top}->state(),"\n"  if $tredDebug;
			},\%group ]);

  print STDERR "GUI prepared.\nOpenning first file ...." if $tredDebug;
  $group{top}->update;
  $group{top}->Busy(-recurse=> 1);
  if (doEvalHook($group{focusedWindow},"init_hook") eq 'stop') {
    $group{top}->Unbusy;
    print STDERR "Stopped by init_hook\n";
    exit;
  }
  my $stylesheet=$opt_s || STYLESHEET_FROM_FILE();
  $group{selectedStylesheet}=$stylesheet;
  applyWindowStylesheet($group{focusedWindow},$stylesheet);

  if ($opt_p) {
    my $dir=$opt_p>0 ? 'vert' : 'horiz';
    for (my $i=1;$i<$opt_p;$i++) {
      splitWindow(\%group,$dir);
    }
    focusCanvas($group{treeWindows}->[0]->canvas,\%group);
  }
  $group{top}->repeat(1000,sub {1}); # otherwise SIGINT would wait till next focus
  $SIG{PIPE}=sub {
    print STDERR "Caught signal SIGPIPE: $!\n";
  };
  $SIG{USR1}=sub {
    if ($insideEval) {
      print STDERR "Caught signal USR1: stopping current evaluation.\n";
    } else {
      print STDERR "Caught signal USR1: ignoring - not in a macro evaluation.\n";
    }
    print STDERR "Current call stack:\n",
      map { my ($pkg, $f, $line) = caller($_); "  $_: file $f line $line\n" } 1..5;
    $insideEval && die "Caught USR1: stopping current evaluation.\nSee the error output for details...\n"
  };
  $SIG{INT}=sub {
    if ($insideEval) {
      print STDERR "Caught SIGINT, stopping current evaluation\n";
      print STDERR "Current call stack:\n",
	map { my ($pkg, $f, $line) = caller($_); "  $_: file $f line $line\n" } 1..5;
      die "Caught SIGINT, stopping current evaluation.\nSee the error output for details...\n";
    } else {
      print STDERR "Caught SIGINT, closing all files\n";
      closeAllFiles(\%group);
      print STDERR "Good bye!\n";
      $group{top}->destroy;
      POSIX::_exit 1;
    }
  };

  if (findFilelist('Default')->count == 0 and findFilelist('CmdLine-1')) {
    selectFilelist(\%group,'CmdLine-1');
  } else {
    selectFilelist(\%group,'Default');
  }
  if ($opt_p) {
    my $dir=$opt_p>0 ? 'vert' : 'horiz';
    my @fl = $opt_l=~/,/g;
    my $fl=@fl+1;
    if ($fl>1) {
      $fl=min($opt_p,$fl);
      my $i;
      for (my $i=0;$i<$fl;$i++) {
	focusCanvas($group{treeWindows}->[$i]->canvas,\%group);
	selectFilelist($group{treeWindows}->[$i],"CmdLine-".($i+1));
	gotoFile($group{treeWindows}->[$i],0);
      }
    } else {
      for (my $i=1;$i<$opt_p;$i++) {
	focusCanvas($group{treeWindows}->[$i]->canvas,\%group);
	$group{treeWindows}->[$i]->{currentFilelist} = $group{treeWindows}->[0]->{currentFilelist};
	gotoFile($group{treeWindows}->[$i],$i);
      }
    }
    focusCanvas($group{treeWindows}->[0]->canvas,\%group);
    $group{tieWindows}=1;
  }

  $group{appenddefault} = 1; #($group{focusedWindow}{currentFilelist}->count()>0);

  print STDERR "done.\nStarting main loop.\n" if $tredDebug;
  # run start_hook
  if (doEvalHook($group{focusedWindow},"start_hook") eq 'stop') {
    $group{top}->Unbusy;
    print STDERR "Stopped by start_hook\n";
    exit;
  }

  # Starting ------------------------------------------
  $group{top}->Unbusy;
  $group{top}->focus if ($^O eq 'MSWin32');
  MainLoop;


  # Finished ------------------------------------------

  # Save configuration
  print STDERR "Saving some configuration options.\n" if $tredDebug;
  my @conf;
  my $ommit="canvasheight|canvaswidth|recentfile[0-9]+|geometry|lastaction|filelist[0-9]+";
  if (open(F,"<$configFile")) {
    @conf= grep { !/^\s*(?:$ommit)\s*=/i } <F>;
    close(F);
  }
  #  $geometry=~s/^[0-9]+x[0-9]+//;
  if ($group{lastActionBookmark}) {
    $group{lastActionBookmark}=~s/\\/\\\\/g;
    push @conf,"LastAction\t=\t".$group{lastActionBookmark}."\n" if $group{lastActionBookmark};
  }
  do {
    my $s;
    push @conf,
      "Geometry\t=\t".$geometry."\n",
      "CanvasHeight\t=\t".$defCHeight."\n",
      "CanvasWidth\t=\t".$defCWidth."\n",
	map { 
	  $s=$recentFiles[$_];
	  $s=~s/\\/\\\\/g;
	  "RecentFile$_\t=\t$s\n"
	} 0..$#recentFiles;

    my $i=0;
    foreach (@filelists) {
      if (ref($_) and defined($_->filename) and $_->filename ne "") {
	$_->save;
	$s=$_->filename();
	$s=~s/\\/\\\\/g;
	push @conf,"filelist".$i++."\t=\t".$s."\n";
      }
    }
  };
  chomp $conf[$#conf];
  $group{top}=undef;
  saveConfig(\%group,@conf);
  print STDERR "Done.\n" if $tredDebug;
}

sub _do_goto_tree {
  my $win=shift;
  update_value_line($win->{framegroup});
  my $no=$win->{treeNo};
  $win->{treeNo}=-1;  # this is to force getNodes & redraw
  gotoTree($win,$no);
  $win->{framegroup}->{IdleTask}=undef;
}

sub onIdleNextTree {
  my ($grp,$win)=grp_win(shift);
  return unless $win->{FSFile};
  $win->toplevel->afterCancel($grp->{IdleTask}) if ($grp->{IdleTask});
  $win->{treeNo}=max(0,min($win->{treeNo}+1,$win->{FSFile}->lastTreeNo));
  update_tree_pos($grp);
  #  update_value_line($grp);
  #  $grp->{valueLine}->idletasks();
  $grp->{vLineNumLabel}->idletasks();
  $grp->{IdleTask}=$win->toplevel->afterIdle([\&_do_goto_tree,$win]);
  Tk->break;
}

sub onIdlePrevTree {
  my ($grp,$win)=grp_win(shift);
  return unless $win->{FSFile};
  if ($win->{treeNo}>0) {
    $win->toplevel->afterCancel($grp->{IdleTask}) if ($grp->{IdleTask});
    $win->{treeNo}--;
    update_tree_pos($grp);
    #    update_value_line($grp);
    #    $grp->{valueLine}->idletasks();
    $grp->{vLineNumLabel}->idletasks();
    $grp->{IdleTask}=$win->toplevel->afterIdle([\&_do_goto_tree,$win]);
  }
  Tk->break;
}

sub RepeatedShowDialog {
  my ($cw, $focus, $oldFocus)= @_;
  $oldFocus= $cw->focusCurrent unless $oldFocus;
  my $oldGrab= $cw->grabCurrent;
  my $grabStatus= $oldGrab->grabStatus if ($oldGrab);

  # instead of Popup
  $cw->deiconify;
  $cw->waitVisibility;

  Tk::catch {
    $cw->grab;
  };
  $focus->focusForce if ($focus);
  Tk::DialogBox::Wait($cw);
  eval {
    $oldFocus->focusForce;
  };
  $cw->withdraw;
  $cw->grabRelease;
  if ($oldGrab) {
    if ($grabStatus eq 'global') {
      $oldGrab->grabGlobal;
    } else {
      $oldGrab->grab;
    }
  }
  return $cw->{selected_button};
}

# This patches $dialog->Show which implicitly focuses the default button;
# here focus stays where it is.
# Usage: my $dlg=DialogBox(); ...; ShowDialog($dlg);
sub ShowDialog {
  my ($cw, $focus, $oldFocus)= @_;
  $oldFocus= $cw->focusCurrent unless $oldFocus;
  my $oldGrab= $cw->grabCurrent;
#  my $old_grab= $cw->grabSave;
#  my $old_focus= $cw->grabSave;
  my $grabStatus= $oldGrab->grabStatus if ($oldGrab);

#  $cw->grab;

  $cw->Popup();

  Tk::catch {
    $cw->grab;
  };
  $focus->focusForce if ($focus);
  Tk::DialogBox::Wait($cw);
  eval {
    $oldFocus->focusForce;
  };
  #&$old_grab;
  #&$old_focus;
  
  $cw->withdraw;
  $cw->grabRelease;
  if ($oldGrab) {
    if ($grabStatus eq 'global') {
      $oldGrab->grabGlobal;
    } else {
      $oldGrab->grab;
    }
  }

  return $cw->{selected_button};
}

sub fileDialog {
  my ($grp,$header_only)= @_;
  my $file;

#  use Tk::FileSelect;
#  my $FSref= $grp->{top}->FileSelect(-selectmode=> extended);
#  print $FSref->Show;

  $file= get_open_filename($grp->{top},-filetypes=> \@open_types);
  if (defined $file and $file ne '') {
    return openStandaloneFile($grp,$file,-justheader => $header_only);
  }
  return 0;
}

sub urlDialog {
  my ($grp,$header_only)= @_;
  if (not(defined $grp->{lastURL}) and
      defined($grp->{focusedWindow}->{FSFile})) {
    $grp->{lastURL} = $grp->{focusedWindow}->{FSFile}->filename();
  }
  $grp->{urlHist} = [] unless ref($grp->{urlHist});
  my $file = QueryString($grp,"Enter URL", "URL: ",$grp->{lastURL},1,$grp->{urlHist});
  if (defined $file and $file ne '') {
    $grp->{lastURL} = $file;
    return openStandaloneFile($grp,$file,-justheader => $header_only);
  }
  return 0;
}

sub askSaveReferences {
  # write embedded DOM documents
  my ($win,$fsfile,$result,$filename)=@_;
  $filename = $fsfile->filename unless defined $filename;
  my (@refs);
  my $schema = fileSchema($fsfile) || return 1;
  my $references = $schema->{reference} || return 1;
  foreach my $reference (@$references) {
    my $name = $reference->{name};
    my $refid = $fsfile->metaData('refnames')->{$name};
    if ($refid) {
      my $href = $fsfile->metaData('references')->{$refid};
      if ($href and $reference->{readas} eq 'dom' and 
	  ref($fsfile->appData('ref')) and $fsfile->appData('ref')->{$refid}) {
	push @refs, $href." [$refid, $name]";
      }
    }
  }
  # CURSOR
  return 1 unless @refs;
  my $initdir = dirname($filename);
  my $selection = [];
  my $return =
    listQuery(
      $win->toplevel,'Select resources to save','multiple',
      \@refs,$selection,
      label => {
	-text => <<'EOF'
This document contains data obtained from external resources.
Please select which of them should be updated:
EOF
       },
      list => {
	-exportselection => 0,
      },
      buttons => [{
	-text => 'Change filename...',
	-underline => 7,
	-command => [sub {
		       my ($l)=@_;
		       my ($file,$rest) = split / \[/,$l->get('active'),2;
		       my $initdir2 = dirname($file);
		       $initdir2 = File::Spec->catfile($initdir,$initdir2)
			 unless File::Spec->file_name_is_absolute($initdir2);
		       $file = get_save_filename(
			 $l->toplevel,
			 -filetypes=> $save_types{all},
			 -title=> "Save As ...",
			 -d $initdir2 ? (-initialdir=> $initdir2) : (),
			 $^O eq 'MSWin32' ? () : (-initialfile=> filename($file)));
		       if ($file ne "") {
			 my $index = $l->index('active');

			 my %selected = map {$_=>1} grep { $l->selectionIncludes($_) } (0 .. $l->size-1);
			 $l->insert($index,$file." [".$rest);
			 $l->delete('active');
			 $l->activate($index);
			 foreach (0 .. $l->size-1) {
			   if ($selected{$_}) {
			     $l->selectionSet($_);
			   } else {
			     $l->selectionClear($_);
			   }
			 }
		       }
		       Tk->break;
		     }]
       }]
     );
  if ($return) {
    %$result = map { /^(.*) \[([^,]+),/ ? ($2 => $1) : () } @$selection;
  }
  return $return;
}

sub saveFileAs {
  my ($win)= @_;
  my $initdir;
  return unless $win->{FSFile};
  my $file=$win->{FSFile}->filename;
  my ($old_file,$old_backend,$old_format) = 
    ($file,$win->{FSFile}->backend,$win->{FSFile}->fileFormat);

  $initdir=dirname($file);
  $initdir=cwd if ($initdir eq './');
  $initdir=~s!${TrEd::Convert::Ds}$!!m;

  my $response=userQuery($win, "\nPlease,\nchoose one of the following output formats.\n\n".
			 "\nWARNING:\nsome formats may be incompatible with the current file.\n",
			 -title => "Save As ...",
			 -buttons => ["Use current","FS","CSTS","TrXML","TEIXML","Storable","Cancel"]);
  return if ($response eq "Cancel");

  if ($response eq 'FS') {
    $file=~s/\.(?:csts|sgml|sgm|cst|trxml|trx|tei|xml)/.fs/i;
    $file=~s/\.(amt|am|m|a)/$1.fs/;
  } elsif ($response eq 'CSTS') {
    $file=~s/\.(?:fs|tei|trxml|trx|xml)/.csts/i;
  } elsif ($response eq 'TrXML') {
    $file=~s/\.(?:csts|sgml|sgm|cst|fs|tei)/.trxml/i;
  } elsif ($response eq 'TEIXML') {
    $file=~s/\.(?:csts|sgml|sgm|cst|fs|trxml|trx)/.xml/i;
  } elsif ($response eq 'Storable') {
    $file=~s/\.(?:csts|sgml|sgm|cst|fs|trxml|trx|tei|xml)/.pls/i;
  } 

  my $filetypes;
  if ($response eq 'Use current') {
    my ($backend) = grep { $backend_map{$_} eq $win->{FSFile}->backend} keys %backend_map;
    if ($backend) {
      $filetypes = $save_types{$backend};
    } else {
      $filetypes = $save_types{'all'};
    }
  } else {
    $filetypes = $save_types{lc($response)};
  }

  $file= get_save_filename($win->toplevel,-filetypes=> $filetypes,
				     -title=> "Save As ...",
				     -d $initdir ? (-initialdir=> $initdir) : (),
     				     $^O eq 'MSWin32' ? () : (-initialfile=> filename($file)));
  my $lock_change=0;
  if ($file ne '') {
    if ($file ne $win->{FSFile}->filename) {
      if ($lockFiles) {
	my $lock = checkLock(undef,$file);
	if ($lock eq "my") {
	  if (userQuery($win,
			"An existing lock on the file $file indicates that it is probably used by another file-object within this process!",
			-bitmap=> 'question',
			-title => "Saving to a locked file?",
			-buttons => ['Steal lock and save','Cancel']) eq 'Cancel') {
	    return -1;
	  }
	} elsif ($lock ne "none") {
	  if (userQuery($win,
			"File $f was $lock!",
			-bitmap=> 'question',
			-title => "Saving to a locked file?",
			-buttons => ['Steal lock and save','Cancel']) eq 'Cancel') {
	    return -1;
	  }
	}
	$lock_change=1;
	$win->{FSFile}->changeFilename($file);
	setFSLockInfo($win->{FSFile}, setLock($file));
      } else {
	$win->{FSFile}->changeFilename($file);
      }
    }
    if ($response ne 'Use current') {
      $win->{FSFile}->changeBackend($backend_map{lc($response)});
    }
    $win->{FSFile}->changeFileFormat(($file=~/\.gz$/ ? "gz-compressed " : "").
				     $win->{FSFile}->backend);
    updateTitle($win->{framegroup});
    if (saveFile($win,$file)==1) {
      removeLock($win->{FSFile},$old_file,1) if ($lock_change);

      if ($file ne $old_file and 
	  ref($win->{FSFile}->appData('fs-part-of'))) {
	my @fs = @{$win->{FSFile}->appData('fs-part-of')};
	if (@fs) {
	  my $filenames = [map { $_->filename } @fs];
	  my $selection=[@$filenames];
	  listQuery(
	    $win->toplevel,
	    'Rename file also in...','multiple',
	    $filenames,$selection,
	    label => {
	      -text => <<'EOF'
You have renamed the current file, but it is referenced from the file(s) below.
Please select files that should update their reference to the current file:
EOF
	     },
	    list => {
	      -exportselection => 0,
	    }
	   );
	  if (@$selection) {
	    my %selected = map { $_ => 1 } grep { $_ ne "" } @$selection;
	    my @failed;
	    foreach my $reff (grep { $selected{$_->filename} } @fs) {
	      my $req = $reff->metaData('fs-require');
	      my $references = $reff->metaData('references');
	      my $match;
	      if (ref($req)) {
		for (@$req) {
		  if ($_->[1] eq $old_file) {
		    if (ref($references)) {
		      $references->{$_->[0]}=$file;
		      $_->[1] = $file;
		      $reff->notSaved(1);
		    }
		    $match = 1;
		  }
		}
	      }
	      unless ($match) {
		push @failed,$reff;
	      }
	    }
	    errorMessage($win,
			 "Couldn't find reference to the current file in the following files:\n\n".
			   join("\n",map { $_->filename } @fs),1) if @failed;
	  }
	}
      }
    } else {
      removeLock($win->{FSFile},$file,1) if ($lock_change);
      $win->{FSFile}->changeFilename($old_file);
      setFSLockInfo($win->{FSFile}, setLock($old_file)) if $lock_change;
      $win->{FSFile}->changeBackend($old_backend);
      $win->{FSFile}->changeFileFormat($old_format);
      updateTitle($win->{framegroup});
      return 0;
    }
  }
  return 0;
}

sub askSaveFiles {
  my ($grp,$cancelbutton)= @_;

  @{$grp->{treeWindows}} = grep { $_ ne $grp->{focusedWindow} } @{$grp->{treeWindows}};
  unshift @{$grp->{treeWindows}},$grp->{focusedWindow};
  my $win;
  my %asked;
  foreach $win (@{ $grp->{treeWindows} }) {
    if ($win->{FSFile}) {
      $asked{$win->{FSFile}}=1;
      focusCanvas($win->canvas(),$win->{framegroup});
      return -1 if askSaveFile($win,0,$cancelbutton) == -1;
      closeFile($win,-no_update => 1,-all_windows => 1);
    }
  }

  for my $fsfile (grep { !$asked{$_} and ref($_) and $_->notSaved } @openfiles) {
    resumeFile($grp->{focusedWindow},$fsfile);
    updateTitle($grp);
    get_nodes_win($grp->{focusedWindow});
    redraw_win($grp->{focusedWindow});
    centerTo($grp->{focusedWindow},$grp->{focusedWindow}->{currentNode});
    $grp->{top}->update();
    return -1 if askSaveFile($grp->{focusedWindow},0,$cancelbutton) == -1;
  }
  closeAllFiles($grp);
}

sub closeAllFiles {
  my ($grp)= @_;

  @{$grp->{treeWindows}} = grep { $_ ne $grp->{focusedWindow} } @{$grp->{treeWindows}};
  unshift @{$grp->{treeWindows}},$grp->{focusedWindow};
  my $win;
  foreach $win (@{ $grp->{treeWindows} }) {
    if ($win->{FSFile}) {
      closeFile($win,-no_update => 1,-all_windows => 1);
    }
  }
  while (@openfiles) {
   my $fsfile = $openfiles[0];

   # to avoid infinite loop, first try closing all files this one is
   # part of
   if ($fsfile and ref($fsfile->appData('fs-part-of'))) {
     foreach (@{$fsfile->appData('fs-part-of')}) {
       __debug("Closing all parts of ".$fsfile->filename);
       closeFile($grp->{focusedWindow},-fsfile => $_,
		 -no_update => 1, -all_windows => 1);
     }
   }
   __debug("Now closing file ".$fsfile->filename);
   closeFile($grp->{focusedWindow},
	     -fsfile => $fsfile,
	     -no_update => 1,
	     -all_windows => 1);
   if (grep {$_==$fsfile} @openfiles) {
     # still there?
     __debug("File still open, pushing it to the end: $fsfile: ".$fsfile->filename);
     shift @openfiles;
     push @openfiles, $fsfile;
     __debug("Open files: @openfiles");
   }
  }
}


# ask user whether the current file should be saved (and save it if yes)
# if $keepbutton parameter is 1, allow user to keep the file
# return 0 if file saved, 1 if file should be kept and undef if no

sub askSaveFile {
  my ($win,$keepbutton,$cancelbutton)=@_;
  return 0 unless
    ref($win->{FSFile}) and
      $win->{FSFile}->notSaved;
  my $answer=userQuery($win,
			$win->{FSFile}->filename().
			"\n\nFile may be changed!\nDo you want to save it?",
			-bitmap=> 'question',
			-title => "Should I save the file?",
			-buttons => ['Yes', 'No', $keepbutton ? 'Keep' : (),
				     $cancelbutton ? 'Cancel' : ()]);
  if ($answer eq 'Yes') {
    return saveFile($win) == -1 ? -1 : 0;
  } elsif ($answer eq 'Keep') {
    return 1;
  } elsif ($answer eq 'Cancel') {
    return -1;
  }
}

sub saveConfig {
 my ($grp)=shift;

 if (open(F,">$configFile")) {
   print STDERR "SAVING CONFIG TO: $configFile\n";
   print F @_;
   close(F);
 } else {
   my $lasterr=conv_from_locale($!);
   my ($trc)=TrEd::Config::tilde_expand('~/.tredrc');
   my ($dc,$ic)=stat($configFile);
   my ($dh,$ih)=stat($trc);
   if ($configFile ne $trc and ($dc != $dh or $ic != $ih) and
       (!defined($grp->{top}) or
       $grp->{top}->toplevel->
       messageBox(-icon=> 'warning',
		  -message=> "Cannot write configuration to $configFile\n($lasterr)\n\n".
		  "Shell I try to save it to ~/.tredrc?\n",
		  -title=> 'Configuration cannot be saved',
		  -type=> 'YesNo',
		  #			  -default=> 'Yes' # problem: Windows 'yes', UNIX 'Yes'
		 )=~ /yes/i)) {
     if (open(F,">".$trc)) {
       print STDERR "SAVING CONFIG TO: $trc\n";
       print F @_;
       close(F);
       $configFile=$trc;
     } else {
       errorMessage($grp->{focusedWindow},'Cannot write to "'.$trc.'"!'."\n($lasterr)\n".
		    "\nConfiguration could not be saved!\nCheck file and directory permissions.",1);
     }
   } else {
     errorMessage($grp->{focusedWindow},"Cannot write to \"$configFile\"!"."\n($lasterr)\n".
		  "\nConfiguration could not be saved!\nCheck file and directory permissions.",1);
   }
 }
}

sub reconfigure {
  my ($grp)=@_;
  addToRecent($grp);
  prepareFonts($grp);
  updateTitle($grp);
  $grp->{valueLine}->configure(-font=> $vLineFont);
  $grp->{statusLine}->configure(-font=> $vLineFont) if $grp->{statusLine};
  foreach (@{$grp->{treeWindows}}) {
    $_->treeView->apply_options($treeViewOpts);
  }
  ApplyGlobalConfig($grp);
}

sub addTextSearchLine {
  my ($parent,$text)=@_;
  my $sf = $parent->Frame;
  $sf->Label(-underline => 1,
	     -text => 'Search:')->pack(qw(-side left));
  my $qs = $sf->Entry(
    -validate => 'key',
    -validatecommand =>
      [sub {
	 my ($text,$value)=@_;
	 return 1 if $value eq "";
	 $text->tagRemove('sel','0.0','end');
	 my $new = $text->search(qw(-forward -exact -nocase), $value, 'insert');
	 if ($new) {
	   $text->SetCursor($new);
	   $text->tagAdd('sel',$new, $new.' + '.length($value).' chars');
	   return 1;
	 } else {
	   return undef;
	 }
       },$text]
     )->pack(qw(-side right -expand 1 -fill x));
  $parent->toplevel->bind('all','<Alt-e>', [$qs,'focus']);
  $parent->toplevel->bind('all','<F3>',
			  [sub {
			     my ($w,$text,$qs)=@_;
			     $qs->focus;
			     $text->FindNext(qw(-forward -exact -nocase), $qs->get());
			  },$text,$qs]);
  $qs->bind('<Return>',[$text,'focus']);
  return $sf;
}

sub editConfig {
  my ($grp)=@_;
  return unless $grp;
  if ($grp->{configDialog}) {
    $grp->{configDialog}->deiconify;
    $grp->{configDialog}->focus;
    $grp->{configDialog}->raise;
    return;
  }
  $grp->{configDialog}= 
    $grp->{top}->Toplevel(-title=> "Edit Config File ($configFile)" , 
			  -width=> "10c");
  my $d=$grp->{configDialog};
  $d->withdraw;
  $d->bind('<Return>'=> [\&dlgReturn,1]);
  my $t= $d->
    Scrolled(qw/Text -relief sunken -borderwidth 2
		     -height 20 -scrollbars oe/);
  $t->Subwidget('scrolled')->menu->delete('File');
  $t->bind('<Alt-f>'  => sub {
	     my ($w)=@_;
	     my $pop=$w->FindPopUp();
	     my ($entry) = grep { $_->isa('Tk::Entry') } $pop->children();
	     $pop->bind('all','<Tab>',[sub { shift->focusNext; }]);
	     $pop->bind('all','<Escape>',[sub { shift; shift->destroy; },$pop]);
	     if (ref($entry)) {
	       $entry->focus();
	     }
	   });
  $t->bind('<Alt-r>'  => sub {
	     my ($w)=@_;
	     my $pop=$w->FindAndReplacePopUp();
	     my ($entry) = grep { $_->isa('Tk::Entry') } $pop->children();
	     $pop->bind('all','<Tab>',[sub { shift->focusNext; }]);
	     $pop->bind('all','<Escape>',[sub { shift; shift->destroy; },$pop]);
	     if (ref($entry)) {
	       $entry->focus();
	     }
	   });
  $t->pack(qw/-side top -expand yes -fill both/);
  addTextSearchLine($d,$t)->pack(qw(-fill x));

  disable_scrollbar_focus($t);
  $t->BindMouseWheelVert();
  my $bottom=$d->Frame()->pack(qw/-side bottom -fill x/);
  $bottom->
    Button(-text=> "  Save and Apply  ",
	   -underline => 2,
	   -command=> [sub {
			  my ($grp,$d,$t)=@_;
			  saveConfig($grp,$t->get("0.0","end"));
			  apply_config(split(/\n/,$t->get("0.0","end")));
			  reconfigure($grp);
			  redraw_all($grp);
			},$grp,$d,$t])
      ->pack(-side=> 'left', -expand=> 1,  -padx=> 1, -pady=> 1);
  $bottom->Button(-text=> "  Apply  ",
		  -underline => 2,
		  -command=> [sub {
				 my ($grp,$w)=@_;
				 apply_config(split(/\n/,$w->get("0.0","end")));
				 reconfigure($grp);
				 redraw_all($grp);
			       },$grp,$t])
    ->pack(-side=> 'left', -expand=> 1,  -padx=> 1, -pady=> 1);

  $bottom->Button(-text=> "  Close  ", 
		  -underline => 2,
		  -command=> [sub { shift->destroy; },$d])
    ->pack(-side=> 'left', -expand=> 1,  -padx=> 1, -pady=> 1);
  _bind_buttons($d,$d);
  $d->bind('<Destroy>'=> [sub { shift; shift->{configDialog}=undef; },$grp ]);
  $d->bind($d,'<Escape>'=> [sub { shift; shift->destroy(); },$d]);
  if (open(F,"<$configFile")) {
    $t->insert('0.0',join "",<F>);
    close(F);
  }
  $t->mark(qw/set insert 0.0/);
  $t->focus();
  $d->Popup;
}

sub QueryString {
  my ($grp, $title, $label,$default_text, $select, $hist)=@_;
  my $top = (ref($grp) and UNIVERSAL::can($grp,'toplevel')) ? $grp->toplevel : $grp->{top};
  my $newvalue=encode($default_text);
  my $d=$top->DialogBox(-title=> $title,
				 -buttons=> ["OK", "Cancel"]);
  escapeButton($d,'Cancel',1);
  $d->bind('<Return>',\&dlgReturn);
  $d->bind('all','<Tab>',[sub { shift->focusNext; }]);
  $d->bind('all','<Shift-Tab>',[sub { shift->focusPrev; }]);

  addBindTags($d,'dialog');
  my ($Entry,@Eopts) = get_entry_type();
  my $e=$d->add($Entry,
		@Eopts,
		-relief=> 'sunken',
		-width=> 70,
		-takefocus=> 1,
		-font=> $font,
		-textvariable=> \$newvalue);
  if ($e->can('history') and ref($hist)) {
    $e->history($hist);
  }
  $e->selectionRange(qw(0 end)) if ($select);
  my $l= $d->Label(-text=> encode($label),
		    -anchor=> 'e',
		    -justify=> 'right');

  $l->pack(-side=>'left');
  $e->pack(-side=>'right');
  $d->resizable(0,0);
#  $e->focus;
  my $result= ShowDialog($d,$e,$top);
  if ($result=~ /OK/) {
    if (ref($hist) and $e->can('historyAdd')) {
      $e->historyAdd($newvalue) if $newvalue ne "";
      @$hist = $e->history();
    }
    $d->destroy; undef $d;
    return decode($newvalue);
  } else {
    $d->destroy; undef $d;
    return undef;
  }
}

sub Query {
  my ($w, $title, $label,$default_text,$select, $hist)=@_;
  my $newvalue=encode($default_text);
  my $d=$w->DialogBox(-title=> $title,
				 -buttons=> ["OK", "Cancel"]);
  $d->bind('<Return>', \&dlgReturn );
  escapeButton($d,'Cancel');
  addBindTags($d,'dialog');
  my ($Entry,@Eopts) = get_entry_type();
  my $e=$d->add($Entry,-relief=> 'sunken',
		    -width=> 40,
		    -takefocus=> 1,
		    -font=> $font,
		    -textvariable=> \$newvalue);
  if ($e->can('history') and ref($hist)) {
    $e->history($hist);
  }
  $e->selectionRange(qw(0 end)) if ($select);
  my $l= $d->Label(-text=> encode($label),
		    -anchor=> 'e',
		    -justify=> 'right');
  $l->pack(-side=>'top');
  $e->pack(-side=>'left');
  $d->resizable(0,0);
#  $e->focus;
  my $result= ShowDialog($d,$e,$w);
  if ($result=~/OK/) {
    if (ref($hist) and $e->can('historyAdd')) {
      $e->historyAdd($newvalue) if $newvalue ne "";
      @$hist = $e->history();
    }
  }
  $d->destroy;
  undef $d;
  if ($result=~ /OK/) {
    return decode($newvalue);
  } else {
    return undef;
  }
}

sub _escapeButton {
  my ($w,$d,$button)=@_;
  if ($w->toplevel == $d) {
    $d->{selected_button}=$button;
  }
  Tk->break;
}
sub _wmdeleteButton { $_[0]->{selected_button}=$_[1] }
sub escapeButton {
  my ($d,$button,$bind_wm)=@_;
  $d->bind('all','<Escape>'=> [\&_escapeButton,$d,$button]);
  $d->protocol('WM_DELETE_WINDOW' => [\&_wmdeleteButton,$d]) if $bind_wm;
}

sub listQuery {
  my ($w,$title,$select_mode,$vals,$selected,%opts)=@_;
  my $top=$w->toplevel;
  my $d=$w->DialogBox(-title	  => $title,
		      -width	  => '8c',
		      -buttons  => ["OK", "Cancel"]);
  $d->bind('<Return>', \&dlgReturn );
  escapeButton($d,'Cancel',1);
  if (ref($opts{label})) {
    $d->Label(%{$opts{label}})->pack(qw/-side top/);
  }
  my $l=$d->Scrolled(qw/Listbox -relief sunken
                        -takefocus 1
                        -width 0
                        -scrollbars e/,
		     -font=> $font,
		     -selectmode => $select_mode,
		     -height=> min($maxDisplayedValues,scalar(@$vals)),
		     ref($opts{list}) ? %{$opts{list}} : ()
		    )->pack(qw/-expand yes -fill both/);
  $l->insert('end',@$vals);
  if (@$vals>0) {
    $l->activate(0);
  }
  $l->BindMouseWheelVert();
  my $f=$d->Frame()->pack(qw/-fill x/);
  if ($select_mode eq 'multiple') {
    $f->Button(-text => 'All',
	       -underline => 0,
	       -command => [
			    sub{
			      my ($list)=@_;
			      $list->selectionSet(0,'end');
			    },
			    $l
			   ])->pack(-side => 'left');
    $f->Button(-text => 'None',
	       -underline => 0,
	       -command => [
			    sub{
			      my ($list)=@_;
			      $list->selectionClear(0,'end');
			    },
			    $l
			   ])->pack(-side => 'left');
  }
  if (ref($opts{buttons})) {
    foreach my $b (@{$opts{buttons}}) {
      if (ref($b->{-command}) eq 'ARRAY') {
	push @{$b->{-command}}, $l;
      }
      $f->Button(%$b)->pack(-side => 'left');
    }
  }

  _bind_buttons($d,$d);
  my $act=0;
  my %selected = map { $_ => 1 } @$selected;
  for ($a=0;$a<@$vals;$a++)  {
    if ($selected{$$vals[$a]}) {
      $l->selectionSet($a);
      if (not $act) {
	$act=1;
	$l->activate($a);
	$l->see($a);
      }
    }
  }
 $l->focus;
 my $result= &main::ShowDialog($d,$l,$top);

 if ($result=~ /OK/) {
   @$selected=();
   foreach (0 .. $l->size-1) {
     push @$selected, $l->get($_) if $l->selectionIncludes($_);
   }
   $d->destroy;
   return 1;
 }
 $d->destroy;
 return 0;
}

sub selectContext {
  my ($grp)=@_;
  my $selection = [$grp->{focusedWindow}->{macroContext}];
  listQuery($grp->{top},'Select Context','browse',[getContexts()],
	    $selection) || return;
  if (@$selection) {
    switchContext($grp->{focusedWindow},$selection->[0]);
  }
}

sub selectStylesheet {
  my ($grp_or_win)=@_;
  my $grp = cast_to_grp($grp_or_win);
  my $win = cast_to_grp($grp_or_win);
  my $selection = [$grp->{selectedStylesheet}];
  listQuery($grp->{top},'Select Context','browse',
	    getStylesheetMenuList($grp),
	    $selection) || return;
  if (@$selection) {
    $grp->{selectedStylesheet} = $selection->[0];
    switchStylesheet($grp,$selection->[0]);
  }
}

sub selectValuesDialog {
 my ($grp, $attr, $vals, $selected, $may_add, $lastFocus,$force)=@_;
 my $a;
 my $multi=0;
 my @prevSelectionSet;

 my $top=$grp->{top};
 $top->Busy(-recurse=> 1);
 my $enabled=($force or doEvalHook($grp->{focusedWindow},
				   'enable_attr_hook',
				   $attr,
				   "ambiguous") ne 'stop');

 my $d=$top->DialogBox(-title=> ($enabled ? "$attr: select values" : "$attr: values"),
		       -width=> '8c',
		       -buttons=> ($enabled ? ["OK", "Cancel"] : ["Cancel"]));
 $d->bind('<Return>', \&dlgReturn );
 escapeButton($d,'Cancel',1);
 $d->resizable(0,0);
 my $l=$d->Scrolled(qw/Listbox -relief sunken -takefocus 1 -scrollbars oe/,
		    -height=> min($maxDisplayedValues,scalar(@$vals)),
		    -font=> $font)->pack(qw/-expand yes -fill both/);
 disable_scrollbar_focus($l);
 $l->insert('end',@$vals);
 $l->BindMouseWheelVert();
 if ($enabled) {
   $l->bind('<Double-ButtonPress-1>'=>
	    [sub { my $w=shift;
		   my $d=shift;
		   my $e= $w->XEvent;
		   $w->BeginSelect($w->index($e->xy));
		   $d->{selected_button}='OK';
		 },$d
	    ]);
 }
 my $act=0;
 for ($a=0;$a<@$vals;$a++)  {
   if (grep { $$vals[$a] eq $_ } @$selected) {
     $l->selectionSet($a);
     if (not $act) {
       print "Activating $a\n"  if $tredDebug;
       $act=1;
       $l->activate($a);
       $l->see($a);
     }
   }
 }
 if ($enabled) {
   $d->Checkbutton(-text    => 'multiple select',
		   -variable=> \$multi,
		   -command => [sub {
				   shift->configure(-selectmode=> $multi ? 'multiple' : 'browse');
				 },$l],
		   -relief  => 'flat')->pack();
   if ($may_add) {
     $d->Button(-text=> 'Add',
		-command=> [sub {
			       my ($grp,$l,$vals,$attr)=@_;
			       $grp->{"histValue:$attr"}=[]
				 unless $grp->{"histValue:$attr"};
			       my $val=
				 QueryString($grp,"Add new value","Value",
					     undef,
					     0,$grp->{"histValue:$attr"});
			       return unless defined $val;
			       push @$vals,$val;
			       $l->insert('end',$val);
			       $l->selectionClear(0,$l->size-1) unless $multi;
			       $l->selectionSet($l->size-1);
			     },$grp,$l,$vals,$attr])->pack();
   }
 }
 $top->Unbusy();
 $l->focus;
 my $result= ShowDialog($d,$l,$lastFocus);
 if ($result=~ /OK/) {
   # Hajic wanted this (I wash my hands):
   # first we store the values, which were selected originaly and
   # stayed selected
   foreach my $s (@$selected) { 
     push @prevSelectionSet, (grep { $$vals[$_] eq $s } (0 .. $l->size-1));
   }
   @$selected=();
   foreach (@prevSelectionSet) {
     if ($l->selectionIncludes($_)) {
       $l->selectionClear($_);
       push @$selected,$$vals[$_];
     }
   }
   foreach (0 .. $l->size-1) {
     push @$selected, $$vals[$_] if $l->selectionIncludes($_);
   }
   $d->destroy;
   undef $d;
   return 1;
 }
 $d->destroy;
 undef $d;
 return 0;
}

sub reloadSentenceView {
  my ($grp,$t,$selref)=@_;
  return unless $t;
  my $d=$grp->{sentDialog};
  $t->delete('0.0','end'); #something smells here!! 
  $grp->{sentDialog}=$d;
  my $filename=$grp->{focusedWindow}->{FSFile}->filename();
  for (my $i=0; $i<=$grp->{focusedWindow}->{FSFile}->lastTreeNo();$i++) {
    $t->window('create', 'end', -window =>
	       $t->Checkbutton(-selectcolor => undef,
			       -indicatoron => 0,
			       -height => 19,
			       -width => 19,
			       -selectimage => icon($grp,"green_belly3"),
			       -image => icon($grp,"gray_belly3"),
			       -variable => \$selref->[$i]
			      ));
    $t->window('create', 'end', -window =>
	       $t->Button(-height => 16,
			  -width => 16,
			  -image => icon($grp,'1rightarrow'),
			  -command => [\&openFile, $grp, "$filename##".($i+1)]
			 ));

    my $v = get_value_line($grp->{focusedWindow},
			   $grp->{focusedWindow}->{FSFile},$i,1,1);
    my %tags;
    @tags{ map { @$_[1..$#$_] } @$v }=();
    foreach my $tag (keys(%tags)) {
      if ($tag=~/^\s*-/) {
	eval {
	  $t->tagConfigure(
			   $tag => (map { (/^\s*(-[[:alnum:]]+)\s*=>\s*(.*\S)\s*$/) }
				    split(/,/,$tag)));
	};
	print $@ if $@;
      }
    }

    $t->insert('end',"(".($i+1).") ",['treeno',"start-tree-".($i+1)],
	       map { ($_->[0], [@$_[1..$#$_]]) } @$v);
    $t->insert('end',"\n",['newline',"end-tree-".($i+1)]);
	       #	       get_value_line($grp->{focusedWindow},
	       #			      $grp->{focusedWindow}->{FSFile},$i,1),'tline',
    #	       "\n",'newline');
  }
  $t->tagAdd('all','0.0','end');
  $t->tagConfigure('all',-lmargin2 => 50);
}

sub sentViewSelectAll {
  my ($grp,$selref)=@_;
  return unless ref($selref) eq 'ARRAY';
  foreach (@{$selref}) {
    $_=1;
  }
}

sub sentViewSelectNone {
  my ($grp,$selref)=@_;
  return unless ref($selref) eq 'ARRAY';
  foreach (@{$selref}) {
    $_=0;
  }
}

sub sentViewGetSelection {
 my ($grp,$selref)=@_;
 $selref||=$grp->{sentDialogSelection};
 my $rng='';
 
 if (ref($selref) eq 'ARRAY') {
   for (my $i=0;$i<=$#{$selref};$i++) {
     $rng.=($i+1)."," if $selref->[$i];
   }
   $rng=~s/,$//;
 }
 return $rng;
}

sub viewSentences {
  my ($grp)=@_;
  return unless $grp and ref($grp->{focusedWindow}->{FSFile});
  if ($grp->{sentDialog}) {
    my $d=$grp->{sentDialog};
    $d->deiconify;
    $d->focus;
    $d->raise;
    return;
  }
  $grp->{sentDialogSelection}=[];
  my $d=$grp->{sentDialog}=
    $grp->{top}->Toplevel(-title=> "List of sentences for ".
			  $grp->{focusedWindow}->{FSFile}->filename(),
			  -width=> "10c");
  $d->withdraw;
  $d->bind('<Return>'=> [\&dlgReturn,1]);
  $d->bind('all','<Escape>'=> [sub { $_[1]->destroy(); },$d]);
  $d->bind('<Destroy>'=> [sub { $_[1]->{sentDialog}=undef; },$grp ]);
  populateSentencesDialog($grp,$grp->{sentDialog},
			  $grp->{focusedWindow}->{FSFile},
			  $grp->{sentDialogSelection},
			  1
			 );
  $d->Popup;
}

sub viewSentencesDialog {
  my ($grp,$top,$fsfile,$selref)=@_;
  return unless $grp and ref($grp->{focusedWindow}->{FSFile});
  my $d=
    $top->DialogBox(-title=> "List of sentences for ".
		    $fsfile->filename(),
		    -width=> "10c");
  $d->bind('<Return>', \&dlgReturn );
  escapeButton($d,'Cancel',1);
  $selref||=[];
  populateSentencesDialog($grp,$d,$fsfile,$selref,0);
  ShowDialog($d,$top);
  $d->destroy;
  undef $d;
  return $selref;
}

sub openSimpleHtml {
  my ($top,$file,$title,$initdir) = @_;
  $file= get_save_filename($top->toplevel,
			   -filetypes=>
			   [["HTML",  ['.html','.htm','.HTM','.HTML']],
			    ["All files",        "*"]],
			   -title=> $title,
			   -d $initdir ? (-initialdir=> $initdir) : (),
			   $^O eq 'MSWin32' ? () : (-initialfile=> filename($file)));
  if (defined($file) and $file ne "") {
    open my $html, ">$file" ||
      errorMessage($top,"Cannot write to \"$file\"!"."\n(".conv_from_locale($!)."\nCheck file and directory permissions.\n".
		     "\nSentences could not be saved!",1);
    my $encoding=$TrEd::Convert::outputenc;
    if ($]>=5.008 and not $TrEd::Convert::support_unicode) {
      _set_encoding($html,':bytes',"html-out");
    } else {
      _set_encoding($html,$encoding,"html-out");
    }
    
    print $html "<html>\n";
    print $html "<head>\n";
    print $html "  <meta http-equiv=\"Content-Type\" content=\"text/html;charset=".$encoding."\" />\n";
    print $html "</head>\n";
    print $html "<body>\n";
    return wantarray ? ($html,$file) : $html;
  } else {
    return undef;
  }
}

sub closeSimpleHtml {
  my ($html) = @_;
  print $html "\n</body>\n";
  print $html "\n</html>\n";
  close($html);
}

sub dumpSentView {
  my ($grp, $fsfile, $t, $create_images, $selref)=@_;

  my $win = $grp->{focusedWindow};
  return if ($create_images and warnWin32PrintConvert($t) eq 'Cancel');

  my $file=$fsfile->filename;
  $file=~s/\.(?:csts|sgml|sgm|cst|trxml|trx|tei|xml|fs|pls)(?:\.gz)?$/.html/i;

  my $initdir=dirname($file);
  $initdir=cwd if ($initdir eq './');
  $initdir=~s!${TrEd::Convert::Ds}$!!m;

  my @selref = split /,/,sentViewGetSelection($grp,$selref);
  unless (@selref) {
    errorMessage($t->toplevel,"No sentences selected. Select requested sentences and try again. To select a sentence, click the round button in front of it.",1);
    return;
  }

  (my $html,$file) = openSimpleHtml($t,$file,"Save Sentences As HTML ...",$initdir);
  if (defined($html)) {
    my @dump=$t->dump('0.0','end'); # to avoid a bug ??
    @dump = map $t->dump("start-tree-$_.first","end-tree-$_.last"), @selref;
    # @dump=$t->dump('0.0','end');
    my $img;

    # there seems to be a bug in Dump which prevents dumping tagoff
    # for the last open element on a line

    while (@dump) {
      my ($K,$V,$I) = splice @dump, 0, 3;
      if ($K eq 'tagon') {
	if ($V eq 'treeno') {
	  $img=1;
	  print $html "<div class=\"TREE\">";
	  print $html "<p>";
	} else {
	  print $html "<u>" if $t->tagCget($V,'-underline');
	  print $html "<font color=\"".$t->tagCget($V,'-foreground')."\">"
	    if $t->tagCget($V,'-foreground');
	  print $html "<span class=\"$1\">" if $V =~ /^tag\s*=>\s*(.*)$/;
	}
	if ($V eq 'newline') {
	  print $html "</p>\n";
	  print $html "</div>\n";
	  print $html "<hr />\n" if $create_images;
	}
      } elsif ($K eq 'tagoff') {
	print $html "</span>" if $V =~  /^tag\s*=>\s*.*$/ ;
	print $html "</font>" if $t->tagCget($V,'-foreground');
	print $html "</u>" if $t->tagCget($V,'-underline');
	$img=0 if $img;
      } elsif ($K eq 'text') {
	if ($img and $create_images) {
	  # create image filename
	  my $img_file = $file;
	  my $no = $V; $no =~ s/[()]|\s*//g;
	  $img_file =~ s/\.[^.]*$/_${no}.png/;
	  print $html "<img src=\"".filename($img_file)."\"/><br />\n";
	  # create image
	  my $canvas=$grp->{top}->Canvas();
	  my $stylesheet = $win->{stylesheet};
	  my $ss = undef;
	  if ($stylesheet ne STYLESHEET_FROM_FILE()) {
	    $ss=$win->{framegroup}->{stylesheets}->{$stylesheet};
	  }

	  $TrEd::TreeView::on_get_root_style = [\&onGetRootStyle,$win];
	  $TrEd::TreeView::on_get_node_style = [\&onGetNodeStyle,$win];

	  TrEd::Print::print_trees
	      ($fsfile,$grp->{top},$canvas,
	       $no,0,1,0,$img_file,0,
	       "$imageMagickConvert -density 75 - $img_file",
	       1,1,
	       $grp->{focusedWindow}->{treeView}->get_showHidden(),
	       {
		 'PS' => $psFontFile,
		 'AFM' => $psFontAFMFile,
		 'TTF' => ($grp->{ttfonts} ? $grp->{ttfonts}->{$ttFont} : ""),
		 'Size' => $psFontSize,
	       },
	       0,0,0,0,0,'BBox',$treeViewOpts,$ss);

	  $TrEd::TreeView::on_get_root_style = undef;
	  $TrEd::TreeView::on_get_node_style = undef;

	  $canvas->destroy();
	  $img=0;
	}
	print $html $V;
      } else {
#	print $html "<other key=\"$K\" value=\"$V\"/>";
      }
    }
    closeSimpleHtml($html);
  }
}

sub populateSentencesDialog {
  my ($grp,$d,$fsfile,$selref,$close_button)=@_;
  return unless $grp and $fsfile;

  use Tk::ROText;
#c -background white
  my $t= $d->
    Scrolled(qw/ROText -relief sunken -borderwidth 2 -setgrid true
                     -spacing3 6 -wrap word
		     -height 20 -scrollbars oe/,
	     -font=>$font
	    );
  $t->Subwidget('scrolled')->menu->delete('File');
  disable_scrollbar_focus($t);
  $t->pack(qw/-expand yes -fill both/);
  $t->BindMouseWheelVert();
  $grp->{sentDialogText}=$t;
  my $bottom=$d->Frame()->pack(qw/-expand yes -fill both/);

  if ($close_button) {
    $bottom->Button(-text=> "Close",
		    -underline => 0,
		    -command=> [sub { $_[0]->destroy; },$d])
      ->pack(-side=> 'left', -expand=> 1,  -padx=> 1, -pady=> 1);
  }

  $bottom->Button(-text=> "Reload",
		  -underline => 0,
		  -command=> [\&reloadSentenceView,$grp,$t,$selref])
    ->pack(-side=> 'left', -expand=> 1,  -padx=> 1, -pady=> 1);
  $bottom->Button(-text=> "Select All",
		  -underline => 7,
		  -command=>[ \&sentViewSelectAll,$grp,$selref])
    ->pack(-side=> 'left', -expand=> 1,  -padx=> 1, -pady=> 1);
  $bottom->Button(-text=> "Clear selection",
		  -underline => 1,
		  -command=>[ \&sentViewSelectNone,$grp,$selref])
    ->pack(-side=> 'left', -expand=> 1,  -padx=> 1, -pady=> 1);
  $bottom->Button(-text=> "Save As HTML",
		  -underline => 0,
		  -command=>[ \&dumpSentView,$grp,$fsfile,$t,0,$selref])
    ->pack(-side=> 'left', -expand=> 1,  -padx=> 1, -pady=> 1);
  $bottom->Button(-text=> "Save As HTML with Images",
		  -underline => 18,
		  -command=>[ \&dumpSentView,$grp,$fsfile,$t,1,$selref])
    ->pack(-side=> 'left', -expand=> 1,  -padx=> 1, -pady=> 1);

  _bind_buttons($d,$d);
  reloadSentenceView($grp,$t,$selref);
}


sub editListAttr {
  my ($win, $value, $attr,$d)=@_;
  return unless $win->{FSFile};
  my @vals= map { encode($_) } $win->{FSFile}->FS->listValues($attr);
  #print "splitting ",$value{$attr},"\n";
  my @selected= map { encode($_) } split /\|/,$value;
  #print "splitted to ", join ('-',@selected),"\n";

  if (selectValuesDialog($win->{framegroup},$attr,\@vals,\@selected,0,$d)) {
    return decode(join('|',@selected));
  }
  return undef;
}

sub editAmbiguousAttr {
  my ($win, $value, $attr)=@_;
  my @vals= map { encode($_) }split /\|/,$value;
  my @selected= @vals;
  
  if (selectValuesDialog($win->{framegroup},$attr,\@vals,\@selected,1,$win->toplevel)) {
    return decode(join('|',@selected));
  }
  return undef;
}

sub focusxEditDn {
  my ($w,$i,$e,$f,$atord)=@_;
  if ($i+1<@$atord) {
    $f->see($e->{$atord->[$i+1]});
    $e->{$atord->[$i+1]}->focus;
  }
  Tk->break;
}

sub focusxEditUp {
  my ($w,$i,$e,$f,$atord)=@_;
  if ($i>0) {
    $f->see($e->{$atord->[$i-1]});
    $e->{$atord->[$i-1]}->focus;
  }
  Tk->break;
}

sub focusxFind {
  my ($w,$i,$e,$f,$atord)=@_;
  my $ev= $w->XEvent;
  my $A= $ev->A;
  if ($A ne "") {
    my $count=scalar(@$atord);
    for (my $j=$i+1;$j<=$i+$count;$j++) {
      if (($atord->[$j % $count]) =~ /^\Q$A\E/i) {
	$f->see($e->{$atord->[$j % $count]});
	$e->{$atord->[$j % $count]}->focus();
	Tk->break;
	return;
      }
    }
  }
}

# sub updateAttrDialog {
#   my ($grp) = @_;
#   if ($grp->{updateAttrDialog} and $grp->{attrsEditor}) {
#     $grp->{attrsEditor}->delete('all');
#     $grp->{attrsEditor}->add_members(@{$grp->{updateAttrDialog}});
#     $grp->{attrsEditor}->update();
#     delete $grp->{updateAttrDialog};
#   }
# }

sub editAttrsDialog_schema {
  my ($win,$node,$attr_path)=@_;
  my $grp = $win->{framegroup};
#   if ($grp->{attrsDialog}) {
#     my $d=$grp->{attrsDialog};
#     my $edit = $grp->{attrsEditor};
#     my $schema = $win->{FSFile}->metaData('schema');
#     my $node_type = $schema->find_type($attr_path);
#     my $attr_name;
#     $d->afterIdle([\&updateAttrDialog,$grp]) unless $grp->{updateAttrDialog};
#     if ($attr_path) {
#       $attr_name = $attr_path;
#       $attr_name =~ s{.*/}{};
#       $grp->{updateAttrDialog} = [ '',$node_type,$node->attr($attr_path), $attr_name ];
#     } else {
#       $grp->{updateAttrDialog} = [ '',$node_type,$node ];
#     }
#     return;
#   }

  require Tk::TrEdNodeEdit;

  use Data::Dumper;
  # __debug("PATH: '$attr_path'\n");

  my $base_type = $node->type;
  my $schema;
  my $enabled = 1;
  my $node_type;
  unless (ref($base_type)) {
    $schema = fileSchema($win->{FSFile});
    my @ntypes = $schema->node_types;
    if (@ntypes==1) {
      $base_type = $schema->type($ntypes[0]);
    } elsif (!grep {!(UNIVERSAL::isa($_,'HASH') and 
	              exists $_->{name} and 
		      $_->{name} ne "")
		  } @ntypes) {
      my $i = 1;
      my @types = map {($i++)." ".$_->{name}} @ntypes;
      my $selection = [$types[0]];
      listQuery($grp->{top},'Untyped node: select node-type','browse',
		\@types,$selection) || return;
      if ($selection->[0]=~/^(\d+) /) {
	$node->set_type($schema->type($ntypes[$1-1]));
	$base_type=$node->type;
      } else {
	return;
      }
    } else {
      errorMessage($win,"Untyped node: can't edit untyped node in a file with a schema defining un-named node-types...\n".
      join("\n",map { Dumper($_) } grep {!(UNIVERSAL::isa($_,'HASH') and 
	  exists $_->{name} and $_->{name} ne "")} @ntypes),1);
      return;
    }
  } else {
    $schema = $node->type->schema;
  }

  $win->toplevel->Busy(-recurse=>1);

  if ($attr_path ne "") {
    $node_type = $base_type->find($attr_path);
    # __debug("NODETYPE: '$attr_path'\n",Dumper($base_type),"\n",Dumper($node_type),"\n");
    $enabled = 0 if doEvalHook($win,'enable_attr_hook',$attr_path,"normal") eq 'stop';
  } else {
    $enabled= 0 if (doEvalHook($win,'enable_edit_node_hook',$node) eq 'stop');
    $node_type = $base_type->type_struct;
  }
  my $dlg_title = ($attr_path ne "" ? "Edit Attribute '$attr_path'" : "Edit Node");
  my @buttons = $enabled ? qw(OK Cancel) : ('Cancel');
  my $d=$win->toplevel->DialogBox(-title=> $dlg_title,
				  -buttons=> \@buttons
				 );
  $d->protocol('WM_DELETE_WINDOW' => [sub { shift->{selected_button}='Cancel'; },$d]);
  $d->maxsize(0,int(0.9*$d->screenheight));

## experiment with a persistent node editor
#   my $d=$grp->{attrsDialog}=
#     $grp->{top}->Toplevel(-title=> "Node attributes",-background => 'white');
#   $d->withdraw;
#   $d->bind('<Destroy>' => [ sub {delete $_[1]->{attrsDialog};
# 				 delete $_[1]->{attrsEditor}; },$grp ]);



  my $edit = # $grp->{attrsEditor} =
    $d->Scrolled('TrEdNodeEdit',
			  -width=> 70,
			  -height => 0,
			  -indicator => 1,
			  -scrollbars => 'oe'
			 );
  $edit->Tk::bind('Freeze','<Map>',undef);
  $edit->bindtags([grep { $_ ne 'Freeze'} $edit->bindtags]);
  $edit->set_schema($schema);
  my $attr_name = $attr_path;
  $attr_name =~ s{(.*/)}{};
  my $base_path = $1;

  $edit->set_enable_callback([
    sub {
      my ($win,$base_path,$path)=@_;
      # __debug("enable_attr_hook: $base_path, $path\n");
      $path = $base_path.$path if $base_path ne "";
      doEvalHook($win,'enable_attr_hook',$path,"normal") eq 'stop' ? 0 : 1
    }, $win,$base_path
   ]);
  #__debug("ATTR-PATH:' $attr_path' ",$node->attr($attr_path),"$attr_name\n", Dumper($node_type),"\n");
  if ($attr_path ne "") {
    $edit->add_member('',$node_type,$node->attr($attr_path), $attr_name);
  } elsif (ref($node_type) and $node_type->{member}) {
    # 1=allow empty (don't create empty structures)
    $edit->add_members('',$node_type,$node,1);
  } else {
    # 1=allow empty (don't create empty structures)
    $edit->add_xmlnode('',$node_type,$node,1);
  }

  if ($attr_path eq "") {
    my $sf = $d->Frame->pack(qw(-fill x -side bottom));
    $sf->Label(-underline => 0,
	       -text => 'Search name:')->pack(qw(-side left));
    my $qs = $sf->Entry(
      -validate => 'key',
      -validatecommand => 
	[sub {
	   my ($tree,$value)=@_;
	   if ($tree->info(exists => $value)) {
	     $tree->select_entry($value);
	     return $value;
	   } elsif ($value =~ /^(.*)\/([^\/]*)/) {
	     my ($p,$v)=($1,$2);
	     if ($tree->info(exists => $p)) {
	       foreach ($tree->info('children'=>$p)) {
		 if (/^\Q$p\E\/\Q$v\E/) {
		   $tree->select_entry($_);
		   return $_;
		 }
	       }
	     }
	   } else {
	     foreach ($tree->info('children')) {
	       if (/^\Q$value\E/) {
		 $tree->select_entry($_);
		 return $_;
	       }
	     }
	   }
	   return undef;
	 },$edit]
       )->pack(qw(-side right -expand 1 -fill x));
    $d->bind('all','<Alt-s>', [$qs,'focus']);
    $qs->bind('<Return>',[$edit,'focus_entry']);
    $qs->bind('<Escape>',[sub { $_[1]->focus; Tk->break; },$edit]);
    $edit->configure(-browsecmd =>
		       [sub { $_[0]->delete(0,'end');
			      $_[0]->insert(0,$_[1]);
			    },$qs]
		      );
  }

  $edit->autosetmode();

  $edit->columnWidth(0,'');
  $edit->columnWidth(1,'');
  $edit->columnWidth(2,'1c');

#  $edit->configure( -height => 0);

  $edit->update;
  $edit->pack(qw(-expand 1 -fill both));
  $edit->BindResize;

  $edit->focus;
  if ($attr_path ne "") {
    $edit->select_entry($attr_name);
  }
  $d->bind('all','<Tab>','focusNext');
  $d->bind('all','<<LeftTab>>','focusPrev');

  for (@buttons) {
    $d->Subwidget("B_$_")->configure(-underline => 0);
    $d->bind('all','<Alt-'.lc(substr($_,0,1)).'>'
	     => [sub { $_[1]->{selected_button}=$_[2] },$d,$_ ]);
  }
  $edit->bind('<Escape>'=> [sub { $_[1]->{selected_button}='Cancel'; },$d ]);
  $d->bind('<Escape>'=> [sub { $_[1]->{selected_button}='Cancel'; },$d ]);
  $d->bind('all','<Control-Return>',\&dlgReturn);
  $edit->bind('<Control-Return>',\&dlgReturn);

  $win->toplevel->Unbusy();

  my $result = ShowDialog($d,$edit,$win->toplevel);
  if ($result=~ /OK/) {
    $win->{FSFile}->notSaved(1);
    save_undo($win,prepare_undo($win,$dlg_title));
    lastActionBookmark($win->{framegroup});
    if ($attr_path eq "") {
      $edit->dump_to_node($node);
    } else {
      my $val = {};
      $edit->dump_to_node($val);
      $node->set_attr($attr_path,$val->{$attr_name});
#      print Dumper($val),"\n";
    }
    doEvalHook($win,"after_edit_node_hook",$node,1);
    get_nodes_fsfile_tree($win->{framegroup},$win->{FSFile},$win->{treeNo});
    redraw_fsfile_tree($win->{framegroup},$win->{FSFile},$win->{treeNo});
  } else {
     doEvalHook($win,"after_edit_node_hook",$node,0);
  }
  $d->destroy;
## for persistent dialog
##  $d->Popup;
  return ($result=~ /OK/) ? 1 : 0;
}

sub editAttrsDialog {
  my ($win,$node)=@_;
  return if (doEvalHook($win,"do_edit_node_hook",$node) eq 'stop');
  return unless $win->{FSFile};
  return editAttrsDialog_schema($win,$node)
    if (ref($node->type) or
	ref(fileSchema($win->{FSFile})));
  my @vals;
  my %e=();
  my @atord=$win->{FSFile}->FS->attributes;

  if ($sortAttrs) {
    @atord=sort {uc($a) cmp uc($b)} $win->{FSFile}->FS->attributes
      unless (doEvalHook($win,"sort_attrs_hook",\@atord));
  }
  my $rows=min($maxDisplayedAttributes,$#atord+1);
  my ($a,$b,$r);

  my $enabled=(doEvalHook($win,'enable_edit_node_hook',$node) eq 'stop') ? 0 : 1;
  my @buttons = $enabled ? qw(OK Cancel) : ('Cancel');
  $win->toplevel->Busy(-recurse=>1);
  my $d=$win->toplevel->DialogBox(-title=> "Edit Node", -width=> '10c',
				  -buttons=> \@buttons
				 );
  $d->bind('<Return>',\&dlgReturn);
  $d->bind('all','<Control-Return>',\&dlgReturn);
  escapeButton($d,'Cancel',1);
  my $ff=$d->Frame(-relief=> 'groove',
		   -bd => 1);
  my $f= $ff->Scrolled('Pane',
		      -sticky => 'we',
		      -scrollbars=> 'oe');
  disable_scrollbar_focus($f);
  $f->BindMouseWheelVert("","EditEntry");

  my $lwidth;
  foreach (@atord) {
    $lwidth=max($lwidth,length($_));
  }
  my $height=0;


  for (my $i=0;$i<=$#atord;$i++) {
    $_=$atord[$i];
    # Reliefs: raised, sunken, flat, ridge, and groove.
    my $eef=$f->Frame()->pack(qw/-side top -expand yes -fill x/);
    $eef->Label(-text=> $_,
		-underline => 0,
		-justify => 'left',
		-width =>$lwidth,
		-anchor=> 'nw')->pack(qw/-side left/);

    if  ($win->{FSFile}->FS->isList($_) or
	 $node->getAttribute($_)=~/^(?:[^\|\\]|\\.)*\|/) { # readonly entry and buttons for list
      $r= $eef->Frame();
      $e{$_}= $r->Entry(-relief=> 'sunken', -takefocus=> 1,
			 -font=> $font)->pack(qw/-expand yes -fill both -side left/);
      addBindTags($e{$_},"EditEntry");
	$b=$r->Button(-text=> "...", -takefocus=> 0,
 		      -command=> [sub {
 				     my ($e,$win,$node,$attr,$d)=@_;
 				     my $result=
 				       ($win->{FSFile}->FS->isList($attr)
 					? editListAttr($win,$e->get,$attr)
 					: editAmbiguousAttr($win,$e->get,$attr,$d));
 				     if (defined $result) {
 				       $e->configure(-state=> 'normal');
 				       $e->delete(0,length($e->get));
 				       $e->insert(0,$result);
 				       $e->configure(-state=> 'disabled');
 				     }
				   },$e{$_},$win,$node,$_,$d]
		     )->pack(qw/-side right/);
	$e{$_}->bind($e{$_},'<space>',[sub { shift; shift->invoke; Tk->break; },$b]);
	$e{$_}->bind($e{$_},'<Return>',[sub { shift; shift->invoke; Tk->break; },$b]);
	$e{$_}->bind($e{$_},'<Control-Return>',\&dlgReturn);
	$e{$_}->bind($e{$_},'<Double-ButtonPress-1>',[sub { shift; shift->invoke; Tk->break; },$b]);
      $e{$_}->insert(0,encode($node->getAttribute($_)));
      $e{$_}->configure(-state=> 'disabled');
      $r->pack(qw/-side right -expand yes -fill both/);
      $height += max($b->reqheight,$e{$_}->reqheight()) if ($i<$rows);
    } else {
      $e{$_}= $eef->Entry(-relief=> 'sunken', -takefocus=> 1,
			 -font=> $font)->pack(qw/-side right -expand yes -fill both/);
      addBindTags($e{$_},"EditEntry");
      $e{$_}->insert(0,encode($node->getAttribute($_)));
      if (doEvalHook($win,'enable_attr_hook',$_,"normal") eq 'stop') {
	$e{$_}->configure(-state=> 'disabled');
      }
      $height += $e{$_}->reqheight() if ($i<$rows);
    }
    $f->bind($e{$_}, '<Tab>',       [\&focusxEditDn,$i,\%e,$f,\@atord]);
    $f->bind($e{$_}, '<Down>',      [\&focusxEditDn,$i,\%e,$f,\@atord]);
    $f->bind($e{$_}, '<Shift-Tab>', [\&focusxEditUp,$i,\%e,$f,\@atord]);
    $f->bind($e{$_}, '<Shift-ISO_Left_Tab>',
	                            [\&focusxEditUp,$i,\%e,$f,\@atord]);
    $f->bind($e{$_}, '<Up>',        [\&focusxEditUp,$i,\%e,$f,\@atord]);
    $f->bind($e{$_}, '<Alt-KeyPress>', [\&focusxFind,$i,\%e,$f,\@atord]);
  }

  $f->configure(-height => $height);
  $f->pack(qw/-expand yes -fill both/);
  $ff->pack(qw/-expand yes -fill both/);
  $win->toplevel->Unbusy();

  my $result= ShowDialog($d,(
			     $atord[0] ? $e{$atord[0]}->focus : undef
			    ),$win->toplevel);

  if ($result=~ /OK/) {
    $win->{FSFile}->notSaved(1);
    save_undo($win,prepare_undo($win,'Edit Node'));
    lastActionBookmark($win->{framegroup});
    foreach $a (@atord) {
      $node->setAttribute($a,decode($e{$a}->get));
    }
    doEvalHook($win,"after_edit_node_hook",$node,1);
    get_nodes_fsfile_tree($win->{framegroup},$win->{FSFile},$win->{treeNo});
    redraw_fsfile_tree($win->{framegroup},$win->{FSFile},$win->{treeNo});
  } else {
     doEvalHook($win,"after_edit_node_hook",$node,0);
  }

  undef %e;
  $d->destroy;
  return ($result =~ /OK/) ? 1 : 0;
}

sub disable_scrollbar_focus {
  my ($scrolled)=@_;
  $scrolled->Subwidget('xscrollbar')->configure(qw(-takefocus 0));
  $scrolled->Subwidget('yscrollbar')->configure(qw(-takefocus 0));
}

sub format_tred_pod {
  map {
    if (/^([BICQ])<(.[^>]*)>/) {
      my $style;
      if ($1 eq 'B') {
	$style = 'bold';
      } elsif ($1 eq 'I') {
	$style = 'italic';
      } elsif ($1 eq 'C') {
	$style = 'fixed';
      } else {
	$style = 'default';
      }
      my $l = $2;
      $l=~s/&lt;/\</g;
      $l=~s/&gt;/\>/g;
      ($l,$style)
    } else {
      my $l=$_;
      $l=~s/&lt;/\</g;
      $l=~s/&gt;/\>/g;
      ($l,'default')
    }} split /([BICQ]<.[^>]*>)/,$_[0]
}

sub tred_pod_add_tags {
  my ($w)=@_;
  $w->tag(qw(configure bold -font C_bold));
  $w->tag(qw(configure fixed -font C_fixed));
  $w->tag(qw(configure default -font C_default));
  $w->tag(qw(configure italic -font C_italic));
}

sub splitPatterns {
  my ($text)=@_;
  my @lines = split /(\n)/,$text;
  my @result;
  my $pattern = '';
  my ($hint,$context);
  while (@lines) {
    my $line = shift @lines;
    if ($line=~/^([a-z]+):/) {
      if ($pattern =~ /\S/) {
	chomp $pattern;
	if ($pattern=~s/^hint:\s*//) {
	  $hint = $pattern;
	} elsif ($pattern=~s/^context:\s*//) {
	  $context = $pattern;
	} else {
	  push @result, $pattern;
	}
      }
      $pattern = $line;
    } else {
      $pattern.=$line;
    }
  }
  if ($pattern =~ /\S/) {
    chomp $pattern;
    if ($pattern=~s/^hint:\s*//) {
      $hint = $pattern;
    } else {
      push @result, $pattern;
    }

  }
  return $hint,$context,\@result;
}

sub deleteStylesheet {
  my ($grp,$stylesheet)=@_;
  delete $grp->{stylesheets}->{$stylesheet};
  updateStylesheetMenu($grp);
  foreach my $win (stylesheetUsingWindows($grp,$stylesheet)) {
    if ($grp->{focusedWindow} == $win) {
      $grp->{selectedStylesheet} = STYLESHEET_FROM_FILE();
    }
    applyWindowStylesheet($win,STYLESHEET_FROM_FILE());
    if ($win->{FSFile}) {
      get_nodes_win($win);
      redraw_win($win);
    }
  }
}

sub setStylesheetPatterns {
  my ($win,$text,$stylesheet,$create)=@_;
  my $grp = $win->{framegroup};
  my ($hint,$patterns);
  if (ref($text)) {
    ($hint,$context,$patterns)=@$text;
  } else {
    ($hint,$context,$patterns)=splitPatterns($text);
  }
  $stylesheet = $win->{stylesheet} unless defined $stylesheet;
  if ($stylesheet eq STYLESHEET_FROM_FILE()) {
    if ($win->{FSFile}) {
      $win->{FSFile}->changeHint($hint);
      $win->{FSFile}->changePatterns(@$patterns);
    } else {
      return 0;
    }
  } else {
    my $s=$grp->{stylesheets}->{$stylesheet};
    if (ref($s)) {
      @{$s->{patterns}} = @$patterns;
      $s->{hint} = $hint;
      $s->{context} = $context;
    } elsif ($create) {
      $grp->{stylesheets}->{$stylesheet}->{patterns}=[@$patterns];
      $grp->{stylesheets}->{$stylesheet}->{hint}=$hint;
      $grp->{stylesheets}->{$stylesheet}->{context}=$context;
      updateStylesheetMenu($grp);
    } else {
      return 0;
    }
  }
  return 1;
}

sub getStylesheetPatterns {
  my ($win,$stylesheet)=@_;
  my ($hint,$context,$patterns);
  $patterns = [];
  $stylesheet = $win->{stylesheet} unless defined $stylesheet;
  if ($stylesheet eq STYLESHEET_FROM_FILE()) {
    if ($win->{FSFile}) {
      $hint = $win->{FSFile}->hint();
      $context = undef;
      @$patterns = $win->{FSFile}->patterns()
    } else {
      return ();
    }
  } else {
    my $s=$win->{framegroup}->{stylesheets}->{$stylesheet};
    if (ref($s)) {
      $hint = $s->{hint};
      $context = $s->{context};
      $context = '.*' unless (wantarray or $context =~ /\S/);
      @$patterns = @{$s->{patterns}};
    } else {
      return ();
    }
  }
  # try to fix old non-labeled patterns
  @$patterns = map { /^([a-z]+):/ ? $_ : "node: ".$_ } @$patterns;
  return wantarray ? ($hint,$context,$patterns) :
    ("context: ".$context."\n".
       # fix old non-labeled hints
       (join "\n",map {"hint: ".$_} split /\n/,$hint)."\n".
	join("\n",@$patterns));
}

sub editStylesheetDialog {
  my ($grp)=@_;
  my $win=$grp->{focusedWindow};
  return if (doEvalHook($win,"customize_attrs_hook") eq 'stop');

  return unless $win->treeView->patterns() or $win->{FSFile};

  $grp->{top}->Busy(-recurse=>1);
  my @buttons = ("OK", "Preview",
		 (($win->{FSFile} and $win->{stylesheet} ne STYLESHEET_FROM_FILE()) ? "Store to current file" : ()),
		 "Cancel");
  my $d=$grp->{top}->
    DialogBox(-title=> "Stylesheet editor",
	      -width=> '10c',
	      -buttons=> \@buttons);

  $d->Subwidget("B_$_")->configure(-underline => 0) for @buttons;
  $d->Subwidget('top')->configure(qw(-takefocus 0));
  $d->Subwidget('bottom')->configure(qw(-takefocus 0));

  # Pattern Editor
  my $eff=$d->Frame(qw/-relief sunken -bd 1 -takefocus 0/)->
    pack(qw/-padx 3 -pady 3 -side top -fill x/);
#  $eff->Frame(qw/-height 6 -takefocus 0/)->pack();
  my $elabff=$d->Frame->pack(-in => $eff, qw/-padx 3 -pady 3 -side top -fill x/);
  $elabff->Label(-text => "Here you can edit the current display stylesheet (press ^I to insert tab, ^L to clear)",
		 -anchor => 'nw', -justify => 'left')->pack(qw/-side left/);
  my $helplabel = $elabff->Label(-text => "Help",
			    -underline => 0,
			    -anchor => 'nw', -justify => 'left')
    ->pack(qw/-side right/);

  my $HELP = <<'EOF';
B<Stylesheet quick help:>
I<In this dialog you may edit the current display stylesheet. Stylesheets are sets of display PATTERNS (as described below) that influence the overall tree appearance as well as visual representation of individual nodes, edges and labels (including label content). Each pattern either represents one line of a label (node or edge), defines a per-node text to appear in the value line above the tree, and/or provides styling information for the node and its edges (such as node shape, color, line thickness, line style, etc.). See the User's manual for more details.>

B<PATTERN:> C<&lt;prefix&gt;:&lt;rules&gt;>

B<Default prefixes:>
  C<context>    - restrict stylesheet to contexts matching given regexp
  C<node>      	- define a node label (default if no prefix given)
  C<edge>      	- define an edge label
  C<style>     	- define node and edge appearance (for individual nodes)
  C<rootstyle> 	- define node and edge appearance globally
  C<text>      	- define per-node value-line text
  C<hint>      	- renders to text displayed in a node's tooltip

B<Rules interpolation:>
  C<${attribute}    >- interpolates to the attribute value
  C<#{color}        >- applies given font color to the rest of the label

  C<&lt;? perlcode ?&gt;>  - evaluates Perl code and interpolates the result.
                    C<$this> - the node the label or style applies to
                    C<$root> - root of the tree
                    C<$${attribute}> - like C<"$this-&gt;{attribute}">

  any other text - interpolates to itself

B<RootStyles:>
  C<balance             >- draw "balanced" Penn-treebank like tree, instead of
  C<                    >  ordering nodes according to a dedicated attribute
  C<                    >  (can only be used in a rootstyle pattern)
  C<baseXPos            >- X-coordinate of the root node
  C<baseYPos            >- Y-coordinate of the root node
  C<nodeXSkip           >- default horizontal skip between nodes
  C<nodeYSkip           >- default vertical skip between nodes

B<Styles:>
  C<#{object-feature:value}>

B<Colors:>
  Colors can be specified either by name (such as 'red', 'lightblue', etc.), or
  by a hex RGB string of the form #RRGGBB.

B<Features:>
  C<Node-shape          >- oval, rectangle, polygon
  C<Node-polygon        >- relative coordinates of the poligon points
  C<Node-width          >- set shape width to the given amount
  C<Node-height         >- set shape height to the given amount
  C<Node-addwidth       >- add to shape width by given amount
  C<Node-addheight      >- add to shape height by given amount
  C<Node-currentwidth   >- set shape width for active node
  C<Node-currentheight  >- set shape height for active node
  C<Node-rellevel       >- alter vertical leveling of the subtree
  C<Node-level          >- alter vertical leveling of a single node
  C<Node-addbeforeskip  >- skip before: 10, 2c, 12pt, etc.
  C<Node-addafterskip   >- skip after
  C<NodeLabel-valign    >- only as rootstyle. Values: top, center, bottom.
  C<NodeLabel-halign    >- left, right, center
  C<NodeLabel-yadj      >- adjust vertical position of node labels by given amount
  C<NodeLabel-dodrawbox >- force drawing a box around labels: yes/no
  C<NodeLabel-nodrawbox >- force disabling a box around node label: yes/no
  C<EdgeLabel-yadj      >- adjust vertical position of edge labels by given amount
  C<EdgeLabel-coords    >- custom edge label position. Default: (n+p)/2,(n+p)/2
  C<EdgeLabel-halign    >- values: right, center, left
  C<EdgeLabel-valign    >- values: top, center, bottom
  C<EdgeLabel-dodrawbox >- force drawing a box around edge labels: yes/no
  C<EdgeLabel-nodrawbox >- force disabling a box around node label: yes/no
  C<Oval-dash           >- pattern for the outline of the node shape
  C<                    >  (oval/rectangle/polygon)
  C<Oval-activedash     >- pattern for the outline of the active node shape
  C<Oval-dashoffset     >- starting offset for the outline pattern
  C<Oval-fill           >- color to fill a node shape with
  C<Oval-activefill     >- color to fill the shape of an active node with
  C<Oval-outline        >- color of the outline of node shape
  C<Oval-activeoutline  >- color of the outline of the shape of the active node
  C<Oval-width          >- width of the outline of a node shape
  C<Oval-activewidth    >- width of the outline of an active node shape
  C<Line-coords         >- coordinations of the edge(s) to be drawn.
  C<                    >  Default: n,n,p,p. (See the documentation for more info.)
  C<Line-arrow          >- side of an edge to put an arrow on: first, both, last
  C<Line-smooth         >- 1 if the line should be drawn as a curve, 0 otherwise.
  C<Line-...            >- ...=dash, activedash, dashoffset, fill, activefill,
  C<Line-...            >  width, activewidth
  C<TextBox-...         >- ...=dash, activedash, dashoffset, fill, activefill,
  C<                    >  outline, activeoutline, width, activewidth
  C<EdgeTextBox-...     >- ditto
  C<                    >  (similar to Oval-... described above)
  C<Text[...]-..        >- see the documentation
  C<TextBg[...]-..      >- ditto

EOF

  require Tk::HelpTiptool;
  my $help = $d->HelpTiptool(-background => '#ffffbb',
			     -troughcolor => '#cccc99',
			     -message=> [format_tred_pod($HELP)]
			    );
  tred_pod_add_tags($help->Subwidget('text'));

  $d->bind('all','<Alt-h>', sub { $help->Toggle($helplabel); });
  $helplabel->bind('<Button>', sub { $help->Toggle($helplabel); });

  # All wrapping frame with attribute selection and buttons
  my $f= $d->Frame(qw/-relief sunken -bd 1 -takefocus 0/);
#  $f->Frame(qw/-height 6 -takefocus 0/)->pack(qw/-side bottom/);
  # Frame with pattenrs listbox
  my $cf= $f->Frame(qw(-takefocus 0));

  my $e= $cf->Scrolled(qw/Text -scrollbars osoe -height 35
                              -relief sunken -borderwidth 2/);
  $e->Subwidget('scrolled')->menu->delete('File');
  disable_scrollbar_focus($e);

  my $preview_applied;
  # the preview command
  $d->Subwidget('B_Preview')->configure(
    -command => [sub {
		   my ($win,$e,$p)=@_;
		   $$p = 1;
		   my ($hint,$context,$patterns)=getStylesheetPatterns($win);
		   setStylesheetPatterns($win,$e->get('0.0','end'));
		   update_value_line($grp);
		   if ($win->{stylesheet} eq STYLESHEET_FROM_FILE()) {
		     redraw_fsfile($grp,$win->{FSFile});
		   } else {
		     redraw_stylesheet($grp,$win->{stylesheet});
		   }
		   setStylesheetPatterns($win,[$hint,$context,$patterns]);
		 },$win,$e,\$preview_applied]);

  # Frame with attribute selection
  my $af= $f->Frame(qw(-takefocus 0));
#  $af->Frame(qw/-height 15 -takefocus 0/)->pack();
  # Attributes listbox
  $af->Label(qw/-text Attributes -underline 0 -anchor nw -justify left/)->pack(qw/-fill both/);
  my $al= $af->Scrolled(qw/Listbox
                     -bg white
                     -width 0
                     -relief sunken
                     -borderwidth 2 -setgrid true
                     -scrollbars oe
                     -exportselection 0/)->pack(qw/-pady 3 -expand yes -fill y/);
  $d->bind('all','<Alt-a>', [$al,'focus']);
  disable_scrollbar_focus($al);
  $al->BindMouseWheelVert();
  my @atord=();
  if ($win->{FSFile}) {
    if (fileSchema($win->{FSFile})) {
      @atord = fileSchema($win->{FSFile})->attributes;
    } else {
      @atord = $win->{FSFile}->FS->attributes;
    }
  }
  if ($sortAttrs) {
    @atord=sort {uc($a) cmp uc($b)} @atord
      unless (doEvalHook($win,"sort_attrs_hook",\@atord));
  }
  $al->insert('end',@atord);
  if (@atord) {
    $al->activate(0);
    $al->selectionSet(0);
  }

   $af->pack(qw/-padx 5 -side left -fill y/);

  {
    my $patterns=getStylesheetPatterns($win);
    $e->insert('0.0',$patterns);
  }
  $e->pack(qw/-padx 3 -pady 3 -side top -expand yes -fill both/);
  addTextSearchLine($cf,$e)->pack(qw(-fill x -side bottom));

  $cf->pack(qw/-padx 5 -side left -expand yes -fill both/);


  $f->pack(qw/-padx 3 -pady 3 -side top -expand yes -fill both/);

  $d->bind('all','<Tab>',[sub { shift->focusNext; }]);
  $e->bind('Tk::Text','<Control-l>',[sub {shift; $e->delete('0.0','end') },$e]);
  $e->bind('Tk::Text','<Tab>',[sub { shift->focusNext; }]);
  $d->bind('all','<Shift-Tab>',[sub { shift->focusPrev; }]);
  $d->bind('all','<Shift-ISO_Left_Tab>',[sub { shift->focusPrev; }]);
  $e->bind(ref($e->Subwidget('scrolled')),'<Control-Return>',\&dlgReturn);
  $e->bind('<Return>',sub{ Tk->break; });
  escapeButton($d,'Cancel',1);
  $al->bind('<Double-1>'=>
	   [sub {
	     $e->delete('sel.first','sel.last') 
	       if ($e->tagNextrange('sel','0.0'));
	     $e->insert('insert','${'.$al->get('active').'}');
	     $e->focus();
	   }]
	  );
  $al->bind('<space>'=>
	   [sub {
	     $e->delete('sel.first','sel.last') 
	       if ($e->tagNextrange('sel','0.0'));
	     $e->insert('insert','${'.$al->get('active').'}');
	   }]
	  );
  $al->bind('<Return>'=>
	   [sub {
	     $e->delete('sel.first','sel.last') 
	       if ($e->tagNextrange('sel','0.0'));
	     $e->insert('insert','${'.$al->get('active').'}');
	     $e->focus();
	     Tk->break;
	   }]
	  );

  $e->focus();
  _bind_buttons($d,$d);
  $grp->{top}->Unbusy();
  my $result= ShowDialog($d,$e,$grp->{top});
  if ($result eq 'Store to current file') {
    switchStylesheet($grp,STYLESHEET_FROM_FILE());
    $grp->{selectedStylesheet} = STYLESHEET_FROM_FILE();
    $win->{FSFile}->notSaved(1);
    $result = 'OK';
  }
  if ($result=~ /OK/) {
    setStylesheetPatterns($win,$e->get('0.0','end'));
    updateStylesheetMenu($grp);
    saveStyleSheets($grp) unless $win->{stylesheet} eq STYLESHEET_FROM_FILE();
    update_value_line($grp);
    if ($win->{stylesheet} eq STYLESHEET_FROM_FILE()) {
      redraw_fsfile($grp,$win->{FSFile});
    } else {
      redraw_stylesheet($grp,$win->{stylesheet});
    }
  } elsif ($preview_applied) {
    if ($win->{stylesheet} eq STYLESHEET_FROM_FILE()) {
      redraw_fsfile($grp,$win->{FSFile});
    } else {
      redraw_stylesheet($grp,$win->{stylesheet});
    }
  }
  $d->destroy;
  undef $d;
}


#####################################################
#####################################################
#####################################################
# Node searching
#####################################################

sub findNodeDialog {
  my ($grp,$template)=@_;
  return unless $grp->{focusedWindow}->{FSFile};
  my $win = $grp->{focusedWindow};
  my $r;
  my @vals;
  my @atord;
  if (fileSchema($win->{FSFile})) {
    @atord = fileSchema($win->{FSFile})->attributes;
  } else {
    @atord = $win->{FSFile}->FS->attributes;
  }

  if ($sortAttrs) {
    my @atord2 = @atord;
    if (doEvalHook($win,"sort_attrs_hook",\@atord2)) {
      @atord = @atord2;
    } else {
      @atord=sort {uc($a) cmp uc($b)} @atord
    }
  }

  my $b;
  my $a;
  my $rows=min($maxDisplayedAttributes,$#atord+1);
  my %e=();
  $grp->{top}->Busy(-recurse=>1);
  my $d=$grp->{top}->DialogBox(-title=> "Find Node By Attributes", -width=> '10c',
				 -buttons=> ["Find"]);
  my $bcl=$d->Subwidget('bottom')->Button(-text=> "Clear",
				  -command=> [sub { my $e=shift;
						     foreach (keys %$e) {
						       $e->{$_}->delete(0,'end');
						     }
						   },\%e] );
  my $bca=$d->Subwidget('bottom')->Button(-text=> "Cancel",
				  -command=> [sub { shift->{selected_button}= "Cancel"},$d] );
  foreach ($bcl,$bca) {
    $_->configure(-width=> 10, -pady=> 0) if ($Tk::platform eq 'MSWin32');
    $_->pack(-side=> 'left', -expand=> 1,  -padx=> 1, -pady=> 1);
  }
  $d->bind('<Return>', \&dlgReturn );
  escapeButton($d,'Cancel',1);
  my $ff=$d->Frame(-relief=> 'groove',
		   -bd => 1);
  my $f= $ff->Scrolled('Pane',
		      -sticky => 'we',
		      -scrollbars=> 'oe');
  disable_scrollbar_focus($f);
  $f->BindMouseWheelVert("","EditEntry");

  my $lwidth;
  foreach (@atord) {
    $lwidth=max($lwidth,length($_));
  }
  my $height=0;
  for (my $i=0;$i<=$#atord;$i++) {
    $_=$atord[$i];
    # Reliefs: raised, sunken, flat, ridge, and groove.
    my $eef=$f->Frame()->pack(qw/-side top -expand yes -fill x/);
    $eef->Label(-text=> $_,
		-underline => 0,
		-justify => 'left',
		-width =>$lwidth,
		-anchor=> 'nw')->pack(qw/-side left/);
    $e{$_}= $eef->Entry(-relief=> 'sunken', -takefocus=> 1,
			-font=> $font)->pack(qw/-side right -expand yes -fill both/);
    addBindTags($e{$_},"EditEntry");
    $e{$_}->insert(0,encode($template->{$_}));
    $height += $e{$_}->reqheight() if ($i<$rows);
    $f->bind($e{$_}, '<Tab>',       [\&focusxEditDn,$i,\%e,$f,\@atord]);
    $f->bind($e{$_}, '<Down>',      [\&focusxEditDn,$i,\%e,$f,\@atord]);
    $f->bind($e{$_}, '<Shift-Tab>', [\&focusxEditUp,$i,\%e,$f,\@atord]);
    $f->bind($e{$_}, '<Shift-ISO_Left_Tab>',
	                            [\&focusxEditUp,$i,\%e,$f,\@atord]);
    $f->bind($e{$_}, '<Up>',        [\&focusxEditUp,$i,\%e,$f,\@atord]);
    $f->bind($e{$_}, '<Alt-KeyPress>', [\&focusxFind,$i,\%e,$f,\@atord]);
  }
  $f->configure(-height => $height);
  $f->pack(qw/-expand yes -fill both/);
  $ff->pack(qw/-expand yes -fill both/);

  do {
    my $of=$d->Frame()->pack(qw/-expand yes -fill x/);
    $of->Label(-text=> 'Search method: ')->pack(qw/-side left/);
    $of->Optionmenu(-variable=> \$grp->{templateMatchMethod},
		    -textvariable=> \$grp->{templateMatchMethod},
		    -options=> ['Regular expression',
				'Exhaustive regular expression',
				'Wildcard pattern',
				'Literal'])->pack(qw/-side left/);
  };
  my $of=$d->Frame()->pack(qw/-expand yes -fill x/);
  $of->Label(-text=> 'Search file-list: ')->pack(qw/-side left/);
  my $om=$of->Optionmenu(-textvariable=> \$grp->{searchFilelist})->pack(qw/-side left/);
  $om->options(['[Current file only]', map { $_->name } @filelists]);
  $of->Button(-text=> 'Edit',
	      -command=> [ sub {
			      my ($grp)=@_;
			      my $name=filelistDialog($grp,1);
			      $om->options(['[Current file only]',map { $_->name } @filelists]);
			      $grp->{searchFilelist}=$name if (ref(findFilelist($name)));
			    },$grp,$om])->pack(qw/-side left/);
  $grp->{top}->Unbusy();
  my $result= ShowDialog($d,($atord[0] ? $e{$atord[0]}->focus : undef),$grp->{top});
  if ($result=~ /Find/) {
    foreach $a (@atord) {
      $template->{$a}=decode($e{$a}->get);
    }
    # Clear all empty rules
    foreach (keys %$template) {
      delete $template->{$_} unless defined($template->{$_}) and $template->{$_} ne '';
    }
    if ($grp->{searchFilelist} ne '[Current file only]') {
      my $fl=findFilelist($grp->{searchFilelist});
      if (ref($fl) and $fl->file_count>0 ) {
	local $insideEval=1;                 # no redraw
	$fl->set_current($fl->file_at(0));
	selectFilelist($grp,$fl);
      }
    } else { 
      $grp->{searchFilelist}=undef;
    }
    doFindFirstTemplated($grp,$template,0);
  }
  $d->destroy;
  undef $d;
}

#####################################
# bound to Escape for busy widgets
#####################################
sub _search_busy {
  my ($w,$grp)=@_;
  print STDERR $grp->{focusedWindow}->{currentFileNo}."stopped by user\n" if ($tredDebug);
  $grp->{stopSearch}=1;
  Tk->break;
}

#####################################
# called after file open to process
# event queue and let user interrupt
# the search process
#####################################
sub _quick_update {
  my $grp=$_[0];
  $grp->{top}->Unbusy();
  $grp->{top}->update();
  $grp->{top}->Busy(-recurse=> 1);
}

######################################
# start searching for a next node
# and display result unless succeeded
######################################
sub doFindFirstTemplated {
  my ($grp,$template,$cont)=@_;
  return undef unless ($grp->{focusedWindow}->{currentNode});
  my $result;
  $grp->{top}->Busy(-recurse=> 1);

  print "Starting search!\n"  if $tredDebug;
  unless ($result=findFirstTemplated($grp,$template,$cont)) {
    redraw_win($grp->{focusedWindow});
    $grp->{top}->toplevel->
      messageBox(-icon=> 'warning',
		 -message=> $grp->{stopSearch} ? "Interrupted by user!" : "No matching node found!",
		 -title=> 'Find',
		 -type=> 'ok');
  }
  $grp->{top}->Unbusy();
  return $result;
}

######################################
# start searching for a prev node
# and display result unless succeeded
######################################
sub doFindPrevTemplated {
  my ($grp,$template,$cont)=@_;
  return undef unless ($grp->{focusedWindow}->{currentNode});
  my $result;
  $grp->{top}->Busy(-recurse=> 1);

  unless ($result=findPrevTemplated($grp,$template,$cont)) {
    redraw_win($grp->{focusedWindow});
    $grp->{top}->toplevel->
      messageBox(-icon=> 'warning',
		 -message=> $grp->{stopSearch} ? "Interrupted by user!" : "No matching node found!",
		 -title=> 'Find',
		 -type=> 'ok');
  }
  $grp->{top}->Unbusy();
  return $result;
}

######################################
# compare nodes with template
######################################
sub cmpTemplateField {
  my ($grp,$val,$templ)=@_;
  my $method=substr($grp->{templateMatchMethod},0,1);
  return $val=~ /^$templ$/ if ($method eq 'E');
  return $val=~ /$templ/ if ($method eq 'R');
  return $val eq $templ if ($method eq 'L');
  if ($method eq 'W') {
    $templ=~s/[.^$(){}<>\\]/\\\&/g;
    $templ=~s/\*/.\*/g;
    $templ=~s/\?/./g;
    return $val=~ /^$templ$/;
  }
  return $val eq $templ;
}

######################################
# go to next node in searchlist
######################################
sub nextNodeInSearchFilelist {
  my ($grp,$node,$tree)=@_;
  my $win=$grp->{focusedWindow};

  $node=(HNext($win,$node) || 
	 $win->{FSFile}->treeList->[(++$$tree)]);
  return $node if ($node or !defined($grp->{searchFilelist}));

  # this realises filelist search
  local $insideEval=1;
  my $result=nextRealFile($grp,1);
  $win->{treeNo}=-1; # force redraw in gotoTree
  $$tree=0;
  # we especially wait for Escape
  _quick_update($grp);
  while (!$grp->{stopSearch} and $result and !$win->{currentNode}) {
    $result=nextRealFile($grp,1);
    # we especially wait for Escape
    _quick_update($grp);
    $win->{treeNo}=-1; # force redraw in gotoTree
  }
  return (!$grp->{stopSearch} and $result) ? $win->{currentNode} : undef;
}

######################################
# find next matching node
######################################
sub findFirstTemplated {
  my ($grp,$template,$skipfirst)=@_;

  my $win=$grp->{focusedWindow};

  return unless $win->{FSFile};
  my $node=$win->{currentNode};
  my $tree=$win->{treeNo};
  my $a;
  $grp->{stopSearch}=0;

  $node=nextNodeInSearchFilelist($grp,$node,\$tree) if ($skipfirst);
  while ($node) {
    unless (grep (!cmpTemplateField($grp,$node->attr($_),$template->{$_}), keys (%$template)))
      {
	gotoTree($win,$tree);
	setCurrent($win, $node);
	centerTo($win,$node);
	return $node;
      }
    $node=nextNodeInSearchFilelist($grp,$node,\$tree);
  }
  return undef;
}

######################################
# go to the last node of a tree
######################################
sub lastSubtreeNode {
  my ($top)=@_;
  return undef unless $top;
  while ($top->firstson) {
    $top=$top->firstson;
    $top=$top->rbrother while ($top->rbrother);
  }
  return $top;
}

######################################
# go to previous node in search list
######################################
sub prevNodeInSearchFilelist {
  my ($grp,$node,$tree)=@_;
  $node=HPrev($grp->{focusedWindow},$node);
  unless ($node or $$tree==0) {
    $node=lastSubtreeNode($grp->{focusedWindow}->{FSFile}->treeList->[(--$$tree)]);
    $node=HPrev($grp->{focusedWindow},$node) unless (isShown($grp->{focusedWindow},$node));
  }
  return $node if $node or !defined($grp->{searchFilelist});

  # this realises filelist search
  local $insideEval=1;
  my $result=prevRealFile($grp,1);
  # we especially wait for Escape
  _quick_update($grp);
  $grp->{focusedWindow}->{treeNo}=-1; # force redraw in gotoTree
  while ($result and !$grp->{stopSearch}
	 and !$grp->{focusedWindow}->{FSFile} || $grp->{focusedWindow}->{FSFile}->lastTreeNo<0) {
    $result=prevRealFile($grp,1);
    # we especially wait for Escape
    _quick_update($grp);
    $grp->{focusedWindow}->{treeNo}=-1; # force redraw in gotoTree
  }
  if ($result and !$grp->{stopSearch}) {
    $$tree=$grp->{focusedWindow}->{FSFile}->lastTreeNo;
    $node=lastSubtreeNode($grp->{focusedWindow}->{FSFile}->treeList->[$$tree]);
    return $node;
  }
  return undef;
}

######################################
# find previous matching node
######################################
sub findPrevTemplated {
  my ($grp,$template,$skipfirst)=@_;
  return unless $grp->{focusedWindow}->{FSFile};
  my $node=$grp->{focusedWindow}->{currentNode};
  my $tree=$grp->{focusedWindow}->{treeNo};
  my $a;
  $grp->{stopSearch}=0;

  $node=prevNodeInSearchFilelist($grp,$node,\$tree) if ($skipfirst);

  while ($node) {
    unless (grep (!cmpTemplateField($grp,$node->attr($_),$template->{$_}), keys (%$template)))
      {
	gotoTree($grp->{focusedWindow}, $tree);
	setCurrent($grp->{focusedWindow}, $node);
	centerTo($grp->{focusedWindow},$node);
	return $node;
      }
    $node=prevNodeInSearchFilelist($grp,$node,\$tree);
  }
  return undef;
}

#############################################
#End of Searching functions
#############################################
#############################################
#############################################


sub node_doubleclick_modif {
  my ($w,$grp,$mod)=@_;
  my $win=findCanvasWindow($grp,$w);
  my $tv=$win->{treeView};
  my $node=$tv->get_obj_pinfo($tv->find_item('withtag','current'));
  doEvalHookWithUndo($win,"node_doubleclick_hook",$node,$mod, $w->XEvent);
}

sub node_click_modif {
  my ($w,$grp,$mod)=@_;
  my $win=findCanvasWindow($grp,$w);
  my $tv=$win->{treeView};
  my $node=$tv->get_obj_pinfo($tv->find_item('withtag','current'));
  doEvalHookWithUndo($win,"node_click_hook",$node,$mod, $w->XEvent);
}

sub node_motion_modif {
  my ($w,$grp,$mod)=@_;
  my $win=findCanvasWindow($grp,$w);
  my $tv=$win->{treeView};
  my $node=$tv->get_obj_pinfo($tv->find_item('withtag','current'));
  doEvalHookWithUndo($win,"node_motion_hook",$node,$mod, $w->XEvent);
}

sub text_doubleclick_modif {
  my ($w,$grp,$mod)=@_;
  my $win=findCanvasWindow($grp,$w);
  return unless($win and $win->{FSFile});
  my $attr;
  my $newvalue;

  my $tv=$win->{treeView};
  my ($t)=$tv->find_item('withtag','current');
  my $node=$tv->get_obj_pinfo($t);
  my $d;
  setCurrent($win,$node);
  $attr=$tv->get_gen_pinfo("attr:$t");

  doEvalHookWithUndo($win,"text_doubleclick_hook",$node,$attr,$mod, $w->XEvent);
}

sub text_doubleclick_modif {
  my ($w,$grp,$mod)=@_;
  my $win=findCanvasWindow($grp,$w);
  return unless($win and $win->{FSFile});
  my $attr;
  my $newvalue;

  my $tv=$win->{treeView};
  my ($t)=$tv->find_item('withtag','current');
  my $node=$tv->get_obj_pinfo($t);
  my $d;
  setCurrent($win,$node);
  ensureCurrentIsDisplayed($win);
  $attr=$tv->get_gen_pinfo("attr:$t");

  doEvalHookWithUndo($win,"text_click_hook",$node,$attr,$mod, $w->XEvent);
}

sub editAttrs {
  my ($w,$grp)=@_;
  my $win=findCanvasWindow($grp,$w);
  my $tv=$win->{treeView};
  my $node=$tv->get_obj_pinfo($tv->find_item('withtag','current'));
  editAttrsDialog($win,$node);
  ensureCurrentIsDisplayed($win);
}

sub editAttr {
  my ($w,$grp)=@_;
  my $win=findCanvasWindow($grp,$w);
  return unless($win and $win->{FSFile});
  my $attr;
  my $newvalue;

  my $tv=$win->{treeView};
  my ($t)=$tv->find_item('withtag','current');
  my $node=$tv->get_obj_pinfo($t);
  my $d;
  setCurrent($win,$node);
  ensureCurrentIsDisplayed($win);
  $attr=$tv->get_gen_pinfo("attr:$t");

  doEditAttr($win,$node,$attr);
}


sub doEditAttr {
  my ($win,$node,$attr)=@_;
  my $grp=$win->{framegroup};
  my $result= doEvalHook($win,'do_edit_attr_hook',$attr,$node);
  return 0 if $result eq 'stop';

  return editAttrsDialog_schema($win,$node,$attr) if (ref($node->type));

  my ($Entry,@Eopts) = get_entry_type();
  my $newvalue;
  if ($win->{FSFile}->FS->isList($attr)) {
    $newvalue= editListAttr($win,$node->getAttribute($attr),$attr,$grp->{top});
    if (defined($newvalue)) {
      $win->toplevel->Busy(-recurse=> 1);
      $win->{FSFile}->notSaved(1);
      save_undo($win,prepare_undo($win,"Edit Attribute '$attr'"));
      lastActionBookmark($grp);
      $node->setAttribute($attr,$newvalue);
      doEvalHook($win,"after_edit_attr_hook",$node,$attr,1);
      get_nodes_fsfile_tree($grp,$win->{FSFile},$win->{treeNo});
      redraw_fsfile_tree($grp,$win->{FSFile},$win->{treeNo});
      $win->toplevel->Unbusy();
    } else {
      doEvalHook($win,"after_edit_attr_hook",$node,$attr,0);
    }
    return;
  }

  if ($node->getAttribute($attr)=~/^(?:[^\|\\]|\\.)*\|/) {
    $newvalue= editAmbiguousAttr($win,$node->getAttribute($attr),$attr);
    if (defined $newvalue) {
      $grp->{top}->Busy(-recurse=> 1);
      $win->{FSFile}->notSaved(1);
      save_undo($win,prepare_undo($win,"Edit Attribute '$attr'"));
      lastActionBookmark($grp);
      $node->setAttribute($attr,$newvalue);
      doEvalHook($win,"after_edit_attr_hook",$node,$attr,1);
      get_nodes_fsfile_tree($grp,$win->{FSFile},$win->{treeNo});
      redraw_fsfile_tree($grp,$win->{FSFile},$win->{treeNo});
      $grp->{top}->Unbusy();
    } else {
      doEvalHook($win,"after_edit_attr_hook",$node,$attr,0);
    }
    return;
  }

  $grp->{top}->Busy(-recurse=> 1);
  my $enabled=doEvalHook($win,'enable_attr_hook',$attr,"normal") ne 'stop';
  $newvalue=encode($node->getAttribute($attr));
  my $d= $grp->{top}->DialogBox(-title=> ($enabled ? "Edit Node Attribute" : "Disabled Node Attribute"),
			     -buttons=> [($enabled ? ("OK", "Cancel") : "Cancel")]);
  $d->bind('<Return>', \&dlgReturn );
  escapeButton($d,'Cancel',1);
  $d->resizable(0,0);
  addBindTags($d,'dialog');
  my $l= $d->Label(-text=> $attr,
		    -anchor=> 'e',
		    -justify=> 'right')->pack(-side=>'left');
  my $e= $d->$Entry(@Entry,
		    -relief=> 'sunken',
		    -width=> 40,
		    -state=> $enabled ? 'normal' : 'disabled',
		    -takefocus=> 1,
		    -font=> $font,
		    -textvariable=> \$newvalue)->pack();
  set_grp_history($grp, $e, "attr-$attr");
  $e->icursor('end');
  $grp->{top}->Unbusy();
  $result= ShowDialog($d,$e,$grp->{top});
  if ($result=~ /OK/) {
    get_grp_history($grp,$e, "attr-$attr");
    $win->{FSFile}->notSaved(1);
    save_undo($win,prepare_undo($win,"Edit Attribute '$attr'"));
    lastActionBookmark($grp);
    $node->setAttribute($attr,decode($newvalue));
    doEvalHook($win,"after_edit_attr_hook",$node,$attr,1);
    get_nodes_fsfile_tree($grp,$win->{FSFile},$win->{treeNo});
    redraw_fsfile_tree($grp,$win->{FSFile},$win->{treeNo});
  } else {
    doEvalHook($win,"after_edit_attr_hook",$node,$attr,0);
  }
  $d->destroy;
  undef $d;
  return ($result =~ /OK/) ? 1 : 0;
}

#############################################
# redraw tree etc.
#############################################

sub nodeOptions {
  my ($win,$node)=@_;
  return $win->{treeView}->node_options($node,
					$win->{FSFile}->FS,
					$win->{currentNode});
}

sub nodeBoxOptions {
  my ($win,$node,$edge)=@_;
  return $win->{treeView}->node_box_options($node,
					 $win->{FSFile}->FS,
					 $win->{currentNode},$edge);
}

sub redraw_win {
  my ($win)=@_;
  return if $insideEval;
  if ($win == $win->{framegroup}->{focusedWindow}) {
    saveFileStateUpdate($win);
    resetUndoStatus($win);
    resetTreePosStatus($win->{framegroup});
    update_status_line($win);
  }
  #------------------------------------------------------------
  #{
  #use Benchmark;
  #my $t0= new Benchmark;
  #for (my $i=0;$i<=50;$i++) {
  #------------------------------------------------------------
  $TrEd::TreeView::on_get_root_style = [\&onGetRootStyle,$win];
  $TrEd::TreeView::on_get_node_style = [\&onGetNodeStyle,$win];
  my $vl;
  $vl=$win->{treeView}->value_line($win->{FSFile},$win->{treeNo},1,0,$win);
  $vl=$win->{treeView}->value_line($win->{FSFile},$win->{treeNo},1,1,$win);
  $vl=get_value_line($win,$win->{FSFile},$win->{treeNo},1,0);
  if ($win->{FSFile} and $win->{treeView}->get_drawSentenceInfo) {
#    $vl=$win->{treeView}->value_line($win->{FSFile},$win->{treeNo},1,0,$win);
  } else {
    undef $vl;
  }

  $win->{treeView}->
    redraw($win->{FSFile},
	   $win->{currentNode},
	   $win->{Nodes},
	   # CHANGE THIS (this is just for printing) :
	   (defined($vl) ? $vl : ""),
	   ($stippleInactiveWindows ?
	      (($win == $win->{framegroup}->{focusedWindow}) ? 'hidden' : 'normal')
		: undef),
	   $win
	  );
  if ($win->{FSFile}) {
    setCurrent($win,$win->{currentNode});
    ensureCurrentIsDisplayed($win);
  }
  $TrEd::TreeView::on_get_root_style= undef; #forget the reference on $win
  $TrEd::TreeView::on_get_node_style= undef;

  #------------------------------------------------------------
  #}
  #my $t1= new Benchmark;
  #my $td= timediff($t1, $t0);
  #print "redraw: the code took:",timestr($td),"\n";
  #}
  #------------------------------------------------------------

  return;
}

sub redraw_fsfile {
  my ($grp,$fsfile)=@_;
  return if $insideEval or !$fsfile;
  foreach (fsfileDisplayingWindows($grp,$fsfile)) {
    redraw_win($_);
  }
  return;
}

sub redraw_stylesheet {
  my ($grp,$stylesheet)=@_;
  return if $insideEval;
  foreach (stylesheetUsingWindows($grp,$stylesheet)) {
    redraw_win($_);
  }
  return;
}


sub redraw_fsfile_tree {
  my ($grp,$fsfile,$tree_no)=@_;
  return if $insideEval or !$fsfile;
  foreach (grep {$_->{treeNo} == $tree_no}
	   fsfileDisplayingWindows($grp,$fsfile)) {
    redraw_win($_);
  }
  return;
}

sub redraw_all {
  my ($grp)=@_;
  foreach (@{ $grp->{treeWindows} }) {
    redraw_win($_);
  }
  return;
}

sub follow_mouse {
  my ($w, $grp)= @_;
  my $e= $w->XEvent;
  my $win=findCanvasWindow($grp,$w);
  my($x, $y)= ($w->fpixels($e->x), $w->fpixels($e->y));
  scrollCanvasToXY($w, $win, $x, $y);
}

sub follow_mouse_press {
  my ($w, $grp)= @_;
  my $win=findCanvasWindow($grp,$w);
  my $tv=$win->{treeView};
  my $e= $w->XEvent;
  my($x, $y)= ($w->fpixels($e->x), $w->fpixels($e->y));

  $tv->store_gen_pinfo("lastX",$x);
  $tv->store_gen_pinfo("lastY",$y);
  $tv->store_gen_pinfo("lastCanvasX",$w->canvasx($x));
  $tv->store_gen_pinfo("lastCanvasY",$w->canvasy($y));
}



sub scrollCanvasToXY {
  my ($w, $win, $X, $Y)=@_;
  my ($ax,$bx)=$w->xview;
  my ($ay,$by)=$w->yview;
  my $canvasX;
  my $tv=$win->{treeView};
  no integer;
  my $sizeX=$w->fpixels($tv->{canvasWidth})*($bx-$ax);
  my $x=min($X,$sizeX);
  my $shiftX=($x-$tv->get_gen_pinfo("lastX"));
  if ($shiftX>0) {
    if ($tv->get_gen_pinfo("lastX")== $sizeX) {
      $shiftX=0;
    } else {
      $shiftX/=$sizeX-$tv->get_gen_pinfo("lastX");
      # a fraction of our right move in window
    }
    $canvasX=$shiftX*
      ($w->fpixels($tv->{canvasWidth})-
       $tv->get_gen_pinfo("lastCanvasX"));
    # this is where we should get on the canvas
  } else {
    if ($tv->get_gen_pinfo("lastX")== 0) {
      $shiftX=0;
    } else {
      $shiftX/=$tv->get_gen_pinfo("lastX");
    }
    $canvasX=$shiftX*
      $tv->get_gen_pinfo("lastCanvasX");
    # this is where we should get on the canvas
  }
  $canvasX+=$tv->get_gen_pinfo("lastCanvasX");
  $w->xview(moveto=>
	    max(0,min(1,($canvasX-$x+1+$w->fpixels($w->cget('-borderwidth')))
		      /$tv->{canvasWidth})));

  # the same for Y
  my $sizeY=$w->fpixels($tv->{canvasHeight})*($by-$ay);
  my $y=min($Y,$sizeY);
  my $shiftY=($y-$tv->get_gen_pinfo("lastY"));
  my $canvasY;
  if ($shiftY>0) {
    if ($tv->get_gen_pinfo("lastY")== $sizeY) {
      $shiftY=0;
    } else {
      $shiftY/=$sizeY-$tv->get_gen_pinfo("lastY");
      # a fraction of our right move in window
    }
    $canvasY=$shiftY*
      ($w->fpixels($tv->{canvasHeight})-
       $tv->get_gen_pinfo("lastCanvasY"));
    # this is where we should get on the canvas
  } else {
    if ($tv->get_gen_pinfo("lastY")==0) {
      $shiftY=0;
    } else {
      $shiftY/=$tv->get_gen_pinfo("lastY");
    }
    $canvasY=$shiftY*
      $tv->get_gen_pinfo("lastCanvasY");
    # this is where we should get on the canvas
  }
  $canvasY+=$tv->get_gen_pinfo("lastCanvasY");
  $w->yview(moveto=>
	    max(0,min(1,($canvasY-$y+1+$w->fpixels($w->cget('-borderwidth')))
		      /$tv->{canvasHeight})));


  $tv->store_gen_pinfo("lastX",$x);
  $tv->store_gen_pinfo("lastY",$y);
  $tv->store_gen_pinfo("lastCanvasX",$w->canvasx($x));
  $tv->store_gen_pinfo("lastCanvasY",$w->canvasy($y));
}

sub ensureCurrentIsDisplayed {
  my ($win)=@_;
  return unless $win->{FSFile};
  my $node = $win->{currentNode};
  while ($node and !$win->treeView->node_is_displayed($node)) {
    $node = $node->parent;
  }
  if (!$node) {
    $node = $win->{Nodes}->[0];
  }
  if ($node and $node != $win->{currentNode}) {
    setCurrent($win,$node);
  }
}

sub currentLeft {
  my $grp=$_[0];
  my $win=$grp->{focusedWindow};
  return unless $win->{FSFile};
  my $node = $win->{currentNode}->lbrother;
  while ($node and !$win->treeView->node_is_displayed($node)) {
    $node = $node->lbrother;
  }
  if ($node) {
    setCurrent($win,$node);
    centerTo($win,$win->{currentNode});
  }
}

sub currentRight {
  my $grp=$_[0];
  my $win=$grp->{focusedWindow};
  return unless $win->{FSFile};
  my $node = $win->{currentNode}->rbrother;
  while ($node and !$win->treeView->node_is_displayed($node)) {
    $node = $node->rbrother;
  }
  if ($node) {
    setCurrent($win,$node);
    centerTo($win,$win->{currentNode});
  }
}

sub currentRightWholeLevel {
  my $grp=$_[0];
  my $win=$grp->{focusedWindow};
  return unless $win->{FSFile};
  my $node = $win->{currentNode};
  return unless $node;
  my $level=$node->level;
  do {
    $node=NextDisplayed($win,$node);
  } while ($node and $level!=$node->level);
  if ($node) {
    setCurrent($win,$node);
    centerTo($win,$win->{currentNode});
  }
}

sub currentLeftWholeLevel {
  my $grp=$_[0];
  my $win=$grp->{focusedWindow};
  return unless $win->{FSFile};
  my $node = $win->{currentNode};
  return unless $node;
  my $level=$node->level;
  do {
    $node=PrevDisplayed($win,$node);
  } while ($node and $level!=$node->level);
  if ($node) {
    setCurrent($win,$node);
    centerTo($win,$win->{currentNode});
  }
}

sub currentDown {
  my $grp=$_[0];
  my $win=$grp->{focusedWindow};
  return unless $win->{FSFile};
  my $node = $win->{currentNode}->firstson;
  while ($node and !$win->treeView->node_is_displayed($node)) {
    $node = NextDisplayed($win,$node,$win->{currentNode});
  }
  if ($node) {
    setCurrent($win,$node);
    centerTo($win,$win->{currentNode});
  }
}

sub currentUp {
  my $grp=$_[0];
  my $win=$grp->{focusedWindow};
  my $node = $win->{currentNode}->parent;
  while ($node and !$win->treeView->node_is_displayed($node)) {
    $node = $node->parent;
  }
  if ($node) {
    setCurrent($win,$node);
    centerTo($win,$win->{currentNode});
  }
}

sub centerToXY {
  my ($win, $x, $y)= @_;
  my ($ax,$bx)=$win->{treeView}->canvas->xview;
  my ($ay,$by)=$win->{treeView}->canvas->yview;

  my $shiftx=($bx-$ax)/2;
  my $shifty=($by-$ay)/2;
  eval {
    $win->{treeView}->canvas->xview(moveto=> min(max(0,$x/$win->{treeView}->{canvasWidth}-$shiftx),1))
      if ($win->{treeView}->{canvasWidth}-$shiftx);
    $win->{treeView}->canvas->yview(moveto=> min(max(0,$y/$win->{treeView}->{canvasHeight}-$shifty),1))
      if ($y/$win->{treeView}->{canvasHeight}-$shifty);
  }
}

sub centerTo {
  my ($win, $node)= @_;
  return unless $node;
  my $tv=$win->{treeView};
  centerToXY($win,
	     $tv->get_node_pinfo($node,"XPOS"),
	     $tv->get_node_pinfo($node,"YPOS"));
}

sub doEvalHookWithUndo {
  my ($win,$hook)=(shift,shift);

  return unless $hook; # and $win->{currentNode};
  my $bookmark=bookmarkThis($win->{framegroup});
  # Save current position (as last action position)
  my $undo=prepare_undo($win,"Hook $context"."->".$hook) if ($win and $win->{FSFile});

  local $insideEval=1;
  my $oldgrp=${"TredMacro::grp"};
  my $oldthis=${"TredMacro::this"};
  my $oldroot=${"TredMacro::root"};
  my $context='TredMacro';
  ${"TredMacro::FileNotSaved"}='?';
  if ($win) {
    ${"TredMacro::this"}=$win->{currentNode};
    ${"TredMacro::root"}=$win->{root};
    $context=$win->{macroContext} || 'TredMacro';
  }
  ${"TredMacro::libDir"}=$libDir;
  ${"TredMacro::forceFileSaved"}=0;
  my $result=do_eval_hook($win,$context,$hook,@_);
  warn "$@\n" if $@;
  my $file_changed=${"TredMacro::FileNotSaved"};

  if ($win) {
    if ($win->{FSFile}) {
      if ($file_changed ne '?' and $file_changed) {
	save_undo($win,$undo);
	lastActionBookmark($win->{framegroup},$bookmark);
	$win->{FSFile}->notSaved(1);
      }
    }
    saveFileStateUpdate($win);
  }

  ${"TredMacro::this"}=$oldthis;
  ${"TredMacro::root"}=$oldroot;
  ${"TredMacro::grp"}=$oldgrp;

  print STDERR "Hook $hook returned $result\n" if $hookDebug;
  return $result;
}


sub doEvalHook {
  my ($win,$hook)=(shift,shift);

  return unless $hook; # and $win->{currentNode};
  my $bookmark=bookmarkThis($win->{framegroup});
  # Save current position (as last action position)

  local $insideEval=1;
  my $oldgrp=${"TredMacro::grp"};
  my $oldthis=${"TredMacro::this"};
  my $oldroot=${"TredMacro::root"};
  my $context='TredMacro';
  ${"TredMacro::FileNotSaved"}='?';
  if ($win) {
    ${"TredMacro::this"}=$win->{currentNode};
    ${"TredMacro::root"}=$win->{root};
    $context=$win->{macroContext} || 'TredMacro';
  }
  ${"TredMacro::libDir"}=$libDir;
  ${"TredMacro::forceFileSaved"}=0;
  my $result=do_eval_hook($win,$context,$hook,@_);
  warn "$@\n" if $@;
  my $file_changed=${"TredMacro::FileNotSaved"};

  if ($win) {
    if ($win->{FSFile}) {
      if ($file_changed ne '?' and $file_changed) {
	lastActionBookmark($win->{framegroup},$bookmark);
	$win->{FSFile}->notSaved(1);
      }
    }
    saveFileStateUpdate($win);
  }

  ${"TredMacro::this"}=$oldthis;
  ${"TredMacro::root"}=$oldroot;
  ${"TredMacro::grp"}=$oldgrp;

  print STDERR "Hook $hook returned $result\n" if $hookDebug;
  return $result;
}


sub examineEvent {
  my $w = shift;
  my $bindings = shift;
  my ($macro,$key,$eA,$eK,$by_event_hook) = resolveEvent($w,@_);
  if ($eA eq $eK) {
    $key .= " [$eA]" if ($eA ne $key);
  } else {
    if ($eA eq $key) {
      $key .= " [$eK]";
    } elsif ($eK eq $key) {
      $key .= " [$eA]";
    } else {
      $key .= " [$eA = $eK]";
    }
  }
  if ($by_event_hook) {
    if (defined($macro)) {
      $$bindings = "$key bound by event_hook to: ".findMacroDescription($macro);
    } else {
      $$bindings = "$key is blocked by event_hook\n";
    }
  } else {
    if (defined($macro)) {
      $$bindings = "$key is bound to: ".findMacroDescription($macro);
    } else {
      $$bindings = "$key is not bound\n";
    }
  }
  print $$bindings."\n";
  Tk->break;
}

sub examineBindingsDialog {
  my ($grp)=@_;
  my $bindings='None';
  my $d = $grp->{top}->DialogBox(-title=> "Examine key bindings",
				 -buttons=> ["Close"]);
  $d->Label(-text=> $attr,
		    -anchor=> 'e',
		    -justify=> 'right')->pack(-side=>'left');
  escapeButton($d,'Cancel');
  $d->Label(qw/-wraplength 6i -justify left -text/,
	    "Press any key to see it's binding in the current context.")->
	      pack(qw/-padx 0 -pady 10 -expand yes -fill both/);
  my $t=$d->Label(-textvariable => \$bindings)->pack(qw/-padx 0 -pady 10 -expand yes -fill both/);

  $d->bind('<KeyPress>'=> [\&examineEvent, \$bindings, $grp, '' ]);

  foreach my $prefix ('Alt','Meta') {
    $d->bind("<$prefix-KeyPress>"=> [\&examineEvent, \$bindings, $grp, uc($prefix).'+' ]);
  }
  foreach (qw(Shift Control Meta Alt Control-Shift Control-Alt
              Control-Meta Alt-Shift Meta-Shift)) {
    foreach my $event (qw(KeyPress Right Left Up Down
                          Return comma period Next Prior greater less)) {
      $d->bind("<$_-$event>"=> [\&examineEvent, \$bindings, $grp, keyBind($_)."+"])
	unless ("$_-$event" eq "Alt-KeyPress" or "$_-$event" eq "Meta-KeyPress")
      }
  }

  $d->bind('<Tab>'		  => [ sub { $bindings='builtin - select next node'; Tk->break; }]);
  $d->bind('<Shift-ISO_Left_Tab>' => [ sub { $bindings='builtin - select previous node'; Tk->break; }]);
  $d->bind('<Shift-Tab>'	  => [ sub { $bindings='builtin - select previous node'; Tk->break; }]);
  $d->bind('<period>'		  => [ sub { $bindings='builtin - go to next tree'; Tk->break; }]);
  $d->bind('<comma>'		  => [ sub { $bindings='builtin - go to previous tree'; Tk->break; }]);
  $d->bind('<Next>'		  => [ sub { $bindings='builtin - go to next tree'; Tk->break; }]);
  $d->bind('<Prior>'		  => [ sub { $bindings='builtin - go to previous tree'; Tk->break; }]);
  $d->bind('<greater>'		  => [ sub { $bindings='builtin - go to last tree in file'; Tk->break; }]);
  $d->bind('<less>'		  => [ sub { $bindings='builtin - go to first tree in file'; Tk->break; }]);
  $d->bind('<KeyPress-Return>'	  => [ sub { $bindings='builtin - view/edit attributes'; Tk->break; }]);
  $d->bind('<KeyPress-Left>'	  => [ sub { $bindings='builtin - select left sibling'; Tk->break; }]);
  $d->bind('<Shift-Left>'	  => [ sub { $bindings='builtin - select node on the left'; Tk->break; }]);
  $d->bind('<KeyPress-Right>'	  => [ sub { $bindings='builtin - select right sibling'; Tk->break; }]);
  $d->bind('<Shift-Right>'	  => [ sub { $bindings='builtin - select node on the right'; Tk->break; }]);
  $d->bind('<KeyPress-Up>'	  => [ sub { $bindings='builtin - select parent node'; Tk->break; }]);
  $d->bind('<KeyPress-Down>'	  => [ sub { $bindings='builtin - select first child-node'; Tk->break; }]);

  ShowDialog($d,$e,$grp->{top});
  $d->destroy;
  undef $d;
}

sub findMacroDescription {
  my ($macro)=@_;
  if ($macro =~ /^(.*)->/) {
    my $b = $menuBindings{$1};
    my ($desc) = grep { ref($b->{$_}) and $b->{$_}[0] eq $macro } keys %$b;
    return "$desc ($macro)" if $desc ne "";
  }
  return "macro $macro";
}

sub doEvalMacro {
  my ($win,$macro)=(shift,shift);
  return unless $macro;# and $win->{currentNode};

  my $bookmark=bookmarkThis($win->{framegroup});
  $win->toplevel->Busy(-recurse=> 1);
  $insideEval=1;

  ${"TredMacro::this"}=$win->{currentNode};
  ${"TredMacro::root"}=$win->{root};
  ${"TredMacro::libDir"}=$libDir;
  ${"TredMacro::FileNotSaved"}='?';
  ${"TredMacro::forceFileSaved"}=0;
  ${"TredMacro::Redraw"}='file';


  my $undo=prepare_undo($win,findMacroDescription($macro));
  my $result=do_eval_macro($win,$macro);
  my $current=${"TredMacro::this"};
  my $file_not_saved=${"TredMacro::FileNotSaved"};
  $file_not_saved=1 if $file_not_saved eq '?';
  if ($win->{FSFile}) {
    if (${"TredMacro::forceFileSaved"}) {
      print STDERR "Macro forsly claims file saved.\n";
      $win->{FSFile}->notSaved($file_not_saved ? 1 : 0);
      lastActionBookmark($win->{framegroup},$bookmark) if $file_not_saved;
    } else {
      if ($file_not_saved) {
	save_undo($win,$undo);
	$win->{FSFile}->notSaved(1);
	lastActionBookmark($win->{framegroup},$bookmark);
      } else {
	print STDERR "Macro claims file untouched.\n" if $macroDebug;
      }
    }
  }
  $insideEval=0;
  #------------------------------------------------------------
  #use Benchmark;
  #my $t0= new Benchmark;
  #for (my $i=0;$i<=50;$i++) {
  ### ??? 4kb/50 runs memory leaks in redraw (probably in Tk)
  #------------------------------------------------------------
  if (${"TredMacro::Redraw"} eq 'all') {
    redraw_all($win->{framegroup});
    get_nodes_all($win->{framegroup});
  } elsif (${"TredMacro::Redraw"} eq 'win') {
    get_nodes_win($win);
    redraw_win($win);
  } elsif (${"TredMacro::Redraw"} eq 'tree') {
    get_nodes_fsfile_tree($win->{framegroup},$win->{FSFile},$win->{treeNo});
    redraw_fsfile_tree($win->{framegroup},$win->{FSFile},$win->{treeNo});
  } elsif (${"TredMacro::Redraw"} eq 'tie') {
    if ($win->{framegroup}->{tieWindows}) {
      get_nodes_all($win->{framegroup});
      redraw_all($win->{framegroup});
    } else {
      get_nodes_win($win);
      redraw_win($win);
    }
  } elsif (${"TredMacro::Redraw"} eq 'none') {
    # do nothing
  } else {
    get_nodes_fsfile($win->{framegroup},$win->{FSFile});
    redraw_fsfile($win->{framegroup},$win->{FSFile});
  }
  #------------------------------------------------------------
  #}
  #my $t1= new Benchmark;
  #my $td= timediff($t1, $t0);
  #print "${TredMacro::FileNotSaved} the code took:",timestr($td),"\n";
  #------------------------------------------------------------

  # the rest of this routine is:
  # memory ok, speed ok
  setCurrent($win,$current) if ($current);
  ensureCurrentIsDisplayed($win);
  ${"TredMacro::this"}=undef;
  ${"TredMacro::root"}=undef;
  ${"TredMacro::grp"}=undef;

  centerTo($win,$win->{currentNode});
  updateTitle($win->{framegroup});

  $win->toplevel->Unbusy;
  return $result;
}

sub resolveKey {
  my $grp=$_[0];
 context:
  foreach my $context ($grp->{focusedWindow}->{macroContext},$grp->{focusedWindow}->{macroContext} eq "TredMacro" ? () : "TredMacro") {
    foreach my $key (@_) {
      if (exists ($keyBindings{$context}->{$key})) {
	return($keyBindings{$context}->{$key},$key)
      }
    }
  }
  return undef;
}

sub resolveEvent {
  my ($w,$grp,$prefix)=@_;
  my $key;
  my $e= $w->XEvent;
  my $A= $e->A;
  my $K= $e->K;
  my @possib=();
  my $macro=undef;

  print STDERR "Prefix: $prefix\n" if $keyboardDebug;
  $prefix=~s/SHIFT\+//g unless ($K=~/^(?:left|right|up|down|next|prior|space|backspace|insert|delete|return|pause|escape|home|end|begin|select|print|execute|undo|redo|menu|find|cancel|help|break|F[0-9]+|L[0-9]+|R[0-9]+|ISO_Left_Tab)$/i);
  if ($keyboardDebug) {
    print STDERR "Pressed: (".ord($A)."), prefix $prefix, keysym $K/",$e->N,"\n";
    print STDERR "Maybe: $prefix$K\n";
  }
  if ($K =~ /^XF86_Switch_VT_(\d+)$/) {
    print STDERR "Translating $shift $K to SHIFT+F$1\n" if $keyboardDebug;
    $prefix='SHIFT+';
    $K='F'.$1;
  }
  push @possib, ($prefix.$A,$prefix.$K);

  $macro = doEvalHook($grp->{focusedWindow},"event_hook",$e,$w,@possib);
  if (defined($macro)) {
    if ($macro eq 'stop') {
      print STDERR "Event blocked by event_hook\n" if $macroDebug || $keyboardDebug;
      return (undef,undef,$prefix.$A,$prefix.$K,1);
    } else {
      print STDERR "Event translated by event_hook to '$macro'\n" if $macroDebug || $keyboardDebug;
      return ($macro,$key,$prefix.$A,$prefix.$K,1);
    }
  } else {
    ($macro,$key)=resolveKey($grp,@possib);
    return ($macro,$key,$prefix.$A,$prefix.$K);
  }
}

sub evalMacro {
  my ($w,$grp,$prefix)=@_;
  my $win=$grp->{focusedWindow};

  my ($macro,$key)=resolveEvent($w,$grp,$prefix);
  if (defined $macro) {
    $grp->{statusLineText}="$key" if $tredDebug;
    $grp->{statusLineText}.=", $macro" if $tredDebug;
    update_status_line($win) if $tredDebug;
#    use Benchmark;
#    my $t0= new Benchmark;
#    # ... your code here ...
#    for (my $i=0;$i<=50;$i++) {
    doEvalMacro($win,$macro);
#    }
#    my $t1= new Benchmark;
#    my $td= timediff($t1, $t0);
#    print "the code took:",timestr($td),"\n";

    return 1;
  } else {
    $grp->{statusLineText}=$key if $tredDebug; #"$prefix$K" if $tredDebug;
    update_status_line($win) if $tredDebug;
  }
  return undef;
}

sub tieGotoTree {
  my ($grp,$no)=@_;
  if ($grp->{tieWindows}) {
    my @tied = grep { $_->{FSFile} } @{$grp->{treeWindows}};
    if (@tied) {
      my $result = 1;
      foreach (@tied) {
	$result &&= gotoTree($_,$no);
      }
      return $result;
    } else {
      return 0
    }
  } else {
    if ($grp->{focusedWindow}->{FSFile}) {
      return gotoTree($grp->{focusedWindow},$no);
    } else {
      return 0;
    }
  }
  return $result;
}

sub tieNextTree {
  my ($grp)=@_;
  if ($grp->{tieWindows}) {
    my @tied = grep { $_->{FSFile} } @{$grp->{treeWindows}};
    if (@tied) {
      my $result = 1;
      foreach (@tied) {
	$result &&= nextTree($_);
      }
      return $result;
    } else {
      return 0
    }
  } else {
    if ($grp->{focusedWindow}->{FSFile}) {
      return nextTree($grp->{focusedWindow});
    } else {
      return 0;
    }
  }
  return $result;
}

sub tiePrevTree {
  my ($grp)=@_;
  if ($grp->{tieWindows}) {
    my @tied = grep { $_->{FSFile} } @{$grp->{treeWindows}};
    if (@tied) {
      my $result = 1;
      foreach (@tied) {
	$result &&= prevTree($_);
      }
      return $result;
    } else {
      return 0
    }
  } else {
    if ($grp->{focusedWindow}->{FSFile}) {
      return prevTree($grp->{focusedWindow});
    } else {
      return 0;
    }
  }
  return $result;
}

sub currentNext {
  my ($win)=@_;
  my $next=NextDisplayed($win,$win->{currentNode});
  if ($next) {
    setCurrent($win,$next);
    centerTo($win,$win->{currentNode});
  }
}


sub currentPrev {
  my ($win)=@_;
  my $prev=PrevDisplayed($win,$win->{currentNode});
  if ($prev) {
    setCurrent($win,$prev);
    centerTo($win,$win->{currentNode});
  }
}


sub node_down {
  my($w,$grp)= @_;
  my $win=findCanvasWindow($grp,$w);
  my $tv=$win->{treeView};
  my $e= $w->XEvent;
  my($x, $y)= ($e->x, $e->y);
  my $node=$tv->get_obj_pinfo($tv->find_item('withtag','current'));

  setCurrent($win,$node);
  $w->dtag('selected');
  $w->addtag('selected', 'withtag', 'current');
  $w->raise('current');
  $tv->store_gen_pinfo("lastX",$x);
  $tv->store_gen_pinfo("lastY",$y);
  $tv->store_gen_pinfo("lastCanvasX",$w->canvasx($x));
  $tv->store_gen_pinfo("lastCanvasY",$w->canvasy($y));
}				# end plot_down

sub node_move {
  my($w,$grp,$scroll)= @_;
  my $win=findCanvasWindow($grp,$w);
  my $tv=$win->{treeView};
  my $e= $w->XEvent;
  my($x, $y)= ($e->x, $e->y);
  my $node=$tv->get_obj_pinfo($tv->find_item('withtag','selected'));

  my $lcx=$tv->get_gen_pinfo('lastCanvasX');
  my $lcy=$tv->get_gen_pinfo('lastCanvasY');
  my ($ncolor,$ocolor);

  if ($scroll) {
    $ncolor=$w->itemcget('selected','-fill');
    $ocolor=$w->itemcget('selected','-outline');
    $w->itemconfigure('selected',
		      -fill=> $tv->canvas->cget('-background'),
		      -outline=> $tv->canvas->cget('-background')
		     );
    scrollCanvasToXY($w, $win, $x, $y);
  } else {
    $tv->store_gen_pinfo('lastCanvasX',$w->canvasx($x));
    $tv->store_gen_pinfo('lastCanvasY',$w->canvasy($y));
  }
  my ($cx, $cy)= ($w->canvasx($x),$w->canvasy($y));
  my $flop;
  my ($nx,$ny) = $w->coords('selected');
  my ($deltax,$deltay) = ($cx-$nx, $cy-$ny);
  $w->coords('selected', map { ($flop++%2) ? $deltay+$_ : $deltax+$_ }
	     $w->coords('selected'));
#  $w->move('selected',  $cx-$lcx, $cy-$lcy);
  $w->itemconfigure('selected', -fill=> $ncolor, -outline=> $ocolor ) if $scroll;
  my $nearest=$tv->get_obj_pinfo($tv->find_item('withtag','nearest'));
  if ($nearest) {
    $w->itemconfigure('nearest',nodeOptions($win,$nearest));
    $tv->apply_stored_style_opts("Oval",$nearest);
    $w->dtag('nearest');
  }

  my @dots= $tv->find_item('withtag','point');
  my $nearestNode=0;
  my $bestDist=10000;
  my $dist;
  foreach my $p (@dots) {
    my $n=$tv->get_obj_pinfo($p);
    if ($n and $n!=$node) {
      $dist=
	($cx-$tv->get_node_pinfo($n,"XPOS"))*
	  ($cx-$tv->get_node_pinfo($n,"XPOS"))+
	    ($cy-$tv->get_node_pinfo($n,"YPOS"))*
	      ($cy-$tv->get_node_pinfo($n,"YPOS"));
      if ($bestDist>$dist) {
	$bestDist=$dist;
	$nearestNode=$n;
      }
    }
  }
  if ($bestDist<800) {
    $w->addtag('nearest','withtag',$tv->get_node_pinfo($nearestNode,"Oval"));
    $w->itemconfigure($tv->get_node_pinfo($nearestNode,"Oval"),
		      -fill=> $tv->get_nearestNodeColor);
  }
}				# end plot_move

sub node_release {
  my($w,$grp,$button)= @_;
  my $win=findCanvasWindow($grp,$w);
  my $tv=$win->{treeView};
  return unless $win->{FSFile};
  my $e= $w->XEvent;
  my($x, $y)= ($e->x, $e->y);
  my $parent;
  my $node;
  my $center=0;
  my ($sel)=$tv->find_item('withtag','selected');
  $node=$tv->get_obj_pinfo($sel) if (defined ($sel));
  if ($node) {
    my ($p)=$tv->find_item('withtag','nearest');
    $w->dtag('nearest');
    $w->dtag('selected');
    if (defined $p) {
      $parent=$tv->get_obj_pinfo($p);
      $w->itemconfigure($tv->get_node_pinfo($parent,"Oval"),
			  nodeOptions($win,$parent));
      if (doEvalHook($win,"node_release_hook",$node,$parent,"$button") ne 'stop') {
	while ($parent) {
	  $p=0, last if ($node eq $parent);
	  $parent=$parent->parent;
	}
	if ($p and $tv->get_obj_pinfo($p) 
	    and $node->parent!=$tv->get_obj_pinfo($p)) {
	  save_undo($win,prepare_undo($win, "Cat/Paste node with mouse"));
	  my $oldparent=$node->parent;
	  Fslib::Paste(Cut($node),
		       $tv->get_obj_pinfo($p),
		       $win->{FSFile}->FS);
	  $win->{FSFile}->notSaved(1);
          doEvalHook($win,"node_moved_hook",$node,$oldparent);
	  lastActionBookmark($grp);
	  redraw_fsfile_tree($grp,$win->{FSFile},$win->{treeNo});
	  centerTo($win,$win->{currentNode});
	  return;
	}
      }
    }
    # returning node to its position
    $w->coords($sel, $tv->node_coords($node,$win->{currentNode}));
  } else { redraw_fsfile_tree($grp,$win->{FSFile},$win->{treeNo}); }
}

sub node_release_modif {
  my($w,$grp,$mod)= @_;
  my $win=findCanvasWindow($grp,$w);
  my $tv=$win->{treeView};
  return unless $win->{FSFile};
  my $e= $w->XEvent;
  my($x, $y)= ($e->x, $e->y);
  my $parent;
  my $node;
  my $center=0;
  my ($sel)=$tv->find_item('withtag','selected');
  $node=$tv->get_obj_pinfo($sel) if (defined ($sel));
  if ($node) {
    my ($p)=$tv->find_item('withtag','nearest');
    $w->dtag('nearest');
    $w->dtag('selected');
    if (defined $p) {
      $parent=$tv->get_obj_pinfo($p);
      $w->itemconfigure($tv->get_node_pinfo($parent,"Oval"),
			  nodeOptions($win,$parent));
      doEvalHookWithUndo($win,"node_release_hook",$node,$parent,$mod,$e);
    }
    # returning node to its position
    $w->coords($sel, $tv->node_coords($node,$win->{currentNode}));
  } else { redraw_fsfile_tree($grp,$win->{FSFile},$win->{treeNo}); }
}

sub prepare_undo {
  my ($win,$message,$phase_only)=@_;
  return unless $maxUndo;
  my $fsfile=$win->{FSFile};
  return undef unless $fsfile;
  my $tree;
  eval { require Storable; };
  if ($@) {
    return undef;
  } else {
    $tree = Storable::freeze($win->{root});
    return ['Storable',$win->{treeNo},$tree,getNodeNo($win,$win->{currentNode}),$message,$phase_only];
  }
}

sub save_undo {
  my ($win,$undo)=@_;
  return unless $maxUndo;
  my $fsfile=$win->{FSFile};
  return unless ref($fsfile) and $undo;
  initAppData($fsfile);

  my $stack=$fsfile->appData('undostack');
  splice @$stack, $fsfile->appData('undo')+1; # remove redo
  push @$stack,$undo;
  if ($maxUndo>0 and @$stack>$maxUndo) {
    splice @$stack, 0, (@$stack-$maxUndo);
    print STDERR "Undo-stack: overflow, removing ",(@$stack-$maxUndo)," items\n" if $tredDebug;
  }
  $fsfile->changeAppData('undo',$#$stack);
  resetUndoStatus($win);
  print STDERR "Undo-stack: $#$stack items\n" if $tredDebug;
}

sub re_do {
  my ($grp_or_win)=@_;
  my $win = cast_to_win($grp_or_win);
  return unless $maxUndo;
  my $fsfile=$win->{FSFile};
  return unless $fsfile;
  my $stack=$fsfile->appData('undostack');
  return unless (@$stack>$fsfile->appData('undo')+2);
  print STDERR "Redo: ",$fsfile->appData('undo')+2,"/$#$stack\n" if $tredDebug;
  $fsfile->changeAppData('undo',$fsfile->appData('undo')+2);
  undo($win,1);
}

sub undo {
  my ($grp_or_win,$redo)=@_;
  my $win = cast_to_win($grp_or_win);
  return unless $maxUndo;
  my $fsfile=$win->{FSFile};
  return unless $fsfile;
  my $stack=$fsfile->appData('undostack');
  my $stackpos=$fsfile->appData('undo');
  return unless (ref($stack) and (@$stack>0) and ($stackpos>=0) and ($stackpos <= $#$stack));
  my $undo=$stack->[$stackpos];
  if ($undo) {
    my $new_undo;
    $new_undo=prepare_undo($win,$undo->[$stackpos][4]) if (!$redo and $#$stack == $stackpos);
    my $type = $undo->[0];
    my $treeNo=$undo->[1];
    my $tree=$undo->[2];
    my $prev = $fsfile->treeList->[$treeNo];
    $prev->destroy if ref($prev);
    if ($type eq 'FS') {
      $fsfile->treeList->[$treeNo]=$fsfile->FS->parseFSTree($tree);
    } elsif ($type eq 'Storable') {
      $fsfile->treeList->[$treeNo]=Storable::thaw($tree);
    }
    if ($#$stack == $stackpos) {
      if ($redo) {
	pop @$stack;
      } else {
	push @$stack, $new_undo;
      }
    }
    print STDERR "Undo: ",$stackpos."/$#$stack\n" if $tredDebug;
    $fsfile->changeAppData('undo',$fsfile->appData('undo')-1);
    resetUndoStatus($win);
    $fsfile->notSaved(1);
    $win->{treeNo}=$treeNo;
    $win->{currentNode}=getNodeByNo($win,$undo->[3]);
    get_nodes_fsfile_tree($win->{framegroup},$fsfile,$treeNo);
    redraw_fsfile_tree($win->{framegroup},$fsfile,$treeNo);
    centerTo($win,$win->{currentNode});
  } else {
    errorMessage($win,"Corrupted undo stack!");
  }
}

sub resetUndoStatus {
  my ($win)=@_;
  my $fsfile=$win->{FSFile};
  my $grp = $win->{framegroup};
  my ($undostatus,$redostatus,$undomessage,$redomessage);

  if ($maxUndo!=0 and ref($fsfile)) {
    my $stack=$fsfile->appData('undostack');
    my $stackpos=$fsfile->appData('undo');
    print STDERR "STATUS: $stackpos/",$#$stack+1,"\n" if $tredDebug;
    $undostatus=(ref($stack) && (@$stack>0));
    $redostatus=($undostatus && (@$stack>$stackpos+2));
    $undostatus &&= (($stackpos>=0) && ($stackpos <= $#$stack));
    $undomessage = ": ".$stack->[$stackpos]->[4] if ($undostatus);
    $redomessage = ": ".$stack->[$stackpos+1]->[4] if ($redostatus);
  } else {
    $undostatus=0;
    $redostatus=0;
  }
  if ($grp->{undoButton}) {
    $grp->{undoButton}->
      configure(-state => ($undostatus ? 'normal' : 'disabled'));
    $grp->{Balloon}->attach($grp->{undoButton},
			    -balloonmsg=> "Undo".$undomessage);
  }
  if ($grp->{redoButton}) {
    $grp->{redoButton}->
      configure(-state => ($redostatus ? 'normal' : 'disabled'));
    $grp->{Balloon}->attach($grp->{redoButton},
			    -balloonmsg=> "Redo".$redomessage);
  }
}

sub resetTreePosStatus {
  my ($grp)=@_;
  my $win=$grp->{focusedWindow};
  my $fsfile=$win->{FSFile};

  my $prevstatus=ref($fsfile) && $fsfile->lastTreeNo>=0 && $win->{treeNo}>0;
  my $nextstatus=ref($fsfile) && $fsfile->lastTreeNo>$win->{treeNo};
  if ($win->{framegroup}->{nextButton}) {
    $win->{framegroup}->{nextButton}->
      configure(-state => ($nextstatus ? 'normal' : 'disabled'));
  }
  if ($win->{framegroup}->{prevButton}) {
    $win->{framegroup}->{prevButton}->
      configure(-state => ($prevstatus ? 'normal' : 'disabled'));
  }
}


sub list_isearch {
  my ($w)=@_;
  my $e= $w->XEvent;
  my $A= $e->A;
  if ($A ne "") {
    my @items=$w->get(0,'end');
    my $count=$w->index('end');
    my $active=$w->index('active');
    for (my $i=$active+1;$i<=$active+$count;$i++) {
      if ($items[$i % $count] =~ /^$A/i) {
	$w->activate($i % $count);
	unless ($w->isa('Tk::Listbox') and
	    $w->cget('-selectmode') eq 'multiple' or
	    $w->cget('-selectmode') eq 'extended') {
	  $w->selectionClear(0,'end');
	  $w->selectionSet($i % $count);
	}
	$w->see($i % $count);
	Tk->break;
	return;
      }
    }
  }
}

sub _set_encoding {
  my ($fh, $enc, $what)=@_;
  if ($enc and $]>=5.008) {
    eval {
      print STDERR ("forcing encoding $enc for $what\n") if $debug;
      $fh->flush();
      binmode $fh; # first get rid of all I/O layers
      if ($enc =~ /^:/) {
	binmode $fh,$enc;
      } else {
	binmode $fh,":encoding($enc)";
      }
    };
    print STDERR $@ if $@;
  }
}

sub cleanup_tredmacro {
  my ($grp)=@_;
  $TrEd::Macros::macrosEvaluated=0;
  # cleanup

  %TrEd::Macros::defines=(TRED => 1);
  my %packages;
  @packages { ('TredMacro',
	       grep {/\S/} grep { !/^main$|^TrEd::/ }
	       map  { (/^package\s+([^;\s]+)\s*;/) } (@TrEd::Macros::macros))
	    } = ();
  foreach my $package ( sort { length($b)<=>length($a) } keys %packages ) {
    no strict qw(refs);
    print STDERR ("Cleaning package $package\n") if $tredDebug;
    %{$package."::"}=();
    eval("package $package; use UNIVERSAL qw(isa can);");
    print STDERR $@ if $@;
  }
}
